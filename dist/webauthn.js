// deno-fmt-ignore-file
// deno-lint-ignore-file
// This code was bundled using `deno bundle` and it's not recommended to edit it manually

if (typeof Deno === "undefined") {
    global.Deno = {
        permissions: false
    };
}
if (typeof crypto === "undefined") {
    global.crypto = (await import("crypto")).webcrypto;
}
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const charsUrl = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
const genLookup = (target1)=>{
    const lookupTemp = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
    for(let i4 = 0; i4 < chars.length; i4++){
        lookupTemp[target1.charCodeAt(i4)] = i4;
    }
    return lookupTemp;
};
const lookup = genLookup(chars);
const lookupUrl = genLookup(charsUrl);
const base64 = {};
base64.toArrayBuffer = (data, urlMode)=>{
    let bufferLength = data.length * 0.75;
    const len = data.length;
    let i5;
    let p = 0;
    let encoded1;
    let encoded2;
    let encoded3;
    let encoded4;
    if (data[data.length - 1] === "=") {
        bufferLength--;
        if (data[data.length - 2] === "=") {
            bufferLength--;
        }
    }
    const arraybuffer = new ArrayBuffer(bufferLength);
    const bytes = new Uint8Array(arraybuffer);
    const target2 = urlMode ? lookupUrl : lookup;
    for(i5 = 0; i5 < len; i5 += 4){
        encoded1 = target2[data.charCodeAt(i5)];
        encoded2 = target2[data.charCodeAt(i5 + 1)];
        encoded3 = target2[data.charCodeAt(i5 + 2)];
        encoded4 = target2[data.charCodeAt(i5 + 3)];
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return arraybuffer;
};
base64.fromArrayBuffer = (arrBuf, urlMode)=>{
    const bytes = new Uint8Array(arrBuf);
    let i6;
    const len = bytes.length;
    let result = "";
    const target3 = urlMode ? charsUrl : chars;
    for(i6 = 0; i6 < len; i6 += 3){
        result += target3[bytes[i6] >> 2];
        result += target3[(bytes[i6] & 3) << 4 | bytes[i6 + 1] >> 4];
        result += target3[(bytes[i6 + 1] & 15) << 2 | bytes[i6 + 2] >> 6];
        result += target3[bytes[i6 + 2] & 63];
    }
    if (len % 3 === 2) {
        result = result.substring(0, result.length - 1) + (urlMode ? "" : "=");
    } else if (len % 3 === 1) {
        result = result.substring(0, result.length - 2) + (urlMode ? "" : "==");
    }
    return result;
};
base64.toString = (str, urlMode)=>{
    return new TextDecoder().decode(base64.toArrayBuffer(str, urlMode));
};
base64.fromString = (str, urlMode)=>{
    return base64.fromArrayBuffer(new TextEncoder().encode(str), urlMode);
};
const base = 36;
const damp = 700;
const delimiter = '-';
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7E]/;
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
const errors = {
    'overflow': 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
};
const baseMinusTMin = 36 - 1;
const floor = Math.floor;
const stringFromCharCode = String.fromCharCode;
function error(type) {
    throw new RangeError(errors[type]);
}
function map(array, fn) {
    const result = [];
    let length = array.length;
    while(length--){
        result[length] = fn(array[length]);
    }
    return result;
}
function mapDomain(string, fn) {
    const parts = string.split('@');
    let result = '';
    if (parts.length > 1) {
        result = parts[0] + '@';
        string = parts[1];
    }
    string = string.replace(regexSeparators, '\x2E');
    const labels = string.split('.');
    const encoded = map(labels, fn).join('.');
    return result + encoded;
}
function ucs2decode(string) {
    const output = [];
    let counter = 0;
    const length = string.length;
    while(counter < length){
        const value = string.charCodeAt(counter++);
        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
            const extra = string.charCodeAt(counter++);
            if ((extra & 0xFC00) == 0xDC00) {
                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
            } else {
                output.push(value);
                counter--;
            }
        } else {
            output.push(value);
        }
    }
    return output;
}
const ucs2encode = (array)=>String.fromCodePoint(...array)
;
const basicToDigit = function(codePoint) {
    if (codePoint - 0x30 < 0x0A) {
        return codePoint - 0x16;
    }
    if (codePoint - 0x41 < 0x1A) {
        return codePoint - 0x41;
    }
    if (codePoint - 0x61 < 0x1A) {
        return codePoint - 0x61;
    }
    return 36;
};
const digitToBasic = function(digit, flag) {
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};
const adapt = function(delta, numPoints, firstTime) {
    let k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for(; delta > baseMinusTMin * 26 >> 1; k += base){
        delta = floor(delta / baseMinusTMin);
    }
    return floor(k + (baseMinusTMin + 1) * delta / (delta + 38));
};
const decode = function(input) {
    const output = [];
    const inputLength = input.length;
    let i7 = 0;
    let n1 = 128;
    let bias = 72;
    let basic = input.lastIndexOf(delimiter);
    if (basic < 0) {
        basic = 0;
    }
    for(let j = 0; j < basic; ++j){
        if (input.charCodeAt(j) >= 0x80) {
            error('not-basic');
        }
        output.push(input.charCodeAt(j));
    }
    for(let index = basic > 0 ? basic + 1 : 0; index < inputLength;){
        let oldi = i7;
        for(let w = 1, k = 36;; k += base){
            if (index >= inputLength) {
                error('invalid-input');
            }
            const digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= 36 || digit > floor((2147483647 - i7) / w)) {
                error('overflow');
            }
            i7 += digit * w;
            const t1 = k <= bias ? 1 : k >= bias + 26 ? 26 : k - bias;
            if (digit < t1) {
                break;
            }
            const baseMinusT = 36 - t1;
            if (w > floor(2147483647 / baseMinusT)) {
                error('overflow');
            }
            w *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i7 - oldi, out, oldi == 0);
        if (floor(i7 / out) > 2147483647 - n1) {
            error('overflow');
        }
        n1 += floor(i7 / out);
        i7 %= out;
        output.splice(i7++, 0, n1);
    }
    return String.fromCodePoint(...output);
};
const encode = function(input) {
    const output = [];
    input = ucs2decode(input);
    let inputLength = input.length;
    let n2 = 128;
    let delta = 0;
    let bias = 72;
    for (const currentValue of input){
        if (currentValue < 0x80) {
            output.push(stringFromCharCode(currentValue));
        }
    }
    let basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) {
        output.push(delimiter);
    }
    while(handledCPCount < inputLength){
        let m = 2147483647;
        for (const currentValue of input){
            if (currentValue >= n2 && currentValue < m) {
                m = currentValue;
            }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n2 > floor((2147483647 - delta) / handledCPCountPlusOne)) {
            error('overflow');
        }
        delta += (m - n2) * handledCPCountPlusOne;
        n2 = m;
        for (const currentValue1 of input){
            if (currentValue1 < n2 && ++delta > 2147483647) {
                error('overflow');
            }
            if (currentValue1 == n2) {
                let q = delta;
                for(let k = 36;; k += base){
                    const t2 = k <= bias ? 1 : k >= bias + 26 ? 26 : k - bias;
                    if (q < t2) {
                        break;
                    }
                    const qMinusT = q - t2;
                    const baseMinusT = 36 - t2;
                    output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
                    q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
            }
        }
        ++delta;
        ++n2;
    }
    return output.join('');
};
const toUnicode = function(input) {
    return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
};
const toASCII = function(input) {
    return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
    });
};
const __default = {
    'version': '2.1.0',
    'ucs2': {
        'decode': ucs2decode,
        'encode': ucs2encode
    },
    'decode': decode,
    'encode': encode,
    'toASCII': toASCII,
    'toUnicode': toUnicode
};
const codes = {};
function hideStackFrames(fn) {
    const hidden = "__node_internal_" + fn.name;
    Object.defineProperty(fn, "name", {
        value: hidden
    });
    return fn;
}
const _toString = Object.prototype.toString;
const _isObjectLike = (value)=>value !== null && typeof value === "object"
;
const _isFunctionLike = (value)=>value !== null && typeof value === "function"
;
function isAnyArrayBuffer(value) {
    return _isObjectLike(value) && (_toString.call(value) === "[object ArrayBuffer]" || _toString.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Arguments]";
}
function isArrayBuffer(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction(value) {
    return _isFunctionLike(value) && _toString.call(value) === "[object AsyncFunction]";
}
function isBooleanObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Boolean]";
}
function isBoxedPrimitive(value) {
    return isBooleanObject(value) || isStringObject(value) || isNumberObject(value) || isSymbolObject(value) || isBigIntObject(value);
}
function isDataView(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object DataView]";
}
function isDate(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Date]";
}
function isGeneratorFunction(value) {
    return _isFunctionLike(value) && _toString.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Generator]";
}
function isMap(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Map]";
}
function isMapIterator(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Module]";
}
function isNativeError(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Error]";
}
function isNumberObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Number]";
}
function isBigIntObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object BigInt]";
}
function isPromise(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Promise]";
}
function isRegExp(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object RegExp]";
}
function isSet(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Set]";
}
function isSetIterator(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object String]";
}
function isSymbolObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Symbol]";
}
function isWeakMap(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object WeakMap]";
}
function isWeakSet(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object WeakSet]";
}
const __default1 = {
    isAsyncFunction,
    isGeneratorFunction,
    isAnyArrayBuffer,
    isArrayBuffer,
    isArgumentsObject,
    isBoxedPrimitive,
    isDataView,
    isMap,
    isMapIterator,
    isModuleNamespaceObject,
    isNativeError,
    isPromise,
    isSet,
    isSetIterator,
    isWeakMap,
    isWeakSet,
    isRegExp,
    isDate,
    isStringObject,
    isNumberObject,
    isBooleanObject,
    isBigIntObject
};
const mod = {
    isAnyArrayBuffer: isAnyArrayBuffer,
    isArgumentsObject: isArgumentsObject,
    isArrayBuffer: isArrayBuffer,
    isAsyncFunction: isAsyncFunction,
    isBooleanObject: isBooleanObject,
    isBoxedPrimitive: isBoxedPrimitive,
    isDataView: isDataView,
    isDate: isDate,
    isGeneratorFunction: isGeneratorFunction,
    isGeneratorObject: isGeneratorObject,
    isMap: isMap,
    isMapIterator: isMapIterator,
    isModuleNamespaceObject: isModuleNamespaceObject,
    isNativeError: isNativeError,
    isNumberObject: isNumberObject,
    isBigIntObject: isBigIntObject,
    isPromise: isPromise,
    isRegExp: isRegExp,
    isSet: isSet,
    isSetIterator: isSetIterator,
    isSharedArrayBuffer: isSharedArrayBuffer,
    isStringObject: isStringObject,
    isSymbolObject: isSymbolObject,
    isWeakMap: isWeakMap,
    isWeakSet: isWeakSet,
    default: __default1
};
Symbol("kKeyObject");
Symbol("kKeyType");
const _toString1 = Object.prototype.toString;
const _isObjectLike1 = (value)=>value !== null && typeof value === "object"
;
function isArrayBufferView(value) {
    return ArrayBuffer.isView(value);
}
function isFloat32Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Float32Array]";
}
function isFloat64Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Float64Array]";
}
function isTypedArray(value) {
    const reTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;
    return _isObjectLike1(value) && reTypedTag.test(_toString1.call(value));
}
function isUint8Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Uint8Array]";
}
const { isDate: isDate1 , isArgumentsObject: isArgumentsObject1 , isBigIntObject: isBigIntObject1 , isBooleanObject: isBooleanObject1 , isNumberObject: isNumberObject1 , isStringObject: isStringObject1 , isSymbolObject: isSymbolObject1 , isNativeError: isNativeError1 , isRegExp: isRegExp1 , isAsyncFunction: isAsyncFunction1 , isGeneratorFunction: isGeneratorFunction1 , isGeneratorObject: isGeneratorObject1 , isPromise: isPromise1 , isMap: isMap1 , isSet: isSet1 , isMapIterator: isMapIterator1 , isSetIterator: isSetIterator1 , isWeakMap: isWeakMap1 , isWeakSet: isWeakSet1 , isArrayBuffer: isArrayBuffer1 , isDataView: isDataView1 , isSharedArrayBuffer: isSharedArrayBuffer1 , isModuleNamespaceObject: isModuleNamespaceObject1 , isAnyArrayBuffer: isAnyArrayBuffer1 , isBoxedPrimitive: isBoxedPrimitive1 ,  } = mod;
function normalizeEncoding(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases(enc);
}
function slowCases(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        case 9:
            if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
                return "base64url";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
function isInt32(value) {
    return value === (value | 0);
}
function isUint32(value) {
    return value === value >>> 0;
}
const validateBuffer = hideStackFrames((buffer, name = "buffer")=>{
    if (!isArrayBufferView(buffer)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, [
            "Buffer",
            "TypedArray",
            "DataView"
        ], buffer);
    }
});
hideStackFrames((value, name, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER)=>{
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
const validateObject = hideStackFrames((value, name, options)=>{
    const useDefaultOptions = options == null;
    const allowArray = useDefaultOptions ? false : options.allowArray;
    const allowFunction = useDefaultOptions ? false : options.allowFunction;
    const nullable = useDefaultOptions ? false : options.nullable;
    if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Object", value);
    }
});
hideStackFrames((value, name, min = -2147483648, max = 2147483647)=>{
    if (!isInt32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
hideStackFrames((value, name, positive)=>{
    if (!isUint32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        const min = positive ? 1 : 0;
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && < 4294967296`, value);
    }
    if (positive && value === 0) {
        throw new codes.ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
    }
});
function validateString(value, name) {
    if (typeof value !== "string") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "string", value);
    }
}
hideStackFrames((value, name, oneOf)=>{
    if (!Array.prototype.includes.call(oneOf, value)) {
        const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v)=>typeof v === "string" ? `'${v}'` : String(v)
        ), ", ");
        const reason = "must be one of: " + allowed;
        throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
hideStackFrames((callback)=>{
    if (typeof callback !== "function") {
        throw new codes.ERR_INVALID_CALLBACK(callback);
    }
});
hideStackFrames((signal, name)=>{
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
});
const validateFunction = hideStackFrames((value, name)=>{
    if (typeof value !== "function") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Function", value);
    }
});
hideStackFrames((value, name, minLength = 0)=>{
    if (!Array.isArray(value)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Array", value);
    }
    if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
Symbol.for("nodejs.util.inspect.custom");
const kEnumerableProperty = Object.create(null);
kEnumerableProperty.enumerable = true;
new Set();
const kCustomPromisifiedSymbol = Symbol.for("nodejs.util.promisify.custom");
const kCustomPromisifyArgsSymbol = Symbol.for("nodejs.util.promisify.customArgs");
function promisify(original) {
    validateFunction(original, "original");
    if (original[kCustomPromisifiedSymbol]) {
        const fn = original[kCustomPromisifiedSymbol];
        validateFunction(fn, "util.promisify.custom");
        return Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    const argumentNames = original[kCustomPromisifyArgsSymbol];
    function fn(...args) {
        return new Promise((resolve3, reject)=>{
            args.push((err, ...values)=>{
                if (err) {
                    return reject(err);
                }
                if (argumentNames !== undefined && values.length > 1) {
                    const obj = {};
                    for(let i8 = 0; i8 < argumentNames.length; i8++){
                        obj[argumentNames[i8]] = values[i8];
                    }
                    resolve3(obj);
                } else {
                    resolve3(values[0]);
                }
            });
            Reflect.apply(original, this, args);
        });
    }
    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn, Object.getOwnPropertyDescriptors(original));
}
promisify.custom = kCustomPromisifiedSymbol;
let core;
if (Deno?.core) {
    core = Deno.core;
} else {
    core = {
        setNextTickCallback: undefined,
        evalContext (_code, _filename) {
            throw new Error("Deno.core.evalContext is not supported in this environment");
        },
        encode (chunk) {
            return new TextEncoder().encode(chunk);
        }
    };
}
const kSize = 2048;
const kMask = 2048 - 1;
class FixedCircularBuffer {
    bottom;
    top;
    list;
    next;
    constructor(){
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
    }
    isEmpty() {
        return this.top === this.bottom;
    }
    isFull() {
        return (this.top + 1 & kMask) === this.bottom;
    }
    push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
    }
    shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === undefined) {
            return null;
        }
        this.list[this.bottom] = undefined;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
    }
}
class FixedQueue {
    head;
    tail;
    constructor(){
        this.head = this.tail = new FixedCircularBuffer();
    }
    isEmpty() {
        return this.head.isEmpty();
    }
    push(data) {
        if (this.head.isFull()) {
            this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
    }
    shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
            this.tail = tail.next;
        }
        return next;
    }
}
const queue = new FixedQueue();
if (typeof core.setNextTickCallback !== "undefined") {
    function runNextTicks() {
        if (!core.hasTickScheduled()) {
            core.runMicrotasks();
        }
        if (!core.hasTickScheduled()) {
            return true;
        }
        processTicksAndRejections();
        return true;
    }
    function processTicksAndRejections() {
        let tock;
        do {
            while(tock = queue.shift()){
                try {
                    const callback = tock.callback;
                    if (tock.args === undefined) {
                        callback();
                    } else {
                        const args = tock.args;
                        switch(args.length){
                            case 1:
                                callback(args[0]);
                                break;
                            case 2:
                                callback(args[0], args[1]);
                                break;
                            case 3:
                                callback(args[0], args[1], args[2]);
                                break;
                            case 4:
                                callback(args[0], args[1], args[2], args[3]);
                                break;
                            default:
                                callback(...args);
                        }
                    }
                } finally{}
            }
            core.runMicrotasks();
        }while (!queue.isEmpty())
        core.setHasTickScheduled(false);
    }
    core.setNextTickCallback(processTicksAndRejections);
    core.setMacrotaskCallback(runNextTicks);
} else {}
var State;
(function(State1) {
    State1[State1["PASSTHROUGH"] = 0] = "PASSTHROUGH";
    State1[State1["PERCENT"] = 1] = "PERCENT";
    State1[State1["POSITIONAL"] = 2] = "POSITIONAL";
    State1[State1["PRECISION"] = 3] = "PRECISION";
    State1[State1["WIDTH"] = 4] = "WIDTH";
})(State || (State = {}));
var WorP;
(function(WorP1) {
    WorP1[WorP1["WIDTH"] = 0] = "WIDTH";
    WorP1[WorP1["PRECISION"] = 1] = "PRECISION";
})(WorP || (WorP = {}));
var F;
(function(F1) {
    F1[F1["sign"] = 1] = "sign";
    F1[F1["mantissa"] = 2] = "mantissa";
    F1[F1["fractional"] = 3] = "fractional";
    F1[F1["esign"] = 4] = "esign";
    F1[F1["exponent"] = 5] = "exponent";
})(F || (F = {}));
const { Deno: Deno1  } = globalThis;
typeof Deno1?.noColor === "boolean" ? Deno1.noColor : true;
new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))", 
].join("|"), "g");
var DiffType;
(function(DiffType1) {
    DiffType1["removed"] = "removed";
    DiffType1["common"] = "common";
    DiffType1["added"] = "added";
})(DiffType || (DiffType = {}));
class AssertionError extends Error {
    name = "AssertionError";
    constructor(message){
        super(message);
    }
}
function unreachable() {
    throw new AssertionError("unreachable");
}
class DenoStdInternalError extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError(msg);
    }
}
function indexOfNeedle(source, needle, start = 0) {
    if (start >= source.length) {
        return -1;
    }
    if (start < 0) {
        start = Math.max(0, source.length + start);
    }
    const s1 = needle[0];
    for(let i9 = start; i9 < source.length; i9++){
        if (source[i9] !== s1) continue;
        const pin = i9;
        let matched = 1;
        let j = i9;
        while(matched < needle.length){
            j++;
            if (source[j] !== needle[j - pin]) {
                break;
            }
            matched++;
        }
        if (matched === needle.length) {
            return pin;
        }
    }
    return -1;
}
function copy(src1, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src1.byteLength > dstBytesAvailable) {
        src1 = src1.subarray(0, dstBytesAvailable);
    }
    dst.set(src1, off);
    return src1.byteLength;
}
const MIN_BUF_SIZE = 16;
const CR = "\r".charCodeAt(0);
const LF = "\n".charCodeAt(0);
class BufferFullError extends Error {
    name;
    constructor(partial){
        super("Buffer full");
        this.partial = partial;
        this.name = "BufferFullError";
    }
    partial;
}
class PartialReadError extends Error {
    name = "PartialReadError";
    partial;
    constructor(){
        super("Encountered UnexpectedEof, data only partially read");
    }
}
class BufReader {
    #buf;
    #rd;
    #r = 0;
    #w = 0;
    #eof = false;
    static create(r1, size = 4096) {
        return r1 instanceof BufReader ? r1 : new BufReader(r1, size);
    }
    constructor(rd, size = 4096){
        if (size < 16) {
            size = MIN_BUF_SIZE;
        }
        this.#reset(new Uint8Array(size), rd);
    }
    size() {
        return this.#buf.byteLength;
    }
    buffered() {
        return this.#w - this.#r;
    }
    #fill = async ()=>{
        if (this.#r > 0) {
            this.#buf.copyWithin(0, this.#r, this.#w);
            this.#w -= this.#r;
            this.#r = 0;
        }
        if (this.#w >= this.#buf.byteLength) {
            throw Error("bufio: tried to fill full buffer");
        }
        for(let i10 = 100; i10 > 0; i10--){
            const rr = await this.#rd.read(this.#buf.subarray(this.#w));
            if (rr === null) {
                this.#eof = true;
                return;
            }
            assert(rr >= 0, "negative read");
            this.#w += rr;
            if (rr > 0) {
                return;
            }
        }
        throw new Error(`No progress after ${100} read() calls`);
    };
    reset(r2) {
        this.#reset(this.#buf, r2);
    }
    #reset = (buf, rd)=>{
        this.#buf = buf;
        this.#rd = rd;
        this.#eof = false;
    };
    async read(p) {
        let rr = p.byteLength;
        if (p.byteLength === 0) return rr;
        if (this.#r === this.#w) {
            if (p.byteLength >= this.#buf.byteLength) {
                const rr = await this.#rd.read(p);
                const nread = rr ?? 0;
                assert(nread >= 0, "negative read");
                return rr;
            }
            this.#r = 0;
            this.#w = 0;
            rr = await this.#rd.read(this.#buf);
            if (rr === 0 || rr === null) return rr;
            assert(rr >= 0, "negative read");
            this.#w += rr;
        }
        const copied = copy(this.#buf.subarray(this.#r, this.#w), p, 0);
        this.#r += copied;
        return copied;
    }
    async readFull(p) {
        let bytesRead = 0;
        while(bytesRead < p.length){
            try {
                const rr = await this.read(p.subarray(bytesRead));
                if (rr === null) {
                    if (bytesRead === 0) {
                        return null;
                    } else {
                        throw new PartialReadError();
                    }
                }
                bytesRead += rr;
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = p.subarray(0, bytesRead);
                } else if (err instanceof Error) {
                    const e1 = new PartialReadError();
                    e1.partial = p.subarray(0, bytesRead);
                    e1.stack = err.stack;
                    e1.message = err.message;
                    e1.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return p;
    }
    async readByte() {
        while(this.#r === this.#w){
            if (this.#eof) return null;
            await this.#fill();
        }
        const c = this.#buf[this.#r];
        this.#r++;
        return c;
    }
    async readString(delim) {
        if (delim.length !== 1) {
            throw new Error("Delimiter should be a single character");
        }
        const buffer = await this.readSlice(delim.charCodeAt(0));
        if (buffer === null) return null;
        return new TextDecoder().decode(buffer);
    }
    async readLine() {
        let line = null;
        try {
            line = await this.readSlice(LF);
        } catch (err) {
            if (err instanceof Deno.errors.BadResource) {
                throw err;
            }
            let partial;
            if (err instanceof PartialReadError) {
                partial = err.partial;
                assert(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
            }
            if (!(err instanceof BufferFullError)) {
                throw err;
            }
            partial = err.partial;
            if (!this.#eof && partial && partial.byteLength > 0 && partial[partial.byteLength - 1] === CR) {
                assert(this.#r > 0, "bufio: tried to rewind past start of buffer");
                this.#r--;
                partial = partial.subarray(0, partial.byteLength - 1);
            }
            if (partial) {
                return {
                    line: partial,
                    more: !this.#eof
                };
            }
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return {
                line,
                more: false
            };
        }
        if (line[line.byteLength - 1] == LF) {
            let drop = 1;
            if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
                drop = 2;
            }
            line = line.subarray(0, line.byteLength - drop);
        }
        return {
            line,
            more: false
        };
    }
    async readSlice(delim) {
        let s2 = 0;
        let slice;
        while(true){
            let i11 = this.#buf.subarray(this.#r + s2, this.#w).indexOf(delim);
            if (i11 >= 0) {
                i11 += s2;
                slice = this.#buf.subarray(this.#r, this.#r + i11 + 1);
                this.#r += i11 + 1;
                break;
            }
            if (this.#eof) {
                if (this.#r === this.#w) {
                    return null;
                }
                slice = this.#buf.subarray(this.#r, this.#w);
                this.#r = this.#w;
                break;
            }
            if (this.buffered() >= this.#buf.byteLength) {
                this.#r = this.#w;
                const oldbuf = this.#buf;
                const newbuf = this.#buf.slice(0);
                this.#buf = newbuf;
                throw new BufferFullError(oldbuf);
            }
            s2 = this.#w - this.#r;
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = slice;
                } else if (err instanceof Error) {
                    const e2 = new PartialReadError();
                    e2.partial = slice;
                    e2.stack = err.stack;
                    e2.message = err.message;
                    e2.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return slice;
    }
    async peek(n6) {
        if (n6 < 0) {
            throw Error("negative count");
        }
        let avail = this.#w - this.#r;
        while(avail < n6 && avail < this.#buf.byteLength && !this.#eof){
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = this.#buf.subarray(this.#r, this.#w);
                } else if (err instanceof Error) {
                    const e3 = new PartialReadError();
                    e3.partial = this.#buf.subarray(this.#r, this.#w);
                    e3.stack = err.stack;
                    e3.message = err.message;
                    e3.cause = err.cause;
                    throw err;
                }
                throw err;
            }
            avail = this.#w - this.#r;
        }
        if (avail === 0 && this.#eof) {
            return null;
        } else if (avail < n6 && this.#eof) {
            return this.#buf.subarray(this.#r, this.#r + avail);
        } else if (avail < n6) {
            throw new BufferFullError(this.#buf.subarray(this.#r, this.#w));
        }
        return this.#buf.subarray(this.#r, this.#r + n6);
    }
}
class AbstractBufBase {
    buf;
    usedBufferBytes = 0;
    err = null;
    constructor(buf){
        this.buf = buf;
    }
    size() {
        return this.buf.byteLength;
    }
    available() {
        return this.buf.byteLength - this.usedBufferBytes;
    }
    buffered() {
        return this.usedBufferBytes;
    }
}
class BufWriter extends AbstractBufBase {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriter ? writer : new BufWriter(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w;
    }
    async flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p.length){
                nwritten += await this.#writer.write(p.subarray(nwritten));
            }
        } catch (e4) {
            if (e4 instanceof Error) {
                this.err = e4;
            }
            throw e4;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    async write(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = await this.#writer.write(data);
                } catch (e5) {
                    if (e5 instanceof Error) {
                        this.err = e5;
                    }
                    throw e5;
                }
            } else {
                numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                await this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
class BufWriterSync extends AbstractBufBase {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriterSync ? writer : new BufWriterSync(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w;
    }
    flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p.length){
                nwritten += this.#writer.writeSync(p.subarray(nwritten));
            }
        } catch (e6) {
            if (e6 instanceof Error) {
                this.err = e6;
            }
            throw e6;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    writeSync(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = this.#writer.writeSync(data);
                } catch (e7) {
                    if (e7 instanceof Error) {
                        this.err = e7;
                    }
                    throw e7;
                }
            } else {
                numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
const isNumericLookup = {};
function isArrayIndex(value) {
    switch(typeof value){
        case "number":
            return value >= 0 && (value | 0) === value;
        case "string":
            {
                const result = isNumericLookup[value];
                if (result !== void 0) {
                    return result;
                }
                const length = value.length;
                if (length === 0) {
                    return isNumericLookup[value] = false;
                }
                let ch = 0;
                let i12 = 0;
                for(; i12 < length; ++i12){
                    ch = value.charCodeAt(i12);
                    if (i12 === 0 && ch === 0x30 && length > 1 || ch < 0x30 || ch > 0x39) {
                        return isNumericLookup[value] = false;
                    }
                }
                return isNumericLookup[value] = true;
            }
        default:
            return false;
    }
}
function getOwnNonIndexProperties(obj, filter) {
    let allProperties = [
        ...Object.getOwnPropertyNames(obj),
        ...Object.getOwnPropertySymbols(obj), 
    ];
    if (Array.isArray(obj)) {
        allProperties = allProperties.filter((k)=>!isArrayIndex(k)
        );
    }
    if (filter === 0) {
        return allProperties;
    }
    const result = [];
    for (const key of allProperties){
        const desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc === undefined) {
            continue;
        }
        if (filter & 1 && !desc.writable) {
            continue;
        }
        if (filter & 2 && !desc.enumerable) {
            continue;
        }
        if (filter & 4 && !desc.configurable) {
            continue;
        }
        if (filter & 8 && typeof key === "string") {
            continue;
        }
        if (filter & 16 && typeof key === "symbol") {
            continue;
        }
        result.push(key);
    }
    return result;
}
const kObjectType = 0;
const kArrayExtrasType = 2;
const kRejected = 2;
const meta = [
    '\\x00',
    '\\x01',
    '\\x02',
    '\\x03',
    '\\x04',
    '\\x05',
    '\\x06',
    '\\x07',
    '\\b',
    '\\t',
    '\\n',
    '\\x0B',
    '\\f',
    '\\r',
    '\\x0E',
    '\\x0F',
    '\\x10',
    '\\x11',
    '\\x12',
    '\\x13',
    '\\x14',
    '\\x15',
    '\\x16',
    '\\x17',
    '\\x18',
    '\\x19',
    '\\x1A',
    '\\x1B',
    '\\x1C',
    '\\x1D',
    '\\x1E',
    '\\x1F',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    "\\'",
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\\\',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\x7F',
    '\\x80',
    '\\x81',
    '\\x82',
    '\\x83',
    '\\x84',
    '\\x85',
    '\\x86',
    '\\x87',
    '\\x88',
    '\\x89',
    '\\x8A',
    '\\x8B',
    '\\x8C',
    '\\x8D',
    '\\x8E',
    '\\x8F',
    '\\x90',
    '\\x91',
    '\\x92',
    '\\x93',
    '\\x94',
    '\\x95',
    '\\x96',
    '\\x97',
    '\\x98',
    '\\x99',
    '\\x9A',
    '\\x9B',
    '\\x9C',
    '\\x9D',
    '\\x9E',
    '\\x9F'
];
const isUndetectableObject = (v)=>typeof v === "undefined" && v !== undefined
;
const strEscapeSequencesRegExp = /[\x00-\x1f\x27\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacer = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g;
const strEscapeSequencesRegExpSingle = /[\x00-\x1f\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacerSingle = /[\x00-\x1f\x5c\x7f-\x9f]/g;
const keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
const numberRegExp = /^(0|[1-9][0-9]*)$/;
const nodeModulesRegExp = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
const classRegExp = /^(\s+[^(]*?)\s*{/;
const stripCommentsRegExp = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g;
const inspectDefaultOptions = {
    showHidden: false,
    depth: 2,
    colors: false,
    customInspect: true,
    showProxy: false,
    maxArrayLength: 100,
    maxStringLength: 10000,
    breakLength: 80,
    compact: 3,
    sorted: false,
    getters: false
};
function getUserOptions(ctx, isCrossContext) {
    const ret = {
        stylize: ctx.stylize,
        showHidden: ctx.showHidden,
        depth: ctx.depth,
        colors: ctx.colors,
        customInspect: ctx.customInspect,
        showProxy: ctx.showProxy,
        maxArrayLength: ctx.maxArrayLength,
        maxStringLength: ctx.maxStringLength,
        breakLength: ctx.breakLength,
        compact: ctx.compact,
        sorted: ctx.sorted,
        getters: ctx.getters,
        ...ctx.userOptions
    };
    if (isCrossContext) {
        Object.setPrototypeOf(ret, null);
        for (const key of Object.keys(ret)){
            if ((typeof ret[key] === "object" || typeof ret[key] === "function") && ret[key] !== null) {
                delete ret[key];
            }
        }
        ret.stylize = Object.setPrototypeOf((value, flavour)=>{
            let stylized;
            try {
                stylized = `${ctx.stylize(value, flavour)}`;
            } catch  {}
            if (typeof stylized !== "string") return value;
            return stylized;
        }, null);
    }
    return ret;
}
function inspect(value, opts) {
    const ctx = {
        budget: {},
        indentationLvl: 0,
        seen: [],
        currentDepth: 0,
        stylize: stylizeNoColor,
        showHidden: inspectDefaultOptions.showHidden,
        depth: inspectDefaultOptions.depth,
        colors: inspectDefaultOptions.colors,
        customInspect: inspectDefaultOptions.customInspect,
        showProxy: inspectDefaultOptions.showProxy,
        maxArrayLength: inspectDefaultOptions.maxArrayLength,
        maxStringLength: inspectDefaultOptions.maxStringLength,
        breakLength: inspectDefaultOptions.breakLength,
        compact: inspectDefaultOptions.compact,
        sorted: inspectDefaultOptions.sorted,
        getters: inspectDefaultOptions.getters
    };
    if (arguments.length > 1) {
        if (arguments.length > 2) {
            if (arguments[2] !== undefined) {
                ctx.depth = arguments[2];
            }
            if (arguments.length > 3 && arguments[3] !== undefined) {
                ctx.colors = arguments[3];
            }
        }
        if (typeof opts === "boolean") {
            ctx.showHidden = opts;
        } else if (opts) {
            const optKeys = Object.keys(opts);
            for(let i13 = 0; i13 < optKeys.length; ++i13){
                const key = optKeys[i13];
                if (inspectDefaultOptions.hasOwnProperty(key) || key === "stylize") {
                    ctx[key] = opts[key];
                } else if (ctx.userOptions === undefined) {
                    ctx.userOptions = opts;
                }
            }
        }
    }
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;
    if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;
    return formatValue(ctx, value, 0);
}
const customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
inspect.custom = customInspectSymbol;
Object.defineProperty(inspect, "defaultOptions", {
    get () {
        return inspectDefaultOptions;
    },
    set (options) {
        validateObject(options, "options");
        return Object.assign(inspectDefaultOptions, options);
    }
});
const defaultFG = 39;
const defaultBG = 49;
inspect.colors = Object.assign(Object.create(null), {
    reset: [
        0,
        0
    ],
    bold: [
        1,
        22
    ],
    dim: [
        2,
        22
    ],
    italic: [
        3,
        23
    ],
    underline: [
        4,
        24
    ],
    blink: [
        5,
        25
    ],
    inverse: [
        7,
        27
    ],
    hidden: [
        8,
        28
    ],
    strikethrough: [
        9,
        29
    ],
    doubleunderline: [
        21,
        24
    ],
    black: [
        30,
        defaultFG
    ],
    red: [
        31,
        defaultFG
    ],
    green: [
        32,
        defaultFG
    ],
    yellow: [
        33,
        defaultFG
    ],
    blue: [
        34,
        defaultFG
    ],
    magenta: [
        35,
        defaultFG
    ],
    cyan: [
        36,
        defaultFG
    ],
    white: [
        37,
        defaultFG
    ],
    bgBlack: [
        40,
        defaultBG
    ],
    bgRed: [
        41,
        defaultBG
    ],
    bgGreen: [
        42,
        defaultBG
    ],
    bgYellow: [
        43,
        defaultBG
    ],
    bgBlue: [
        44,
        defaultBG
    ],
    bgMagenta: [
        45,
        defaultBG
    ],
    bgCyan: [
        46,
        defaultBG
    ],
    bgWhite: [
        47,
        defaultBG
    ],
    framed: [
        51,
        54
    ],
    overlined: [
        53,
        55
    ],
    gray: [
        90,
        defaultFG
    ],
    redBright: [
        91,
        defaultFG
    ],
    greenBright: [
        92,
        defaultFG
    ],
    yellowBright: [
        93,
        defaultFG
    ],
    blueBright: [
        94,
        defaultFG
    ],
    magentaBright: [
        95,
        defaultFG
    ],
    cyanBright: [
        96,
        defaultFG
    ],
    whiteBright: [
        97,
        defaultFG
    ],
    bgGray: [
        100,
        defaultBG
    ],
    bgRedBright: [
        101,
        defaultBG
    ],
    bgGreenBright: [
        102,
        defaultBG
    ],
    bgYellowBright: [
        103,
        defaultBG
    ],
    bgBlueBright: [
        104,
        defaultBG
    ],
    bgMagentaBright: [
        105,
        defaultBG
    ],
    bgCyanBright: [
        106,
        defaultBG
    ],
    bgWhiteBright: [
        107,
        defaultBG
    ]
});
function defineColorAlias(target4, alias) {
    Object.defineProperty(inspect.colors, alias, {
        get () {
            return this[target4];
        },
        set (value) {
            this[target4] = value;
        },
        configurable: true,
        enumerable: false
    });
}
defineColorAlias("gray", "grey");
defineColorAlias("gray", "blackBright");
defineColorAlias("bgGray", "bgGrey");
defineColorAlias("bgGray", "bgBlackBright");
defineColorAlias("dim", "faint");
defineColorAlias("strikethrough", "crossedout");
defineColorAlias("strikethrough", "strikeThrough");
defineColorAlias("strikethrough", "crossedOut");
defineColorAlias("hidden", "conceal");
defineColorAlias("inverse", "swapColors");
defineColorAlias("inverse", "swapcolors");
defineColorAlias("doubleunderline", "doubleUnderline");
inspect.styles = Object.assign(Object.create(null), {
    special: "cyan",
    number: "yellow",
    bigint: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    symbol: "green",
    date: "magenta",
    regexp: "red",
    module: "underline"
});
function addQuotes(str, quotes) {
    if (quotes === -1) {
        return `"${str}"`;
    }
    if (quotes === -2) {
        return `\`${str}\``;
    }
    return `'${str}'`;
}
const escapeFn = (str)=>meta[str.charCodeAt(0)]
;
function strEscape(str) {
    let escapeTest = strEscapeSequencesRegExp;
    let escapeReplace = strEscapeSequencesReplacer;
    let singleQuote = 39;
    if (str.includes("'")) {
        if (!str.includes('"')) {
            singleQuote = -1;
        } else if (!str.includes("`") && !str.includes("${")) {
            singleQuote = -2;
        }
        if (singleQuote !== 39) {
            escapeTest = strEscapeSequencesRegExpSingle;
            escapeReplace = strEscapeSequencesReplacerSingle;
        }
    }
    if (str.length < 5000 && !escapeTest.test(str)) {
        return addQuotes(str, singleQuote);
    }
    if (str.length > 100) {
        str = str.replace(escapeReplace, escapeFn);
        return addQuotes(str, singleQuote);
    }
    let result = "";
    let last = 0;
    const lastIndex = str.length;
    for(let i14 = 0; i14 < lastIndex; i14++){
        const point = str.charCodeAt(i14);
        if (point === singleQuote || point === 92 || point < 32 || point > 126 && point < 160) {
            if (last === i14) {
                result += meta[point];
            } else {
                result += `${str.slice(last, i14)}${meta[point]}`;
            }
            last = i14 + 1;
        }
    }
    if (last !== lastIndex) {
        result += str.slice(last);
    }
    return addQuotes(result, singleQuote);
}
function stylizeWithColor(str, styleType) {
    const style = inspect.styles[styleType];
    if (style !== undefined) {
        const color = inspect.colors[style];
        if (color !== undefined) {
            return `\u001b[${color[0]}m${str}\u001b[${color[1]}m`;
        }
    }
    return str;
}
function stylizeNoColor(str) {
    return str;
}
function formatValue(ctx, value, recurseTimes, typedArray) {
    if (typeof value !== "object" && typeof value !== "function" && !isUndetectableObject(value)) {
        return formatPrimitive(ctx.stylize, value, ctx);
    }
    if (value === null) {
        return ctx.stylize("null", "null");
    }
    const context = value;
    const proxy = undefined;
    if (ctx.customInspect) {
        const maybeCustom = value[customInspectSymbol];
        if (typeof maybeCustom === "function" && maybeCustom !== inspect && !(value.constructor && value.constructor.prototype === value)) {
            const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
            const isCrossContext = proxy !== undefined || !(context instanceof Object);
            const ret = maybeCustom.call(context, depth, getUserOptions(ctx, isCrossContext));
            if (ret !== context) {
                if (typeof ret !== "string") {
                    return formatValue(ctx, ret, recurseTimes);
                }
                return ret.replace(/\n/g, `\n${" ".repeat(ctx.indentationLvl)}`);
            }
        }
    }
    if (ctx.seen.includes(value)) {
        let index = 1;
        if (ctx.circular === undefined) {
            ctx.circular = new Map();
            ctx.circular.set(value, index);
        } else {
            index = ctx.circular.get(value);
            if (index === undefined) {
                index = ctx.circular.size + 1;
                ctx.circular.set(value, index);
            }
        }
        return ctx.stylize(`[Circular *${index}]`, "special");
    }
    return formatRaw(ctx, value, recurseTimes, typedArray);
}
function formatRaw(ctx, value, recurseTimes, typedArray) {
    let keys;
    let protoProps;
    if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {
        protoProps = [];
    }
    const constructor = getConstructorName(value, ctx, recurseTimes, protoProps);
    if (protoProps !== undefined && protoProps.length === 0) {
        protoProps = undefined;
    }
    let tag = value[Symbol.toStringTag];
    if (typeof tag !== "string") {
        tag = "";
    }
    let base2 = "";
    let formatter = getEmptyFormatArray;
    let braces;
    let noIterator = true;
    let i15 = 0;
    const filter = ctx.showHidden ? 0 : 2;
    let extrasType = 0;
    if (value[Symbol.iterator] || constructor === null) {
        noIterator = false;
        if (Array.isArray(value)) {
            const prefix = constructor !== "Array" || tag !== "" ? getPrefix(constructor, tag, "Array", `(${value.length})`) : "";
            keys = getOwnNonIndexProperties(value, filter);
            braces = [
                `${prefix}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}]`;
            }
            extrasType = kArrayExtrasType;
            formatter = formatArray;
        } else if (isSet1(value)) {
            const size = value.size;
            const prefix = getPrefix(constructor, tag, "Set", `(${size})`);
            keys = getKeys(value, ctx.showHidden);
            formatter = constructor !== null ? formatSet.bind(null, value) : formatSet.bind(null, value.values());
            if (size === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix}{}`;
            }
            braces = [
                `${prefix}{`,
                "}"
            ];
        } else if (isMap1(value)) {
            const size = value.size;
            const prefix = getPrefix(constructor, tag, "Map", `(${size})`);
            keys = getKeys(value, ctx.showHidden);
            formatter = constructor !== null ? formatMap.bind(null, value) : formatMap.bind(null, value.entries());
            if (size === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix}{}`;
            }
            braces = [
                `${prefix}{`,
                "}"
            ];
        } else if (isTypedArray(value)) {
            keys = getOwnNonIndexProperties(value, filter);
            const bound = value;
            const fallback = "";
            const size = value.length;
            const prefix = getPrefix(constructor, tag, fallback, `(${size})`);
            braces = [
                `${prefix}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
                return `${braces[0]}]`;
            }
            formatter = formatTypedArray.bind(null, bound, size);
            extrasType = kArrayExtrasType;
        } else if (isMapIterator1(value)) {
            keys = getKeys(value, ctx.showHidden);
            braces = getIteratorBraces("Map", tag);
            formatter = formatIterator.bind(null, braces);
        } else if (isSetIterator1(value)) {
            keys = getKeys(value, ctx.showHidden);
            braces = getIteratorBraces("Set", tag);
            formatter = formatIterator.bind(null, braces);
        } else {
            noIterator = true;
        }
    }
    if (noIterator) {
        keys = getKeys(value, ctx.showHidden);
        braces = [
            "{",
            "}"
        ];
        if (constructor === "Object") {
            if (isArgumentsObject1(value)) {
                braces[0] = "[Arguments] {";
            } else if (tag !== "") {
                braces[0] = `${getPrefix(constructor, tag, "Object")}{`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}}`;
            }
        } else if (typeof value === "function") {
            base2 = getFunctionBase(value, constructor, tag);
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base2, "special");
            }
        } else if (isRegExp1(value)) {
            base2 = RegExp(constructor !== null ? value : new RegExp(value)).toString();
            const prefix = getPrefix(constructor, tag, "RegExp");
            if (prefix !== "RegExp ") {
                base2 = `${prefix}${base2}`;
            }
            if (keys.length === 0 && protoProps === undefined || recurseTimes > ctx.depth && ctx.depth !== null) {
                return ctx.stylize(base2, "regexp");
            }
        } else if (isDate1(value)) {
            base2 = Number.isNaN(value.getTime()) ? value.toString() : value.toISOString();
            const prefix = getPrefix(constructor, tag, "Date");
            if (prefix !== "Date ") {
                base2 = `${prefix}${base2}`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base2, "date");
            }
        } else if (value instanceof Error) {
            base2 = formatError(value, constructor, tag, ctx, keys);
            if (keys.length === 0 && protoProps === undefined) {
                return base2;
            }
        } else if (isAnyArrayBuffer1(value)) {
            const arrayType = isArrayBuffer1(value) ? "ArrayBuffer" : "SharedArrayBuffer";
            const prefix = getPrefix(constructor, tag, arrayType);
            if (typedArray === undefined) {
                formatter = formatArrayBuffer;
            } else if (keys.length === 0 && protoProps === undefined) {
                return prefix + `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;
            }
            braces[0] = `${prefix}{`;
            Array.prototype.unshift(keys, "byteLength");
        } else if (isDataView1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "DataView")}{`;
            Array.prototype.unshift(keys, "byteLength", "byteOffset", "buffer");
        } else if (isPromise1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "Promise")}{`;
            formatter = formatPromise;
        } else if (isWeakSet1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "WeakSet")}{`;
            formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;
        } else if (isWeakMap1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "WeakMap")}{`;
            formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;
        } else if (isModuleNamespaceObject1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "Module")}{`;
            formatter = formatNamespaceObject.bind(null, keys);
        } else if (isBoxedPrimitive1(value)) {
            base2 = getBoxedBase(value, ctx, keys, constructor, tag);
            if (keys.length === 0 && protoProps === undefined) {
                return base2;
            }
        } else {
            if (keys.length === 0 && protoProps === undefined) {
                return `${getCtxStyle(value, constructor, tag)}{}`;
            }
            braces[0] = `${getCtxStyle(value, constructor, tag)}{`;
        }
    }
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        let constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);
        if (constructor !== null) {
            constructorName = `[${constructorName}]`;
        }
        return ctx.stylize(constructorName, "special");
    }
    recurseTimes += 1;
    ctx.seen.push(value);
    ctx.currentDepth = recurseTimes;
    let output;
    const indentationLvl = ctx.indentationLvl;
    try {
        output = formatter(ctx, value, recurseTimes);
        for(i15 = 0; i15 < keys.length; i15++){
            output.push(formatProperty(ctx, value, recurseTimes, keys[i15], extrasType));
        }
        if (protoProps !== undefined) {
            output.push(...protoProps);
        }
    } catch (err) {
        const constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);
        return handleMaxCallStackSize(ctx, err, constructorName, indentationLvl);
    }
    if (ctx.circular !== undefined) {
        const index = ctx.circular.get(value);
        if (index !== undefined) {
            const reference = ctx.stylize(`<ref *${index}>`, "special");
            if (ctx.compact !== true) {
                base2 = base2 === "" ? reference : `${reference} ${base2}`;
            } else {
                braces[0] = `${reference} ${braces[0]}`;
            }
        }
    }
    ctx.seen.pop();
    if (ctx.sorted) {
        const comparator = ctx.sorted === true ? undefined : ctx.sorted;
        if (extrasType === 0) {
            output = output.sort(comparator);
        } else if (keys.length > 1) {
            const sorted = output.slice(output.length - keys.length).sort(comparator);
            output.splice(output.length - keys.length, keys.length, ...sorted);
        }
    }
    const res = reduceToSingleString(ctx, output, base2, braces, extrasType, recurseTimes, value);
    const budget = ctx.budget[ctx.indentationLvl] || 0;
    const newLength = budget + res.length;
    ctx.budget[ctx.indentationLvl] = newLength;
    if (newLength > 2 ** 27) {
        ctx.depth = -1;
    }
    return res;
}
const builtInObjects = new Set(Object.getOwnPropertyNames(globalThis).filter((e8)=>/^[A-Z][a-zA-Z0-9]+$/.test(e8)
));
function addPrototypeProperties(ctx, main, obj, recurseTimes, output) {
    let depth = 0;
    let keys;
    let keySet;
    do {
        if (depth !== 0 || main === obj) {
            obj = Object.getPrototypeOf(obj);
            if (obj === null) {
                return;
            }
            const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
            if (descriptor !== undefined && typeof descriptor.value === "function" && builtInObjects.has(descriptor.value.name)) {
                return;
            }
        }
        if (depth === 0) {
            keySet = new Set();
        } else {
            Array.prototype.forEach(keys, (key)=>keySet.add(key)
            );
        }
        keys = Reflect.ownKeys(obj);
        Array.prototype.push(ctx.seen, main);
        for (const key1 of keys){
            if (key1 === "constructor" || main.hasOwnProperty(key1) || depth !== 0 && keySet.has(key1)) {
                continue;
            }
            const desc = Object.getOwnPropertyDescriptor(obj, key1);
            if (typeof desc.value === "function") {
                continue;
            }
            const value = formatProperty(ctx, obj, recurseTimes, key1, 0, desc, main);
            if (ctx.colors) {
                Array.prototype.push(output, `\u001b[2m${value}\u001b[22m`);
            } else {
                Array.prototype.push(output, value);
            }
        }
        Array.prototype.pop(ctx.seen);
    }while (++depth !== 3)
}
function getConstructorName(obj, ctx, recurseTimes, protoProps) {
    let firstProto;
    const tmp = obj;
    while(obj || isUndetectableObject(obj)){
        const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
        if (descriptor !== undefined && typeof descriptor.value === "function" && descriptor.value.name !== "" && isInstanceof(tmp, descriptor.value)) {
            if (protoProps !== undefined && (firstProto !== obj || !builtInObjects.has(descriptor.value.name))) {
                addPrototypeProperties(ctx, tmp, firstProto || tmp, recurseTimes, protoProps);
            }
            return descriptor.value.name;
        }
        obj = Object.getPrototypeOf(obj);
        if (firstProto === undefined) {
            firstProto = obj;
        }
    }
    if (firstProto === null) {
        return null;
    }
    const res = undefined;
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        return `${res} <Complex prototype>`;
    }
    const protoConstr = getConstructorName(firstProto, ctx, recurseTimes + 1, protoProps);
    if (protoConstr === null) {
        return `${res} <${inspect(firstProto, {
            ...ctx,
            customInspect: false,
            depth: -1
        })}>`;
    }
    return `${res} <${protoConstr}>`;
}
function formatPrimitive(fn, value, ctx) {
    if (typeof value === "string") {
        let trailer = "";
        if (value.length > ctx.maxStringLength) {
            const remaining = value.length - ctx.maxStringLength;
            value = value.slice(0, ctx.maxStringLength);
            trailer = `... ${remaining} more character${remaining > 1 ? "s" : ""}`;
        }
        if (ctx.compact !== true && value.length > 16 && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
            return value.split(/(?<=\n)/).map((line)=>fn(strEscape(line), "string")
            ).join(` +\n${" ".repeat(ctx.indentationLvl + 2)}`) + trailer;
        }
        return fn(strEscape(value), "string") + trailer;
    }
    if (typeof value === "number") {
        return formatNumber(fn, value);
    }
    if (typeof value === "bigint") {
        return formatBigInt(fn, value);
    }
    if (typeof value === "boolean") {
        return fn(`${value}`, "boolean");
    }
    if (typeof value === "undefined") {
        return fn("undefined", "undefined");
    }
    return fn(value.toString(), "symbol");
}
function getEmptyFormatArray() {
    return [];
}
function isInstanceof(object, proto) {
    try {
        return object instanceof proto;
    } catch  {
        return false;
    }
}
function getPrefix(constructor, tag, fallback, size = "") {
    if (constructor === null) {
        if (tag !== "" && fallback !== tag) {
            return `[${fallback}${size}: null prototype] [${tag}] `;
        }
        return `[${fallback}${size}: null prototype] `;
    }
    if (tag !== "" && constructor !== tag) {
        return `${constructor}${size} [${tag}] `;
    }
    return `${constructor}${size} `;
}
function formatArray(ctx, value, recurseTimes) {
    const valLen = value.length;
    const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
    const remaining = valLen - len;
    const output = [];
    for(let i16 = 0; i16 < len; i16++){
        if (!value.hasOwnProperty(i16)) {
            return formatSpecialArray(ctx, value, recurseTimes, len, output, i16);
        }
        output.push(formatProperty(ctx, value, recurseTimes, i16, 1));
    }
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getCtxStyle(_value, constructor, tag) {
    let fallback = "";
    if (constructor === null) {
        if (fallback === tag) {
            fallback = "Object";
        }
    }
    return getPrefix(constructor, tag, fallback);
}
function getKeys(value, showHidden) {
    let keys;
    const symbols = Object.getOwnPropertySymbols(value);
    if (showHidden) {
        keys = Object.getOwnPropertyNames(value);
        if (symbols.length !== 0) {
            Array.prototype.push.apply(keys, symbols);
        }
    } else {
        try {
            keys = Object.keys(value);
        } catch (_err) {
            keys = Object.getOwnPropertyNames(value);
        }
        if (symbols.length !== 0) {}
    }
    return keys;
}
function formatSet(value, ctx, _ignored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const v of value){
        Array.prototype.push(output, formatValue(ctx, v, recurseTimes));
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatMap(value, ctx, _gnored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const { 0: k , 1: v  } of value){
        output.push(`${formatValue(ctx, k, recurseTimes)} => ${formatValue(ctx, v, recurseTimes)}`);
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatTypedArray(value, length, ctx, _ignored, recurseTimes) {
    const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), length);
    const remaining = value.length - maxLength;
    const output = new Array(maxLength);
    const elementFormatter = value.length > 0 && typeof value[0] === "number" ? formatNumber : formatBigInt;
    for(let i17 = 0; i17 < maxLength; ++i17){
        output[i17] = elementFormatter(ctx.stylize, value[i17]);
    }
    if (remaining > 0) {
        output[maxLength] = `... ${remaining} more item${remaining > 1 ? "s" : ""}`;
    }
    if (ctx.showHidden) {
        ctx.indentationLvl += 2;
        for (const key of [
            "BYTES_PER_ELEMENT",
            "length",
            "byteLength",
            "byteOffset",
            "buffer", 
        ]){
            const str = formatValue(ctx, value[key], recurseTimes, true);
            Array.prototype.push(output, `[${key}]: ${str}`);
        }
        ctx.indentationLvl -= 2;
    }
    return output;
}
function getIteratorBraces(type, tag) {
    if (tag !== `${type} Iterator`) {
        if (tag !== "") {
            tag += "] [";
        }
        tag += `${type} Iterator`;
    }
    return [
        `[${tag}] {`,
        "}"
    ];
}
function formatIterator(braces, ctx, value, recurseTimes) {
    const { 0: entries , 1: isKeyValue  } = value;
    if (isKeyValue) {
        braces[0] = braces[0].replace(/ Iterator] {$/, " Entries] {");
        return formatMapIterInner(ctx, recurseTimes, entries, 2);
    }
    return formatSetIterInner(ctx, recurseTimes, entries, 1);
}
function getFunctionBase(value, constructor, tag) {
    const stringified = Function.prototype.toString(value);
    if (stringified.slice(0, 5) === "class" && stringified.endsWith("}")) {
        const slice = stringified.slice(5, -1);
        const bracketIndex = slice.indexOf("{");
        if (bracketIndex !== -1 && (!slice.slice(0, bracketIndex).includes("(") || classRegExp.test(slice.replace(stripCommentsRegExp)))) {
            return getClassBase(value, constructor, tag);
        }
    }
    let type = "Function";
    if (isGeneratorFunction1(value)) {
        type = `Generator${type}`;
    }
    if (isAsyncFunction1(value)) {
        type = `Async${type}`;
    }
    let base3 = `[${type}`;
    if (constructor === null) {
        base3 += " (null prototype)";
    }
    if (value.name === "") {
        base3 += " (anonymous)";
    } else {
        base3 += `: ${value.name}`;
    }
    base3 += "]";
    if (constructor !== type && constructor !== null) {
        base3 += ` ${constructor}`;
    }
    if (tag !== "" && constructor !== tag) {
        base3 += ` [${tag}]`;
    }
    return base3;
}
function formatError(err, constructor, tag, ctx, keys) {
    const name = err.name != null ? String(err.name) : "Error";
    let len = name.length;
    let stack = err.stack ? String(err.stack) : err.toString();
    if (!ctx.showHidden && keys.length !== 0) {
        for (const name of [
            "name",
            "message",
            "stack"
        ]){
            const index = keys.indexOf(name);
            if (index !== -1 && stack.includes(err[name])) {
                keys.splice(index, 1);
            }
        }
    }
    if (constructor === null || name.endsWith("Error") && stack.startsWith(name) && (stack.length === len || stack[len] === ":" || stack[len] === "\n")) {
        let fallback = "Error";
        if (constructor === null) {
            const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
            fallback = start && start[1] || "";
            len = fallback.length;
            fallback = fallback || "Error";
        }
        const prefix = getPrefix(constructor, tag, fallback).slice(0, -1);
        if (name !== prefix) {
            if (prefix.includes(name)) {
                if (len === 0) {
                    stack = `${prefix}: ${stack}`;
                } else {
                    stack = `${prefix}${stack.slice(len)}`;
                }
            } else {
                stack = `${prefix} [${name}]${stack.slice(len)}`;
            }
        }
    }
    let pos = err.message && stack.indexOf(err.message) || -1;
    if (pos !== -1) {
        pos += err.message.length;
    }
    const stackStart = stack.indexOf("\n    at", pos);
    if (stackStart === -1) {
        stack = `[${stack}]`;
    } else if (ctx.colors) {
        let newStack = stack.slice(0, stackStart);
        const lines = stack.slice(stackStart + 1).split("\n");
        for (const line of lines){
            let nodeModule;
            newStack += "\n";
            let pos = 0;
            while(nodeModule = nodeModulesRegExp.exec(line)){
                newStack += line.slice(pos, nodeModule.index + 14);
                newStack += ctx.stylize(nodeModule[1], "module");
                pos = nodeModule.index + nodeModule[0].length;
            }
            newStack += pos === 0 ? line : line.slice(pos);
        }
        stack = newStack;
    }
    if (ctx.indentationLvl !== 0) {
        const indentation = " ".repeat(ctx.indentationLvl);
        stack = stack.replace(/\n/g, `\n${indentation}`);
    }
    return stack;
}
let hexSlice;
function formatArrayBuffer(ctx, value) {
    let buffer;
    try {
        buffer = new Uint8Array(value);
    } catch  {
        return [
            ctx.stylize("(detached)", "special")
        ];
    }
    let str = hexSlice(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, "$1 ").trim();
    const remaining = buffer.length - ctx.maxArrayLength;
    if (remaining > 0) {
        str += ` ... ${remaining} more byte${remaining > 1 ? "s" : ""}`;
    }
    return [
        `${ctx.stylize("[Uint8Contents]", "special")}: <${str}>`
    ];
}
function formatNumber(fn, value) {
    return fn(Object.is(value, -0) ? "-0" : `${value}`, "number");
}
function formatPromise(ctx, value, recurseTimes) {
    let output;
    const { 0: state1 , 1: result  } = value;
    if (state1 === 0) {
        output = [
            ctx.stylize("<pending>", "special")
        ];
    } else {
        ctx.indentationLvl += 2;
        const str = formatValue(ctx, result, recurseTimes);
        ctx.indentationLvl -= 2;
        output = [
            state1 === kRejected ? `${ctx.stylize("<rejected>", "special")} ${str}` : str, 
        ];
    }
    return output;
}
function formatWeakCollection(ctx) {
    return [
        ctx.stylize("<items unknown>", "special")
    ];
}
function formatWeakSet(ctx, value, recurseTimes) {
    const entries = value;
    return formatSetIterInner(ctx, recurseTimes, entries, 0);
}
function formatWeakMap(ctx, value, recurseTimes) {
    const entries = value;
    return formatMapIterInner(ctx, recurseTimes, entries, 0);
}
function formatProperty(ctx, value, recurseTimes, key, type, desc, original = value) {
    let name, str;
    let extra = " ";
    desc = desc || Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key],
        enumerable: true
    };
    if (desc.value !== undefined) {
        const diff = ctx.compact !== true || type !== 0 ? 2 : 3;
        ctx.indentationLvl += diff;
        str = formatValue(ctx, desc.value, recurseTimes);
        if (diff === 3 && ctx.breakLength < getStringWidth(str, ctx.colors)) {
            extra = `\n${" ".repeat(ctx.indentationLvl)}`;
        }
        ctx.indentationLvl -= diff;
    } else if (desc.get !== undefined) {
        const label = desc.set !== undefined ? "Getter/Setter" : "Getter";
        const s3 = ctx.stylize;
        const sp = "special";
        if (ctx.getters && (ctx.getters === true || ctx.getters === "get" && desc.set === undefined || ctx.getters === "set" && desc.set !== undefined)) {
            try {
                const tmp = desc.get.call(original);
                ctx.indentationLvl += 2;
                if (tmp === null) {
                    str = `${s3(`[${label}:`, sp)} ${s3("null", "null")}${s3("]", sp)}`;
                } else if (typeof tmp === "object") {
                    str = `${s3(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;
                } else {
                    const primitive = formatPrimitive(s3, tmp, ctx);
                    str = `${s3(`[${label}:`, sp)} ${primitive}${s3("]", sp)}`;
                }
                ctx.indentationLvl -= 2;
            } catch (err) {
                const message = `<Inspection threw (${err.message})>`;
                str = `${s3(`[${label}:`, sp)} ${message}${s3("]", sp)}`;
            }
        } else {
            str = ctx.stylize(`[${label}]`, sp);
        }
    } else if (desc.set !== undefined) {
        str = ctx.stylize("[Setter]", "special");
    } else {
        str = ctx.stylize("undefined", "undefined");
    }
    if (type === 1) {
        return str;
    }
    if (typeof key === "symbol") {
        const tmp = key.toString().replace(strEscapeSequencesReplacer, escapeFn);
        name = `[${ctx.stylize(tmp, "symbol")}]`;
    } else if (key === "__proto__") {
        name = "['__proto__']";
    } else if (desc.enumerable === false) {
        const tmp = key.replace(strEscapeSequencesReplacer, escapeFn);
        name = `[${tmp}]`;
    } else if (keyStrRegExp.test(key)) {
        name = ctx.stylize(key, "name");
    } else {
        name = ctx.stylize(strEscape(key), "string");
    }
    return `${name}:${extra}${str}`;
}
function handleMaxCallStackSize(_ctx, _err, _constructorName, _indentationLvl) {}
const colorRegExp = /\u001b\[\d\d?m/g;
function removeColors(str) {
    return str.replace(colorRegExp, "");
}
function isBelowBreakLength(ctx, output, start, base4) {
    let totalLength = output.length + start;
    if (totalLength + output.length > ctx.breakLength) {
        return false;
    }
    for(let i18 = 0; i18 < output.length; i18++){
        if (ctx.colors) {
            totalLength += removeColors(output[i18]).length;
        } else {
            totalLength += output[i18].length;
        }
        if (totalLength > ctx.breakLength) {
            return false;
        }
    }
    return base4 === "" || !base4.includes("\n");
}
function formatBigInt(fn, value) {
    return fn(`${value}n`, "bigint");
}
function formatNamespaceObject(keys, ctx, value, recurseTimes) {
    const output = new Array(keys.length);
    for(let i19 = 0; i19 < keys.length; i19++){
        try {
            output[i19] = formatProperty(ctx, value, recurseTimes, keys[i19], kObjectType);
        } catch (_err) {
            const tmp = {
                [keys[i19]]: ""
            };
            output[i19] = formatProperty(ctx, tmp, recurseTimes, keys[i19], kObjectType);
            const pos = output[i19].lastIndexOf(" ");
            output[i19] = output[i19].slice(0, pos + 1) + ctx.stylize("<uninitialized>", "special");
        }
    }
    keys.length = 0;
    return output;
}
function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i20) {
    const keys = Object.keys(value);
    let index = i20;
    for(; i20 < keys.length && output.length < maxLength; i20++){
        const key = keys[i20];
        const tmp = +key;
        if (tmp > 2 ** 32 - 2) {
            break;
        }
        if (`${index}` !== key) {
            if (!numberRegExp.test(key)) {
                break;
            }
            const emptyItems = tmp - index;
            const ending = emptyItems > 1 ? "s" : "";
            const message = `<${emptyItems} empty item${ending}>`;
            output.push(ctx.stylize(message, "undefined"));
            index = tmp;
            if (output.length === maxLength) {
                break;
            }
        }
        output.push(formatProperty(ctx, value, recurseTimes, key, 1));
        index++;
    }
    const remaining = value.length - index;
    if (output.length !== maxLength) {
        if (remaining > 0) {
            const ending = remaining > 1 ? "s" : "";
            const message = `<${remaining} empty item${ending}>`;
            output.push(ctx.stylize(message, "undefined"));
        }
    } else if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getBoxedBase(value, ctx, keys, constructor, tag) {
    let type;
    if (isNumberObject1(value)) {
        type = "Number";
    } else if (isStringObject1(value)) {
        type = "String";
        keys.splice(0, value.length);
    } else if (isBooleanObject1(value)) {
        type = "Boolean";
    } else if (isBigIntObject1(value)) {
        type = "BigInt";
    } else {
        type = "Symbol";
    }
    let base5 = `[${type}`;
    if (type !== constructor) {
        if (constructor === null) {
            base5 += " (null prototype)";
        } else {
            base5 += ` (${constructor})`;
        }
    }
    base5 += `: ${formatPrimitive(stylizeNoColor, value.valueOf(), ctx)}]`;
    if (tag !== "" && tag !== constructor) {
        base5 += ` [${tag}]`;
    }
    if (keys.length !== 0 || ctx.stylize === stylizeNoColor) {
        return base5;
    }
    return ctx.stylize(base5, type.toLowerCase());
}
function getClassBase(value, constructor, tag) {
    const hasName = value.hasOwnProperty("name");
    const name = hasName && value.name || "(anonymous)";
    let base6 = `class ${name}`;
    if (constructor !== "Function" && constructor !== null) {
        base6 += ` [${constructor}]`;
    }
    if (tag !== "" && constructor !== tag) {
        base6 += ` [${tag}]`;
    }
    if (constructor !== null) {
        const superName = Object.getPrototypeOf(value).name;
        if (superName) {
            base6 += ` extends ${superName}`;
        }
    } else {
        base6 += " extends [null prototype]";
    }
    return `[${base6}]`;
}
function reduceToSingleString(ctx, output, base7, braces, extrasType, recurseTimes, value) {
    if (ctx.compact !== true) {
        if (typeof ctx.compact === "number" && ctx.compact >= 1) {
            const entries = output.length;
            if (extrasType === 2 && entries > 6) {
                output = groupArrayElements(ctx, output, value);
            }
            if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
                const start = output.length + ctx.indentationLvl + braces[0].length + base7.length + 10;
                if (isBelowBreakLength(ctx, output, start, base7)) {
                    return `${base7 ? `${base7} ` : ""}${braces[0]} ${join(output, ", ")}` + ` ${braces[1]}`;
                }
            }
        }
        const indentation = `\n${" ".repeat(ctx.indentationLvl)}`;
        return `${base7 ? `${base7} ` : ""}${braces[0]}${indentation}  ` + `${join(output, `,${indentation}  `)}${indentation}${braces[1]}`;
    }
    if (isBelowBreakLength(ctx, output, 0, base7)) {
        return `${braces[0]}${base7 ? ` ${base7}` : ""} ${join(output, ", ")} ` + braces[1];
    }
    const indentation = " ".repeat(ctx.indentationLvl);
    const ln = base7 === "" && braces[0].length === 1 ? " " : `${base7 ? ` ${base7}` : ""}\n${indentation}  `;
    return `${braces[0]}${ln}${join(output, `,\n${indentation}  `)} ${braces[1]}`;
}
function join(output, separator) {
    let str = "";
    if (output.length !== 0) {
        const lastIndex = output.length - 1;
        for(let i21 = 0; i21 < lastIndex; i21++){
            str += output[i21];
            str += separator;
        }
        str += output[lastIndex];
    }
    return str;
}
function groupArrayElements(ctx, output, value) {
    let totalLength = 0;
    let maxLength = 0;
    let i22 = 0;
    let outputLength = output.length;
    if (ctx.maxArrayLength < output.length) {
        outputLength--;
    }
    const separatorSpace = 2;
    const dataLen = new Array(outputLength);
    for(; i22 < outputLength; i22++){
        const len = getStringWidth(output[i22], ctx.colors);
        dataLen[i22] = len;
        totalLength += len + separatorSpace;
        if (maxLength < len) {
            maxLength = len;
        }
    }
    const actualMax = maxLength + 2;
    if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
        const averageBias = Math.sqrt(actualMax - totalLength / output.length);
        const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
        const columns = Math.min(Math.round(Math.sqrt(2.5 * biasedMax * outputLength) / biasedMax), Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), ctx.compact * 4, 15);
        if (columns <= 1) {
            return output;
        }
        const tmp = [];
        const maxLineLength = [];
        for(let i23 = 0; i23 < columns; i23++){
            let lineMaxLength = 0;
            for(let j = i23; j < output.length; j += columns){
                if (dataLen[j] > lineMaxLength) {
                    lineMaxLength = dataLen[j];
                }
            }
            lineMaxLength += separatorSpace;
            maxLineLength[i23] = lineMaxLength;
        }
        let order = String.prototype.padStart;
        if (value !== undefined) {
            for(let i24 = 0; i24 < output.length; i24++){
                if (typeof value[i24] !== "number" && typeof value[i24] !== "bigint") {
                    order = String.prototype.padEnd;
                    break;
                }
            }
        }
        for(let i110 = 0; i110 < outputLength; i110 += columns){
            const max = Math.min(i110 + columns, outputLength);
            let str = "";
            let j = i110;
            for(; j < max - 1; j++){
                const padding = maxLineLength[j - i110] + output[j].length - dataLen[j];
                str += `${output[j]}, `.padStart(padding, " ");
            }
            if (order === String.prototype.padStart) {
                const padding = maxLineLength[j - i110] + output[j].length - dataLen[j] - 2;
                str += output[j].padStart(padding, " ");
            } else {
                str += output[j];
            }
            Array.prototype.push(tmp, str);
        }
        if (ctx.maxArrayLength < output.length) {
            Array.prototype.push(tmp, output[outputLength]);
        }
        output = tmp;
    }
    return output;
}
function formatMapIterInner(ctx, recurseTimes, entries, state2) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const len = entries.length / 2;
    const remaining = len - maxArrayLength;
    const maxLength = Math.min(maxArrayLength, len);
    let output = new Array(maxLength);
    let i25 = 0;
    ctx.indentationLvl += 2;
    if (state2 === 0) {
        for(; i25 < maxLength; i25++){
            const pos = i25 * 2;
            output[i25] = `${formatValue(ctx, entries[pos], recurseTimes)} => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;
        }
        if (!ctx.sorted) {
            output = output.sort();
        }
    } else {
        for(; i25 < maxLength; i25++){
            const pos = i25 * 2;
            const res = [
                formatValue(ctx, entries[pos], recurseTimes),
                formatValue(ctx, entries[pos + 1], recurseTimes), 
            ];
            output[i25] = reduceToSingleString(ctx, res, "", [
                "[",
                "]"
            ], kArrayExtrasType, recurseTimes);
        }
    }
    ctx.indentationLvl -= 2;
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function formatSetIterInner(ctx, recurseTimes, entries, state3) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const maxLength = Math.min(maxArrayLength, entries.length);
    const output = new Array(maxLength);
    ctx.indentationLvl += 2;
    for(let i26 = 0; i26 < maxLength; i26++){
        output[i26] = formatValue(ctx, entries[i26], recurseTimes);
    }
    ctx.indentationLvl -= 2;
    if (state3 === 0 && !ctx.sorted) {
        output.sort();
    }
    const remaining = entries.length - maxLength;
    if (remaining > 0) {
        Array.prototype.push(output, `... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
const ansiPattern = "[\\u001B\\u009B][[\\]()#;?]*" + "(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*" + "|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)" + "|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))";
const ansi = new RegExp(ansiPattern, "g");
function getStringWidth(str, removeControlChars = true) {
    let width = 0;
    if (removeControlChars) {
        str = stripVTControlCharacters(str);
    }
    str = str.normalize("NFC");
    for (const __char of str[Symbol.iterator]()){
        const code = __char.codePointAt(0);
        if (isFullWidthCodePoint(code)) {
            width += 2;
        } else if (!isZeroWidthCodePoint(code)) {
            width++;
        }
    }
    return width;
}
const isFullWidthCodePoint = (code)=>{
    return code >= 0x1100 && (code <= 0x115f || code === 0x2329 || code === 0x232a || code >= 0x2e80 && code <= 0x3247 && code !== 0x303f || code >= 0x3250 && code <= 0x4dbf || code >= 0x4e00 && code <= 0xa4c6 || code >= 0xa960 && code <= 0xa97c || code >= 0xac00 && code <= 0xd7a3 || code >= 0xf900 && code <= 0xfaff || code >= 0xfe10 && code <= 0xfe19 || code >= 0xfe30 && code <= 0xfe6b || code >= 0xff01 && code <= 0xff60 || code >= 0xffe0 && code <= 0xffe6 || code >= 0x1b000 && code <= 0x1b001 || code >= 0x1f200 && code <= 0x1f251 || code >= 0x1f300 && code <= 0x1f64f || code >= 0x20000 && code <= 0x3fffd);
};
const isZeroWidthCodePoint = (code)=>{
    return code <= 0x1F || code >= 0x7F && code <= 0x9F || code >= 0x300 && code <= 0x36F || code >= 0x200B && code <= 0x200F || code >= 0x20D0 && code <= 0x20FF || code >= 0xFE00 && code <= 0xFE0F || code >= 0xFE20 && code <= 0xFE2F || code >= 0xE0100 && code <= 0xE01EF;
};
function stripVTControlCharacters(str) {
    validateString(str, "str");
    return str.replace(ansi, "");
}
let debugImpls;
function initializeDebugEnv(debugEnv) {
    debugImpls = Object.create(null);
    if (debugEnv) {
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replaceAll("*", ".*").replaceAll(",", "$|^");
        new RegExp(`^${debugEnv}$`, "i");
    } else {}
}
let state = "";
if (Deno.permissions) {
    state = (await Deno.permissions.query({
        name: "env",
        variable: "NODE_DEBUG"
    })).state;
}
if (state === "granted") {
    initializeDebugEnv(Deno.env.get("NODE_DEBUG") ?? "");
} else {
    initializeDebugEnv("");
}
const osType = (()=>{
    const { Deno  } = globalThis;
    if (typeof Deno?.build?.os === "string") {
        return Deno.build.os;
    }
    const { navigator  } = globalThis;
    if (navigator?.appVersion?.includes?.("Win") ?? false) {
        return "windows";
    }
    return "linux";
})();
const isWindows = osType === "windows";
const os = {
    UV_UDP_REUSEADDR: 4,
    dlopen: {
        RTLD_LAZY: 1,
        RTLD_NOW: 2,
        RTLD_GLOBAL: 8,
        RTLD_LOCAL: 4
    },
    errno: {
        E2BIG: 7,
        EACCES: 13,
        EADDRINUSE: 48,
        EADDRNOTAVAIL: 49,
        EAFNOSUPPORT: 47,
        EAGAIN: 35,
        EALREADY: 37,
        EBADF: 9,
        EBADMSG: 94,
        EBUSY: 16,
        ECANCELED: 89,
        ECHILD: 10,
        ECONNABORTED: 53,
        ECONNREFUSED: 61,
        ECONNRESET: 54,
        EDEADLK: 11,
        EDESTADDRREQ: 39,
        EDOM: 33,
        EDQUOT: 69,
        EEXIST: 17,
        EFAULT: 14,
        EFBIG: 27,
        EHOSTUNREACH: 65,
        EIDRM: 90,
        EILSEQ: 92,
        EINPROGRESS: 36,
        EINTR: 4,
        EINVAL: 22,
        EIO: 5,
        EISCONN: 56,
        EISDIR: 21,
        ELOOP: 62,
        EMFILE: 24,
        EMLINK: 31,
        EMSGSIZE: 40,
        EMULTIHOP: 95,
        ENAMETOOLONG: 63,
        ENETDOWN: 50,
        ENETRESET: 52,
        ENETUNREACH: 51,
        ENFILE: 23,
        ENOBUFS: 55,
        ENODATA: 96,
        ENODEV: 19,
        ENOENT: 2,
        ENOEXEC: 8,
        ENOLCK: 77,
        ENOLINK: 97,
        ENOMEM: 12,
        ENOMSG: 91,
        ENOPROTOOPT: 42,
        ENOSPC: 28,
        ENOSR: 98,
        ENOSTR: 99,
        ENOSYS: 78,
        ENOTCONN: 57,
        ENOTDIR: 20,
        ENOTEMPTY: 66,
        ENOTSOCK: 38,
        ENOTSUP: 45,
        ENOTTY: 25,
        ENXIO: 6,
        EOPNOTSUPP: 102,
        EOVERFLOW: 84,
        EPERM: 1,
        EPIPE: 32,
        EPROTO: 100,
        EPROTONOSUPPORT: 43,
        EPROTOTYPE: 41,
        ERANGE: 34,
        EROFS: 30,
        ESPIPE: 29,
        ESRCH: 3,
        ESTALE: 70,
        ETIME: 101,
        ETIMEDOUT: 60,
        ETXTBSY: 26,
        EWOULDBLOCK: 35,
        EXDEV: 18
    },
    signals: {
        SIGHUP: 1,
        SIGINT: 2,
        SIGQUIT: 3,
        SIGILL: 4,
        SIGTRAP: 5,
        SIGABRT: 6,
        SIGIOT: 6,
        SIGBUS: 10,
        SIGFPE: 8,
        SIGKILL: 9,
        SIGUSR1: 30,
        SIGSEGV: 11,
        SIGUSR2: 31,
        SIGPIPE: 13,
        SIGALRM: 14,
        SIGTERM: 15,
        SIGCHLD: 20,
        SIGCONT: 19,
        SIGSTOP: 17,
        SIGTSTP: 18,
        SIGTTIN: 21,
        SIGTTOU: 22,
        SIGURG: 16,
        SIGXCPU: 24,
        SIGXFSZ: 25,
        SIGVTALRM: 26,
        SIGPROF: 27,
        SIGWINCH: 28,
        SIGIO: 23,
        SIGINFO: 29,
        SIGSYS: 12,
        SIGEMT: 7,
        SIGPWR: 30,
        SIGSTKFLT: 16
    },
    priority: {
        PRIORITY_LOW: 19,
        PRIORITY_BELOW_NORMAL: 10,
        PRIORITY_NORMAL: 0,
        PRIORITY_ABOVE_NORMAL: -7,
        PRIORITY_HIGH: -14,
        PRIORITY_HIGHEST: -20
    }
};
os.errno.EEXIST;
os.errno.ENOENT;
const codeToErrorWindows = [
    [
        -4093,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -4092,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -4091,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -4090,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -4089,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -4088,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -4084,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -4083,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -4082,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -4081,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -4079,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -4078,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -4077,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -4076,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -4075,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -4074,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -4036,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -4073,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4072,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -4071,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -4070,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -4069,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -4068,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -4067,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -4066,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -4065,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -4064,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -4063,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -4062,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -4061,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -4060,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -4059,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -4058,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -4057,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -4035,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -4055,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -4054,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -4053,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -4052,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -4051,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -4050,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -4049,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -4048,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -4047,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -4046,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -4045,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -4044,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -4034,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -4043,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -4042,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -4041,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -4040,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -4039,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -4038,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -4037,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -4033,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -4032,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -4031,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -4029,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -4027,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeWindows = codeToErrorWindows.map(([status, [error2]])=>[
        error2,
        status
    ]
);
const codeToErrorDarwin = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -48,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -49,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -47,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -35,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -37,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -89,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -53,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -61,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -54,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -39,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -65,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -56,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -62,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -40,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -63,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -50,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -51,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -55,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -42,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -78,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -57,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -66,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -38,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -45,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -100,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -43,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -41,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -58,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -60,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -64,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -79,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -92,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeDarwin = codeToErrorDarwin.map(([status, [code]])=>[
        code,
        status
    ]
);
const codeToErrorLinux = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -98,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -99,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -97,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -11,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -114,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -125,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -103,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -111,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -104,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -89,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -113,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -106,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -40,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -90,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -36,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -100,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -101,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -105,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -64,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -92,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -38,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -107,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -39,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -88,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -95,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -71,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -93,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -91,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -108,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -110,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -112,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -121,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -84,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeLinux = codeToErrorLinux.map(([status, [code]])=>[
        code,
        status
    ]
);
const errorMap = new Map(osType === "windows" ? codeToErrorWindows : osType === "darwin" ? codeToErrorDarwin : osType === "linux" ? codeToErrorLinux : unreachable());
const codeMap = new Map(osType === "windows" ? errorToCodeWindows : osType === "darwin" ? errorToCodeDarwin : osType === "linux" ? errorToCodeLinux : unreachable());
var Encodings;
(function(Encodings1) {
    Encodings1[Encodings1["ASCII"] = 0] = "ASCII";
    Encodings1[Encodings1["UTF8"] = 1] = "UTF8";
    Encodings1[Encodings1["BASE64"] = 2] = "BASE64";
    Encodings1[Encodings1["UCS2"] = 3] = "UCS2";
    Encodings1[Encodings1["BINARY"] = 4] = "BINARY";
    Encodings1[Encodings1["HEX"] = 5] = "HEX";
    Encodings1[Encodings1["BUFFER"] = 6] = "BUFFER";
    Encodings1[Encodings1["BASE64URL"] = 7] = "BASE64URL";
    Encodings1[Encodings1["LATIN1"] = 4] = "LATIN1";
})(Encodings || (Encodings = {}));
const encodings = [];
encodings[Encodings.ASCII] = "ascii";
encodings[Encodings.BASE64] = "base64";
encodings[Encodings.BASE64URL] = "base64url";
encodings[Encodings.BUFFER] = "buffer";
encodings[Encodings.HEX] = "hex";
encodings[Encodings.LATIN1] = "latin1";
encodings[Encodings.UCS2] = "utf16le";
encodings[Encodings.UTF8] = "utf8";
function numberToBytes(n3) {
    if (n3 === 0) return new Uint8Array([
        0
    ]);
    const bytes = [];
    bytes.unshift(n3 & 255);
    while(n3 >= 256){
        n3 = n3 >>> 8;
        bytes.unshift(n3 & 255);
    }
    return new Uint8Array(bytes);
}
function findLastIndex(targetBuffer, buffer, offset) {
    offset = offset > targetBuffer.length ? targetBuffer.length : offset;
    const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
    const searchableBufferLastIndex = searchableBuffer.length - 1;
    const bufferLastIndex = buffer.length - 1;
    let lastMatchIndex = -1;
    let matches = 0;
    let index = -1;
    for(let x = 0; x <= searchableBufferLastIndex; x++){
        if (searchableBuffer[searchableBufferLastIndex - x] === buffer[bufferLastIndex - matches]) {
            if (lastMatchIndex === -1) {
                lastMatchIndex = x;
            }
            matches++;
        } else {
            matches = 0;
            if (lastMatchIndex !== -1) {
                x = lastMatchIndex + 1;
                lastMatchIndex = -1;
            }
            continue;
        }
        if (matches === buffer.length) {
            index = x;
            break;
        }
    }
    if (index === -1) return index;
    return searchableBufferLastIndex - index;
}
function indexOfBuffer(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
    if (!Encodings[encoding] === undefined) {
        throw new Error(`Unknown encoding code ${encoding}`);
    }
    if (!forwardDirection) {
        if (byteOffset < 0) {
            byteOffset = targetBuffer.length + byteOffset;
        }
        if (buffer.length === 0) {
            return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
        }
        return findLastIndex(targetBuffer, buffer, byteOffset);
    }
    if (buffer.length === 0) {
        return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return indexOfNeedle(targetBuffer, buffer, byteOffset);
}
function indexOfNumber(targetBuffer, number, byteOffset, forwardDirection) {
    const bytes = numberToBytes(number);
    if (bytes.length > 1) {
        throw new Error("Multi byte number search is not supported");
    }
    return indexOfBuffer(targetBuffer, numberToBytes(number), byteOffset, Encodings.UTF8, forwardDirection);
}
const base64abc = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/", 
];
function encode1(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i27;
    const l = uint8.length;
    for(i27 = 2; i27 < l; i27 += 3){
        result += base64abc[uint8[i27 - 2] >> 2];
        result += base64abc[(uint8[i27 - 2] & 0x03) << 4 | uint8[i27 - 1] >> 4];
        result += base64abc[(uint8[i27 - 1] & 0x0f) << 2 | uint8[i27] >> 6];
        result += base64abc[uint8[i27] & 0x3f];
    }
    if (i27 === l + 1) {
        result += base64abc[uint8[i27 - 2] >> 2];
        result += base64abc[(uint8[i27 - 2] & 0x03) << 4];
        result += "==";
    }
    if (i27 === l) {
        result += base64abc[uint8[i27 - 2] >> 2];
        result += base64abc[(uint8[i27 - 2] & 0x03) << 4 | uint8[i27 - 1] >> 4];
        result += base64abc[(uint8[i27 - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
function decode1(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i28 = 0; i28 < size; i28++){
        bytes[i28] = binString.charCodeAt(i28);
    }
    return bytes;
}
function addPaddingToBase64url(base64url) {
    if (base64url.length % 4 === 2) return base64url + "==";
    if (base64url.length % 4 === 3) return base64url + "=";
    if (base64url.length % 4 === 1) {
        throw new TypeError("Illegal base64url string!");
    }
    return base64url;
}
function convertBase64urlToBase64(b64url) {
    if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
        throw new TypeError("Failed to decode base64url: invalid character");
    }
    return addPaddingToBase64url(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url(b64) {
    return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode2(data) {
    return convertBase64ToBase64url(encode1(data));
}
function decode2(b64url) {
    return decode1(convertBase64urlToBase64(b64url));
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i29 = 0; i29 < str.length; ++i29){
        byteArray.push(str.charCodeAt(i29) & 255);
    }
    return new Uint8Array(byteArray);
}
function base64ToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("-", "+").replaceAll("_", "/");
    return decode1(str);
}
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while(str.length % 4 !== 0){
        str = str + "=";
    }
    return str;
}
function base64UrlToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("+", "-").replaceAll("/", "_");
    return decode2(str);
}
function hexToBytes(str) {
    const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
    let i30;
    for(i30 = 0; i30 < byteArray.length; i30++){
        const a1 = Number.parseInt(str[i30 * 2], 16);
        const b = Number.parseInt(str[i30 * 2 + 1], 16);
        if (Number.isNaN(a1) && Number.isNaN(b)) {
            break;
        }
        byteArray[i30] = a1 << 4 | b;
    }
    return new Uint8Array(i30 === byteArray.length ? byteArray : byteArray.slice(0, i30));
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i31 = 0; i31 < str.length; ++i31){
        if ((units -= 2) < 0) {
            break;
        }
        c = str.charCodeAt(i31);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return new Uint8Array(byteArray);
}
function bytesToAscii(bytes) {
    let ret = "";
    for(let i32 = 0; i32 < bytes.length; ++i32){
        ret += String.fromCharCode(bytes[i32] & 127);
    }
    return ret;
}
function bytesToUtf16le(bytes) {
    let res = "";
    for(let i33 = 0; i33 < bytes.length - 1; i33 += 2){
        res += String.fromCharCode(bytes[i33] + bytes[i33 + 1] * 256);
    }
    return res;
}
const utf8Encoder = new TextEncoder();
const float32Array = new Float32Array(1);
const uInt8Float32Array = new Uint8Array(float32Array.buffer);
const float64Array = new Float64Array(1);
const uInt8Float64Array = new Uint8Array(float64Array.buffer);
float32Array[0] = -1;
const bigEndian = uInt8Float32Array[3] === 0;
function readUInt48LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first * 2 ** 8 + last;
}
function readUInt32BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 8);
    }
    uInt8Float64Array[7] = first;
    uInt8Float64Array[6] = buffer[++offset];
    uInt8Float64Array[5] = buffer[++offset];
    uInt8Float64Array[4] = buffer[++offset];
    uInt8Float64Array[3] = buffer[++offset];
    uInt8Float64Array[2] = buffer[++offset];
    uInt8Float64Array[1] = buffer[++offset];
    uInt8Float64Array[0] = last;
    return float64Array[0];
}
function readDoubleForwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 8);
    }
    uInt8Float64Array[0] = first;
    uInt8Float64Array[1] = buffer[++offset];
    uInt8Float64Array[2] = buffer[++offset];
    uInt8Float64Array[3] = buffer[++offset];
    uInt8Float64Array[4] = buffer[++offset];
    uInt8Float64Array[5] = buffer[++offset];
    uInt8Float64Array[6] = buffer[++offset];
    uInt8Float64Array[7] = last;
    return float64Array[0];
}
function writeDoubleForwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 7);
    float64Array[0] = val;
    buffer[offset++] = uInt8Float64Array[0];
    buffer[offset++] = uInt8Float64Array[1];
    buffer[offset++] = uInt8Float64Array[2];
    buffer[offset++] = uInt8Float64Array[3];
    buffer[offset++] = uInt8Float64Array[4];
    buffer[offset++] = uInt8Float64Array[5];
    buffer[offset++] = uInt8Float64Array[6];
    buffer[offset++] = uInt8Float64Array[7];
    return offset;
}
function writeDoubleBackwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 7);
    float64Array[0] = val;
    buffer[offset++] = uInt8Float64Array[7];
    buffer[offset++] = uInt8Float64Array[6];
    buffer[offset++] = uInt8Float64Array[5];
    buffer[offset++] = uInt8Float64Array[4];
    buffer[offset++] = uInt8Float64Array[3];
    buffer[offset++] = uInt8Float64Array[2];
    buffer[offset++] = uInt8Float64Array[1];
    buffer[offset++] = uInt8Float64Array[0];
    return offset;
}
function readFloatBackwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 4);
    }
    uInt8Float32Array[3] = first;
    uInt8Float32Array[2] = buffer[++offset];
    uInt8Float32Array[1] = buffer[++offset];
    uInt8Float32Array[0] = last;
    return float32Array[0];
}
function readFloatForwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 4);
    }
    uInt8Float32Array[0] = first;
    uInt8Float32Array[1] = buffer[++offset];
    uInt8Float32Array[2] = buffer[++offset];
    uInt8Float32Array[3] = last;
    return float32Array[0];
}
function writeFloatForwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 3);
    float32Array[0] = val;
    buffer[offset++] = uInt8Float32Array[0];
    buffer[offset++] = uInt8Float32Array[1];
    buffer[offset++] = uInt8Float32Array[2];
    buffer[offset++] = uInt8Float32Array[3];
    return offset;
}
function writeFloatBackwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 3);
    float32Array[0] = val;
    buffer[offset++] = uInt8Float32Array[3];
    buffer[offset++] = uInt8Float32Array[2];
    buffer[offset++] = uInt8Float32Array[1];
    buffer[offset++] = uInt8Float32Array[0];
    return offset;
}
function readInt24LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt40LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[offset + 4] + last * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt48BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[++offset] + first * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf8(str) {
    return utf8Encoder.encode(str).length;
}
function base64ByteLength(str, bytes) {
    if (str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    if (bytes > 1 && str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    return bytes * 3 >>> 2;
}
const encodingsMap = Object.create(null);
for(let i = 0; i < encodings.length; ++i){
    encodingsMap[encodings[i]] = i;
}
const encodingOps = {
    ascii: {
        byteLength: (string)=>string.length
        ,
        encoding: "ascii",
        encodingVal: encodingsMap.ascii,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.ascii, dir)
        ,
        slice: (buf, start, end)=>buf.asciiSlice(start, end)
        ,
        write: (buf, string, offset, len)=>buf.asciiWrite(string, offset, len)
    },
    base64: {
        byteLength: (string)=>base64ByteLength(string, string.length)
        ,
        encoding: "base64",
        encodingVal: encodingsMap.base64,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, base64ToBytes(val), byteOffset, encodingsMap.base64, dir)
        ,
        slice: (buf, start, end)=>buf.base64Slice(start, end)
        ,
        write: (buf, string, offset, len)=>buf.base64Write(string, offset, len)
    },
    base64url: {
        byteLength: (string)=>base64ByteLength(string, string.length)
        ,
        encoding: "base64url",
        encodingVal: encodingsMap.base64url,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, base64UrlToBytes(val), byteOffset, encodingsMap.base64url, dir)
        ,
        slice: (buf, start, end)=>buf.base64urlSlice(start, end)
        ,
        write: (buf, string, offset, len)=>buf.base64urlWrite(string, offset, len)
    },
    hex: {
        byteLength: (string)=>string.length >>> 1
        ,
        encoding: "hex",
        encodingVal: encodingsMap.hex,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, hexToBytes(val), byteOffset, encodingsMap.hex, dir)
        ,
        slice: (buf, start, end)=>buf.hexSlice(start, end)
        ,
        write: (buf, string, offset, len)=>buf.hexWrite(string, offset, len)
    },
    latin1: {
        byteLength: (string)=>string.length
        ,
        encoding: "latin1",
        encodingVal: encodingsMap.latin1,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.latin1, dir)
        ,
        slice: (buf, start, end)=>buf.latin1Slice(start, end)
        ,
        write: (buf, string, offset, len)=>buf.latin1Write(string, offset, len)
    },
    ucs2: {
        byteLength: (string)=>string.length * 2
        ,
        encoding: "ucs2",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir)
        ,
        slice: (buf, start, end)=>buf.ucs2Slice(start, end)
        ,
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    },
    utf8: {
        byteLength: byteLengthUtf8,
        encoding: "utf8",
        encodingVal: encodingsMap.utf8,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf8Encoder.encode(val), byteOffset, encodingsMap.utf8, dir)
        ,
        slice: (buf, start, end)=>buf.utf8Slice(start, end)
        ,
        write: (buf, string, offset, len)=>buf.utf8Write(string, offset, len)
    },
    utf16le: {
        byteLength: (string)=>string.length * 2
        ,
        encoding: "utf16le",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir)
        ,
        slice: (buf, start, end)=>buf.ucs2Slice(start, end)
        ,
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    }
};
function getEncodingOps(encoding) {
    encoding = String(encoding).toLowerCase();
    switch(encoding.length){
        case 4:
            if (encoding === "utf8") return encodingOps.utf8;
            if (encoding === "ucs2") return encodingOps.ucs2;
            break;
        case 5:
            if (encoding === "utf-8") return encodingOps.utf8;
            if (encoding === "ascii") return encodingOps.ascii;
            if (encoding === "ucs-2") return encodingOps.ucs2;
            break;
        case 7:
            if (encoding === "utf16le") {
                return encodingOps.utf16le;
            }
            break;
        case 8:
            if (encoding === "utf-16le") {
                return encodingOps.utf16le;
            }
            break;
        case 6:
            if (encoding === "latin1" || encoding === "binary") {
                return encodingOps.latin1;
            }
            if (encoding === "base64") return encodingOps.base64;
        case 3:
            if (encoding === "hex") {
                return encodingOps.hex;
            }
            break;
        case 9:
            if (encoding === "base64url") {
                return encodingOps.base64url;
            }
            break;
    }
}
function _copyActual(source, target5, targetStart, sourceStart, sourceEnd) {
    if (sourceEnd - sourceStart > target5.length - targetStart) {
        sourceEnd = sourceStart + target5.length - targetStart;
    }
    let nb = sourceEnd - sourceStart;
    const sourceLen = source.length - sourceStart;
    if (nb > sourceLen) {
        nb = sourceLen;
    }
    if (sourceStart !== 0 || sourceEnd < source.length) {
        source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
    }
    target5.set(source, targetStart);
    return nb;
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new codes.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new codes.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function validateNumber(value, name) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
}
function checkBounds(buf, offset, byteLength1) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength1] === undefined) {
        boundsError(offset, buf.length - (byteLength1 + 1));
    }
}
function checkInt(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
        const n4 = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
            if (min === 0 || min === 0n) {
                range = `>= 0${n4} and < 2${n4} ** ${(byteLength2 + 1) * 8}${n4}`;
            } else {
                range = `>= -(2${n4} ** ${(byteLength2 + 1) * 8 - 1}${n4}) and ` + `< 2${n4} ** ${(byteLength2 + 1) * 8 - 1}${n4}`;
            }
        } else {
            range = `>= ${min}${n4} and <= ${max}${n4}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength2);
}
function toInteger(n5, defaultVal) {
    n5 = +n5;
    if (!Number.isNaN(n5) && n5 >= Number.MIN_SAFE_INTEGER && n5 <= Number.MAX_SAFE_INTEGER) {
        return n5 % 1 === 0 ? n5 : Math.floor(n5);
    }
    return defaultVal;
}
function writeU_Int8(buf, value, offset, min, max) {
    value = +value;
    validateNumber(offset, "offset");
    if (value > max || value < min) {
        throw new codes.ERR_OUT_OF_RANGE("value", `>= ${min} and <= ${max}`, value);
    }
    if (buf[offset] === undefined) {
        boundsError(offset, buf.length - 1);
    }
    buf[offset] = value;
    return offset + 1;
}
function writeU_Int16BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 1);
    buf[offset++] = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function _writeUInt32LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int16LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 1);
    buf[offset++] = value;
    buf[offset++] = value >>> 8;
    return offset;
}
function _writeUInt32BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int48BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = newVal >>> 8;
    buf[offset++] = newVal;
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int40BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 4);
    buf[offset++] = Math.floor(value * 2 ** -32);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int32BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int24BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 2);
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 3;
}
function validateOffset(value, name, min = 0, max = Number.MAX_SAFE_INTEGER) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
}
function writeU_Int48LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = newVal;
    buf[offset++] = newVal >>> 8;
    return offset;
}
function writeU_Int40LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 4);
    const newVal = value;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = Math.floor(newVal * 2 ** -32);
    return offset;
}
function writeU_Int32LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int24LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 2);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
const kMaxLength = 2147483647;
const MAX_UINT32 = 2 ** 32;
const customInspectSymbol1 = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
const INSPECT_MAX_BYTES = 50;
Object.defineProperty(Buffer1.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer1.isBuffer(this)) {
            return void 0;
        }
        return this.buffer;
    }
});
Object.defineProperty(Buffer1.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer1.isBuffer(this)) {
            return void 0;
        }
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > 2147483647) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer1.prototype);
    return buf;
}
function Buffer1(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("string", "string", arg);
        }
        return _allocUnsafe(arg);
    }
    return _from(arg, encodingOrOffset, length);
}
Buffer1.poolSize = 8192;
function _from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
    }
    if (typeof value === "object" && value !== null) {
        if (isAnyArrayBuffer1(value)) {
            return fromArrayBuffer(value, encodingOrOffset, length);
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
            return _from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b) {
            return b;
        }
        if (typeof value[Symbol.toPrimitive] === "function") {
            const primitive = value[Symbol.toPrimitive]("string");
            if (typeof primitive === "string") {
                return fromString(primitive, encodingOrOffset);
            }
        }
    }
    throw new codes.ERR_INVALID_ARG_TYPE("first argument", [
        "string",
        "Buffer",
        "ArrayBuffer",
        "Array",
        "Array-like Object"
    ], value);
}
Buffer1.from = function from(value, encodingOrOffset, length) {
    return _from(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer1.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer1, Uint8Array);
function assertSize(size) {
    validateNumber(size, "size");
    if (!(size >= 0 && size <= 2147483647)) {
        throw new codes.ERR_INVALID_ARG_VALUE.RangeError("size", size);
    }
}
function _alloc(size, fill, encoding) {
    assertSize(size);
    const buffer = createBuffer(size);
    if (fill !== undefined) {
        if (encoding !== undefined && typeof encoding !== "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
        }
        return buffer.fill(fill, encoding);
    }
    return buffer;
}
Buffer1.alloc = function alloc(size, fill, encoding) {
    return _alloc(size, fill, encoding);
};
function _allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
Buffer1.allocUnsafe = function allocUnsafe(size) {
    return _allocUnsafe(size);
};
Buffer1.allocUnsafeSlow = function allocUnsafeSlow(size) {
    return _allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
    }
    if (!Buffer1.isEncoding(encoding)) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
        buf = buf.slice(0, actual);
    }
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i34 = 0; i34 < length; i34 += 1){
        buf[i34] = array[i34] & 255;
    }
    return buf;
}
function fromObject(obj) {
    if (obj.length !== undefined || isAnyArrayBuffer1(obj.buffer)) {
        if (typeof obj.length !== "number") {
            return createBuffer(0);
        }
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
    }
}
function checked(length) {
    if (length >= 2147483647) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647..toString(16) + " bytes");
    }
    return length | 0;
}
function SlowBuffer(length) {
    assertSize(length);
    return Buffer1.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer, Uint8Array);
Buffer1.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer1.prototype;
};
Buffer1.compare = function compare(a2, b) {
    if (isInstance(a2, Uint8Array)) {
        a2 = Buffer1.from(a2, a2.offset, a2.byteLength);
    }
    if (isInstance(b, Uint8Array)) {
        b = Buffer1.from(b, b.offset, b.byteLength);
    }
    if (!Buffer1.isBuffer(a2) || !Buffer1.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a2 === b) {
        return 0;
    }
    let x = a2.length;
    let y = b.length;
    for(let i35 = 0, len = Math.min(x, y); i35 < len; ++i35){
        if (a2[i35] !== b[i35]) {
            x = a2[i35];
            y = b[i35];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
Buffer1.isEncoding = function isEncoding(encoding) {
    return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding(encoding) !== undefined;
};
Buffer1.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
        throw new codes.ERR_INVALID_ARG_TYPE("list", "Array", list);
    }
    if (list.length === 0) {
        return Buffer1.alloc(0);
    }
    if (length === undefined) {
        length = 0;
        for(let i36 = 0; i36 < list.length; i36++){
            if (list[i36].length) {
                length += list[i36].length;
            }
        }
    } else {
        validateOffset(length, "length");
    }
    const buffer = Buffer1.allocUnsafe(length);
    let pos = 0;
    for(let i37 = 0; i37 < list.length; i37++){
        const buf = list[i37];
        if (!isUint8Array(buf)) {
            throw new codes.ERR_INVALID_ARG_TYPE(`list[${i37}]`, [
                "Buffer",
                "Uint8Array"
            ], list[i37]);
        }
        pos += _copyActual(buf, buffer, pos, 0, buf.length);
    }
    if (pos < length) {
        buffer.fill(0, pos, length);
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (typeof string !== "string") {
        if (isArrayBufferView(string) || isAnyArrayBuffer1(string)) {
            return string.byteLength;
        }
        throw new codes.ERR_INVALID_ARG_TYPE("string", [
            "string",
            "Buffer",
            "ArrayBuffer"
        ], string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) {
        return 0;
    }
    if (!encoding) {
        return mustMatch ? -1 : byteLengthUtf8(string);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        return mustMatch ? -1 : byteLengthUtf8(string);
    }
    return ops.byteLength(string);
}
Buffer1.byteLength = byteLength;
Buffer1.prototype._isBuffer = true;
function swap(b, n7, m) {
    const i38 = b[n7];
    b[n7] = b[m];
    b[m] = i38;
}
Buffer1.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for(let i39 = 0; i39 < len; i39 += 2){
        swap(this, i39, i39 + 1);
    }
    return this;
};
Buffer1.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for(let i40 = 0; i40 < len; i40 += 4){
        swap(this, i40, i40 + 3);
        swap(this, i40 + 1, i40 + 2);
    }
    return this;
};
Buffer1.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for(let i41 = 0; i41 < len; i41 += 8){
        swap(this, i41, i41 + 7);
        swap(this, i41 + 1, i41 + 6);
        swap(this, i41 + 2, i41 + 5);
        swap(this, i41 + 3, i41 + 4);
    }
    return this;
};
Buffer1.prototype.toString = function toString(encoding, start, end) {
    if (arguments.length === 0) {
        return this.utf8Slice(0, this.length);
    }
    const len = this.length;
    if (start <= 0) {
        start = 0;
    } else if (start >= len) {
        return "";
    } else {
        start |= 0;
    }
    if (end === undefined || end > len) {
        end = len;
    } else {
        end |= 0;
    }
    if (end <= start) {
        return "";
    }
    if (encoding === undefined) {
        return this.utf8Slice(start, end);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.slice(this, start, end);
};
Buffer1.prototype.toLocaleString = Buffer1.prototype.toString;
Buffer1.prototype.equals = function equals(b) {
    if (!isUint8Array(b)) {
        throw new codes.ERR_INVALID_ARG_TYPE("otherBuffer", [
            "Buffer",
            "Uint8Array"
        ], b);
    }
    if (this === b) {
        return true;
    }
    return Buffer1.compare(this, b) === 0;
};
Buffer1.prototype.inspect = function inspect() {
    let str = "";
    const max = INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) {
        str += " ... ";
    }
    return "<Buffer " + str + ">";
};
if (customInspectSymbol1) {
    Buffer1.prototype[customInspectSymbol1] = Buffer1.prototype.inspect;
}
Buffer1.prototype.compare = function compare(target6, start, end, thisStart, thisEnd) {
    if (isInstance(target6, Uint8Array)) {
        target6 = Buffer1.from(target6, target6.offset, target6.byteLength);
    }
    if (!Buffer1.isBuffer(target6)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target6);
    }
    if (start === undefined) {
        start = 0;
    } else {
        validateOffset(start, "targetStart", 0, kMaxLength);
    }
    if (end === undefined) {
        end = target6.length;
    } else {
        validateOffset(end, "targetEnd", 0, target6.length);
    }
    if (thisStart === undefined) {
        thisStart = 0;
    } else {
        validateOffset(start, "sourceStart", 0, kMaxLength);
    }
    if (thisEnd === undefined) {
        thisEnd = this.length;
    } else {
        validateOffset(end, "sourceEnd", 0, this.length);
    }
    if (start < 0 || end > target6.length || thisStart < 0 || thisEnd > this.length) {
        throw new codes.ERR_OUT_OF_RANGE("out of range index", "range");
    }
    if (thisStart >= thisEnd && start >= end) {
        return 0;
    }
    if (thisStart >= thisEnd) {
        return -1;
    }
    if (start >= end) {
        return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target6) {
        return 0;
    }
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target6.slice(start, end);
    for(let i42 = 0; i42 < len; ++i42){
        if (thisCopy[i42] !== targetCopy[i42]) {
            x = thisCopy[i42];
            y = targetCopy[i42];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    validateBuffer(buffer);
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = undefined;
    } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
    }
    dir = !!dir;
    if (typeof val === "number") {
        return indexOfNumber(buffer, val >>> 0, byteOffset, dir);
    }
    let ops;
    if (encoding === undefined) {
        ops = encodingOps.utf8;
    } else {
        ops = getEncodingOps(encoding);
    }
    if (typeof val === "string") {
        if (ops === undefined) {
            throw new codes.ERR_UNKNOWN_ENCODING(encoding);
        }
        return ops.indexOf(buffer, val, byteOffset, dir);
    }
    if (isUint8Array(val)) {
        const encodingVal = ops === undefined ? encodingsMap.utf8 : ops.encodingVal;
        return indexOfBuffer(buffer, val, byteOffset, encodingVal, dir);
    }
    throw new codes.ERR_INVALID_ARG_TYPE("value", [
        "number",
        "string",
        "Buffer",
        "Uint8Array"
    ], val);
}
Buffer1.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer1.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer1.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
Buffer1.prototype.asciiSlice = function asciiSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToAscii(this);
    } else {
        return bytesToAscii(this.slice(offset, length));
    }
};
Buffer1.prototype.asciiWrite = function asciiWrite(string, offset, length) {
    return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer1.prototype.base64Slice = function base64Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode1(this);
    } else {
        return encode1(this.slice(offset, length));
    }
};
Buffer1.prototype.base64Write = function base64Write(string, offset, length) {
    return blitBuffer(base64ToBytes(string), this, offset, length);
};
Buffer1.prototype.base64urlSlice = function base64urlSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode2(this);
    } else {
        return encode2(this.slice(offset, length));
    }
};
Buffer1.prototype.base64urlWrite = function base64urlWrite(string, offset, length) {
    return blitBuffer(base64UrlToBytes(string), this, offset, length);
};
Buffer1.prototype.hexWrite = function hexWrite(string, offset, length) {
    return blitBuffer(hexToBytes(string, this.length - offset), this, offset, length);
};
Buffer1.prototype.hexSlice = function hexSlice(string, offset, length) {
    return _hexSlice(this, string, offset, length);
};
Buffer1.prototype.latin1Slice = function latin1Slice(string, offset, length) {
    return _latin1Slice(this, string, offset, length);
};
Buffer1.prototype.latin1Write = function latin1Write(string, offset, length) {
    return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer1.prototype.ucs2Slice = function ucs2Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToUtf16le(this);
    } else {
        return bytesToUtf16le(this.slice(offset, length));
    }
};
Buffer1.prototype.ucs2Write = function ucs2Write(string, offset, length) {
    return blitBuffer(utf16leToBytes(string, this.length - offset), this, offset, length);
};
Buffer1.prototype.utf8Slice = function utf8Slice(string, offset, length) {
    return _utf8Slice(this, string, offset, length);
};
Buffer1.prototype.utf8Write = function utf8Write(string, offset, length) {
    return blitBuffer(utf8ToBytes(string, this.length - offset), this, offset, length);
};
Buffer1.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
        return this.utf8Write(string, 0, this.length);
    }
    if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    } else {
        validateOffset(offset, "offset", 0, this.length);
        const remaining = this.length - offset;
        if (length === undefined) {
            length = remaining;
        } else if (typeof length === "string") {
            encoding = length;
            length = remaining;
        } else {
            validateOffset(length, "length", 0, this.length);
            if (length > remaining) {
                length = remaining;
            }
        }
    }
    if (!encoding) {
        return this.utf8Write(string, offset, length);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.write(this, string, offset, length);
};
Buffer1.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function fromArrayBuffer(obj, byteOffset, length) {
    if (byteOffset === undefined) {
        byteOffset = 0;
    } else {
        byteOffset = +byteOffset;
        if (Number.isNaN(byteOffset)) {
            byteOffset = 0;
        }
    }
    const maxLength = obj.byteLength - byteOffset;
    if (maxLength < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("offset");
    }
    if (length === undefined) {
        length = maxLength;
    } else {
        length = +length;
        if (length > 0) {
            if (length > maxLength) {
                throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("length");
            }
        } else {
            length = 0;
        }
    }
    const buffer = new Uint8Array(obj, byteOffset, length);
    Object.setPrototypeOf(buffer, Buffer1.prototype);
    return buffer;
}
function _utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i43 = start;
    while(i43 < end){
        const firstByte = buf[i43];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i43 + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 128) {
                        codePoint = firstByte;
                    }
                    break;
                case 2:
                    secondByte = buf[i43 + 1];
                    if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 3:
                    secondByte = buf[i43 + 1];
                    thirdByte = buf[i43 + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 4:
                    secondByte = buf[i43 + 1];
                    thirdByte = buf[i43 + 2];
                    fourthByte = buf[i43 + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                            codePoint = tempCodePoint;
                        }
                    }
            }
        }
        if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i43 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
const MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= 4096) {
        return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i44 = 0;
    while(i44 < len){
        res += String.fromCharCode.apply(String, codePoints.slice(i44, i44 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
}
function _latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i45 = start; i45 < end; ++i45){
        ret += String.fromCharCode(buf[i45]);
    }
    return ret;
}
function _hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) {
        start = 0;
    }
    if (!end || end < 0 || end > len) {
        end = len;
    }
    let out = "";
    for(let i46 = start; i46 < end; ++i46){
        out += hexSliceLookupTable[buf[i46]];
    }
    return out;
}
Buffer1.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) {
            start = 0;
        }
    } else if (start > len) {
        start = len;
    }
    if (end < 0) {
        end += len;
        if (end < 0) {
            end = 0;
        }
    } else if (end > len) {
        end = len;
    }
    if (end < start) {
        end = start;
    }
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer1.prototype);
    return newBuf;
};
Buffer1.prototype.readUintLE = Buffer1.prototype.readUIntLE = function readUIntLE(offset, byteLength1) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength1 === 6) {
        return readUInt48LE(this, offset);
    }
    if (byteLength1 === 5) {
        return readUInt40LE(this, offset);
    }
    if (byteLength1 === 3) {
        return readUInt24LE(this, offset);
    }
    if (byteLength1 === 4) {
        return this.readUInt32LE(offset);
    }
    if (byteLength1 === 2) {
        return this.readUInt16LE(offset);
    }
    if (byteLength1 === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength1, 6, "byteLength");
};
Buffer1.prototype.readUintBE = Buffer1.prototype.readUIntBE = function readUIntBE(offset, byteLength2) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength2 === 6) {
        return readUInt48BE(this, offset);
    }
    if (byteLength2 === 5) {
        return readUInt40BE(this, offset);
    }
    if (byteLength2 === 3) {
        return readUInt24BE(this, offset);
    }
    if (byteLength2 === 4) {
        return this.readUInt32BE(offset);
    }
    if (byteLength2 === 2) {
        return this.readUInt16BE(offset);
    }
    if (byteLength2 === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength2, 6, "byteLength");
};
Buffer1.prototype.readUint8 = Buffer1.prototype.readUInt8 = function readUInt8(offset = 0) {
    validateNumber(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val;
};
Buffer1.prototype.readUint16BE = Buffer1.prototype.readUInt16BE = readUInt16BE;
Buffer1.prototype.readUint16LE = Buffer1.prototype.readUInt16LE = function readUInt16LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first + last * 2 ** 8;
};
Buffer1.prototype.readUint32LE = Buffer1.prototype.readUInt32LE = function readUInt32LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer1.prototype.readUint32BE = Buffer1.prototype.readUInt32BE = readUInt32BE;
Buffer1.prototype.readBigUint64LE = Buffer1.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer1.prototype.readBigUint64BE = Buffer1.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer1.prototype.readIntLE = function readIntLE(offset, byteLength3) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength3 === 6) {
        return readInt48LE(this, offset);
    }
    if (byteLength3 === 5) {
        return readInt40LE(this, offset);
    }
    if (byteLength3 === 3) {
        return readInt24LE(this, offset);
    }
    if (byteLength3 === 4) {
        return this.readInt32LE(offset);
    }
    if (byteLength3 === 2) {
        return this.readInt16LE(offset);
    }
    if (byteLength3 === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength3, 6, "byteLength");
};
Buffer1.prototype.readIntBE = function readIntBE(offset, byteLength4) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength4 === 6) {
        return readInt48BE(this, offset);
    }
    if (byteLength4 === 5) {
        return readInt40BE(this, offset);
    }
    if (byteLength4 === 3) {
        return readInt24BE(this, offset);
    }
    if (byteLength4 === 4) {
        return this.readInt32BE(offset);
    }
    if (byteLength4 === 2) {
        return this.readInt16BE(offset);
    }
    if (byteLength4 === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength4, 6, "byteLength");
};
Buffer1.prototype.readInt8 = function readInt8(offset = 0) {
    validateNumber(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val | (val & 2 ** 7) * 0x1fffffe;
};
Buffer1.prototype.readInt16LE = function readInt16LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first + last * 2 ** 8;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer1.prototype.readInt16BE = function readInt16BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first * 2 ** 8 + last;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer1.prototype.readInt32LE = function readInt32LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer1.prototype.readInt32BE = function readInt32BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer1.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer1.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer1.prototype.readFloatLE = function readFloatLE(offset) {
    return bigEndian ? readFloatBackwards(this, offset) : readFloatForwards(this, offset);
};
Buffer1.prototype.readFloatBE = function readFloatBE(offset) {
    return bigEndian ? readFloatForwards(this, offset) : readFloatBackwards(this, offset);
};
Buffer1.prototype.readDoubleLE = function readDoubleLE(offset) {
    return bigEndian ? readDoubleBackwards(this, offset) : readDoubleForwards(this, offset);
};
Buffer1.prototype.readDoubleBE = function readDoubleBE(offset) {
    return bigEndian ? readDoubleForwards(this, offset) : readDoubleBackwards(this, offset);
};
Buffer1.prototype.writeUintLE = Buffer1.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength5) {
    if (byteLength5 === 6) {
        return writeU_Int48LE(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength5 === 5) {
        return writeU_Int40LE(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength5 === 3) {
        return writeU_Int24LE(this, value, offset, 0, 0xffffff);
    }
    if (byteLength5 === 4) {
        return writeU_Int32LE(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength5 === 2) {
        return writeU_Int16LE(this, value, offset, 0, 0xffff);
    }
    if (byteLength5 === 1) {
        return writeU_Int8(this, value, offset, 0, 0xff);
    }
    boundsError(byteLength5, 6, "byteLength");
};
Buffer1.prototype.writeUintBE = Buffer1.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength6) {
    if (byteLength6 === 6) {
        return writeU_Int48BE(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength6 === 5) {
        return writeU_Int40BE(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength6 === 3) {
        return writeU_Int24BE(this, value, offset, 0, 0xffffff);
    }
    if (byteLength6 === 4) {
        return writeU_Int32BE(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength6 === 2) {
        return writeU_Int16BE(this, value, offset, 0, 0xffff);
    }
    if (byteLength6 === 1) {
        return writeU_Int8(this, value, offset, 0, 0xff);
    }
    boundsError(byteLength6, 6, "byteLength");
};
Buffer1.prototype.writeUint8 = Buffer1.prototype.writeUInt8 = function writeUInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, 0, 0xff);
};
Buffer1.prototype.writeUint16LE = Buffer1.prototype.writeUInt16LE = function writeUInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, 0, 0xffff);
};
Buffer1.prototype.writeUint16BE = Buffer1.prototype.writeUInt16BE = function writeUInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, 0, 0xffff);
};
Buffer1.prototype.writeUint32LE = Buffer1.prototype.writeUInt32LE = function writeUInt32LE(value, offset = 0) {
    return _writeUInt32LE(this, value, offset, 0, 0xffffffff);
};
Buffer1.prototype.writeUint32BE = Buffer1.prototype.writeUInt32BE = function writeUInt32BE(value, offset = 0) {
    return _writeUInt32BE(this, value, offset, 0, 0xffffffff);
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer1.prototype.writeBigUint64LE = Buffer1.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer1.prototype.writeBigUint64BE = Buffer1.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer1.prototype.writeIntLE = function writeIntLE(value, offset, byteLength7) {
    if (byteLength7 === 6) {
        return writeU_Int48LE(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength7 === 5) {
        return writeU_Int40LE(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength7 === 3) {
        return writeU_Int24LE(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength7 === 4) {
        return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength7 === 2) {
        return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength7 === 1) {
        return writeU_Int8(this, value, offset, -0x80, 0x7f);
    }
    boundsError(byteLength7, 6, "byteLength");
};
Buffer1.prototype.writeIntBE = function writeIntBE(value, offset, byteLength8) {
    if (byteLength8 === 6) {
        return writeU_Int48BE(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength8 === 5) {
        return writeU_Int40BE(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength8 === 3) {
        return writeU_Int24BE(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength8 === 4) {
        return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength8 === 2) {
        return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength8 === 1) {
        return writeU_Int8(this, value, offset, -0x80, 0x7f);
    }
    boundsError(byteLength8, 6, "byteLength");
};
Buffer1.prototype.writeInt8 = function writeInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, -0x80, 0x7f);
};
Buffer1.prototype.writeInt16LE = function writeInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);
};
Buffer1.prototype.writeInt16BE = function writeInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);
};
Buffer1.prototype.writeInt32LE = function writeInt32LE(value, offset = 0) {
    return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer1.prototype.writeInt32BE = function writeInt32BE(value, offset = 0) {
    return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer1.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer1.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer1.prototype.writeFloatLE = function writeFloatLE(value, offset) {
    return bigEndian ? writeFloatBackwards(this, value, offset) : writeFloatForwards(this, value, offset);
};
Buffer1.prototype.writeFloatBE = function writeFloatBE(value, offset) {
    return bigEndian ? writeFloatForwards(this, value, offset) : writeFloatBackwards(this, value, offset);
};
Buffer1.prototype.writeDoubleLE = function writeDoubleLE(value, offset) {
    return bigEndian ? writeDoubleBackwards(this, value, offset) : writeDoubleForwards(this, value, offset);
};
Buffer1.prototype.writeDoubleBE = function writeDoubleBE(value, offset) {
    return bigEndian ? writeDoubleForwards(this, value, offset) : writeDoubleBackwards(this, value, offset);
};
Buffer1.prototype.copy = function copy(target7, targetStart, sourceStart, sourceEnd) {
    if (!isUint8Array(this)) {
        throw new codes.ERR_INVALID_ARG_TYPE("source", [
            "Buffer",
            "Uint8Array"
        ], this);
    }
    if (!isUint8Array(target7)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target7);
    }
    if (targetStart === undefined) {
        targetStart = 0;
    } else {
        targetStart = toInteger(targetStart, 0);
        if (targetStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
        }
    }
    if (sourceStart === undefined) {
        sourceStart = 0;
    } else {
        sourceStart = toInteger(sourceStart, 0);
        if (sourceStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
        }
        if (sourceStart >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT32}`, sourceStart);
        }
    }
    if (sourceEnd === undefined) {
        sourceEnd = this.length;
    } else {
        sourceEnd = toInteger(sourceEnd, 0);
        if (sourceEnd < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
        }
        if (sourceEnd >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT32}`, sourceEnd);
        }
    }
    if (targetStart >= target7.length) {
        return 0;
    }
    if (sourceEnd > 0 && sourceEnd < sourceStart) {
        sourceEnd = sourceStart;
    }
    if (sourceEnd === sourceStart) {
        return 0;
    }
    if (target7.length === 0 || this.length === 0) {
        return 0;
    }
    if (sourceEnd > this.length) {
        sourceEnd = this.length;
    }
    if (target7.length - targetStart < sourceEnd - sourceStart) {
        sourceEnd = target7.length - targetStart + sourceStart;
    }
    const len = sourceEnd - sourceStart;
    if (this === target7 && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, sourceStart, sourceEnd);
    } else {
        Uint8Array.prototype.set.call(target7, this.subarray(sourceStart, sourceEnd), targetStart);
    }
    return len;
};
Buffer1.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer1.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                val = code;
            }
        }
    } else if (typeof val === "number") {
        val = val & 255;
    } else if (typeof val === "boolean") {
        val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
    }
    if (end <= start) {
        return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) {
        val = 0;
    }
    let i47;
    if (typeof val === "number") {
        for(i47 = start; i47 < end; ++i47){
            this[i47] = val;
        }
    } else {
        const bytes = Buffer1.isBuffer(val) ? val : Buffer1.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
            throw new codes.ERR_INVALID_ARG_VALUE("value", val);
        }
        for(i47 = 0; i47 < end - start; ++i47){
            this[i47 + start] = bytes[i47 % len];
        }
    }
    return this;
};
function checkBounds1(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
    }
}
function checkIntBI(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
        const n8 = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
                range = `>= 0${n8} and < 2${n8} ** ${(byteLength2 + 1) * 8}${n8}`;
            } else {
                range = `>= -(2${n8} ** ${(byteLength2 + 1) * 8 - 1}${n8}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n8}`;
            }
        } else {
            range = `>= ${min}${n8} and <= ${max}${n8}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds1(buf, offset, byteLength2);
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i48 = 0; i48 < length; ++i48){
        codePoint = string.charCodeAt(i48);
        if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
                if (codePoint > 56319) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                } else if (i48 + 1 === length) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                }
                leadSurrogate = codePoint;
                continue;
            }
            if (codePoint < 56320) {
                if ((units -= 3) > -1) {
                    bytes.push(239, 191, 189);
                }
                leadSurrogate = codePoint;
                continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
            if ((units -= 3) > -1) {
                bytes.push(239, 191, 189);
            }
        }
        leadSurrogate = null;
        if (codePoint < 128) {
            if ((units -= 1) < 0) {
                break;
            }
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) {
                break;
            }
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) {
                break;
            }
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) {
                break;
            }
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
            throw new Error("Invalid code point");
        }
    }
    return bytes;
}
function blitBuffer(src2, dst, offset, length) {
    let i49;
    for(i49 = 0; i49 < length; ++i49){
        if (i49 + offset >= dst.length || i49 >= src2.length) {
            break;
        }
        dst[i49 + offset] = src2[i49];
    }
    return i49;
}
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i50 = 0; i50 < 16; ++i50){
        const i16 = i50 * 16;
        for(let j = 0; j < 16; ++j){
            table[i16 + j] = alphabet[i50] + alphabet[j];
        }
    }
    return table;
}();
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}
globalThis.atob;
globalThis.Blob;
globalThis.btoa;
var valueType;
(function(valueType1) {
    valueType1[valueType1["noIterator"] = 0] = "noIterator";
    valueType1[valueType1["isArray"] = 1] = "isArray";
    valueType1[valueType1["isSet"] = 2] = "isSet";
    valueType1[valueType1["isMap"] = 3] = "isMap";
})(valueType || (valueType = {}));
let memo;
function innerDeepEqual(val1, val2, strict, memos = memo) {
    if (val1 === val2) {
        if (val1 !== 0) return true;
        return strict ? Object.is(val1, val2) : true;
    }
    if (strict) {
        if (typeof val1 !== "object") {
            return typeof val1 === "number" && Number.isNaN(val1) && Number.isNaN(val2);
        }
        if (typeof val2 !== "object" || val1 === null || val2 === null) {
            return false;
        }
        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
            return false;
        }
    } else {
        if (val1 === null || typeof val1 !== "object") {
            if (val2 === null || typeof val2 !== "object") {
                return val1 == val2 || Number.isNaN(val1) && Number.isNaN(val2);
            }
            return false;
        }
        if (val2 === null || typeof val2 !== "object") {
            return false;
        }
    }
    const val1Tag = Object.prototype.toString.call(val1);
    const val2Tag = Object.prototype.toString.call(val2);
    if (val1Tag !== val2Tag) {
        return false;
    }
    if (Array.isArray(val1)) {
        if (!Array.isArray(val2) || val1.length !== val2.length) {
            return false;
        }
        const filter = strict ? 2 : 2 | 16;
        const keys1 = getOwnNonIndexProperties(val1, filter);
        const keys2 = getOwnNonIndexProperties(val2, filter);
        if (keys1.length !== keys2.length) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isArray, keys1);
    } else if (val1Tag === "[object Object]") {
        return keyCheck(val1, val2, strict, memos, valueType.noIterator);
    } else if (val1 instanceof Date) {
        if (!(val2 instanceof Date) || val1.getTime() !== val2.getTime()) {
            return false;
        }
    } else if (val1 instanceof RegExp) {
        if (!(val2 instanceof RegExp) || !areSimilarRegExps(val1, val2)) {
            return false;
        }
    } else if (isNativeError1(val1) || val1 instanceof Error) {
        if (!isNativeError1(val2) && !(val2 instanceof Error) || val1.message !== val2.message || val1.name !== val2.name) {
            return false;
        }
    } else if (isArrayBufferView(val1)) {
        const TypedArrayPrototypeGetSymbolToStringTag = (val)=>Object.getOwnPropertySymbols(val).map((item)=>item.toString()
            ).toString()
        ;
        if (isTypedArray(val1) && isTypedArray(val2) && TypedArrayPrototypeGetSymbolToStringTag(val1) !== TypedArrayPrototypeGetSymbolToStringTag(val2)) {
            return false;
        }
        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
            if (!areSimilarFloatArrays(val1, val2)) {
                return false;
            }
        } else if (!areSimilarTypedArrays(val1, val2)) {
            return false;
        }
        const filter = strict ? 2 : 2 | 16;
        const keysVal1 = getOwnNonIndexProperties(val1, filter);
        const keysVal2 = getOwnNonIndexProperties(val2, filter);
        if (keysVal1.length !== keysVal2.length) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.noIterator, keysVal1);
    } else if (isSet1(val1)) {
        if (!isSet1(val2) || val1.size !== val2.size) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isSet);
    } else if (isMap1(val1)) {
        if (!isMap1(val2) || val1.size !== val2.size) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isMap);
    } else if (isAnyArrayBuffer1(val1)) {
        if (!isAnyArrayBuffer1(val2) || !areEqualArrayBuffers(val1, val2)) {
            return false;
        }
    } else if (isBoxedPrimitive1(val1)) {
        if (!isEqualBoxedPrimitive(val1, val2)) {
            return false;
        }
    } else if (Array.isArray(val2) || isArrayBufferView(val2) || isSet1(val2) || isMap1(val2) || isDate1(val2) || isRegExp1(val2) || isAnyArrayBuffer1(val2) || isBoxedPrimitive1(val2) || isNativeError1(val2) || val2 instanceof Error) {
        return false;
    }
    return keyCheck(val1, val2, strict, memos, valueType.noIterator);
}
function keyCheck(val1, val2, strict, memos, iterationType, aKeys = []) {
    if (arguments.length === 5) {
        aKeys = Object.keys(val1);
        const bKeys = Object.keys(val2);
        if (aKeys.length !== bKeys.length) {
            return false;
        }
    }
    let i51 = 0;
    for(; i51 < aKeys.length; i51++){
        if (!val2.propertyIsEnumerable(aKeys[i51])) {
            return false;
        }
    }
    if (strict && arguments.length === 5) {
        const symbolKeysA = Object.getOwnPropertySymbols(val1);
        if (symbolKeysA.length !== 0) {
            let count = 0;
            for(i51 = 0; i51 < symbolKeysA.length; i51++){
                const key = symbolKeysA[i51];
                if (val1.propertyIsEnumerable(key)) {
                    if (!val2.propertyIsEnumerable(key)) {
                        return false;
                    }
                    aKeys.push(key.toString());
                    count++;
                } else if (val2.propertyIsEnumerable(key)) {
                    return false;
                }
            }
            const symbolKeysB = Object.getOwnPropertySymbols(val2);
            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
                return false;
            }
        } else {
            const symbolKeysB = Object.getOwnPropertySymbols(val2);
            if (symbolKeysB.length !== 0 && getEnumerables(val2, symbolKeysB).length !== 0) {
                return false;
            }
        }
    }
    if (aKeys.length === 0 && (iterationType === valueType.noIterator || iterationType === valueType.isArray && val1.length === 0 || val1.size === 0)) {
        return true;
    }
    if (memos === undefined) {
        memos = {
            val1: new Map(),
            val2: new Map(),
            position: 0
        };
    } else {
        const val2MemoA = memos.val1.get(val1);
        if (val2MemoA !== undefined) {
            const val2MemoB = memos.val2.get(val2);
            if (val2MemoB !== undefined) {
                return val2MemoA === val2MemoB;
            }
        }
        memos.position++;
    }
    memos.val1.set(val1, memos.position);
    memos.val2.set(val2, memos.position);
    const areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
    memos.val1.delete(val1);
    memos.val2.delete(val2);
    return areEq;
}
function areSimilarRegExps(a3, b) {
    return a3.source === b.source && a3.flags === b.flags && a3.lastIndex === b.lastIndex;
}
function areSimilarFloatArrays(arr1, arr2) {
    if (arr1.byteLength !== arr2.byteLength) {
        return false;
    }
    for(let i52 = 0; i52 < arr1.byteLength; i52++){
        if (arr1[i52] !== arr2[i52]) {
            return false;
        }
    }
    return true;
}
function areSimilarTypedArrays(arr1, arr2) {
    if (arr1.byteLength !== arr2.byteLength) {
        return false;
    }
    return Buffer1.compare(new Uint8Array(arr1.buffer, arr1.byteOffset, arr1.byteLength), new Uint8Array(arr2.buffer, arr2.byteOffset, arr2.byteLength)) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
    return buf1.byteLength === buf2.byteLength && Buffer1.compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(a4, b) {
    if (Object.getOwnPropertyNames(a4).length !== Object.getOwnPropertyNames(b).length) {
        return false;
    }
    if (Object.getOwnPropertySymbols(a4).length !== Object.getOwnPropertySymbols(b).length) {
        return false;
    }
    if (isNumberObject1(a4)) {
        return isNumberObject1(b) && Object.is(Number.prototype.valueOf.call(a4), Number.prototype.valueOf.call(b));
    }
    if (isStringObject1(a4)) {
        return isStringObject1(b) && String.prototype.valueOf.call(a4) === String.prototype.valueOf.call(b);
    }
    if (isBooleanObject1(a4)) {
        return isBooleanObject1(b) && Boolean.prototype.valueOf.call(a4) === Boolean.prototype.valueOf.call(b);
    }
    if (isBigIntObject1(a4)) {
        return isBigIntObject1(b) && BigInt.prototype.valueOf.call(a4) === BigInt.prototype.valueOf.call(b);
    }
    if (isSymbolObject1(a4)) {
        return isSymbolObject1(b) && Symbol.prototype.valueOf.call(a4) === Symbol.prototype.valueOf.call(b);
    }
    throw Error(`Unknown boxed type`);
}
function getEnumerables(val, keys) {
    return keys.filter((key)=>val.propertyIsEnumerable(key)
    );
}
function objEquiv(obj1, obj2, strict, keys, memos, iterationType) {
    let i53 = 0;
    if (iterationType === valueType.isSet) {
        if (!setEquiv(obj1, obj2, strict, memos)) {
            return false;
        }
    } else if (iterationType === valueType.isMap) {
        if (!mapEquiv(obj1, obj2, strict, memos)) {
            return false;
        }
    } else if (iterationType === valueType.isArray) {
        for(; i53 < obj1.length; i53++){
            if (obj1.hasOwnProperty(i53)) {
                if (!obj2.hasOwnProperty(i53) || !innerDeepEqual(obj1[i53], obj2[i53], strict, memos)) {
                    return false;
                }
            } else if (obj2.hasOwnProperty(i53)) {
                return false;
            } else {
                const keys1 = Object.keys(obj1);
                for(; i53 < keys1.length; i53++){
                    const key = keys1[i53];
                    if (!obj2.hasOwnProperty(key) || !innerDeepEqual(obj1[key], obj2[key], strict, memos)) {
                        return false;
                    }
                }
                if (keys1.length !== Object.keys(obj2).length) {
                    return false;
                }
                if (keys1.length !== Object.keys(obj2).length) {
                    return false;
                }
                return true;
            }
        }
    }
    for(i53 = 0; i53 < keys.length; i53++){
        const key = keys[i53];
        if (!innerDeepEqual(obj1[key], obj2[key], strict, memos)) {
            return false;
        }
    }
    return true;
}
function findLooseMatchingPrimitives(primitive) {
    switch(typeof primitive){
        case "undefined":
            return null;
        case "object":
            return undefined;
        case "symbol":
            return false;
        case "string":
            primitive = +primitive;
        case "number":
            if (Number.isNaN(primitive)) {
                return false;
            }
    }
    return true;
}
function setMightHaveLoosePrim(set1, set2, primitive) {
    const altValue = findLooseMatchingPrimitives(primitive);
    if (altValue != null) return altValue;
    return set2.has(altValue) && !set1.has(altValue);
}
function setHasEqualElement(set, val1, strict, memos) {
    for (const val2 of set){
        if (innerDeepEqual(val1, val2, strict, memos)) {
            set.delete(val2);
            return true;
        }
    }
    return false;
}
function setEquiv(set1, set2, strict, memos) {
    let set = null;
    for (const item of set1){
        if (typeof item === "object" && item !== null) {
            if (set === null) {
                set = new Set();
            }
            set.add(item);
        } else if (!set2.has(item)) {
            if (strict) return false;
            if (!setMightHaveLoosePrim(set1, set2, item)) {
                return false;
            }
            if (set === null) {
                set = new Set();
            }
            set.add(item);
        }
    }
    if (set !== null) {
        for (const item of set2){
            if (typeof item === "object" && item !== null) {
                if (!setHasEqualElement(set, item, strict, memos)) return false;
            } else if (!strict && !set1.has(item) && !setHasEqualElement(set, item, strict, memos)) {
                return false;
            }
        }
        return set.size === 0;
    }
    return true;
}
function mapMightHaveLoosePrimitive(map1, map2, primitive, item, memos) {
    const altValue = findLooseMatchingPrimitives(primitive);
    if (altValue != null) {
        return altValue;
    }
    const curB = map2.get(altValue);
    if (curB === undefined && !map2.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
        return false;
    }
    return !map1.has(altValue) && innerDeepEqual(item, curB, false, memos);
}
function mapEquiv(map1, map2, strict, memos) {
    let set = null;
    for (const { 0: key , 1: item1  } of map1){
        if (typeof key === "object" && key !== null) {
            if (set === null) {
                set = new Set();
            }
            set.add(key);
        } else {
            const item2 = map2.get(key);
            if (item2 === undefined && !map2.has(key) || !innerDeepEqual(item1, item2, strict, memos)) {
                if (strict) return false;
                if (!mapMightHaveLoosePrimitive(map1, map2, key, item1, memos)) {
                    return false;
                }
                if (set === null) {
                    set = new Set();
                }
                set.add(key);
            }
        }
    }
    if (set !== null) {
        for (const { 0: key , 1: item  } of map2){
            if (typeof key === "object" && key !== null) {
                if (!mapHasEqualEntry(set, map1, key, item, strict, memos)) {
                    return false;
                }
            } else if (!strict && (!map1.has(key) || !innerDeepEqual(map1.get(key), item, false, memos)) && !mapHasEqualEntry(set, map1, key, item, false, memos)) {
                return false;
            }
        }
        return set.size === 0;
    }
    return true;
}
function mapHasEqualEntry(set, map3, key1, item1, strict, memos) {
    for (const key2 of set){
        if (innerDeepEqual(key1, key2, strict, memos) && innerDeepEqual(item1, map3.get(key2), strict, memos)) {
            set.delete(key2);
            return true;
        }
    }
    return false;
}
const NumberIsSafeInteger = Number.isSafeInteger;
function getSystemErrorName(code) {
    if (typeof code !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE("err", "number", code);
    }
    if (code >= 0 || !NumberIsSafeInteger(code)) {
        throw new codes.ERR_OUT_OF_RANGE("err", "a negative integer", code);
    }
    return errorMap.get(code)?.[0];
}
const { errno: { ENOTDIR , ENOENT  } ,  } = os;
const kIsNodeError = Symbol("kIsNodeError");
const classRegExp1 = /^([A-Z][a-z0-9]*)+$/;
const kTypes = [
    "string",
    "function",
    "number",
    "object",
    "Function",
    "Object",
    "boolean",
    "bigint",
    "symbol", 
];
function addNumericalSeparator(val) {
    let res = "";
    let i54 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i54 >= start + 4; i54 -= 3){
        res = `_${val.slice(i54 - 3, i54)}${res}`;
    }
    return `${val.slice(0, i54)}${res}`;
}
const captureLargerStackTrace = hideStackFrames(function captureLargerStackTrace(err) {
    Error.captureStackTrace(err);
    return err;
});
hideStackFrames(function uvExceptionWithHostPort(err, syscall, address, port) {
    const { 0: code , 1: uvmsg  } = uvErrmapGet(err) || uvUnmappedError;
    const message = `${syscall} ${code}: ${uvmsg}`;
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    const ex = new Error(`${message}${details}`);
    ex.code = code;
    ex.errno = err;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace(ex);
});
hideStackFrames(function errnoException(err, syscall, original) {
    const code = getSystemErrorName(err);
    const message = original ? `${syscall} ${code} ${original}` : `${syscall} ${code}`;
    const ex = new Error(message);
    ex.errno = err;
    ex.code = code;
    ex.syscall = syscall;
    return captureLargerStackTrace(ex);
});
function uvErrmapGet(name) {
    return errorMap.get(name);
}
const uvUnmappedError = [
    "UNKNOWN",
    "unknown error"
];
hideStackFrames(function uvException(ctx) {
    const { 0: code , 1: uvmsg  } = uvErrmapGet(ctx.errno) || uvUnmappedError;
    let message = `${code}: ${ctx.message || uvmsg}, ${ctx.syscall}`;
    let path2;
    let dest;
    if (ctx.path) {
        path2 = ctx.path.toString();
        message += ` '${path2}'`;
    }
    if (ctx.dest) {
        dest = ctx.dest.toString();
        message += ` -> '${dest}'`;
    }
    const err = new Error(message);
    for (const prop of Object.keys(ctx)){
        if (prop === "message" || prop === "path" || prop === "dest") {
            continue;
        }
        err[prop] = ctx[prop];
    }
    err.code = code;
    if (path2) {
        err.path = path2;
    }
    if (dest) {
        err.dest = dest;
    }
    return captureLargerStackTrace(err);
});
hideStackFrames(function exceptionWithHostPort(err, syscall, address, port, additional) {
    const code = getSystemErrorName(err);
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    if (additional) {
        details += ` - Local (${additional})`;
    }
    const ex = new Error(`${syscall} ${code}${details}`);
    ex.errno = err;
    ex.code = code;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace(ex);
});
hideStackFrames(function(code, syscall, hostname) {
    let errno;
    if (typeof code === "number") {
        errno = code;
        if (code === codeMap.get("EAI_NODATA") || code === codeMap.get("EAI_NONAME")) {
            code = "ENOTFOUND";
        } else {
            code = getSystemErrorName(code);
        }
    }
    const message = `${syscall} ${code}${hostname ? ` ${hostname}` : ""}`;
    const ex = new Error(message);
    ex.errno = errno;
    ex.code = code;
    ex.syscall = syscall;
    if (hostname) {
        ex.hostname = hostname;
    }
    return captureLargerStackTrace(ex);
});
class NodeErrorAbstraction extends Error {
    code;
    constructor(name, code, message){
        super(message);
        this.code = code;
        this.name = name;
        this.stack = this.stack && `${name} [${this.code}]${this.stack.slice(20)}`;
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
class NodeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(Error.prototype.name, code, message);
    }
}
class NodeRangeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(RangeError.prototype.name, code, message);
        Object.setPrototypeOf(this, RangeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeTypeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(TypeError.prototype.name, code, message);
        Object.setPrototypeOf(this, TypeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeURIError extends NodeErrorAbstraction {
    constructor(code, message){
        super(URIError.prototype.name, code, message);
        Object.setPrototypeOf(this, URIError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeSystemError extends NodeErrorAbstraction {
    constructor(key, context, msgPrefix){
        let message = `${msgPrefix}: ${context.syscall} returned ` + `${context.code} (${context.message})`;
        if (context.path !== undefined) {
            message += ` ${context.path}`;
        }
        if (context.dest !== undefined) {
            message += ` => ${context.dest}`;
        }
        super("SystemError", key, message);
        captureLargerStackTrace(this);
        Object.defineProperties(this, {
            [kIsNodeError]: {
                value: true,
                enumerable: false,
                writable: false,
                configurable: true
            },
            info: {
                value: context,
                enumerable: true,
                configurable: true,
                writable: false
            },
            errno: {
                get () {
                    return context.errno;
                },
                set: (value)=>{
                    context.errno = value;
                },
                enumerable: true,
                configurable: true
            },
            syscall: {
                get () {
                    return context.syscall;
                },
                set: (value)=>{
                    context.syscall = value;
                },
                enumerable: true,
                configurable: true
            }
        });
        if (context.path !== undefined) {
            Object.defineProperty(this, "path", {
                get () {
                    return context.path;
                },
                set: (value)=>{
                    context.path = value;
                },
                enumerable: true,
                configurable: true
            });
        }
        if (context.dest !== undefined) {
            Object.defineProperty(this, "dest", {
                get () {
                    return context.dest;
                },
                set: (value)=>{
                    context.dest = value;
                },
                enumerable: true,
                configurable: true
            });
        }
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
function makeSystemErrorWithCode(key, msgPrfix) {
    return class NodeError extends NodeSystemError {
        constructor(ctx){
            super(key, ctx, msgPrfix);
        }
    };
}
makeSystemErrorWithCode("ERR_FS_EISDIR", "Path is a directory");
function createInvalidArgType(name, expected) {
    expected = Array.isArray(expected) ? expected : [
        expected
    ];
    let msg = "The ";
    if (name.endsWith(" argument")) {
        msg += `${name} `;
    } else {
        const type = name.includes(".") ? "property" : "argument";
        msg += `"${name}" ${type} `;
    }
    msg += "must be ";
    const types1 = [];
    const instances = [];
    const other = [];
    for (const value of expected){
        if (kTypes.includes(value)) {
            types1.push(value.toLocaleLowerCase());
        } else if (classRegExp1.test(value)) {
            instances.push(value);
        } else {
            other.push(value);
        }
    }
    if (instances.length > 0) {
        const pos = types1.indexOf("object");
        if (pos !== -1) {
            types1.splice(pos, 1);
            instances.push("Object");
        }
    }
    if (types1.length > 0) {
        if (types1.length > 2) {
            const last = types1.pop();
            msg += `one of type ${types1.join(", ")}, or ${last}`;
        } else if (types1.length === 2) {
            msg += `one of type ${types1[0]} or ${types1[1]}`;
        } else {
            msg += `of type ${types1[0]}`;
        }
        if (instances.length > 0 || other.length > 0) {
            msg += " or ";
        }
    }
    if (instances.length > 0) {
        if (instances.length > 2) {
            const last = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last}`;
        } else {
            msg += `an instance of ${instances[0]}`;
            if (instances.length === 2) {
                msg += ` or ${instances[1]}`;
            }
        }
        if (other.length > 0) {
            msg += " or ";
        }
    }
    if (other.length > 0) {
        if (other.length > 2) {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
        } else if (other.length === 2) {
            msg += `one of ${other[0]} or ${other[1]}`;
        } else {
            if (other[0].toLowerCase() !== other[0]) {
                msg += "an ";
            }
            msg += `${other[0]}`;
        }
    }
    return msg;
}
class ERR_INVALID_ARG_TYPE_RANGE extends NodeRangeError {
    constructor(name, expected, actual){
        const msg = createInvalidArgType(name, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
    }
}
class ERR_INVALID_ARG_TYPE extends NodeTypeError {
    constructor(name, expected, actual){
        const msg = createInvalidArgType(name, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
    }
    static RangeError = ERR_INVALID_ARG_TYPE_RANGE;
}
class ERR_INVALID_ARG_VALUE_RANGE extends NodeRangeError {
    constructor(name, value, reason = "is invalid"){
        const type = name.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
    }
}
class ERR_INVALID_ARG_VALUE extends NodeTypeError {
    constructor(name, value, reason = "is invalid"){
        const type = name.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
    }
    static RangeError = ERR_INVALID_ARG_VALUE_RANGE;
}
function invalidArgTypeHelper(input) {
    if (input == null) {
        return ` Received ${input}`;
    }
    if (typeof input === "function" && input.name) {
        return ` Received function ${input.name}`;
    }
    if (typeof input === "object") {
        if (input.constructor && input.constructor.name) {
            return ` Received an instance of ${input.constructor.name}`;
        }
        return ` Received ${inspect(input, {
            depth: -1
        })}`;
    }
    let inspected = inspect(input, {
        colors: false
    });
    if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`;
    }
    return ` Received type ${typeof input} (${inspected})`;
}
class ERR_OUT_OF_RANGE extends RangeError {
    code = "ERR_OUT_OF_RANGE";
    constructor(str, range, input, replaceDefaultBoolean = false){
        assert(range, 'Missing "range" argument');
        let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
            received = String(input);
            if (input > 2n ** 32n || input < -(2n ** 32n)) {
                received = addNumericalSeparator(received);
            }
            received += "n";
        } else {
            received = inspect(input);
        }
        msg += ` It must be ${range}. Received ${received}`;
        super(msg);
        const { name  } = this;
        this.name = `${name} [${this.code}]`;
        this.stack;
        this.name = name;
    }
}
class ERR_BUFFER_OUT_OF_BOUNDS extends NodeRangeError {
    constructor(name){
        super("ERR_BUFFER_OUT_OF_BOUNDS", name ? `"${name}" is outside of buffer bounds` : "Attempt to access memory outside buffer bounds");
    }
}
class ERR_INVALID_CALLBACK extends NodeTypeError {
    constructor(object){
        super("ERR_INVALID_CALLBACK", `Callback must be a function. Received ${inspect(object)}`);
    }
}
class ERR_INVALID_URI extends NodeURIError {
    constructor(){
        super("ERR_INVALID_URI", `URI malformed`);
    }
}
class ERR_IPC_CHANNEL_CLOSED extends NodeError {
    constructor(){
        super("ERR_IPC_CHANNEL_CLOSED", `Channel closed`);
    }
}
class ERR_SOCKET_BAD_PORT extends NodeRangeError {
    constructor(name, port, allowZero = true){
        assert(typeof allowZero === "boolean", "The 'allowZero' argument must be of type boolean.");
        const operator = allowZero ? ">=" : ">";
        super("ERR_SOCKET_BAD_PORT", `${name} should be ${operator} 0 and < 65536. Received ${port}.`);
    }
}
class ERR_UNKNOWN_ENCODING extends NodeTypeError {
    constructor(x){
        super("ERR_UNKNOWN_ENCODING", `Unknown encoding: ${x}`);
    }
}
codes.ERR_IPC_CHANNEL_CLOSED = ERR_IPC_CHANNEL_CLOSED;
codes.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE;
codes.ERR_INVALID_ARG_VALUE = ERR_INVALID_ARG_VALUE;
codes.ERR_INVALID_CALLBACK = ERR_INVALID_CALLBACK;
codes.ERR_OUT_OF_RANGE = ERR_OUT_OF_RANGE;
codes.ERR_SOCKET_BAD_PORT = ERR_SOCKET_BAD_PORT;
codes.ERR_BUFFER_OUT_OF_BOUNDS = ERR_BUFFER_OUT_OF_BOUNDS;
codes.ERR_UNKNOWN_ENCODING = ERR_UNKNOWN_ENCODING;
const CHAR_FORWARD_SLASH = 47;
const CHAR_FORWARD_SLASH1 = 47;
function assertPath(path3) {
    if (typeof path3 !== "string") {
        throw new ERR_INVALID_ARG_TYPE("path", [
            "string"
        ], path3);
    }
}
function isPosixPathSeparator(code) {
    return code === 47;
}
function isPathSeparator(code) {
    return isPosixPathSeparator(code) || code === 92;
}
function isWindowsDeviceRoot(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString(path4, allowAboveRoot, separator, isPathSeparator1) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i55 = 0, len = path4.length; i55 <= len; ++i55){
        if (i55 < len) code = path4.charCodeAt(i55);
        else if (isPathSeparator1(code)) break;
        else code = CHAR_FORWARD_SLASH1;
        if (isPathSeparator1(code)) {
            if (lastSlash === i55 - 1 || dots === 1) {} else if (lastSlash !== i55 - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i55;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i55;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path4.slice(lastSlash + 1, i55);
                else res = path4.slice(lastSlash + 1, i55);
                lastSegmentLength = i55 - lastSlash - 1;
            }
            lastSlash = i55;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format(sep3, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base8 = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base8;
    if (dir === pathObject.root) return dir + base8;
    return dir + sep3 + base8;
}
const WHITESPACE_ENCODINGS = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS[c] ?? c;
    });
}
const sep = "\\";
const delimiter1 = ";";
function resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i56 = pathSegments.length - 1; i56 >= -1; i56--){
        let path5;
        const { Deno  } = globalThis;
        if (i56 >= 0) {
            path5 = pathSegments[i56];
        } else if (!resolvedDevice) {
            if (typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path5 = Deno.cwd();
        } else {
            if (typeof Deno?.env?.get !== "function" || typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path5 = Deno.cwd();
            if (path5 === undefined || path5.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path5 = `${resolvedDevice}\\`;
            }
        }
        assertPath(path5);
        const len = path5.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute1 = false;
        const code = path5.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator(code)) {
                isAbsolute1 = true;
                if (isPathSeparator(path5.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator(path5.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path5.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator(path5.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator(path5.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path5.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path5.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot(code)) {
                if (path5.charCodeAt(1) === 58) {
                    device = path5.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator(path5.charCodeAt(2))) {
                            isAbsolute1 = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator(code)) {
            rootEnd = 1;
            isAbsolute1 = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path5.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute1;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize(path6) {
    assertPath(path6);
    const len = path6.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute2 = false;
    const code = path6.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            isAbsolute2 = true;
            if (isPathSeparator(path6.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path6.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path6.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path6.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path6.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path6.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path6.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path6.charCodeAt(1) === 58) {
                device = path6.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path6.charCodeAt(2))) {
                        isAbsolute2 = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString(path6.slice(rootEnd), !isAbsolute2, "\\", isPathSeparator);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute2) tail = ".";
    if (tail.length > 0 && isPathSeparator(path6.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute2) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute2) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute(path7) {
    assertPath(path7);
    const len = path7.length;
    if (len === 0) return false;
    const code = path7.charCodeAt(0);
    if (isPathSeparator(code)) {
        return true;
    } else if (isWindowsDeviceRoot(code)) {
        if (len > 2 && path7.charCodeAt(1) === 58) {
            if (isPathSeparator(path7.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join1(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i57 = 0; i57 < pathsCount; ++i57){
        const path8 = paths[i57];
        assertPath(path8);
        if (path8.length > 0) {
            if (joined === undefined) joined = firstPart = path8;
            else joined += `\\${path8}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert(firstPart != null);
    if (isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize(joined);
}
function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    const fromOrig = resolve(from);
    const toOrig = resolve(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i58 = 0;
    for(; i58 <= length; ++i58){
        if (i58 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i58) === 92) {
                    return toOrig.slice(toStart + i58 + 1);
                } else if (i58 === 2) {
                    return toOrig.slice(toStart + i58);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i58) === 92) {
                    lastCommonSep = i58;
                } else if (i58 === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i58);
        const toCode = to.charCodeAt(toStart + i58);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i58;
    }
    if (i58 !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i58 = fromStart + lastCommonSep + 1; i58 <= fromEnd; ++i58){
        if (i58 === fromEnd || from.charCodeAt(i58) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath(path9) {
    if (typeof path9 !== "string") return path9;
    if (path9.length === 0) return "";
    const resolvedPath = resolve(path9);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path9;
}
function dirname(path10) {
    assertPath(path10);
    const len = path10.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path10.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator(path10.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path10.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path10.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path10.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path10;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path10.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator(path10.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return path10;
    }
    for(let i59 = len - 1; i59 >= offset; --i59){
        if (isPathSeparator(path10.charCodeAt(i59))) {
            if (!matchedSlash) {
                end = i59;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path10.slice(0, end);
}
function basename(path11, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new ERR_INVALID_ARG_TYPE("ext", [
            "string"
        ], ext);
    }
    assertPath(path11);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i60;
    if (path11.length >= 2) {
        const drive = path11.charCodeAt(0);
        if (isWindowsDeviceRoot(drive)) {
            if (path11.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path11.length) {
        if (ext.length === path11.length && ext === path11) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i60 = path11.length - 1; i60 >= start; --i60){
            const code = path11.charCodeAt(i60);
            if (isPathSeparator(code)) {
                if (!matchedSlash) {
                    start = i60 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i60 + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i60;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path11.length;
        return path11.slice(start, end);
    } else {
        for(i60 = path11.length - 1; i60 >= start; --i60){
            if (isPathSeparator(path11.charCodeAt(i60))) {
                if (!matchedSlash) {
                    start = i60 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i60 + 1;
            }
        }
        if (end === -1) return "";
        return path11.slice(start, end);
    }
}
function extname(path12) {
    assertPath(path12);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path12.length >= 2 && path12.charCodeAt(1) === 58 && isWindowsDeviceRoot(path12.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i61 = path12.length - 1; i61 >= start; --i61){
        const code = path12.charCodeAt(i61);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i61 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i61 + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i61;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path12.slice(startDot, end);
}
function format(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new ERR_INVALID_ARG_TYPE("pathObject", [
            "Object"
        ], pathObject);
    }
    return _format("\\", pathObject);
}
function parse(path13) {
    assertPath(path13);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path13.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path13.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = 1;
            if (isPathSeparator(path13.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path13.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path13.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path13.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path13.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path13.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path13;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path13;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        ret.root = ret.dir = path13;
        return ret;
    }
    if (rootEnd > 0) ret.root = path13.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i62 = path13.length - 1;
    let preDotState = 0;
    for(; i62 >= rootEnd; --i62){
        code = path13.charCodeAt(i62);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i62 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i62 + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i62;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path13.slice(startPart, end);
        }
    } else {
        ret.name = path13.slice(startPart, startDot);
        ret.base = path13.slice(startPart, end);
        ret.ext = path13.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path13.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path14 = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path14 = `\\\\${url.hostname}${path14}`;
    }
    return path14;
}
function toFileUrl(path15) {
    if (!isAbsolute(path15)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path15.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const __default2 = {
    basename,
    delimiter: delimiter1,
    dirname,
    extname,
    format,
    fromFileUrl,
    isAbsolute,
    join: join1,
    normalize,
    parse,
    relative,
    resolve,
    sep,
    toFileUrl,
    toNamespacedPath
};
const mod1 = {
    sep: sep,
    delimiter: delimiter1,
    resolve: resolve,
    normalize: normalize,
    isAbsolute: isAbsolute,
    join: join1,
    relative: relative,
    toNamespacedPath: toNamespacedPath,
    dirname: dirname,
    basename: basename,
    extname: extname,
    format: format,
    parse: parse,
    fromFileUrl: fromFileUrl,
    toFileUrl: toFileUrl,
    default: __default2
};
const sep1 = "/";
const delimiter2 = ":";
function resolve1(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i63 = pathSegments.length - 1; i63 >= -1 && !resolvedAbsolute; i63--){
        let path16;
        if (i63 >= 0) path16 = pathSegments[i63];
        else {
            const { Deno  } = globalThis;
            if (typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path16 = Deno.cwd();
        }
        assertPath(path16);
        if (path16.length === 0) {
            continue;
        }
        resolvedPath = `${path16}/${resolvedPath}`;
        resolvedAbsolute = path16.charCodeAt(0) === CHAR_FORWARD_SLASH1;
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize1(path17) {
    assertPath(path17);
    if (path17.length === 0) return ".";
    const isAbsolute1 = path17.charCodeAt(0) === 47;
    const trailingSeparator = path17.charCodeAt(path17.length - 1) === 47;
    path17 = normalizeString(path17, !isAbsolute1, "/", isPosixPathSeparator);
    if (path17.length === 0 && !isAbsolute1) path17 = ".";
    if (path17.length > 0 && trailingSeparator) path17 += "/";
    if (isAbsolute1) return `/${path17}`;
    return path17;
}
function isAbsolute1(path18) {
    assertPath(path18);
    return path18.length > 0 && path18.charCodeAt(0) === 47;
}
function join2(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i64 = 0, len = paths.length; i64 < len; ++i64){
        const path19 = paths[i64];
        assertPath(path19);
        if (path19.length > 0) {
            if (!joined) joined = path19;
            else joined += `/${path19}`;
        }
    }
    if (!joined) return ".";
    return normalize1(joined);
}
function relative1(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    from = resolve1(from);
    to = resolve1(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i65 = 0;
    for(; i65 <= length; ++i65){
        if (i65 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i65) === 47) {
                    return to.slice(toStart + i65 + 1);
                } else if (i65 === 0) {
                    return to.slice(toStart + i65);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i65) === 47) {
                    lastCommonSep = i65;
                } else if (i65 === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i65);
        const toCode = to.charCodeAt(toStart + i65);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i65;
    }
    let out = "";
    for(i65 = fromStart + lastCommonSep + 1; i65 <= fromEnd; ++i65){
        if (i65 === fromEnd || from.charCodeAt(i65) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath1(path20) {
    return path20;
}
function dirname1(path21) {
    assertPath(path21);
    if (path21.length === 0) return ".";
    const hasRoot = path21.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i66 = path21.length - 1; i66 >= 1; --i66){
        if (path21.charCodeAt(i66) === 47) {
            if (!matchedSlash) {
                end = i66;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path21.slice(0, end);
}
function basename1(path22, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new ERR_INVALID_ARG_TYPE("ext", [
            "string"
        ], ext);
    }
    assertPath(path22);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i67;
    if (ext !== undefined && ext.length > 0 && ext.length <= path22.length) {
        if (ext.length === path22.length && ext === path22) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i67 = path22.length - 1; i67 >= 0; --i67){
            const code = path22.charCodeAt(i67);
            if (code === 47) {
                if (!matchedSlash) {
                    start = i67 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i67 + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i67;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path22.length;
        return path22.slice(start, end);
    } else {
        for(i67 = path22.length - 1; i67 >= 0; --i67){
            if (path22.charCodeAt(i67) === 47) {
                if (!matchedSlash) {
                    start = i67 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i67 + 1;
            }
        }
        if (end === -1) return "";
        return path22.slice(start, end);
    }
}
function extname1(path23) {
    assertPath(path23);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i68 = path23.length - 1; i68 >= 0; --i68){
        const code = path23.charCodeAt(i68);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i68 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i68 + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i68;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path23.slice(startDot, end);
}
function format1(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new ERR_INVALID_ARG_TYPE("pathObject", [
            "Object"
        ], pathObject);
    }
    return _format("/", pathObject);
}
function parse1(path24) {
    assertPath(path24);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path24.length === 0) return ret;
    const isAbsolute2 = path24.charCodeAt(0) === 47;
    let start;
    if (isAbsolute2) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i69 = path24.length - 1;
    let preDotState = 0;
    for(; i69 >= start; --i69){
        const code = path24.charCodeAt(i69);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i69 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i69 + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i69;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute2) {
                ret.base = ret.name = path24.slice(1, end);
            } else {
                ret.base = ret.name = path24.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute2) {
            ret.name = path24.slice(1, startDot);
            ret.base = path24.slice(1, end);
        } else {
            ret.name = path24.slice(startPart, startDot);
            ret.base = path24.slice(startPart, end);
        }
        ret.ext = path24.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path24.slice(0, startPart - 1);
    else if (isAbsolute2) ret.dir = "/";
    return ret;
}
function fromFileUrl1(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl1(path25) {
    if (!isAbsolute1(path25)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(path25.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const __default3 = {
    basename: basename1,
    delimiter: delimiter2,
    dirname: dirname1,
    extname: extname1,
    format: format1,
    fromFileUrl: fromFileUrl1,
    isAbsolute: isAbsolute1,
    join: join2,
    normalize: normalize1,
    parse: parse1,
    relative: relative1,
    resolve: resolve1,
    sep: sep1,
    toFileUrl: toFileUrl1,
    toNamespacedPath: toNamespacedPath1
};
const mod2 = {
    sep: sep1,
    delimiter: delimiter2,
    resolve: resolve1,
    normalize: normalize1,
    isAbsolute: isAbsolute1,
    join: join2,
    relative: relative1,
    toNamespacedPath: toNamespacedPath1,
    dirname: dirname1,
    basename: basename1,
    extname: extname1,
    format: format1,
    parse: parse1,
    fromFileUrl: fromFileUrl1,
    toFileUrl: toFileUrl1,
    default: __default3
};
const path = isWindows ? mod1 : mod2;
const { join: join3 , normalize: normalize2  } = path;
const path1 = isWindows ? __default2 : __default3;
const { basename: basename2 , delimiter: delimiter3 , dirname: dirname2 , extname: extname2 , format: format2 , fromFileUrl: fromFileUrl2 , isAbsolute: isAbsolute2 , join: join4 , normalize: normalize3 , parse: parse2 , relative: relative2 , resolve: resolve2 , sep: sep2 , toFileUrl: toFileUrl2 , toNamespacedPath: toNamespacedPath2 ,  } = path1;
"use strict";
const base1 = 36;
const damp1 = 700;
const delimiter4 = "-";
const regexNonASCII1 = /[^\0-\x7E]/;
const regexSeparators1 = /[\x2E\u3002\uFF0E\uFF61]/g;
const errors1 = {
    "overflow": "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
};
const baseMinusTMin1 = 36 - 1;
function error1(type) {
    throw new RangeError(errors1[type]);
}
function mapDomain1(str, fn) {
    const parts = str.split("@");
    let result = "";
    if (parts.length > 1) {
        result = parts[0] + "@";
        str = parts[1];
    }
    str = str.replace(regexSeparators1, "\x2E");
    const labels = str.split(".");
    const encoded = labels.map(fn).join(".");
    return result + encoded;
}
function ucs2decode1(str) {
    const output = [];
    let counter = 0;
    const length = str.length;
    while(counter < length){
        const value = str.charCodeAt(counter++);
        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
            const extra = str.charCodeAt(counter++);
            if ((extra & 0xFC00) == 0xDC00) {
                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
            } else {
                output.push(value);
                counter--;
            }
        } else {
            output.push(value);
        }
    }
    return output;
}
function digitToBasic1(digit, flag) {
    return digit + 22 + 75 * Number(digit < 26) - (Number(flag != 0) << 5);
}
function adapt1(delta, numPoints, firstTime) {
    let k = 0;
    delta = firstTime ? Math.floor(delta / damp1) : delta >> 1;
    delta += Math.floor(delta / numPoints);
    for(; delta > baseMinusTMin1 * 26 >> 1; k += base1){
        delta = Math.floor(delta / baseMinusTMin1);
    }
    return Math.floor(k + (baseMinusTMin1 + 1) * delta / (delta + 38));
}
function encode3(str) {
    const output = [];
    const input = ucs2decode1(str);
    const inputLength = input.length;
    let n9 = 128;
    let delta = 0;
    let bias = 72;
    for (const currentValue of input){
        if (currentValue < 0x80) {
            output.push(String.fromCharCode(currentValue));
        }
    }
    const basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) {
        output.push(delimiter4);
    }
    while(handledCPCount < inputLength){
        let m = 2147483647;
        for (const currentValue of input){
            if (currentValue >= n9 && currentValue < m) {
                m = currentValue;
            }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n9 > Math.floor((2147483647 - delta) / handledCPCountPlusOne)) {
            error1("overflow");
        }
        delta += (m - n9) * handledCPCountPlusOne;
        n9 = m;
        for (const currentValue1 of input){
            if (currentValue1 < n9 && ++delta > 2147483647) {
                error1("overflow");
            }
            if (currentValue1 == n9) {
                let q = delta;
                for(let k = 36;; k += base1){
                    const t3 = k <= bias ? 1 : k >= bias + 26 ? 26 : k - bias;
                    if (q < t3) {
                        break;
                    }
                    const qMinusT = q - t3;
                    const baseMinusT = 36 - t3;
                    output.push(String.fromCharCode(digitToBasic1(t3 + qMinusT % baseMinusT, 0)));
                    q = Math.floor(qMinusT / baseMinusT);
                }
                output.push(String.fromCharCode(digitToBasic1(q, 0)));
                bias = adapt1(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
            }
        }
        ++delta;
        ++n9;
    }
    return output.join("");
}
function toASCII1(input) {
    return mapDomain1(input, function(str) {
        return regexNonASCII1.test(str) ? "xn--" + encode3(str) : str;
    });
}
const hexTable = new Array(256);
for(let i1 = 0; i1 < 256; ++i1){
    hexTable[i1] = "%" + ((i1 < 16 ? "0" : "") + i1.toString(16)).toUpperCase();
}
new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
]);
function encodeStr(str, noEscapeTable, hexTable1) {
    const len = str.length;
    if (len === 0) return "";
    let out = "";
    let lastPos = 0;
    for(let i1 = 0; i1 < len; i1++){
        let c = str.charCodeAt(i1);
        if (c < 0x80) {
            if (noEscapeTable[c] === 1) continue;
            if (lastPos < i1) out += str.slice(lastPos, i1);
            lastPos = i1 + 1;
            out += hexTable1[c];
            continue;
        }
        if (lastPos < i1) out += str.slice(lastPos, i1);
        if (c < 0x800) {
            lastPos = i1 + 1;
            out += hexTable1[0xc0 | c >> 6] + hexTable1[0x80 | c & 0x3f];
            continue;
        }
        if (c < 0xd800 || c >= 0xe000) {
            lastPos = i1 + 1;
            out += hexTable1[0xe0 | c >> 12] + hexTable1[0x80 | c >> 6 & 0x3f] + hexTable1[0x80 | c & 0x3f];
            continue;
        }
        ++i1;
        if (i1 >= len) throw new ERR_INVALID_URI();
        const c2 = str.charCodeAt(i1) & 0x3ff;
        lastPos = i1 + 1;
        c = 0x10000 + ((c & 0x3ff) << 10 | c2);
        out += hexTable1[0xf0 | c >> 18] + hexTable1[0x80 | c >> 12 & 0x3f] + hexTable1[0x80 | c >> 6 & 0x3f] + hexTable1[0x80 | c & 0x3f];
    }
    if (lastPos === 0) return str;
    if (lastPos < len) return out + str.slice(lastPos);
    return out;
}
const decode3 = parse3;
const encode4 = stringify;
function qsEscape(str) {
    if (typeof str !== "string") {
        if (typeof str === "object") {
            str = String(str);
        } else {
            str += "";
        }
    }
    return encodeStr(str, noEscape, hexTable);
}
const escape1 = qsEscape;
const isHexTable = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
]);
function charCodes(str) {
    const ret = new Array(str.length);
    for(let i70 = 0; i70 < str.length; ++i70){
        ret[i70] = str.charCodeAt(i70);
    }
    return ret;
}
function addKeyVal(obj, key, value, keyEncoded, valEncoded, decode11) {
    if (key.length > 0 && keyEncoded) {
        key = decode11(key);
    }
    if (value.length > 0 && valEncoded) {
        value = decode11(value);
    }
    if (obj[key] === undefined) {
        obj[key] = value;
    } else {
        const curValue = obj[key];
        if (curValue.pop) {
            curValue[curValue.length] = value;
        } else {
            obj[key] = [
                curValue,
                value
            ];
        }
    }
}
function parse3(str, sep4 = "&", eq = "=", { decodeURIComponent =unescape1 , maxKeys =1000  } = {}) {
    const obj = Object.create(null);
    if (typeof str !== "string" || str.length === 0) {
        return obj;
    }
    const sepCodes = !sep4 ? [
        38
    ] : charCodes(String(sep4));
    const eqCodes = !eq ? [
        61
    ] : charCodes(String(eq));
    const sepLen = sepCodes.length;
    const eqLen = eqCodes.length;
    let pairs = 1000;
    if (typeof maxKeys === "number") {
        pairs = maxKeys > 0 ? maxKeys : -1;
    }
    let decode21 = unescape1;
    if (decodeURIComponent) {
        decode21 = decodeURIComponent;
    }
    const customDecode = decode21 !== unescape1;
    let lastPos = 0;
    let sepIdx = 0;
    let eqIdx = 0;
    let key = "";
    let value = "";
    let keyEncoded = customDecode;
    let valEncoded = customDecode;
    const plusChar = customDecode ? "%20" : " ";
    let encodeCheck = 0;
    for(let i71 = 0; i71 < str.length; ++i71){
        const code = str.charCodeAt(i71);
        if (code === sepCodes[sepIdx]) {
            if (++sepIdx === sepLen) {
                const end = i71 - sepIdx + 1;
                if (eqIdx < eqLen) {
                    if (lastPos < end) {
                        key += str.slice(lastPos, end);
                    } else if (key.length === 0) {
                        if (--pairs === 0) {
                            return obj;
                        }
                        lastPos = i71 + 1;
                        sepIdx = eqIdx = 0;
                        continue;
                    }
                } else if (lastPos < end) {
                    value += str.slice(lastPos, end);
                }
                addKeyVal(obj, key, value, keyEncoded, valEncoded, decode21);
                if (--pairs === 0) {
                    return obj;
                }
                key = value = "";
                encodeCheck = 0;
                lastPos = i71 + 1;
                sepIdx = eqIdx = 0;
            }
        } else {
            sepIdx = 0;
            if (eqIdx < eqLen) {
                if (code === eqCodes[eqIdx]) {
                    if (++eqIdx === eqLen) {
                        const end = i71 - eqIdx + 1;
                        if (lastPos < end) {
                            key += str.slice(lastPos, end);
                        }
                        encodeCheck = 0;
                        lastPos = i71 + 1;
                    }
                    continue;
                } else {
                    eqIdx = 0;
                    if (!keyEncoded) {
                        if (code === 37) {
                            encodeCheck = 1;
                            continue;
                        } else if (encodeCheck > 0) {
                            if (isHexTable[code] === 1) {
                                if (++encodeCheck === 3) {
                                    keyEncoded = true;
                                }
                                continue;
                            } else {
                                encodeCheck = 0;
                            }
                        }
                    }
                }
                if (code === 43) {
                    if (lastPos < i71) {
                        key += str.slice(lastPos, i71);
                    }
                    key += plusChar;
                    lastPos = i71 + 1;
                    continue;
                }
            }
            if (code === 43) {
                if (lastPos < i71) {
                    value += str.slice(lastPos, i71);
                }
                value += plusChar;
                lastPos = i71 + 1;
            } else if (!valEncoded) {
                if (code === 37) {
                    encodeCheck = 1;
                } else if (encodeCheck > 0) {
                    if (isHexTable[code] === 1) {
                        if (++encodeCheck === 3) {
                            valEncoded = true;
                        }
                    } else {
                        encodeCheck = 0;
                    }
                }
            }
        }
    }
    if (lastPos < str.length) {
        if (eqIdx < eqLen) {
            key += str.slice(lastPos);
        } else if (sepIdx < sepLen) {
            value += str.slice(lastPos);
        }
    } else if (eqIdx === 0 && key.length === 0) {
        return obj;
    }
    addKeyVal(obj, key, value, keyEncoded, valEncoded, decode21);
    return obj;
}
const noEscape = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
]);
function stringifyPrimitive(v) {
    if (typeof v === "string") {
        return v;
    }
    if (typeof v === "number" && isFinite(v)) {
        return "" + v;
    }
    if (typeof v === "bigint") {
        return "" + v;
    }
    if (typeof v === "boolean") {
        return v ? "true" : "false";
    }
    return "";
}
function encodeStringifiedCustom(v, encode11) {
    return encode11(stringifyPrimitive(v));
}
function encodeStringified(v, encode21) {
    if (typeof v === "string") {
        return v.length ? encode21(v) : "";
    }
    if (typeof v === "number" && isFinite(v)) {
        return Math.abs(v) < 1e21 ? "" + v : encode21("" + v);
    }
    if (typeof v === "bigint") {
        return "" + v;
    }
    if (typeof v === "boolean") {
        return v ? "true" : "false";
    }
    return "";
}
function stringify(obj, sep5, eq, options) {
    sep5 ||= "&";
    eq ||= "=";
    const encode31 = options ? options.encodeURIComponent : qsEscape;
    const convert = options ? encodeStringifiedCustom : encodeStringified;
    if (obj !== null && typeof obj === "object") {
        const keys = Object.keys(obj);
        const len = keys.length;
        let fields = "";
        for(let i72 = 0; i72 < len; ++i72){
            const k = keys[i72];
            const v = obj[k];
            let ks = convert(k, encode31);
            ks += eq;
            if (Array.isArray(v)) {
                const vlen = v.length;
                if (vlen === 0) continue;
                if (fields) {
                    fields += sep5;
                }
                for(let j = 0; j < vlen; ++j){
                    if (j) {
                        fields += sep5;
                    }
                    fields += ks;
                    fields += convert(v[j], encode31);
                }
            } else {
                if (fields) {
                    fields += sep5;
                }
                fields += ks;
                fields += convert(v, encode31);
            }
        }
        return fields;
    }
    return "";
}
const unhexTable = new Int8Array([
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    +0,
    +1,
    +2,
    +3,
    +4,
    +5,
    +6,
    +7,
    +8,
    +9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
]);
function unescapeBuffer(s4, decodeSpaces = false) {
    const out = new Buffer1(s4.length);
    let index = 0;
    let outIndex = 0;
    let currentChar;
    let nextChar;
    let hexHigh;
    let hexLow;
    const maxLength = s4.length - 2;
    let hasHex = false;
    while(index < s4.length){
        currentChar = s4.charCodeAt(index);
        if (currentChar === 43 && decodeSpaces) {
            out[outIndex++] = 32;
            index++;
            continue;
        }
        if (currentChar === 37 && index < maxLength) {
            currentChar = s4.charCodeAt(++index);
            hexHigh = unhexTable[currentChar];
            if (!(hexHigh >= 0)) {
                out[outIndex++] = 37;
                continue;
            } else {
                nextChar = s4.charCodeAt(++index);
                hexLow = unhexTable[nextChar];
                if (!(hexLow >= 0)) {
                    out[outIndex++] = 37;
                    index--;
                } else {
                    hasHex = true;
                    currentChar = hexHigh * 16 + hexLow;
                }
            }
        }
        out[outIndex++] = currentChar;
        index++;
    }
    return hasHex ? out.slice(0, outIndex) : out;
}
function qsUnescape(s5) {
    try {
        return decodeURIComponent(s5);
    } catch  {
        return unescapeBuffer(s5).toString();
    }
}
const unescape1 = qsUnescape;
const __default4 = {
    parse: parse3,
    stringify,
    decode: decode3,
    encode: encode4,
    unescape: unescape1,
    escape: escape1,
    unescapeBuffer
};
const protocolPattern = /^[a-z0-9.+-]+:/i;
const portPattern = /:[0-9]*$/;
const hostPattern = /^\/\/[^@/]+@[^@/]+/;
const simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/;
const unsafeProtocol = new Set([
    "javascript",
    "javascript:"
]);
const hostlessProtocol = new Set([
    "javascript",
    "javascript:"
]);
const slashedProtocol = new Set([
    "http",
    "http:",
    "https",
    "https:",
    "ftp",
    "ftp:",
    "gopher",
    "gopher:",
    "file",
    "file:",
    "ws",
    "ws:",
    "wss",
    "wss:", 
]);
const noEscapeAuth = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
]);
const _url = URL;
class Url {
    protocol;
    slashes;
    auth;
    host;
    port;
    hostname;
    hash;
    search;
    query;
    pathname;
    path;
    href;
    constructor(){
        this.protocol = null;
        this.slashes = null;
        this.auth = null;
        this.host = null;
        this.port = null;
        this.hostname = null;
        this.hash = null;
        this.search = null;
        this.query = null;
        this.pathname = null;
        this.path = null;
        this.href = null;
    }
    parseHost() {
        let host = this.host || "";
        let port = portPattern.exec(host);
        if (port) {
            port = port[0];
            if (port !== ":") {
                this.port = port.slice(1);
            }
            host = host.slice(0, host.length - port.length);
        }
        if (host) this.hostname = host;
    }
    resolve(relative3) {
        return this.resolveObject(parse4(relative3, false, true)).format();
    }
    resolveObject(relative4) {
        if (typeof relative4 === "string") {
            const rel = new Url();
            rel.urlParse(relative4, false, true);
            relative4 = rel;
        }
        const result = new Url();
        const tkeys = Object.keys(this);
        for(let tk = 0; tk < tkeys.length; tk++){
            const tkey = tkeys[tk];
            result[tkey] = this[tkey];
        }
        result.hash = relative4.hash;
        if (relative4.href === "") {
            result.href = result.format();
            return result;
        }
        if (relative4.slashes && !relative4.protocol) {
            const rkeys = Object.keys(relative4);
            for(let rk = 0; rk < rkeys.length; rk++){
                const rkey = rkeys[rk];
                if (rkey !== "protocol") result[rkey] = relative4[rkey];
            }
            if (result.protocol && slashedProtocol.has(result.protocol) && result.hostname && !result.pathname) {
                result.path = result.pathname = "/";
            }
            result.href = result.format();
            return result;
        }
        if (relative4.protocol && relative4.protocol !== result.protocol) {
            if (!slashedProtocol.has(relative4.protocol)) {
                const keys = Object.keys(relative4);
                for(let v = 0; v < keys.length; v++){
                    const k = keys[v];
                    result[k] = relative4[k];
                }
                result.href = result.format();
                return result;
            }
            result.protocol = relative4.protocol;
            if (!relative4.host && !/^file:?$/.test(relative4.protocol) && !hostlessProtocol.has(relative4.protocol)) {
                const relPath = (relative4.pathname || "").split("/");
                while(relPath.length && !(relative4.host = relPath.shift() || null));
                if (!relative4.host) relative4.host = "";
                if (!relative4.hostname) relative4.hostname = "";
                if (relPath[0] !== "") relPath.unshift("");
                if (relPath.length < 2) relPath.unshift("");
                result.pathname = relPath.join("/");
            } else {
                result.pathname = relative4.pathname;
            }
            result.search = relative4.search;
            result.query = relative4.query;
            result.host = relative4.host || "";
            result.auth = relative4.auth;
            result.hostname = relative4.hostname || relative4.host;
            result.port = relative4.port;
            if (result.pathname || result.search) {
                const p = result.pathname || "";
                const s6 = result.search || "";
                result.path = p + s6;
            }
            result.slashes = result.slashes || relative4.slashes;
            result.href = result.format();
            return result;
        }
        const isSourceAbs = result.pathname && result.pathname.charAt(0) === "/";
        const isRelAbs = relative4.host || relative4.pathname && relative4.pathname.charAt(0) === "/";
        let mustEndAbs = isRelAbs || isSourceAbs || result.host && relative4.pathname;
        const removeAllDots = mustEndAbs;
        let srcPath = result.pathname && result.pathname.split("/") || [];
        const relPath = relative4.pathname && relative4.pathname.split("/") || [];
        const noLeadingSlashes = result.protocol && !slashedProtocol.has(result.protocol);
        if (noLeadingSlashes) {
            result.hostname = "";
            result.port = null;
            if (result.host) {
                if (srcPath[0] === "") srcPath[0] = result.host;
                else srcPath.unshift(result.host);
            }
            result.host = "";
            if (relative4.protocol) {
                relative4.hostname = null;
                relative4.port = null;
                result.auth = null;
                if (relative4.host) {
                    if (relPath[0] === "") relPath[0] = relative4.host;
                    else relPath.unshift(relative4.host);
                }
                relative4.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
        }
        if (isRelAbs) {
            if (relative4.host || relative4.host === "") {
                if (result.host !== relative4.host) result.auth = null;
                result.host = relative4.host;
                result.port = relative4.port;
            }
            if (relative4.hostname || relative4.hostname === "") {
                if (result.hostname !== relative4.hostname) result.auth = null;
                result.hostname = relative4.hostname;
            }
            result.search = relative4.search;
            result.query = relative4.query;
            srcPath = relPath;
        } else if (relPath.length) {
            if (!srcPath) srcPath = [];
            srcPath.pop();
            srcPath = srcPath.concat(relPath);
            result.search = relative4.search;
            result.query = relative4.query;
        } else if (relative4.search !== null && relative4.search !== undefined) {
            if (noLeadingSlashes) {
                result.hostname = result.host = srcPath.shift() || null;
                const authInHost = result.host && result.host.indexOf("@") > 0 && result.host.split("@");
                if (authInHost) {
                    result.auth = authInHost.shift() || null;
                    result.host = result.hostname = authInHost.shift() || null;
                }
            }
            result.search = relative4.search;
            result.query = relative4.query;
            if (result.pathname !== null || result.search !== null) {
                result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
            }
            result.href = result.format();
            return result;
        }
        if (!srcPath.length) {
            result.pathname = null;
            if (result.search) {
                result.path = "/" + result.search;
            } else {
                result.path = null;
            }
            result.href = result.format();
            return result;
        }
        let last = srcPath.slice(-1)[0];
        const hasTrailingSlash = (result.host || relative4.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
        let up = 0;
        for(let i73 = srcPath.length - 1; i73 >= 0; i73--){
            last = srcPath[i73];
            if (last === ".") {
                srcPath.splice(i73, 1);
            } else if (last === "..") {
                srcPath.splice(i73, 1);
                up++;
            } else if (up) {
                srcPath.splice(i73, 1);
                up--;
            }
        }
        if (!mustEndAbs && !removeAllDots) {
            while(up--){
                srcPath.unshift("..");
            }
        }
        if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
            srcPath.unshift("");
        }
        if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
            srcPath.push("");
        }
        const isAbsolute3 = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
        if (noLeadingSlashes) {
            result.hostname = result.host = isAbsolute3 ? "" : srcPath.length ? srcPath.shift() || null : "";
            const authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
            if (authInHost) {
                result.auth = authInHost.shift() || null;
                result.host = result.hostname = authInHost.shift() || null;
            }
        }
        mustEndAbs = mustEndAbs || result.host && srcPath.length;
        if (mustEndAbs && !isAbsolute3) {
            srcPath.unshift("");
        }
        if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
        } else {
            result.pathname = srcPath.join("/");
        }
        if (result.pathname !== null || result.search !== null) {
            result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.auth = relative4.auth || result.auth;
        result.slashes = result.slashes || relative4.slashes;
        result.href = result.format();
        return result;
    }
    format() {
        let auth = this.auth || "";
        if (auth) {
            auth = encodeStr(auth, noEscapeAuth, hexTable);
            auth += "@";
        }
        let protocol = this.protocol || "";
        let pathname = this.pathname || "";
        let hash = this.hash || "";
        let host = "";
        let query = "";
        if (this.host) {
            host = auth + this.host;
        } else if (this.hostname) {
            host = auth + (this.hostname.includes(":") && !isIpv6Hostname(this.hostname) ? "[" + this.hostname + "]" : this.hostname);
            if (this.port) {
                host += ":" + this.port;
            }
        }
        if (this.query !== null && typeof this.query === "object") {
            query = __default4.stringify(this.query);
        }
        let search = this.search || query && "?" + query || "";
        if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58) {
            protocol += ":";
        }
        let newPathname = "";
        let lastPos = 0;
        for(let i74 = 0; i74 < pathname.length; ++i74){
            switch(pathname.charCodeAt(i74)){
                case 35:
                    if (i74 - lastPos > 0) {
                        newPathname += pathname.slice(lastPos, i74);
                    }
                    newPathname += "%23";
                    lastPos = i74 + 1;
                    break;
                case 63:
                    if (i74 - lastPos > 0) {
                        newPathname += pathname.slice(lastPos, i74);
                    }
                    newPathname += "%3F";
                    lastPos = i74 + 1;
                    break;
            }
        }
        if (lastPos > 0) {
            if (lastPos !== pathname.length) {
                pathname = newPathname + pathname.slice(lastPos);
            } else pathname = newPathname;
        }
        if (this.slashes || slashedProtocol.has(protocol)) {
            if (this.slashes || host) {
                if (pathname && pathname.charCodeAt(0) !== 47) {
                    pathname = "/" + pathname;
                }
                host = "//" + host;
            } else if (protocol.length >= 4 && protocol.charCodeAt(0) === 102 && protocol.charCodeAt(1) === 105 && protocol.charCodeAt(2) === 108 && protocol.charCodeAt(3) === 101) {
                host = "//";
            }
        }
        search = search.replace(/#/g, "%23");
        if (hash && hash.charCodeAt(0) !== 35) {
            hash = "#" + hash;
        }
        if (search && search.charCodeAt(0) !== 63) {
            search = "?" + search;
        }
        return protocol + host + pathname + search + hash;
    }
    urlParse(url, parseQueryString, slashesDenoteHost) {
        let hasHash = false;
        let start = -1;
        let end = -1;
        let rest = "";
        let lastPos = 0;
        for(let i75 = 0, inWs = false, split = false; i75 < url.length; ++i75){
            const code = url.charCodeAt(i75);
            const isWs = code === 32 || code === 9 || code === 13 || code === 10 || code === 12 || code === 160 || code === 65279;
            if (start === -1) {
                if (isWs) continue;
                lastPos = start = i75;
            } else if (inWs) {
                if (!isWs) {
                    end = -1;
                    inWs = false;
                }
            } else if (isWs) {
                end = i75;
                inWs = true;
            }
            if (!split) {
                switch(code){
                    case 35:
                        hasHash = true;
                    case 63:
                        split = true;
                        break;
                    case 92:
                        if (i75 - lastPos > 0) rest += url.slice(lastPos, i75);
                        rest += "/";
                        lastPos = i75 + 1;
                        break;
                }
            } else if (!hasHash && code === 35) {
                hasHash = true;
            }
        }
        if (start !== -1) {
            if (lastPos === start) {
                if (end === -1) {
                    if (start === 0) rest = url;
                    else rest = url.slice(start);
                } else {
                    rest = url.slice(start, end);
                }
            } else if (end === -1 && lastPos < url.length) {
                rest += url.slice(lastPos);
            } else if (end !== -1 && lastPos < end) {
                rest += url.slice(lastPos, end);
            }
        }
        if (!slashesDenoteHost && !hasHash) {
            const simplePath = simplePathPattern.exec(rest);
            if (simplePath) {
                this.path = rest;
                this.href = rest;
                this.pathname = simplePath[1];
                if (simplePath[2]) {
                    this.search = simplePath[2];
                    if (parseQueryString) {
                        this.query = __default4.parse(this.search.slice(1));
                    } else {
                        this.query = this.search.slice(1);
                    }
                } else if (parseQueryString) {
                    this.search = null;
                    this.query = Object.create(null);
                }
                return this;
            }
        }
        let proto = protocolPattern.exec(rest);
        let lowerProto = "";
        if (proto) {
            proto = proto[0];
            lowerProto = proto.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.slice(proto.length);
        }
        let slashes;
        if (slashesDenoteHost || proto || hostPattern.test(rest)) {
            slashes = rest.charCodeAt(0) === CHAR_FORWARD_SLASH && rest.charCodeAt(1) === CHAR_FORWARD_SLASH;
            if (slashes && !(proto && hostlessProtocol.has(lowerProto))) {
                rest = rest.slice(2);
                this.slashes = true;
            }
        }
        if (!hostlessProtocol.has(lowerProto) && (slashes || proto && !slashedProtocol.has(proto))) {
            let hostEnd = -1;
            let atSign = -1;
            let nonHost = -1;
            for(let i76 = 0; i76 < rest.length; ++i76){
                switch(rest.charCodeAt(i76)){
                    case 9:
                    case 10:
                    case 13:
                    case 32:
                    case 34:
                    case 37:
                    case 39:
                    case 59:
                    case 60:
                    case 62:
                    case 92:
                    case 94:
                    case 96:
                    case 123:
                    case 124:
                    case 125:
                        if (nonHost === -1) nonHost = i76;
                        break;
                    case 35:
                    case 47:
                    case 63:
                        if (nonHost === -1) nonHost = i76;
                        hostEnd = i76;
                        break;
                    case 64:
                        atSign = i76;
                        nonHost = -1;
                        break;
                }
                if (hostEnd !== -1) break;
            }
            start = 0;
            if (atSign !== -1) {
                this.auth = decodeURIComponent(rest.slice(0, atSign));
                start = atSign + 1;
            }
            if (nonHost === -1) {
                this.host = rest.slice(start);
                rest = "";
            } else {
                this.host = rest.slice(start, nonHost);
                rest = rest.slice(nonHost);
            }
            this.parseHost();
            if (typeof this.hostname !== "string") this.hostname = "";
            const hostname = this.hostname;
            const ipv6Hostname = isIpv6Hostname(hostname);
            if (!ipv6Hostname) {
                rest = getHostname(this, rest, hostname);
            }
            if (this.hostname.length > 255) {
                this.hostname = "";
            } else {
                this.hostname = this.hostname.toLowerCase();
            }
            if (!ipv6Hostname) {
                this.hostname = toASCII1(this.hostname);
            }
            const p = this.port ? ":" + this.port : "";
            const h = this.hostname || "";
            this.host = h + p;
            if (ipv6Hostname) {
                this.hostname = this.hostname.slice(1, -1);
                if (rest[0] !== "/") {
                    rest = "/" + rest;
                }
            }
        }
        if (!unsafeProtocol.has(lowerProto)) {
            rest = autoEscapeStr(rest);
        }
        let questionIdx = -1;
        let hashIdx = -1;
        for(let i1 = 0; i1 < rest.length; ++i1){
            const code = rest.charCodeAt(i1);
            if (code === 35) {
                this.hash = rest.slice(i1);
                hashIdx = i1;
                break;
            } else if (code === 63 && questionIdx === -1) {
                questionIdx = i1;
            }
        }
        if (questionIdx !== -1) {
            if (hashIdx === -1) {
                this.search = rest.slice(questionIdx);
                this.query = rest.slice(questionIdx + 1);
            } else {
                this.search = rest.slice(questionIdx, hashIdx);
                this.query = rest.slice(questionIdx + 1, hashIdx);
            }
            if (parseQueryString) {
                this.query = __default4.parse(this.query);
            }
        } else if (parseQueryString) {
            this.search = null;
            this.query = Object.create(null);
        }
        const useQuestionIdx = questionIdx !== -1 && (hashIdx === -1 || questionIdx < hashIdx);
        const firstIdx = useQuestionIdx ? questionIdx : hashIdx;
        if (firstIdx === -1) {
            if (rest.length > 0) this.pathname = rest;
        } else if (firstIdx > 0) {
            this.pathname = rest.slice(0, firstIdx);
        }
        if (slashedProtocol.has(lowerProto) && this.hostname && !this.pathname) {
            this.pathname = "/";
        }
        if (this.pathname || this.search) {
            const p = this.pathname || "";
            const s7 = this.search || "";
            this.path = p + s7;
        }
        this.href = this.format();
        return this;
    }
}
function isIpv6Hostname(hostname) {
    return hostname.charCodeAt(0) === 91 && hostname.charCodeAt(hostname.length - 1) === 93;
}
function getHostname(self, rest, hostname) {
    for(let i77 = 0; i77 < hostname.length; ++i77){
        const code = hostname.charCodeAt(i77);
        const isValid = code >= 97 && code <= 122 || code === 46 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 43 || code === 95 || code > 127;
        if (!isValid) {
            self.hostname = hostname.slice(0, i77);
            return `/${hostname.slice(i77)}${rest}`;
        }
    }
    return rest;
}
const escapedCodes = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%09",
    "%0A",
    "",
    "",
    "%0D",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%20",
    "",
    "%22",
    "",
    "",
    "",
    "",
    "%27",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%3C",
    "",
    "%3E",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%5C",
    "",
    "%5E",
    "",
    "%60",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%7B",
    "%7C",
    "%7D"
];
function autoEscapeStr(rest) {
    let escaped = "";
    let lastEscapedPos = 0;
    for(let i78 = 0; i78 < rest.length; ++i78){
        const escapedChar = escapedCodes[rest.charCodeAt(i78)];
        if (escapedChar) {
            if (i78 > lastEscapedPos) {
                escaped += rest.slice(lastEscapedPos, i78);
            }
            escaped += escapedChar;
            lastEscapedPos = i78 + 1;
        }
    }
    if (lastEscapedPos === 0) {
        return rest;
    }
    if (lastEscapedPos < rest.length) {
        escaped += rest.slice(lastEscapedPos);
    }
    return escaped;
}
function parse4(url, parseQueryString, slashesDenoteHost) {
    if (url instanceof Url) return url;
    const urlObject = new Url();
    urlObject.urlParse(url, parseQueryString, slashesDenoteHost);
    return urlObject;
}
function a(a1, o1) {
    let i1 = 0, e1 = a1.length, s2 = !1;
    if (!1 === o1) {
        if (!0 === a1.startsWith("data:")) return null;
        for(; i1 < a1.length && a1.charCodeAt(i1) <= 32;)i1 += 1;
        for(; e1 > i1 + 1 && a1.charCodeAt(e1 - 1) <= 32;)e1 -= 1;
        if (47 === a1.charCodeAt(i1) && 47 === a1.charCodeAt(i1 + 1)) i1 += 2;
        else {
            const o2 = a1.indexOf(":/", i1);
            if (-1 !== o2) {
                const e3 = o2 - i1, s1 = a1.charCodeAt(i1), n1 = a1.charCodeAt(i1 + 1), r1 = a1.charCodeAt(i1 + 2), t1 = a1.charCodeAt(i1 + 3), c1 = a1.charCodeAt(i1 + 4);
                if (5 === e3 && 104 === s1 && 116 === n1 && 116 === r1 && 112 === t1 && 115 === c1) ;
                else if (4 === e3 && 104 === s1 && 116 === n1 && 116 === r1 && 112 === t1) ;
                else if (3 === e3 && 119 === s1 && 115 === n1 && 115 === r1) ;
                else if (2 === e3 && 119 === s1 && 115 === n1) ;
                else for(let e2 = i1; e2 < o2; e2 += 1){
                    const o3 = 32 | a1.charCodeAt(e2);
                    if (!1 == (o3 >= 97 && o3 <= 122 || o3 >= 48 && o3 <= 57 || 46 === o3 || 45 === o3 || 43 === o3)) return null;
                }
                for(i1 = o2 + 2; 47 === a1.charCodeAt(i1);)i1 += 1;
            }
        }
        let o4 = -1, n2 = -1, r2 = -1;
        for(let t2 = i1; t2 < e1; t2 += 1){
            const i2 = a1.charCodeAt(t2);
            if (35 === i2 || 47 === i2 || 63 === i2) {
                e1 = t2;
                break;
            }
            64 === i2 ? o4 = t2 : 93 === i2 ? n2 = t2 : 58 === i2 ? r2 = t2 : i2 >= 65 && i2 <= 90 && (s2 = !0);
        }
        if (-1 !== o4 && o4 > i1 && o4 < e1 && (i1 = o4 + 1), 91 === a1.charCodeAt(i1)) return -1 !== n2 ? a1.slice(i1 + 1, n2).toLowerCase() : null;
        -1 !== r2 && r2 > i1 && r2 < e1 && (e1 = r2);
    }
    for(; e1 > i1 + 1 && 46 === a1.charCodeAt(e1 - 1);)e1 -= 1;
    const n3 = 0 !== i1 || e1 !== a1.length ? a1.slice(i1, e1) : a1;
    return s2 ? n3.toLowerCase() : n3;
}
function o(a2) {
    if (a2.length > 255) return !1;
    if (0 === a2.length) return !1;
    if (!1 == ((o6 = a2.charCodeAt(0)) >= 97 && o6 <= 122 || o6 >= 48 && o6 <= 57 || o6 > 127)) return !1;
    var o6;
    let i3 = -1, e4 = -1;
    const s3 = a2.length;
    for(let o5 = 0; o5 < s3; o5 += 1){
        const s4 = a2.charCodeAt(o5);
        if (46 === s4) {
            if (o5 - i3 > 64 || 46 === e4 || 45 === e4 || 95 === e4) return !1;
            i3 = o5;
        } else if (!1 === (function(a3) {
            return a3 >= 97 && a3 <= 122 || a3 >= 48 && a3 <= 57 || a3 > 127;
        }(s4) || 45 === s4 || 95 === s4)) return !1;
        e4 = s4;
    }
    return s3 - i3 - 1 <= 63 && 45 !== e4;
}
const i2 = function({ allowIcannDomains: a4 = !0 , allowPrivateDomains: o7 = !1 , detectIp: i4 = !0 , extractHostname: e5 = !0 , mixedInputs: s5 = !0 , validHosts: n4 = null , validateHostname: r3 = !0  }) {
    return {
        allowIcannDomains: a4,
        allowPrivateDomains: o7,
        detectIp: i4,
        extractHostname: e5,
        mixedInputs: s5,
        validHosts: n4,
        validateHostname: r3
    };
}({});
function e(e6, s6, n5, r4, t3) {
    const c2 = function(a5) {
        return void 0 === a5 ? i2 : function({ allowIcannDomains: a6 = !0 , allowPrivateDomains: o8 = !1 , detectIp: i5 = !0 , extractHostname: e7 = !0 , mixedInputs: s7 = !0 , validHosts: n6 = null , validateHostname: r5 = !0  }) {
            return {
                allowIcannDomains: a6,
                allowPrivateDomains: o8,
                detectIp: i5,
                extractHostname: e7,
                mixedInputs: s7,
                validHosts: n6,
                validateHostname: r5
            };
        }(a5);
    }(r4);
    return "string" != typeof e6 ? t3 : (!1 === c2.extractHostname ? t3.hostname = e6 : !0 === c2.mixedInputs ? t3.hostname = a(e6, o(e6)) : t3.hostname = a(e6, !1), 0 === s6 || null === t3.hostname || !0 === c2.detectIp && (t3.isIp = function(a7) {
        if (a7.length < 3) return !1;
        let o9 = "[" === a7[0] ? 1 : 0, i6 = a7.length;
        if ("]" === a7[i6 - 1] && (i6 -= 1), i6 - o9 > 39) return !1;
        let e8 = !1;
        for(; o9 < i6; o9 += 1){
            const i7 = a7.charCodeAt(o9);
            if (58 === i7) e8 = !0;
            else if (0 == (i7 >= 48 && i7 <= 57 || i7 >= 97 && i7 <= 102 || i7 >= 65 && i7 <= 90)) return !1;
        }
        return e8;
    }(u1 = t3.hostname) || function(a8) {
        if (a8.length < 7) return !1;
        if (a8.length > 15) return !1;
        let o10 = 0;
        for(let i8 = 0; i8 < a8.length; i8 += 1){
            const e9 = a8.charCodeAt(i8);
            if (46 === e9) o10 += 1;
            else if (e9 < 48 || e9 > 57) return !1;
        }
        return 3 === o10 && 46 !== a8.charCodeAt(0) && 46 !== a8.charCodeAt(a8.length - 1);
    }(u1), !0 === t3.isIp) ? t3 : !0 === c2.validateHostname && !0 === c2.extractHostname && !1 === o(t3.hostname) ? (t3.hostname = null, t3) : (n5(t3.hostname, c2, t3), 2 === s6 || null === t3.publicSuffix ? t3 : (t3.domain = function(a10, o11, i9) {
        if (null !== i9.validHosts) {
            const a9 = i9.validHosts;
            for(let i10 = 0; i10 < a9.length; i10 += 1){
                const e10 = a9[i10];
                if (!0 === function(a11, o12) {
                    return !!a11.endsWith(o12) && (a11.length === o12.length || "." === a11[a11.length - o12.length - 1]);
                }(o11, e10)) return e10;
            }
        }
        return a10.length === o11.length ? null : function(a12, o13) {
            const i11 = a12.length - o13.length - 2, e11 = a12.lastIndexOf(".", i11);
            return -1 === e11 ? a12 : a12.slice(e11 + 1);
        }(o11, a10);
    }(t3.publicSuffix, t3.hostname, c2), 3 === s6 || null === t3.domain ? t3 : (t3.subdomain = function(a13, o14) {
        return o14.length === a13.length ? "" : a13.slice(0, -o14.length - 1);
    }(t3.hostname, t3.domain), 4 === s6 || (t3.domainWithoutSuffix = (l1 = t3.domain, m1 = t3.publicSuffix, l1.slice(0, -m1.length - 1))), t3))));
    var u1, l1, m1;
}
const s = function() {
    const a14 = {
        $: 1,
        succ: {}
    }, o15 = {
        $: 0,
        succ: {
            city: a14
        }
    };
    return {
        $: 0,
        succ: {
            ck: {
                $: 0,
                succ: {
                    www: a14
                }
            },
            jp: {
                $: 0,
                succ: {
                    kawasaki: o15,
                    kitakyushu: o15,
                    kobe: o15,
                    nagoya: o15,
                    sapporo: o15,
                    sendai: o15,
                    yokohama: o15
                }
            }
        }
    };
}(), n = function() {
    const a15 = {
        $: 1,
        succ: {}
    }, o16 = {
        $: 2,
        succ: {}
    }, i12 = {
        $: 1,
        succ: {
            gov: a15,
            com: a15,
            org: a15,
            net: a15,
            edu: a15
        }
    }, e12 = {
        $: 0,
        succ: {
            "*": o16
        }
    }, s8 = {
        $: 1,
        succ: {
            blogspot: o16
        }
    }, n7 = {
        $: 1,
        succ: {
            gov: a15
        }
    }, r6 = {
        $: 0,
        succ: {
            "*": a15
        }
    }, t4 = {
        $: 0,
        succ: {
            cloud: o16
        }
    }, c3 = {
        $: 1,
        succ: {
            co: o16
        }
    }, u2 = {
        $: 2,
        succ: {
            nodes: o16
        }
    }, l2 = {
        $: 0,
        succ: {
            s3: o16
        }
    }, m2 = {
        $: 0,
        succ: {
            direct: o16
        }
    }, d1 = {
        $: 0,
        succ: {
            dualstack: l2
        }
    }, g1 = {
        $: 0,
        succ: {
            s3: o16,
            dualstack: l2,
            "s3-website": o16
        }
    }, h1 = {
        $: 0,
        succ: {
            apps: o16
        }
    }, k = {
        $: 0,
        succ: {
            paas: o16
        }
    }, b = {
        $: 0,
        succ: {
            app: o16
        }
    }, p = {
        $: 2,
        succ: {
            eu: o16
        }
    }, y = {
        $: 0,
        succ: {
            site: o16
        }
    }, f = {
        $: 0,
        succ: {
            pages: o16
        }
    }, v = {
        $: 1,
        succ: {
            com: a15,
            edu: a15,
            net: a15,
            org: a15
        }
    }, x = {
        $: 0,
        succ: {
            j: o16
        }
    }, w = {
        $: 0,
        succ: {
            jelastic: o16
        }
    }, $ = {
        $: 0,
        succ: {
            user: o16
        }
    }, z = {
        $: 1,
        succ: {
            ybo: o16
        }
    }, j = {
        $: 0,
        succ: {
            cust: o16,
            reservd: o16
        }
    }, q = {
        $: 0,
        succ: {
            cust: o16
        }
    }, I = {
        $: 1,
        succ: {
            gov: a15,
            edu: a15,
            mil: a15,
            com: a15,
            org: a15,
            net: a15
        }
    }, S = {
        $: 1,
        succ: {
            edu: a15,
            biz: a15,
            net: a15,
            org: a15,
            gov: a15,
            info: a15,
            com: a15
        }
    }, C = {
        $: 1,
        succ: {
            gov: a15,
            blogspot: o16
        }
    }, P = {
        $: 1,
        succ: {
            barsy: o16
        }
    }, A = {
        $: 0,
        succ: {
            forgot: o16
        }
    }, H = {
        $: 1,
        succ: {
            gs: a15
        }
    }, D = {
        $: 0,
        succ: {
            nes: a15
        }
    }, W = {
        $: 1,
        succ: {
            k12: a15,
            cc: a15,
            lib: a15
        }
    }, L = {
        $: 1,
        succ: {
            cc: a15,
            lib: a15
        }
    };
    return {
        $: 0,
        succ: {
            ac: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    gov: a15,
                    net: a15,
                    mil: a15,
                    org: a15,
                    drr: o16
                }
            },
            ad: {
                $: 1,
                succ: {
                    nom: a15
                }
            },
            ae: {
                $: 1,
                succ: {
                    co: a15,
                    net: a15,
                    org: a15,
                    sch: a15,
                    ac: a15,
                    gov: a15,
                    mil: a15,
                    blogspot: o16
                }
            },
            aero: {
                $: 1,
                succ: {
                    "accident-investigation": a15,
                    "accident-prevention": a15,
                    aerobatic: a15,
                    aeroclub: a15,
                    aerodrome: a15,
                    agents: a15,
                    aircraft: a15,
                    airline: a15,
                    airport: a15,
                    "air-surveillance": a15,
                    airtraffic: a15,
                    "air-traffic-control": a15,
                    ambulance: a15,
                    amusement: a15,
                    association: a15,
                    author: a15,
                    ballooning: a15,
                    broker: a15,
                    caa: a15,
                    cargo: a15,
                    catering: a15,
                    certification: a15,
                    championship: a15,
                    charter: a15,
                    civilaviation: a15,
                    club: a15,
                    conference: a15,
                    consultant: a15,
                    consulting: a15,
                    control: a15,
                    council: a15,
                    crew: a15,
                    design: a15,
                    dgca: a15,
                    educator: a15,
                    emergency: a15,
                    engine: a15,
                    engineer: a15,
                    entertainment: a15,
                    equipment: a15,
                    exchange: a15,
                    express: a15,
                    federation: a15,
                    flight: a15,
                    fuel: a15,
                    gliding: a15,
                    government: a15,
                    groundhandling: a15,
                    group: a15,
                    hanggliding: a15,
                    homebuilt: a15,
                    insurance: a15,
                    journal: a15,
                    journalist: a15,
                    leasing: a15,
                    logistics: a15,
                    magazine: a15,
                    maintenance: a15,
                    media: a15,
                    microlight: a15,
                    modelling: a15,
                    navigation: a15,
                    parachuting: a15,
                    paragliding: a15,
                    "passenger-association": a15,
                    pilot: a15,
                    press: a15,
                    production: a15,
                    recreation: a15,
                    repbody: a15,
                    res: a15,
                    research: a15,
                    rotorcraft: a15,
                    safety: a15,
                    scientist: a15,
                    services: a15,
                    show: a15,
                    skydiving: a15,
                    software: a15,
                    student: a15,
                    trader: a15,
                    trading: a15,
                    trainer: a15,
                    union: a15,
                    workinggroup: a15,
                    works: a15
                }
            },
            af: i12,
            ag: {
                $: 1,
                succ: {
                    com: a15,
                    org: a15,
                    net: a15,
                    co: a15,
                    nom: a15
                }
            },
            ai: {
                $: 1,
                succ: {
                    off: a15,
                    com: a15,
                    net: a15,
                    org: a15,
                    uwu: o16
                }
            },
            al: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    gov: a15,
                    mil: a15,
                    net: a15,
                    org: a15,
                    blogspot: o16
                }
            },
            am: {
                $: 1,
                succ: {
                    co: a15,
                    com: a15,
                    commune: a15,
                    net: a15,
                    org: a15,
                    radio: o16,
                    blogspot: o16,
                    neko: o16,
                    nyaa: o16
                }
            },
            ao: {
                $: 1,
                succ: {
                    ed: a15,
                    gv: a15,
                    og: a15,
                    co: a15,
                    pb: a15,
                    it: a15
                }
            },
            aq: a15,
            ar: {
                $: 1,
                succ: {
                    bet: a15,
                    com: s8,
                    coop: a15,
                    edu: a15,
                    gob: a15,
                    gov: a15,
                    int: a15,
                    mil: a15,
                    musica: a15,
                    mutual: a15,
                    net: a15,
                    org: a15,
                    senasa: a15,
                    tur: a15
                }
            },
            arpa: {
                $: 1,
                succ: {
                    e164: a15,
                    "in-addr": a15,
                    ip6: a15,
                    iris: a15,
                    uri: a15,
                    urn: a15
                }
            },
            as: n7,
            asia: {
                $: 1,
                succ: {
                    cloudns: o16
                }
            },
            at: {
                $: 1,
                succ: {
                    ac: {
                        $: 1,
                        succ: {
                            sth: a15
                        }
                    },
                    co: s8,
                    gv: a15,
                    or: a15,
                    funkfeuer: {
                        $: 0,
                        succ: {
                            wien: o16
                        }
                    },
                    futurecms: {
                        $: 0,
                        succ: {
                            "*": o16,
                            ex: e12,
                            in: e12
                        }
                    },
                    futurehosting: o16,
                    futuremailing: o16,
                    ortsinfo: {
                        $: 0,
                        succ: {
                            ex: e12,
                            kunden: e12
                        }
                    },
                    biz: o16,
                    info: o16,
                    priv: o16,
                    myspreadshop: o16,
                    "12hp": o16,
                    "2ix": o16,
                    "4lima": o16,
                    "lima-city": o16
                }
            },
            au: {
                $: 1,
                succ: {
                    com: {
                        $: 1,
                        succ: {
                            blogspot: o16,
                            cloudlets: {
                                $: 0,
                                succ: {
                                    mel: o16
                                }
                            },
                            myspreadshop: o16
                        }
                    },
                    net: a15,
                    org: a15,
                    edu: {
                        $: 1,
                        succ: {
                            act: a15,
                            catholic: a15,
                            nsw: {
                                $: 1,
                                succ: {
                                    schools: a15
                                }
                            },
                            nt: a15,
                            qld: a15,
                            sa: a15,
                            tas: a15,
                            vic: a15,
                            wa: a15
                        }
                    },
                    gov: {
                        $: 1,
                        succ: {
                            qld: a15,
                            sa: a15,
                            tas: a15,
                            vic: a15,
                            wa: a15
                        }
                    },
                    asn: a15,
                    id: a15,
                    info: a15,
                    conf: a15,
                    oz: a15,
                    act: a15,
                    nsw: a15,
                    nt: a15,
                    qld: a15,
                    sa: a15,
                    tas: a15,
                    vic: a15,
                    wa: a15
                }
            },
            aw: {
                $: 1,
                succ: {
                    com: a15
                }
            },
            ax: {
                $: 1,
                succ: {
                    be: o16,
                    cat: o16,
                    es: o16,
                    eu: o16,
                    gg: o16,
                    mc: o16,
                    us: o16,
                    xy: o16
                }
            },
            az: {
                $: 1,
                succ: {
                    com: a15,
                    net: a15,
                    int: a15,
                    gov: a15,
                    org: a15,
                    edu: a15,
                    info: a15,
                    pp: a15,
                    mil: a15,
                    name: a15,
                    pro: a15,
                    biz: a15
                }
            },
            ba: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    gov: a15,
                    mil: a15,
                    net: a15,
                    org: a15,
                    rs: o16,
                    blogspot: o16
                }
            },
            bb: {
                $: 1,
                succ: {
                    biz: a15,
                    co: a15,
                    com: a15,
                    edu: a15,
                    gov: a15,
                    info: a15,
                    net: a15,
                    org: a15,
                    store: a15,
                    tv: a15
                }
            },
            bd: r6,
            be: {
                $: 1,
                succ: {
                    ac: a15,
                    webhosting: o16,
                    blogspot: o16,
                    interhostsolutions: t4,
                    kuleuven: {
                        $: 0,
                        succ: {
                            ezproxy: o16
                        }
                    },
                    myspreadshop: o16,
                    transurl: e12
                }
            },
            bf: n7,
            bg: {
                $: 1,
                succ: {
                    0: a15,
                    1: a15,
                    2: a15,
                    3: a15,
                    4: a15,
                    5: a15,
                    6: a15,
                    7: a15,
                    8: a15,
                    9: a15,
                    a: a15,
                    b: a15,
                    c: a15,
                    d: a15,
                    e: a15,
                    f: a15,
                    g: a15,
                    h: a15,
                    i: a15,
                    j: a15,
                    k: a15,
                    l: a15,
                    m: a15,
                    n: a15,
                    o: a15,
                    p: a15,
                    q: a15,
                    r: a15,
                    s: a15,
                    t: a15,
                    u: a15,
                    v: a15,
                    w: a15,
                    x: a15,
                    y: a15,
                    z: a15,
                    blogspot: o16,
                    barsy: o16
                }
            },
            bh: i12,
            bi: {
                $: 1,
                succ: {
                    co: a15,
                    com: a15,
                    edu: a15,
                    or: a15,
                    org: a15
                }
            },
            biz: {
                $: 1,
                succ: {
                    cloudns: o16,
                    jozi: o16,
                    dyndns: o16,
                    "for-better": o16,
                    "for-more": o16,
                    "for-some": o16,
                    "for-the": o16,
                    selfip: o16,
                    webhop: o16,
                    orx: o16,
                    mmafan: o16,
                    myftp: o16,
                    "no-ip": o16,
                    dscloud: o16
                }
            },
            bj: {
                $: 1,
                succ: {
                    asso: a15,
                    barreau: a15,
                    gouv: a15,
                    blogspot: o16
                }
            },
            bm: i12,
            bn: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    gov: a15,
                    net: a15,
                    org: a15,
                    co: o16
                }
            },
            bo: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    gob: a15,
                    int: a15,
                    org: a15,
                    net: a15,
                    mil: a15,
                    tv: a15,
                    web: a15,
                    academia: a15,
                    agro: a15,
                    arte: a15,
                    blog: a15,
                    bolivia: a15,
                    ciencia: a15,
                    cooperativa: a15,
                    democracia: a15,
                    deporte: a15,
                    ecologia: a15,
                    economia: a15,
                    empresa: a15,
                    indigena: a15,
                    industria: a15,
                    info: a15,
                    medicina: a15,
                    movimiento: a15,
                    musica: a15,
                    natural: a15,
                    nombre: a15,
                    noticias: a15,
                    patria: a15,
                    politica: a15,
                    profesional: a15,
                    plurinacional: a15,
                    pueblo: a15,
                    revista: a15,
                    salud: a15,
                    tecnologia: a15,
                    tksat: a15,
                    transporte: a15,
                    wiki: a15
                }
            },
            br: {
                $: 1,
                succ: {
                    "9guacu": a15,
                    abc: a15,
                    adm: a15,
                    adv: a15,
                    agr: a15,
                    aju: a15,
                    am: a15,
                    anani: a15,
                    aparecida: a15,
                    app: a15,
                    arq: a15,
                    art: a15,
                    ato: a15,
                    b: a15,
                    barueri: a15,
                    belem: a15,
                    bhz: a15,
                    bib: a15,
                    bio: a15,
                    blog: a15,
                    bmd: a15,
                    boavista: a15,
                    bsb: a15,
                    campinagrande: a15,
                    campinas: a15,
                    caxias: a15,
                    cim: a15,
                    cng: a15,
                    cnt: a15,
                    com: {
                        $: 1,
                        succ: {
                            blogspot: o16,
                            virtualcloud: {
                                $: 0,
                                succ: {
                                    scale: {
                                        $: 0,
                                        succ: {
                                            users: o16
                                        }
                                    }
                                }
                            }
                        }
                    },
                    contagem: a15,
                    coop: a15,
                    coz: a15,
                    cri: a15,
                    cuiaba: a15,
                    curitiba: a15,
                    def: a15,
                    des: a15,
                    det: a15,
                    dev: a15,
                    ecn: a15,
                    eco: a15,
                    edu: a15,
                    emp: a15,
                    enf: a15,
                    eng: a15,
                    esp: a15,
                    etc: a15,
                    eti: a15,
                    far: a15,
                    feira: a15,
                    flog: a15,
                    floripa: a15,
                    fm: a15,
                    fnd: a15,
                    fortal: a15,
                    fot: a15,
                    foz: a15,
                    fst: a15,
                    g12: a15,
                    geo: a15,
                    ggf: a15,
                    goiania: a15,
                    gov: {
                        $: 1,
                        succ: {
                            ac: a15,
                            al: a15,
                            am: a15,
                            ap: a15,
                            ba: a15,
                            ce: a15,
                            df: a15,
                            es: a15,
                            go: a15,
                            ma: a15,
                            mg: a15,
                            ms: a15,
                            mt: a15,
                            pa: a15,
                            pb: a15,
                            pe: a15,
                            pi: a15,
                            pr: a15,
                            rj: a15,
                            rn: a15,
                            ro: a15,
                            rr: a15,
                            rs: a15,
                            sc: a15,
                            se: a15,
                            sp: a15,
                            to: a15
                        }
                    },
                    gru: a15,
                    imb: a15,
                    ind: a15,
                    inf: a15,
                    jab: a15,
                    jampa: a15,
                    jdf: a15,
                    joinville: a15,
                    jor: a15,
                    jus: a15,
                    leg: {
                        $: 1,
                        succ: {
                            ac: o16,
                            al: o16,
                            am: o16,
                            ap: o16,
                            ba: o16,
                            ce: o16,
                            df: o16,
                            es: o16,
                            go: o16,
                            ma: o16,
                            mg: o16,
                            ms: o16,
                            mt: o16,
                            pa: o16,
                            pb: o16,
                            pe: o16,
                            pi: o16,
                            pr: o16,
                            rj: o16,
                            rn: o16,
                            ro: o16,
                            rr: o16,
                            rs: o16,
                            sc: o16,
                            se: o16,
                            sp: o16,
                            to: o16
                        }
                    },
                    lel: a15,
                    log: a15,
                    londrina: a15,
                    macapa: a15,
                    maceio: a15,
                    manaus: a15,
                    maringa: a15,
                    mat: a15,
                    med: a15,
                    mil: a15,
                    morena: a15,
                    mp: a15,
                    mus: a15,
                    natal: a15,
                    net: a15,
                    niteroi: a15,
                    nom: r6,
                    not: a15,
                    ntr: a15,
                    odo: a15,
                    ong: a15,
                    org: a15,
                    osasco: a15,
                    palmas: a15,
                    poa: a15,
                    ppg: a15,
                    pro: a15,
                    psc: a15,
                    psi: a15,
                    pvh: a15,
                    qsl: a15,
                    radio: a15,
                    rec: a15,
                    recife: a15,
                    rep: a15,
                    ribeirao: a15,
                    rio: a15,
                    riobranco: a15,
                    riopreto: a15,
                    salvador: a15,
                    sampa: a15,
                    santamaria: a15,
                    santoandre: a15,
                    saobernardo: a15,
                    saogonca: a15,
                    seg: a15,
                    sjc: a15,
                    slg: a15,
                    slz: a15,
                    sorocaba: a15,
                    srv: a15,
                    taxi: a15,
                    tc: a15,
                    tec: a15,
                    teo: a15,
                    the: a15,
                    tmp: a15,
                    trd: a15,
                    tur: a15,
                    tv: a15,
                    udi: a15,
                    vet: a15,
                    vix: a15,
                    vlog: a15,
                    wiki: a15,
                    zlg: a15
                }
            },
            bs: {
                $: 1,
                succ: {
                    com: a15,
                    net: a15,
                    org: a15,
                    edu: a15,
                    gov: a15,
                    we: o16
                }
            },
            bt: i12,
            bv: a15,
            bw: {
                $: 1,
                succ: {
                    co: a15,
                    org: a15
                }
            },
            by: {
                $: 1,
                succ: {
                    gov: a15,
                    mil: a15,
                    com: s8,
                    of: a15,
                    mycloud: o16,
                    mediatech: o16
                }
            },
            bz: {
                $: 1,
                succ: {
                    com: a15,
                    net: a15,
                    org: a15,
                    edu: a15,
                    gov: a15,
                    za: o16,
                    gsj: o16
                }
            },
            ca: {
                $: 1,
                succ: {
                    ab: a15,
                    bc: a15,
                    mb: a15,
                    nb: a15,
                    nf: a15,
                    nl: a15,
                    ns: a15,
                    nt: a15,
                    nu: a15,
                    on: a15,
                    pe: a15,
                    qc: a15,
                    sk: a15,
                    yk: a15,
                    gc: a15,
                    barsy: o16,
                    awdev: e12,
                    co: o16,
                    blogspot: o16,
                    "no-ip": o16,
                    myspreadshop: o16
                }
            },
            cat: a15,
            cc: {
                $: 1,
                succ: {
                    cloudns: o16,
                    ftpaccess: o16,
                    "game-server": o16,
                    myphotos: o16,
                    scrapping: o16,
                    twmail: o16,
                    csx: o16,
                    fantasyleague: o16,
                    spawn: {
                        $: 0,
                        succ: {
                            instances: o16
                        }
                    }
                }
            },
            cd: n7,
            cf: s8,
            cg: a15,
            ch: {
                $: 1,
                succ: {
                    square7: o16,
                    blogspot: o16,
                    flow: {
                        $: 0,
                        succ: {
                            ae: {
                                $: 0,
                                succ: {
                                    alp1: o16
                                }
                            },
                            appengine: o16
                        }
                    },
                    "linkyard-cloud": o16,
                    dnsking: o16,
                    gotdns: o16,
                    myspreadshop: o16,
                    firenet: {
                        $: 0,
                        succ: {
                            "*": o16,
                            svc: e12
                        }
                    },
                    "12hp": o16,
                    "2ix": o16,
                    "4lima": o16,
                    "lima-city": o16
                }
            },
            ci: {
                $: 1,
                succ: {
                    org: a15,
                    or: a15,
                    com: a15,
                    co: a15,
                    edu: a15,
                    ed: a15,
                    ac: a15,
                    net: a15,
                    go: a15,
                    asso: a15,
                    "xn--aroport-bya": a15,
                    "aéroport": a15,
                    int: a15,
                    presse: a15,
                    md: a15,
                    gouv: a15,
                    fin: o16,
                    nl: o16
                }
            },
            ck: r6,
            cl: {
                $: 1,
                succ: {
                    co: a15,
                    gob: a15,
                    gov: a15,
                    mil: a15,
                    blogspot: o16
                }
            },
            cm: {
                $: 1,
                succ: {
                    co: a15,
                    com: a15,
                    gov: a15,
                    net: a15
                }
            },
            cn: {
                $: 1,
                succ: {
                    ac: a15,
                    com: {
                        $: 1,
                        succ: {
                            amazonaws: {
                                $: 0,
                                succ: {
                                    compute: e12,
                                    eb: {
                                        $: 0,
                                        succ: {
                                            "cn-north-1": o16,
                                            "cn-northwest-1": o16
                                        }
                                    },
                                    elb: e12,
                                    "cn-north-1": l2
                                }
                            }
                        }
                    },
                    edu: a15,
                    gov: a15,
                    net: a15,
                    org: a15,
                    mil: a15,
                    "xn--55qx5d": a15,
                    "公司": a15,
                    "xn--io0a7i": a15,
                    "网络": a15,
                    "xn--od0alg": a15,
                    "網絡": a15,
                    ah: a15,
                    bj: a15,
                    cq: a15,
                    fj: a15,
                    gd: a15,
                    gs: a15,
                    gz: a15,
                    gx: a15,
                    ha: a15,
                    hb: a15,
                    he: a15,
                    hi: a15,
                    hl: a15,
                    hn: a15,
                    jl: a15,
                    js: a15,
                    jx: a15,
                    ln: a15,
                    nm: a15,
                    nx: a15,
                    qh: a15,
                    sc: a15,
                    sd: a15,
                    sh: a15,
                    sn: a15,
                    sx: a15,
                    tj: a15,
                    xj: a15,
                    xz: a15,
                    yn: a15,
                    zj: a15,
                    hk: a15,
                    mo: a15,
                    tw: a15,
                    instantcloud: o16,
                    quickconnect: m2
                }
            },
            co: {
                $: 1,
                succ: {
                    arts: a15,
                    com: s8,
                    edu: a15,
                    firm: a15,
                    gov: a15,
                    info: a15,
                    int: a15,
                    mil: a15,
                    net: a15,
                    nom: a15,
                    org: a15,
                    rec: a15,
                    web: a15,
                    carrd: o16,
                    crd: o16,
                    otap: e12,
                    leadpages: o16,
                    lpages: o16,
                    mypi: o16,
                    n4t: o16,
                    repl: {
                        $: 2,
                        succ: {
                            id: o16
                        }
                    },
                    supabase: o16
                }
            },
            com: {
                $: 1,
                succ: {
                    devcdnaccesso: e12,
                    adobeaemcloud: {
                        $: 2,
                        succ: {
                            dev: e12
                        }
                    },
                    airkitapps: o16,
                    "airkitapps-au": o16,
                    aivencloud: o16,
                    kasserver: o16,
                    amazonaws: {
                        $: 0,
                        succ: {
                            compute: e12,
                            "compute-1": e12,
                            "us-east-1": {
                                $: 2,
                                succ: {
                                    dualstack: l2
                                }
                            },
                            elb: e12,
                            s3: o16,
                            "s3-ap-northeast-1": o16,
                            "s3-ap-northeast-2": o16,
                            "s3-ap-south-1": o16,
                            "s3-ap-southeast-1": o16,
                            "s3-ap-southeast-2": o16,
                            "s3-ca-central-1": o16,
                            "s3-eu-central-1": o16,
                            "s3-eu-west-1": o16,
                            "s3-eu-west-2": o16,
                            "s3-eu-west-3": o16,
                            "s3-external-1": o16,
                            "s3-fips-us-gov-west-1": o16,
                            "s3-sa-east-1": o16,
                            "s3-us-gov-west-1": o16,
                            "s3-us-east-2": o16,
                            "s3-us-west-1": o16,
                            "s3-us-west-2": o16,
                            "ap-northeast-2": g1,
                            "ap-south-1": g1,
                            "ca-central-1": g1,
                            "eu-central-1": g1,
                            "eu-west-2": g1,
                            "eu-west-3": g1,
                            "us-east-2": g1,
                            "ap-northeast-1": d1,
                            "ap-southeast-1": d1,
                            "ap-southeast-2": d1,
                            "eu-west-1": d1,
                            "sa-east-1": d1,
                            "s3-website-us-east-1": o16,
                            "s3-website-us-west-1": o16,
                            "s3-website-us-west-2": o16,
                            "s3-website-ap-northeast-1": o16,
                            "s3-website-ap-southeast-1": o16,
                            "s3-website-ap-southeast-2": o16,
                            "s3-website-eu-west-1": o16,
                            "s3-website-sa-east-1": o16
                        }
                    },
                    elasticbeanstalk: {
                        $: 2,
                        succ: {
                            "ap-northeast-1": o16,
                            "ap-northeast-2": o16,
                            "ap-northeast-3": o16,
                            "ap-south-1": o16,
                            "ap-southeast-1": o16,
                            "ap-southeast-2": o16,
                            "ca-central-1": o16,
                            "eu-central-1": o16,
                            "eu-west-1": o16,
                            "eu-west-2": o16,
                            "eu-west-3": o16,
                            "sa-east-1": o16,
                            "us-east-1": o16,
                            "us-east-2": o16,
                            "us-gov-west-1": o16,
                            "us-west-1": o16,
                            "us-west-2": o16
                        }
                    },
                    awsglobalaccelerator: o16,
                    siiites: o16,
                    appspacehosted: o16,
                    appspaceusercontent: o16,
                    "on-aptible": o16,
                    myasustor: o16,
                    "balena-devices": o16,
                    betainabox: o16,
                    boutir: o16,
                    bplaced: o16,
                    cafjs: o16,
                    br: o16,
                    cn: o16,
                    de: o16,
                    eu: o16,
                    jpn: o16,
                    mex: o16,
                    ru: o16,
                    sa: o16,
                    uk: o16,
                    us: o16,
                    za: o16,
                    ar: o16,
                    hu: o16,
                    kr: o16,
                    no: o16,
                    qc: o16,
                    uy: o16,
                    africa: o16,
                    gr: o16,
                    co: o16,
                    jdevcloud: o16,
                    wpdevcloud: o16,
                    cloudcontrolled: o16,
                    cloudcontrolapp: o16,
                    trycloudflare: o16,
                    "customer-oci": {
                        $: 0,
                        succ: {
                            "*": o16,
                            oci: e12,
                            ocp: e12,
                            ocs: e12
                        }
                    },
                    dattolocal: o16,
                    dattorelay: o16,
                    dattoweb: o16,
                    mydatto: o16,
                    builtwithdark: o16,
                    datadetect: {
                        $: 0,
                        succ: {
                            demo: o16,
                            instance: o16
                        }
                    },
                    ddns5: o16,
                    discordsays: o16,
                    discordsez: o16,
                    drayddns: o16,
                    dreamhosters: o16,
                    mydrobo: o16,
                    "dyndns-at-home": o16,
                    "dyndns-at-work": o16,
                    "dyndns-blog": o16,
                    "dyndns-free": o16,
                    "dyndns-home": o16,
                    "dyndns-ip": o16,
                    "dyndns-mail": o16,
                    "dyndns-office": o16,
                    "dyndns-pics": o16,
                    "dyndns-remote": o16,
                    "dyndns-server": o16,
                    "dyndns-web": o16,
                    "dyndns-wiki": o16,
                    "dyndns-work": o16,
                    blogdns: o16,
                    cechire: o16,
                    dnsalias: o16,
                    dnsdojo: o16,
                    doesntexist: o16,
                    dontexist: o16,
                    doomdns: o16,
                    "dyn-o-saur": o16,
                    dynalias: o16,
                    "est-a-la-maison": o16,
                    "est-a-la-masion": o16,
                    "est-le-patron": o16,
                    "est-mon-blogueur": o16,
                    "from-ak": o16,
                    "from-al": o16,
                    "from-ar": o16,
                    "from-ca": o16,
                    "from-ct": o16,
                    "from-dc": o16,
                    "from-de": o16,
                    "from-fl": o16,
                    "from-ga": o16,
                    "from-hi": o16,
                    "from-ia": o16,
                    "from-id": o16,
                    "from-il": o16,
                    "from-in": o16,
                    "from-ks": o16,
                    "from-ky": o16,
                    "from-ma": o16,
                    "from-md": o16,
                    "from-mi": o16,
                    "from-mn": o16,
                    "from-mo": o16,
                    "from-ms": o16,
                    "from-mt": o16,
                    "from-nc": o16,
                    "from-nd": o16,
                    "from-ne": o16,
                    "from-nh": o16,
                    "from-nj": o16,
                    "from-nm": o16,
                    "from-nv": o16,
                    "from-oh": o16,
                    "from-ok": o16,
                    "from-or": o16,
                    "from-pa": o16,
                    "from-pr": o16,
                    "from-ri": o16,
                    "from-sc": o16,
                    "from-sd": o16,
                    "from-tn": o16,
                    "from-tx": o16,
                    "from-ut": o16,
                    "from-va": o16,
                    "from-vt": o16,
                    "from-wa": o16,
                    "from-wi": o16,
                    "from-wv": o16,
                    "from-wy": o16,
                    getmyip: o16,
                    gotdns: o16,
                    "hobby-site": o16,
                    homelinux: o16,
                    homeunix: o16,
                    iamallama: o16,
                    "is-a-anarchist": o16,
                    "is-a-blogger": o16,
                    "is-a-bookkeeper": o16,
                    "is-a-bulls-fan": o16,
                    "is-a-caterer": o16,
                    "is-a-chef": o16,
                    "is-a-conservative": o16,
                    "is-a-cpa": o16,
                    "is-a-cubicle-slave": o16,
                    "is-a-democrat": o16,
                    "is-a-designer": o16,
                    "is-a-doctor": o16,
                    "is-a-financialadvisor": o16,
                    "is-a-geek": o16,
                    "is-a-green": o16,
                    "is-a-guru": o16,
                    "is-a-hard-worker": o16,
                    "is-a-hunter": o16,
                    "is-a-landscaper": o16,
                    "is-a-lawyer": o16,
                    "is-a-liberal": o16,
                    "is-a-libertarian": o16,
                    "is-a-llama": o16,
                    "is-a-musician": o16,
                    "is-a-nascarfan": o16,
                    "is-a-nurse": o16,
                    "is-a-painter": o16,
                    "is-a-personaltrainer": o16,
                    "is-a-photographer": o16,
                    "is-a-player": o16,
                    "is-a-republican": o16,
                    "is-a-rockstar": o16,
                    "is-a-socialist": o16,
                    "is-a-student": o16,
                    "is-a-teacher": o16,
                    "is-a-techie": o16,
                    "is-a-therapist": o16,
                    "is-an-accountant": o16,
                    "is-an-actor": o16,
                    "is-an-actress": o16,
                    "is-an-anarchist": o16,
                    "is-an-artist": o16,
                    "is-an-engineer": o16,
                    "is-an-entertainer": o16,
                    "is-certified": o16,
                    "is-gone": o16,
                    "is-into-anime": o16,
                    "is-into-cars": o16,
                    "is-into-cartoons": o16,
                    "is-into-games": o16,
                    "is-leet": o16,
                    "is-not-certified": o16,
                    "is-slick": o16,
                    "is-uberleet": o16,
                    "is-with-theband": o16,
                    "isa-geek": o16,
                    "isa-hockeynut": o16,
                    issmarterthanyou: o16,
                    "likes-pie": o16,
                    likescandy: o16,
                    "neat-url": o16,
                    "saves-the-whales": o16,
                    selfip: o16,
                    "sells-for-less": o16,
                    "sells-for-u": o16,
                    servebbs: o16,
                    "simple-url": o16,
                    "space-to-rent": o16,
                    "teaches-yoga": o16,
                    writesthisblog: o16,
                    digitaloceanspaces: e12,
                    ddnsfree: o16,
                    ddnsgeek: o16,
                    giize: o16,
                    gleeze: o16,
                    kozow: o16,
                    loseyourip: o16,
                    ooguy: o16,
                    theworkpc: o16,
                    mytuleap: o16,
                    "tuleap-partners": o16,
                    encoreapi: o16,
                    evennode: {
                        $: 0,
                        succ: {
                            "eu-1": o16,
                            "eu-2": o16,
                            "eu-3": o16,
                            "eu-4": o16,
                            "us-1": o16,
                            "us-2": o16,
                            "us-3": o16,
                            "us-4": o16
                        }
                    },
                    onfabrica: o16,
                    fbsbx: h1,
                    "fastly-terrarium": o16,
                    "fastvps-server": o16,
                    mydobiss: o16,
                    firebaseapp: o16,
                    fldrv: o16,
                    forgeblocks: o16,
                    framercanvas: o16,
                    "freebox-os": o16,
                    freeboxos: o16,
                    freemyip: o16,
                    gentapps: o16,
                    gentlentapis: o16,
                    githubusercontent: o16,
                    "0emm": e12,
                    appspot: {
                        $: 2,
                        succ: {
                            r: e12
                        }
                    },
                    codespot: o16,
                    googleapis: o16,
                    googlecode: o16,
                    pagespeedmobilizer: o16,
                    publishproxy: o16,
                    withgoogle: o16,
                    withyoutube: o16,
                    blogspot: o16,
                    awsmppl: o16,
                    herokuapp: o16,
                    herokussl: o16,
                    myravendb: o16,
                    impertrixcdn: o16,
                    impertrix: o16,
                    smushcdn: o16,
                    wphostedmail: o16,
                    wpmucdn: o16,
                    pixolino: o16,
                    amscompute: o16,
                    clicketcloud: o16,
                    dopaas: o16,
                    hidora: o16,
                    "hosted-by-previder": k,
                    hosteur: {
                        $: 0,
                        succ: {
                            "rag-cloud": o16,
                            "rag-cloud-ch": o16
                        }
                    },
                    "ik-server": {
                        $: 0,
                        succ: {
                            jcloud: o16,
                            "jcloud-ver-jpc": o16
                        }
                    },
                    jelastic: {
                        $: 0,
                        succ: {
                            demo: o16
                        }
                    },
                    kilatiron: o16,
                    massivegrid: k,
                    wafaicloud: {
                        $: 0,
                        succ: {
                            jed: o16,
                            lon: o16,
                            ryd: o16
                        }
                    },
                    joyent: {
                        $: 0,
                        succ: {
                            cns: e12
                        }
                    },
                    ktistory: o16,
                    lpusercontent: o16,
                    lmpm: b,
                    linode: {
                        $: 0,
                        succ: {
                            members: o16,
                            nodebalancer: e12
                        }
                    },
                    linodeobjects: e12,
                    linodeusercontent: {
                        $: 0,
                        succ: {
                            ip: o16
                        }
                    },
                    barsycenter: o16,
                    barsyonline: o16,
                    mazeplay: o16,
                    miniserver: o16,
                    meteorapp: p,
                    hostedpi: o16,
                    "mythic-beasts": {
                        $: 0,
                        succ: {
                            customer: o16,
                            caracal: o16,
                            fentiger: o16,
                            lynx: o16,
                            ocelot: o16,
                            oncilla: o16,
                            onza: o16,
                            sphinx: o16,
                            vs: o16,
                            x: o16,
                            yali: o16
                        }
                    },
                    nospamproxy: t4,
                    "4u": o16,
                    nfshost: o16,
                    "001www": o16,
                    ddnslive: o16,
                    myiphost: o16,
                    blogsyte: o16,
                    ciscofreak: o16,
                    damnserver: o16,
                    ditchyourip: o16,
                    dnsiskinky: o16,
                    dynns: o16,
                    geekgalaxy: o16,
                    "health-carereform": o16,
                    homesecuritymac: o16,
                    homesecuritypc: o16,
                    myactivedirectory: o16,
                    mysecuritycamera: o16,
                    "net-freaks": o16,
                    onthewifi: o16,
                    point2this: o16,
                    quicksytes: o16,
                    securitytactics: o16,
                    serveexchange: o16,
                    servehumour: o16,
                    servep2p: o16,
                    servesarcasm: o16,
                    stufftoread: o16,
                    unusualperson: o16,
                    workisboring: o16,
                    "3utilities": o16,
                    ddnsking: o16,
                    myvnc: o16,
                    servebeer: o16,
                    servecounterstrike: o16,
                    serveftp: o16,
                    servegame: o16,
                    servehalflife: o16,
                    servehttp: o16,
                    serveirc: o16,
                    servemp3: o16,
                    servepics: o16,
                    servequake: o16,
                    observableusercontent: {
                        $: 0,
                        succ: {
                            static: o16
                        }
                    },
                    orsites: o16,
                    operaunite: o16,
                    "authgear-staging": o16,
                    authgearapps: o16,
                    skygearapp: o16,
                    outsystemscloud: o16,
                    ownprovider: o16,
                    pgfog: o16,
                    pagefrontapp: o16,
                    pagexl: o16,
                    paywhirl: e12,
                    gotpantheon: o16,
                    "platter-app": o16,
                    pleskns: o16,
                    "postman-echo": o16,
                    prgmr: {
                        $: 0,
                        succ: {
                            xen: o16
                        }
                    },
                    pythonanywhere: p,
                    qualifioapp: o16,
                    qbuser: o16,
                    qa2: o16,
                    "dev-myqnapcloud": o16,
                    "alpha-myqnapcloud": o16,
                    myqnapcloud: o16,
                    quipelements: e12,
                    rackmaze: o16,
                    rhcloud: o16,
                    render: b,
                    onrender: o16,
                    logoip: o16,
                    scrysec: o16,
                    "firewall-gateway": o16,
                    myshopblocks: o16,
                    myshopify: o16,
                    shopitsite: o16,
                    "1kapp": o16,
                    appchizi: o16,
                    applinzi: o16,
                    sinaapp: o16,
                    vipsinaapp: o16,
                    "bounty-full": {
                        $: 2,
                        succ: {
                            alpha: o16,
                            beta: o16
                        }
                    },
                    "try-snowplow": o16,
                    "stackhero-network": o16,
                    "playstation-cloud": o16,
                    myspreadshop: o16,
                    stdlib: {
                        $: 0,
                        succ: {
                            api: o16
                        }
                    },
                    "temp-dns": o16,
                    dsmynas: o16,
                    familyds: o16,
                    "tb-hosting": y,
                    reservd: o16,
                    thingdustdata: o16,
                    bloxcms: o16,
                    "townnews-staging": o16,
                    typeform: {
                        $: 0,
                        succ: {
                            pro: o16
                        }
                    },
                    hk: o16,
                    vultrobjects: e12,
                    wafflecell: o16,
                    "reserve-online": o16,
                    hotelwithflight: o16,
                    remotewd: o16,
                    wiardweb: f,
                    messwithdns: o16,
                    "woltlab-demo": o16,
                    wpenginepowered: {
                        $: 2,
                        succ: {
                            js: o16
                        }
                    },
                    wixsite: o16,
                    xnbay: {
                        $: 2,
                        succ: {
                            u2: o16,
                            "u2-local": o16
                        }
                    },
                    yolasite: o16
                }
            },
            coop: a15,
            cr: {
                $: 1,
                succ: {
                    ac: a15,
                    co: a15,
                    ed: a15,
                    fi: a15,
                    go: a15,
                    or: a15,
                    sa: a15
                }
            },
            cu: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    org: a15,
                    net: a15,
                    gov: a15,
                    inf: a15
                }
            },
            cv: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    int: a15,
                    nome: a15,
                    org: a15,
                    blogspot: o16
                }
            },
            cw: v,
            cx: {
                $: 1,
                succ: {
                    gov: a15,
                    ath: o16,
                    info: o16
                }
            },
            cy: {
                $: 1,
                succ: {
                    ac: a15,
                    biz: a15,
                    com: {
                        $: 1,
                        succ: {
                            blogspot: o16,
                            scaleforce: x
                        }
                    },
                    ekloges: a15,
                    gov: a15,
                    ltd: a15,
                    mil: a15,
                    net: a15,
                    org: a15,
                    press: a15,
                    pro: a15,
                    tm: a15
                }
            },
            cz: {
                $: 1,
                succ: {
                    co: o16,
                    realm: o16,
                    e4: o16,
                    blogspot: o16,
                    metacentrum: {
                        $: 0,
                        succ: {
                            cloud: e12,
                            custom: o16
                        }
                    },
                    muni: {
                        $: 0,
                        succ: {
                            cloud: {
                                $: 0,
                                succ: {
                                    flt: o16,
                                    usr: o16
                                }
                            }
                        }
                    }
                }
            },
            de: {
                $: 1,
                succ: {
                    bplaced: o16,
                    square7: o16,
                    com: o16,
                    cosidns: {
                        $: 0,
                        succ: {
                            dyn: o16
                        }
                    },
                    "dynamisches-dns": o16,
                    dnsupdater: o16,
                    "internet-dns": o16,
                    "l-o-g-i-n": o16,
                    dnshome: o16,
                    fuettertdasnetz: o16,
                    isteingeek: o16,
                    istmein: o16,
                    lebtimnetz: o16,
                    leitungsen: o16,
                    traeumtgerade: o16,
                    ddnss: {
                        $: 2,
                        succ: {
                            dyn: o16,
                            dyndns: o16
                        }
                    },
                    dyndns1: o16,
                    "dyn-ip24": o16,
                    "home-webserver": {
                        $: 2,
                        succ: {
                            dyn: o16
                        }
                    },
                    "myhome-server": o16,
                    frusky: e12,
                    goip: o16,
                    blogspot: o16,
                    "xn--gnstigbestellen-zvb": o16,
                    "günstigbestellen": o16,
                    "xn--gnstigliefern-wob": o16,
                    "günstigliefern": o16,
                    "hs-heilbronn": {
                        $: 0,
                        succ: {
                            it: f
                        }
                    },
                    "dyn-berlin": o16,
                    "in-berlin": o16,
                    "in-brb": o16,
                    "in-butter": o16,
                    "in-dsl": o16,
                    "in-vpn": o16,
                    "mein-iserv": o16,
                    schulserver: o16,
                    "test-iserv": o16,
                    keymachine: o16,
                    "git-repos": o16,
                    "lcube-server": o16,
                    "svn-repos": o16,
                    barsy: o16,
                    logoip: o16,
                    "firewall-gateway": o16,
                    "my-gateway": o16,
                    "my-router": o16,
                    spdns: o16,
                    speedpartner: {
                        $: 0,
                        succ: {
                            customer: o16
                        }
                    },
                    myspreadshop: o16,
                    "taifun-dns": o16,
                    "12hp": o16,
                    "2ix": o16,
                    "4lima": o16,
                    "lima-city": o16,
                    "dd-dns": o16,
                    "dray-dns": o16,
                    draydns: o16,
                    "dyn-vpn": o16,
                    dynvpn: o16,
                    "mein-vigor": o16,
                    "my-vigor": o16,
                    "my-wan": o16,
                    "syno-ds": o16,
                    "synology-diskstation": o16,
                    "synology-ds": o16,
                    uberspace: e12,
                    virtualuser: o16,
                    "virtual-user": o16,
                    "community-pro": o16,
                    diskussionsbereich: o16
                }
            },
            dj: a15,
            dk: {
                $: 1,
                succ: {
                    biz: o16,
                    co: o16,
                    firm: o16,
                    reg: o16,
                    store: o16,
                    blogspot: o16,
                    myspreadshop: o16
                }
            },
            dm: i12,
            do: {
                $: 1,
                succ: {
                    art: a15,
                    com: a15,
                    edu: a15,
                    gob: a15,
                    gov: a15,
                    mil: a15,
                    net: a15,
                    org: a15,
                    sld: a15,
                    web: a15
                }
            },
            dz: {
                $: 1,
                succ: {
                    art: a15,
                    asso: a15,
                    com: a15,
                    edu: a15,
                    gov: a15,
                    org: a15,
                    net: a15,
                    pol: a15,
                    soc: a15,
                    tm: a15
                }
            },
            ec: {
                $: 1,
                succ: {
                    com: a15,
                    info: a15,
                    net: a15,
                    fin: a15,
                    k12: a15,
                    med: a15,
                    pro: a15,
                    org: a15,
                    edu: a15,
                    gov: a15,
                    gob: a15,
                    mil: a15,
                    base: o16,
                    official: o16
                }
            },
            edu: {
                $: 1,
                succ: {
                    rit: {
                        $: 0,
                        succ: {
                            "git-pages": o16
                        }
                    }
                }
            },
            ee: {
                $: 1,
                succ: {
                    edu: a15,
                    gov: a15,
                    riik: a15,
                    lib: a15,
                    med: a15,
                    com: s8,
                    pri: a15,
                    aip: a15,
                    org: a15,
                    fie: a15
                }
            },
            eg: {
                $: 1,
                succ: {
                    com: s8,
                    edu: a15,
                    eun: a15,
                    gov: a15,
                    mil: a15,
                    name: a15,
                    net: a15,
                    org: a15,
                    sci: a15
                }
            },
            er: r6,
            es: {
                $: 1,
                succ: {
                    com: s8,
                    nom: a15,
                    org: a15,
                    gob: a15,
                    edu: a15,
                    myspreadshop: o16
                }
            },
            et: {
                $: 1,
                succ: {
                    com: a15,
                    gov: a15,
                    org: a15,
                    edu: a15,
                    biz: a15,
                    name: a15,
                    info: a15,
                    net: a15
                }
            },
            eu: {
                $: 1,
                succ: {
                    airkitapps: o16,
                    mycd: o16,
                    cloudns: o16,
                    dogado: w,
                    barsy: o16,
                    wellbeingzone: o16,
                    spdns: o16,
                    transurl: e12,
                    diskstation: o16
                }
            },
            fi: {
                $: 1,
                succ: {
                    aland: a15,
                    dy: o16,
                    blogspot: o16,
                    "xn--hkkinen-5wa": o16,
                    "häkkinen": o16,
                    iki: o16,
                    cloudplatform: {
                        $: 0,
                        succ: {
                            fi: o16
                        }
                    },
                    datacenter: {
                        $: 0,
                        succ: {
                            demo: o16,
                            paas: o16
                        }
                    },
                    kapsi: o16,
                    myspreadshop: o16
                }
            },
            fj: {
                $: 1,
                succ: {
                    ac: a15,
                    biz: a15,
                    com: a15,
                    gov: a15,
                    info: a15,
                    mil: a15,
                    name: a15,
                    net: a15,
                    org: a15,
                    pro: a15
                }
            },
            fk: r6,
            fm: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    net: a15,
                    org: a15,
                    radio: o16
                }
            },
            fo: a15,
            fr: {
                $: 1,
                succ: {
                    asso: a15,
                    com: a15,
                    gouv: a15,
                    nom: a15,
                    prd: a15,
                    tm: a15,
                    aeroport: a15,
                    avocat: a15,
                    avoues: a15,
                    cci: a15,
                    chambagri: a15,
                    "chirurgiens-dentistes": a15,
                    "experts-comptables": a15,
                    "geometre-expert": a15,
                    greta: a15,
                    "huissier-justice": a15,
                    medecin: a15,
                    notaires: a15,
                    pharmacien: a15,
                    port: a15,
                    veterinaire: a15,
                    "en-root": o16,
                    "fbx-os": o16,
                    fbxos: o16,
                    "freebox-os": o16,
                    freeboxos: o16,
                    blogspot: o16,
                    goupile: o16,
                    "on-web": o16,
                    "chirurgiens-dentistes-en-france": o16,
                    dedibox: o16,
                    myspreadshop: o16,
                    ynh: o16
                }
            },
            ga: a15,
            gb: a15,
            gd: {
                $: 1,
                succ: {
                    edu: a15,
                    gov: a15
                }
            },
            ge: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    gov: a15,
                    org: a15,
                    mil: a15,
                    net: a15,
                    pvt: a15
                }
            },
            gf: a15,
            gg: {
                $: 1,
                succ: {
                    co: a15,
                    net: a15,
                    org: a15,
                    kaas: o16,
                    cya: o16,
                    panel: {
                        $: 2,
                        succ: {
                            daemon: o16
                        }
                    }
                }
            },
            gh: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    gov: a15,
                    org: a15,
                    mil: a15
                }
            },
            gi: {
                $: 1,
                succ: {
                    com: a15,
                    ltd: a15,
                    gov: a15,
                    mod: a15,
                    edu: a15,
                    org: a15
                }
            },
            gl: {
                $: 1,
                succ: {
                    co: a15,
                    com: a15,
                    edu: a15,
                    net: a15,
                    org: a15,
                    biz: o16,
                    xx: o16
                }
            },
            gm: a15,
            gn: {
                $: 1,
                succ: {
                    ac: a15,
                    com: a15,
                    edu: a15,
                    gov: a15,
                    org: a15,
                    net: a15
                }
            },
            gov: a15,
            gp: {
                $: 1,
                succ: {
                    com: a15,
                    net: a15,
                    mobi: a15,
                    edu: a15,
                    org: a15,
                    asso: a15,
                    app: o16
                }
            },
            gq: a15,
            gr: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    net: a15,
                    org: a15,
                    gov: a15,
                    blogspot: o16
                }
            },
            gs: a15,
            gt: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    gob: a15,
                    ind: a15,
                    mil: a15,
                    net: a15,
                    org: a15,
                    blog: o16,
                    de: o16,
                    to: o16
                }
            },
            gu: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    gov: a15,
                    guam: a15,
                    info: a15,
                    net: a15,
                    org: a15,
                    web: a15
                }
            },
            gw: a15,
            gy: {
                $: 1,
                succ: {
                    co: a15,
                    com: a15,
                    edu: a15,
                    gov: a15,
                    net: a15,
                    org: a15,
                    be: o16
                }
            },
            hk: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    gov: a15,
                    idv: a15,
                    net: a15,
                    org: a15,
                    "xn--55qx5d": a15,
                    "公司": a15,
                    "xn--wcvs22d": a15,
                    "教育": a15,
                    "xn--lcvr32d": a15,
                    "敎育": a15,
                    "xn--mxtq1m": a15,
                    "政府": a15,
                    "xn--gmqw5a": a15,
                    "個人": a15,
                    "xn--ciqpn": a15,
                    "个人": a15,
                    "xn--gmq050i": a15,
                    "箇人": a15,
                    "xn--zf0avx": a15,
                    "網络": a15,
                    "xn--io0a7i": a15,
                    "网络": a15,
                    "xn--mk0axi": a15,
                    "组織": a15,
                    "xn--od0alg": a15,
                    "網絡": a15,
                    "xn--od0aq3b": a15,
                    "网絡": a15,
                    "xn--tn0ag": a15,
                    "组织": a15,
                    "xn--uc0atv": a15,
                    "組織": a15,
                    "xn--uc0ay4a": a15,
                    "組织": a15,
                    blogspot: o16,
                    secaas: o16,
                    ltd: o16,
                    inc: o16
                }
            },
            hm: a15,
            hn: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    org: a15,
                    net: a15,
                    mil: a15,
                    gob: a15,
                    cc: o16
                }
            },
            hr: {
                $: 1,
                succ: {
                    iz: a15,
                    from: a15,
                    name: a15,
                    com: a15,
                    blogspot: o16,
                    free: o16
                }
            },
            ht: {
                $: 1,
                succ: {
                    com: a15,
                    shop: a15,
                    firm: a15,
                    info: a15,
                    adult: a15,
                    net: a15,
                    pro: a15,
                    org: a15,
                    med: a15,
                    art: a15,
                    coop: a15,
                    pol: a15,
                    asso: a15,
                    edu: a15,
                    rel: a15,
                    gouv: a15,
                    perso: a15
                }
            },
            hu: {
                $: 1,
                succ: {
                    2e3: a15,
                    co: a15,
                    info: a15,
                    org: a15,
                    priv: a15,
                    sport: a15,
                    tm: a15,
                    agrar: a15,
                    bolt: a15,
                    casino: a15,
                    city: a15,
                    erotica: a15,
                    erotika: a15,
                    film: a15,
                    forum: a15,
                    games: a15,
                    hotel: a15,
                    ingatlan: a15,
                    jogasz: a15,
                    konyvelo: a15,
                    lakas: a15,
                    media: a15,
                    news: a15,
                    reklam: a15,
                    sex: a15,
                    shop: a15,
                    suli: a15,
                    szex: a15,
                    tozsde: a15,
                    utazas: a15,
                    video: a15,
                    blogspot: o16
                }
            },
            id: {
                $: 1,
                succ: {
                    ac: a15,
                    biz: a15,
                    co: s8,
                    desa: a15,
                    go: a15,
                    mil: a15,
                    my: {
                        $: 1,
                        succ: {
                            rss: e12
                        }
                    },
                    net: a15,
                    or: a15,
                    ponpes: a15,
                    sch: a15,
                    web: a15,
                    flap: o16,
                    forte: o16
                }
            },
            ie: {
                $: 1,
                succ: {
                    gov: a15,
                    blogspot: o16,
                    myspreadshop: o16
                }
            },
            il: {
                $: 1,
                succ: {
                    ac: a15,
                    co: {
                        $: 1,
                        succ: {
                            ravpage: o16,
                            blogspot: o16,
                            tabitorder: o16
                        }
                    },
                    gov: a15,
                    idf: a15,
                    k12: a15,
                    muni: a15,
                    net: a15,
                    org: a15
                }
            },
            im: {
                $: 1,
                succ: {
                    ac: a15,
                    co: {
                        $: 1,
                        succ: {
                            ltd: a15,
                            plc: a15
                        }
                    },
                    com: a15,
                    net: a15,
                    org: a15,
                    tt: a15,
                    tv: a15,
                    ro: o16
                }
            },
            in: {
                $: 1,
                succ: {
                    co: a15,
                    firm: a15,
                    net: a15,
                    org: a15,
                    gen: a15,
                    ind: a15,
                    nic: a15,
                    ac: a15,
                    edu: a15,
                    res: a15,
                    gov: a15,
                    mil: a15,
                    web: o16,
                    cloudns: o16,
                    blogspot: o16,
                    barsy: o16,
                    supabase: o16
                }
            },
            info: {
                $: 1,
                succ: {
                    cloudns: o16,
                    "dynamic-dns": o16,
                    dyndns: o16,
                    "barrel-of-knowledge": o16,
                    "barrell-of-knowledge": o16,
                    "for-our": o16,
                    "groks-the": o16,
                    "groks-this": o16,
                    "here-for-more": o16,
                    knowsitall: o16,
                    selfip: o16,
                    webhop: o16,
                    barsy: o16,
                    mayfirst: o16,
                    forumz: o16,
                    nsupdate: o16,
                    dvrcam: o16,
                    ilovecollege: o16,
                    "no-ip": o16,
                    dnsupdate: o16,
                    "v-info": o16
                }
            },
            int: {
                $: 1,
                succ: {
                    eu: a15
                }
            },
            io: {
                $: 1,
                succ: {
                    2038: o16,
                    com: a15,
                    apigee: o16,
                    "b-data": o16,
                    backplaneapp: o16,
                    banzaicloud: {
                        $: 0,
                        succ: {
                            app: o16,
                            backyards: e12
                        }
                    },
                    bitbucket: o16,
                    bluebite: o16,
                    boxfuse: o16,
                    browsersafetymark: o16,
                    bigv: {
                        $: 0,
                        succ: {
                            uk0: o16
                        }
                    },
                    cleverapps: o16,
                    dappnode: {
                        $: 0,
                        succ: {
                            dyndns: o16
                        }
                    },
                    dedyn: o16,
                    drud: o16,
                    definima: o16,
                    "fh-muenster": o16,
                    shw: o16,
                    forgerock: {
                        $: 0,
                        succ: {
                            id: o16
                        }
                    },
                    ghost: o16,
                    github: o16,
                    gitlab: o16,
                    lolipop: o16,
                    "hasura-app": o16,
                    hostyhosting: o16,
                    moonscale: e12,
                    beebyte: k,
                    beebyteapp: {
                        $: 0,
                        succ: {
                            sekd1: o16
                        }
                    },
                    jele: o16,
                    unispace: {
                        $: 0,
                        succ: {
                            "cloud-fr1": o16
                        }
                    },
                    webthings: o16,
                    loginline: o16,
                    barsy: o16,
                    azurecontainer: e12,
                    ngrok: o16,
                    nodeart: {
                        $: 0,
                        succ: {
                            stage: o16
                        }
                    },
                    nid: o16,
                    pantheonsite: o16,
                    dyn53: o16,
                    pstmn: {
                        $: 2,
                        succ: {
                            mock: o16
                        }
                    },
                    protonet: o16,
                    qoto: o16,
                    qcx: {
                        $: 2,
                        succ: {
                            sys: e12
                        }
                    },
                    vaporcloud: o16,
                    vbrplsbx: {
                        $: 0,
                        succ: {
                            g: o16
                        }
                    },
                    "on-k3s": e12,
                    "on-rio": e12,
                    readthedocs: o16,
                    resindevice: o16,
                    resinstaging: {
                        $: 0,
                        succ: {
                            devices: o16
                        }
                    },
                    hzc: o16,
                    sandcats: o16,
                    shiftcrypto: o16,
                    shiftedit: o16,
                    "mo-siemens": o16,
                    musician: o16,
                    lair: h1,
                    stolos: e12,
                    spacekit: o16,
                    utwente: o16,
                    s5y: e12,
                    edugit: o16,
                    telebit: o16,
                    thingdust: {
                        $: 0,
                        succ: {
                            dev: j,
                            disrec: j,
                            prod: q,
                            testing: j
                        }
                    },
                    tickets: o16,
                    upli: o16,
                    wedeploy: o16,
                    editorx: o16,
                    basicserver: o16,
                    virtualserver: o16
                }
            },
            iq: I,
            ir: {
                $: 1,
                succ: {
                    ac: a15,
                    co: a15,
                    gov: a15,
                    id: a15,
                    net: a15,
                    org: a15,
                    sch: a15,
                    "xn--mgba3a4f16a": a15,
                    "ایران": a15,
                    "xn--mgba3a4fra": a15,
                    "ايران": a15
                }
            },
            is: {
                $: 1,
                succ: {
                    net: a15,
                    com: a15,
                    edu: a15,
                    gov: a15,
                    org: a15,
                    int: a15,
                    cupcake: o16,
                    blogspot: o16
                }
            },
            it: {
                $: 1,
                succ: {
                    gov: a15,
                    edu: a15,
                    abr: a15,
                    abruzzo: a15,
                    "aosta-valley": a15,
                    aostavalley: a15,
                    bas: a15,
                    basilicata: a15,
                    cal: a15,
                    calabria: a15,
                    cam: a15,
                    campania: a15,
                    "emilia-romagna": a15,
                    emiliaromagna: a15,
                    emr: a15,
                    "friuli-v-giulia": a15,
                    "friuli-ve-giulia": a15,
                    "friuli-vegiulia": a15,
                    "friuli-venezia-giulia": a15,
                    "friuli-veneziagiulia": a15,
                    "friuli-vgiulia": a15,
                    "friuliv-giulia": a15,
                    "friulive-giulia": a15,
                    friulivegiulia: a15,
                    "friulivenezia-giulia": a15,
                    friuliveneziagiulia: a15,
                    friulivgiulia: a15,
                    fvg: a15,
                    laz: a15,
                    lazio: a15,
                    lig: a15,
                    liguria: a15,
                    lom: a15,
                    lombardia: a15,
                    lombardy: a15,
                    lucania: a15,
                    mar: a15,
                    marche: a15,
                    mol: a15,
                    molise: a15,
                    piedmont: a15,
                    piemonte: a15,
                    pmn: a15,
                    pug: a15,
                    puglia: a15,
                    sar: a15,
                    sardegna: a15,
                    sardinia: a15,
                    sic: a15,
                    sicilia: a15,
                    sicily: a15,
                    taa: a15,
                    tos: a15,
                    toscana: a15,
                    "trentin-sud-tirol": a15,
                    "xn--trentin-sd-tirol-rzb": a15,
                    "trentin-süd-tirol": a15,
                    "trentin-sudtirol": a15,
                    "xn--trentin-sdtirol-7vb": a15,
                    "trentin-südtirol": a15,
                    "trentin-sued-tirol": a15,
                    "trentin-suedtirol": a15,
                    "trentino-a-adige": a15,
                    "trentino-aadige": a15,
                    "trentino-alto-adige": a15,
                    "trentino-altoadige": a15,
                    "trentino-s-tirol": a15,
                    "trentino-stirol": a15,
                    "trentino-sud-tirol": a15,
                    "xn--trentino-sd-tirol-c3b": a15,
                    "trentino-süd-tirol": a15,
                    "trentino-sudtirol": a15,
                    "xn--trentino-sdtirol-szb": a15,
                    "trentino-südtirol": a15,
                    "trentino-sued-tirol": a15,
                    "trentino-suedtirol": a15,
                    trentino: a15,
                    "trentinoa-adige": a15,
                    trentinoaadige: a15,
                    "trentinoalto-adige": a15,
                    trentinoaltoadige: a15,
                    "trentinos-tirol": a15,
                    trentinostirol: a15,
                    "trentinosud-tirol": a15,
                    "xn--trentinosd-tirol-rzb": a15,
                    "trentinosüd-tirol": a15,
                    trentinosudtirol: a15,
                    "xn--trentinosdtirol-7vb": a15,
                    "trentinosüdtirol": a15,
                    "trentinosued-tirol": a15,
                    trentinosuedtirol: a15,
                    "trentinsud-tirol": a15,
                    "xn--trentinsd-tirol-6vb": a15,
                    "trentinsüd-tirol": a15,
                    trentinsudtirol: a15,
                    "xn--trentinsdtirol-nsb": a15,
                    "trentinsüdtirol": a15,
                    "trentinsued-tirol": a15,
                    trentinsuedtirol: a15,
                    tuscany: a15,
                    umb: a15,
                    umbria: a15,
                    "val-d-aosta": a15,
                    "val-daosta": a15,
                    "vald-aosta": a15,
                    valdaosta: a15,
                    "valle-aosta": a15,
                    "valle-d-aosta": a15,
                    "valle-daosta": a15,
                    valleaosta: a15,
                    "valled-aosta": a15,
                    valledaosta: a15,
                    "vallee-aoste": a15,
                    "xn--valle-aoste-ebb": a15,
                    "vallée-aoste": a15,
                    "vallee-d-aoste": a15,
                    "xn--valle-d-aoste-ehb": a15,
                    "vallée-d-aoste": a15,
                    valleeaoste: a15,
                    "xn--valleaoste-e7a": a15,
                    "valléeaoste": a15,
                    valleedaoste: a15,
                    "xn--valledaoste-ebb": a15,
                    "valléedaoste": a15,
                    vao: a15,
                    vda: a15,
                    ven: a15,
                    veneto: a15,
                    ag: a15,
                    agrigento: a15,
                    al: a15,
                    alessandria: a15,
                    "alto-adige": a15,
                    altoadige: a15,
                    an: a15,
                    ancona: a15,
                    "andria-barletta-trani": a15,
                    "andria-trani-barletta": a15,
                    andriabarlettatrani: a15,
                    andriatranibarletta: a15,
                    ao: a15,
                    aosta: a15,
                    aoste: a15,
                    ap: a15,
                    aq: a15,
                    aquila: a15,
                    ar: a15,
                    arezzo: a15,
                    "ascoli-piceno": a15,
                    ascolipiceno: a15,
                    asti: a15,
                    at: a15,
                    av: a15,
                    avellino: a15,
                    ba: a15,
                    "balsan-sudtirol": a15,
                    "xn--balsan-sdtirol-nsb": a15,
                    "balsan-südtirol": a15,
                    "balsan-suedtirol": a15,
                    balsan: a15,
                    bari: a15,
                    "barletta-trani-andria": a15,
                    barlettatraniandria: a15,
                    belluno: a15,
                    benevento: a15,
                    bergamo: a15,
                    bg: a15,
                    bi: a15,
                    biella: a15,
                    bl: a15,
                    bn: a15,
                    bo: a15,
                    bologna: a15,
                    "bolzano-altoadige": a15,
                    bolzano: a15,
                    "bozen-sudtirol": a15,
                    "xn--bozen-sdtirol-2ob": a15,
                    "bozen-südtirol": a15,
                    "bozen-suedtirol": a15,
                    bozen: a15,
                    br: a15,
                    brescia: a15,
                    brindisi: a15,
                    bs: a15,
                    bt: a15,
                    "bulsan-sudtirol": a15,
                    "xn--bulsan-sdtirol-nsb": a15,
                    "bulsan-südtirol": a15,
                    "bulsan-suedtirol": a15,
                    bulsan: a15,
                    bz: a15,
                    ca: a15,
                    cagliari: a15,
                    caltanissetta: a15,
                    "campidano-medio": a15,
                    campidanomedio: a15,
                    campobasso: a15,
                    "carbonia-iglesias": a15,
                    carboniaiglesias: a15,
                    "carrara-massa": a15,
                    carraramassa: a15,
                    caserta: a15,
                    catania: a15,
                    catanzaro: a15,
                    cb: a15,
                    ce: a15,
                    "cesena-forli": a15,
                    "xn--cesena-forl-mcb": a15,
                    "cesena-forlì": a15,
                    cesenaforli: a15,
                    "xn--cesenaforl-i8a": a15,
                    "cesenaforlì": a15,
                    ch: a15,
                    chieti: a15,
                    ci: a15,
                    cl: a15,
                    cn: a15,
                    co: a15,
                    como: a15,
                    cosenza: a15,
                    cr: a15,
                    cremona: a15,
                    crotone: a15,
                    cs: a15,
                    ct: a15,
                    cuneo: a15,
                    cz: a15,
                    "dell-ogliastra": a15,
                    dellogliastra: a15,
                    en: a15,
                    enna: a15,
                    fc: a15,
                    fe: a15,
                    fermo: a15,
                    ferrara: a15,
                    fg: a15,
                    fi: a15,
                    firenze: a15,
                    florence: a15,
                    fm: a15,
                    foggia: a15,
                    "forli-cesena": a15,
                    "xn--forl-cesena-fcb": a15,
                    "forlì-cesena": a15,
                    forlicesena: a15,
                    "xn--forlcesena-c8a": a15,
                    "forlìcesena": a15,
                    fr: a15,
                    frosinone: a15,
                    ge: a15,
                    genoa: a15,
                    genova: a15,
                    go: a15,
                    gorizia: a15,
                    gr: a15,
                    grosseto: a15,
                    "iglesias-carbonia": a15,
                    iglesiascarbonia: a15,
                    im: a15,
                    imperia: a15,
                    is: a15,
                    isernia: a15,
                    kr: a15,
                    "la-spezia": a15,
                    laquila: a15,
                    laspezia: a15,
                    latina: a15,
                    lc: a15,
                    le: a15,
                    lecce: a15,
                    lecco: a15,
                    li: a15,
                    livorno: a15,
                    lo: a15,
                    lodi: a15,
                    lt: a15,
                    lu: a15,
                    lucca: a15,
                    macerata: a15,
                    mantova: a15,
                    "massa-carrara": a15,
                    massacarrara: a15,
                    matera: a15,
                    mb: a15,
                    mc: a15,
                    me: a15,
                    "medio-campidano": a15,
                    mediocampidano: a15,
                    messina: a15,
                    mi: a15,
                    milan: a15,
                    milano: a15,
                    mn: a15,
                    mo: a15,
                    modena: a15,
                    "monza-brianza": a15,
                    "monza-e-della-brianza": a15,
                    monza: a15,
                    monzabrianza: a15,
                    monzaebrianza: a15,
                    monzaedellabrianza: a15,
                    ms: a15,
                    mt: a15,
                    na: a15,
                    naples: a15,
                    napoli: a15,
                    no: a15,
                    novara: a15,
                    nu: a15,
                    nuoro: a15,
                    og: a15,
                    ogliastra: a15,
                    "olbia-tempio": a15,
                    olbiatempio: a15,
                    or: a15,
                    oristano: a15,
                    ot: a15,
                    pa: a15,
                    padova: a15,
                    padua: a15,
                    palermo: a15,
                    parma: a15,
                    pavia: a15,
                    pc: a15,
                    pd: a15,
                    pe: a15,
                    perugia: a15,
                    "pesaro-urbino": a15,
                    pesarourbino: a15,
                    pescara: a15,
                    pg: a15,
                    pi: a15,
                    piacenza: a15,
                    pisa: a15,
                    pistoia: a15,
                    pn: a15,
                    po: a15,
                    pordenone: a15,
                    potenza: a15,
                    pr: a15,
                    prato: a15,
                    pt: a15,
                    pu: a15,
                    pv: a15,
                    pz: a15,
                    ra: a15,
                    ragusa: a15,
                    ravenna: a15,
                    rc: a15,
                    re: a15,
                    "reggio-calabria": a15,
                    "reggio-emilia": a15,
                    reggiocalabria: a15,
                    reggioemilia: a15,
                    rg: a15,
                    ri: a15,
                    rieti: a15,
                    rimini: a15,
                    rm: a15,
                    rn: a15,
                    ro: a15,
                    roma: a15,
                    rome: a15,
                    rovigo: a15,
                    sa: a15,
                    salerno: a15,
                    sassari: a15,
                    savona: a15,
                    si: a15,
                    siena: a15,
                    siracusa: a15,
                    so: a15,
                    sondrio: a15,
                    sp: a15,
                    sr: a15,
                    ss: a15,
                    suedtirol: a15,
                    "xn--sdtirol-n2a": a15,
                    "südtirol": a15,
                    sv: a15,
                    ta: a15,
                    taranto: a15,
                    te: a15,
                    "tempio-olbia": a15,
                    tempioolbia: a15,
                    teramo: a15,
                    terni: a15,
                    tn: a15,
                    to: a15,
                    torino: a15,
                    tp: a15,
                    tr: a15,
                    "trani-andria-barletta": a15,
                    "trani-barletta-andria": a15,
                    traniandriabarletta: a15,
                    tranibarlettaandria: a15,
                    trapani: a15,
                    trento: a15,
                    treviso: a15,
                    trieste: a15,
                    ts: a15,
                    turin: a15,
                    tv: a15,
                    ud: a15,
                    udine: a15,
                    "urbino-pesaro": a15,
                    urbinopesaro: a15,
                    va: a15,
                    varese: a15,
                    vb: a15,
                    vc: a15,
                    ve: a15,
                    venezia: a15,
                    venice: a15,
                    verbania: a15,
                    vercelli: a15,
                    verona: a15,
                    vi: a15,
                    "vibo-valentia": a15,
                    vibovalentia: a15,
                    vicenza: a15,
                    viterbo: a15,
                    vr: a15,
                    vs: a15,
                    vt: a15,
                    vv: a15,
                    blogspot: o16,
                    neen: {
                        $: 0,
                        succ: {
                            jc: o16
                        }
                    },
                    tim: {
                        $: 0,
                        succ: {
                            open: {
                                $: 0,
                                succ: {
                                    jelastic: t4
                                }
                            }
                        }
                    },
                    "16-b": o16,
                    "32-b": o16,
                    "64-b": o16,
                    myspreadshop: o16,
                    syncloud: o16
                }
            },
            je: {
                $: 1,
                succ: {
                    co: a15,
                    net: a15,
                    org: a15,
                    of: o16
                }
            },
            jm: r6,
            jo: {
                $: 1,
                succ: {
                    com: a15,
                    org: a15,
                    net: a15,
                    edu: a15,
                    sch: a15,
                    gov: a15,
                    mil: a15,
                    name: a15
                }
            },
            jobs: a15,
            jp: {
                $: 1,
                succ: {
                    ac: a15,
                    ad: a15,
                    co: a15,
                    ed: a15,
                    go: a15,
                    gr: a15,
                    lg: a15,
                    ne: {
                        $: 1,
                        succ: {
                            aseinet: $,
                            gehirn: o16
                        }
                    },
                    or: a15,
                    aichi: {
                        $: 1,
                        succ: {
                            aisai: a15,
                            ama: a15,
                            anjo: a15,
                            asuke: a15,
                            chiryu: a15,
                            chita: a15,
                            fuso: a15,
                            gamagori: a15,
                            handa: a15,
                            hazu: a15,
                            hekinan: a15,
                            higashiura: a15,
                            ichinomiya: a15,
                            inazawa: a15,
                            inuyama: a15,
                            isshiki: a15,
                            iwakura: a15,
                            kanie: a15,
                            kariya: a15,
                            kasugai: a15,
                            kira: a15,
                            kiyosu: a15,
                            komaki: a15,
                            konan: a15,
                            kota: a15,
                            mihama: a15,
                            miyoshi: a15,
                            nishio: a15,
                            nisshin: a15,
                            obu: a15,
                            oguchi: a15,
                            oharu: a15,
                            okazaki: a15,
                            owariasahi: a15,
                            seto: a15,
                            shikatsu: a15,
                            shinshiro: a15,
                            shitara: a15,
                            tahara: a15,
                            takahama: a15,
                            tobishima: a15,
                            toei: a15,
                            togo: a15,
                            tokai: a15,
                            tokoname: a15,
                            toyoake: a15,
                            toyohashi: a15,
                            toyokawa: a15,
                            toyone: a15,
                            toyota: a15,
                            tsushima: a15,
                            yatomi: a15
                        }
                    },
                    akita: {
                        $: 1,
                        succ: {
                            akita: a15,
                            daisen: a15,
                            fujisato: a15,
                            gojome: a15,
                            hachirogata: a15,
                            happou: a15,
                            higashinaruse: a15,
                            honjo: a15,
                            honjyo: a15,
                            ikawa: a15,
                            kamikoani: a15,
                            kamioka: a15,
                            katagami: a15,
                            kazuno: a15,
                            kitaakita: a15,
                            kosaka: a15,
                            kyowa: a15,
                            misato: a15,
                            mitane: a15,
                            moriyoshi: a15,
                            nikaho: a15,
                            noshiro: a15,
                            odate: a15,
                            oga: a15,
                            ogata: a15,
                            semboku: a15,
                            yokote: a15,
                            yurihonjo: a15
                        }
                    },
                    aomori: {
                        $: 1,
                        succ: {
                            aomori: a15,
                            gonohe: a15,
                            hachinohe: a15,
                            hashikami: a15,
                            hiranai: a15,
                            hirosaki: a15,
                            itayanagi: a15,
                            kuroishi: a15,
                            misawa: a15,
                            mutsu: a15,
                            nakadomari: a15,
                            noheji: a15,
                            oirase: a15,
                            owani: a15,
                            rokunohe: a15,
                            sannohe: a15,
                            shichinohe: a15,
                            shingo: a15,
                            takko: a15,
                            towada: a15,
                            tsugaru: a15,
                            tsuruta: a15
                        }
                    },
                    chiba: {
                        $: 1,
                        succ: {
                            abiko: a15,
                            asahi: a15,
                            chonan: a15,
                            chosei: a15,
                            choshi: a15,
                            chuo: a15,
                            funabashi: a15,
                            futtsu: a15,
                            hanamigawa: a15,
                            ichihara: a15,
                            ichikawa: a15,
                            ichinomiya: a15,
                            inzai: a15,
                            isumi: a15,
                            kamagaya: a15,
                            kamogawa: a15,
                            kashiwa: a15,
                            katori: a15,
                            katsuura: a15,
                            kimitsu: a15,
                            kisarazu: a15,
                            kozaki: a15,
                            kujukuri: a15,
                            kyonan: a15,
                            matsudo: a15,
                            midori: a15,
                            mihama: a15,
                            minamiboso: a15,
                            mobara: a15,
                            mutsuzawa: a15,
                            nagara: a15,
                            nagareyama: a15,
                            narashino: a15,
                            narita: a15,
                            noda: a15,
                            oamishirasato: a15,
                            omigawa: a15,
                            onjuku: a15,
                            otaki: a15,
                            sakae: a15,
                            sakura: a15,
                            shimofusa: a15,
                            shirako: a15,
                            shiroi: a15,
                            shisui: a15,
                            sodegaura: a15,
                            sosa: a15,
                            tako: a15,
                            tateyama: a15,
                            togane: a15,
                            tohnosho: a15,
                            tomisato: a15,
                            urayasu: a15,
                            yachimata: a15,
                            yachiyo: a15,
                            yokaichiba: a15,
                            yokoshibahikari: a15,
                            yotsukaido: a15
                        }
                    },
                    ehime: {
                        $: 1,
                        succ: {
                            ainan: a15,
                            honai: a15,
                            ikata: a15,
                            imabari: a15,
                            iyo: a15,
                            kamijima: a15,
                            kihoku: a15,
                            kumakogen: a15,
                            masaki: a15,
                            matsuno: a15,
                            matsuyama: a15,
                            namikata: a15,
                            niihama: a15,
                            ozu: a15,
                            saijo: a15,
                            seiyo: a15,
                            shikokuchuo: a15,
                            tobe: a15,
                            toon: a15,
                            uchiko: a15,
                            uwajima: a15,
                            yawatahama: a15
                        }
                    },
                    fukui: {
                        $: 1,
                        succ: {
                            echizen: a15,
                            eiheiji: a15,
                            fukui: a15,
                            ikeda: a15,
                            katsuyama: a15,
                            mihama: a15,
                            minamiechizen: a15,
                            obama: a15,
                            ohi: a15,
                            ono: a15,
                            sabae: a15,
                            sakai: a15,
                            takahama: a15,
                            tsuruga: a15,
                            wakasa: a15
                        }
                    },
                    fukuoka: {
                        $: 1,
                        succ: {
                            ashiya: a15,
                            buzen: a15,
                            chikugo: a15,
                            chikuho: a15,
                            chikujo: a15,
                            chikushino: a15,
                            chikuzen: a15,
                            chuo: a15,
                            dazaifu: a15,
                            fukuchi: a15,
                            hakata: a15,
                            higashi: a15,
                            hirokawa: a15,
                            hisayama: a15,
                            iizuka: a15,
                            inatsuki: a15,
                            kaho: a15,
                            kasuga: a15,
                            kasuya: a15,
                            kawara: a15,
                            keisen: a15,
                            koga: a15,
                            kurate: a15,
                            kurogi: a15,
                            kurume: a15,
                            minami: a15,
                            miyako: a15,
                            miyama: a15,
                            miyawaka: a15,
                            mizumaki: a15,
                            munakata: a15,
                            nakagawa: a15,
                            nakama: a15,
                            nishi: a15,
                            nogata: a15,
                            ogori: a15,
                            okagaki: a15,
                            okawa: a15,
                            oki: a15,
                            omuta: a15,
                            onga: a15,
                            onojo: a15,
                            oto: a15,
                            saigawa: a15,
                            sasaguri: a15,
                            shingu: a15,
                            shinyoshitomi: a15,
                            shonai: a15,
                            soeda: a15,
                            sue: a15,
                            tachiarai: a15,
                            tagawa: a15,
                            takata: a15,
                            toho: a15,
                            toyotsu: a15,
                            tsuiki: a15,
                            ukiha: a15,
                            umi: a15,
                            usui: a15,
                            yamada: a15,
                            yame: a15,
                            yanagawa: a15,
                            yukuhashi: a15
                        }
                    },
                    fukushima: {
                        $: 1,
                        succ: {
                            aizubange: a15,
                            aizumisato: a15,
                            aizuwakamatsu: a15,
                            asakawa: a15,
                            bandai: a15,
                            date: a15,
                            fukushima: a15,
                            furudono: a15,
                            futaba: a15,
                            hanawa: a15,
                            higashi: a15,
                            hirata: a15,
                            hirono: a15,
                            iitate: a15,
                            inawashiro: a15,
                            ishikawa: a15,
                            iwaki: a15,
                            izumizaki: a15,
                            kagamiishi: a15,
                            kaneyama: a15,
                            kawamata: a15,
                            kitakata: a15,
                            kitashiobara: a15,
                            koori: a15,
                            koriyama: a15,
                            kunimi: a15,
                            miharu: a15,
                            mishima: a15,
                            namie: a15,
                            nango: a15,
                            nishiaizu: a15,
                            nishigo: a15,
                            okuma: a15,
                            omotego: a15,
                            ono: a15,
                            otama: a15,
                            samegawa: a15,
                            shimogo: a15,
                            shirakawa: a15,
                            showa: a15,
                            soma: a15,
                            sukagawa: a15,
                            taishin: a15,
                            tamakawa: a15,
                            tanagura: a15,
                            tenei: a15,
                            yabuki: a15,
                            yamato: a15,
                            yamatsuri: a15,
                            yanaizu: a15,
                            yugawa: a15
                        }
                    },
                    gifu: {
                        $: 1,
                        succ: {
                            anpachi: a15,
                            ena: a15,
                            gifu: a15,
                            ginan: a15,
                            godo: a15,
                            gujo: a15,
                            hashima: a15,
                            hichiso: a15,
                            hida: a15,
                            higashishirakawa: a15,
                            ibigawa: a15,
                            ikeda: a15,
                            kakamigahara: a15,
                            kani: a15,
                            kasahara: a15,
                            kasamatsu: a15,
                            kawaue: a15,
                            kitagata: a15,
                            mino: a15,
                            minokamo: a15,
                            mitake: a15,
                            mizunami: a15,
                            motosu: a15,
                            nakatsugawa: a15,
                            ogaki: a15,
                            sakahogi: a15,
                            seki: a15,
                            sekigahara: a15,
                            shirakawa: a15,
                            tajimi: a15,
                            takayama: a15,
                            tarui: a15,
                            toki: a15,
                            tomika: a15,
                            wanouchi: a15,
                            yamagata: a15,
                            yaotsu: a15,
                            yoro: a15
                        }
                    },
                    gunma: {
                        $: 1,
                        succ: {
                            annaka: a15,
                            chiyoda: a15,
                            fujioka: a15,
                            higashiagatsuma: a15,
                            isesaki: a15,
                            itakura: a15,
                            kanna: a15,
                            kanra: a15,
                            katashina: a15,
                            kawaba: a15,
                            kiryu: a15,
                            kusatsu: a15,
                            maebashi: a15,
                            meiwa: a15,
                            midori: a15,
                            minakami: a15,
                            naganohara: a15,
                            nakanojo: a15,
                            nanmoku: a15,
                            numata: a15,
                            oizumi: a15,
                            ora: a15,
                            ota: a15,
                            shibukawa: a15,
                            shimonita: a15,
                            shinto: a15,
                            showa: a15,
                            takasaki: a15,
                            takayama: a15,
                            tamamura: a15,
                            tatebayashi: a15,
                            tomioka: a15,
                            tsukiyono: a15,
                            tsumagoi: a15,
                            ueno: a15,
                            yoshioka: a15
                        }
                    },
                    hiroshima: {
                        $: 1,
                        succ: {
                            asaminami: a15,
                            daiwa: a15,
                            etajima: a15,
                            fuchu: a15,
                            fukuyama: a15,
                            hatsukaichi: a15,
                            higashihiroshima: a15,
                            hongo: a15,
                            jinsekikogen: a15,
                            kaita: a15,
                            kui: a15,
                            kumano: a15,
                            kure: a15,
                            mihara: a15,
                            miyoshi: a15,
                            naka: a15,
                            onomichi: a15,
                            osakikamijima: a15,
                            otake: a15,
                            saka: a15,
                            sera: a15,
                            seranishi: a15,
                            shinichi: a15,
                            shobara: a15,
                            takehara: a15
                        }
                    },
                    hokkaido: {
                        $: 1,
                        succ: {
                            abashiri: a15,
                            abira: a15,
                            aibetsu: a15,
                            akabira: a15,
                            akkeshi: a15,
                            asahikawa: a15,
                            ashibetsu: a15,
                            ashoro: a15,
                            assabu: a15,
                            atsuma: a15,
                            bibai: a15,
                            biei: a15,
                            bifuka: a15,
                            bihoro: a15,
                            biratori: a15,
                            chippubetsu: a15,
                            chitose: a15,
                            date: a15,
                            ebetsu: a15,
                            embetsu: a15,
                            eniwa: a15,
                            erimo: a15,
                            esan: a15,
                            esashi: a15,
                            fukagawa: a15,
                            fukushima: a15,
                            furano: a15,
                            furubira: a15,
                            haboro: a15,
                            hakodate: a15,
                            hamatonbetsu: a15,
                            hidaka: a15,
                            higashikagura: a15,
                            higashikawa: a15,
                            hiroo: a15,
                            hokuryu: a15,
                            hokuto: a15,
                            honbetsu: a15,
                            horokanai: a15,
                            horonobe: a15,
                            ikeda: a15,
                            imakane: a15,
                            ishikari: a15,
                            iwamizawa: a15,
                            iwanai: a15,
                            kamifurano: a15,
                            kamikawa: a15,
                            kamishihoro: a15,
                            kamisunagawa: a15,
                            kamoenai: a15,
                            kayabe: a15,
                            kembuchi: a15,
                            kikonai: a15,
                            kimobetsu: a15,
                            kitahiroshima: a15,
                            kitami: a15,
                            kiyosato: a15,
                            koshimizu: a15,
                            kunneppu: a15,
                            kuriyama: a15,
                            kuromatsunai: a15,
                            kushiro: a15,
                            kutchan: a15,
                            kyowa: a15,
                            mashike: a15,
                            matsumae: a15,
                            mikasa: a15,
                            minamifurano: a15,
                            mombetsu: a15,
                            moseushi: a15,
                            mukawa: a15,
                            muroran: a15,
                            naie: a15,
                            nakagawa: a15,
                            nakasatsunai: a15,
                            nakatombetsu: a15,
                            nanae: a15,
                            nanporo: a15,
                            nayoro: a15,
                            nemuro: a15,
                            niikappu: a15,
                            niki: a15,
                            nishiokoppe: a15,
                            noboribetsu: a15,
                            numata: a15,
                            obihiro: a15,
                            obira: a15,
                            oketo: a15,
                            okoppe: a15,
                            otaru: a15,
                            otobe: a15,
                            otofuke: a15,
                            otoineppu: a15,
                            oumu: a15,
                            ozora: a15,
                            pippu: a15,
                            rankoshi: a15,
                            rebun: a15,
                            rikubetsu: a15,
                            rishiri: a15,
                            rishirifuji: a15,
                            saroma: a15,
                            sarufutsu: a15,
                            shakotan: a15,
                            shari: a15,
                            shibecha: a15,
                            shibetsu: a15,
                            shikabe: a15,
                            shikaoi: a15,
                            shimamaki: a15,
                            shimizu: a15,
                            shimokawa: a15,
                            shinshinotsu: a15,
                            shintoku: a15,
                            shiranuka: a15,
                            shiraoi: a15,
                            shiriuchi: a15,
                            sobetsu: a15,
                            sunagawa: a15,
                            taiki: a15,
                            takasu: a15,
                            takikawa: a15,
                            takinoue: a15,
                            teshikaga: a15,
                            tobetsu: a15,
                            tohma: a15,
                            tomakomai: a15,
                            tomari: a15,
                            toya: a15,
                            toyako: a15,
                            toyotomi: a15,
                            toyoura: a15,
                            tsubetsu: a15,
                            tsukigata: a15,
                            urakawa: a15,
                            urausu: a15,
                            uryu: a15,
                            utashinai: a15,
                            wakkanai: a15,
                            wassamu: a15,
                            yakumo: a15,
                            yoichi: a15
                        }
                    },
                    hyogo: {
                        $: 1,
                        succ: {
                            aioi: a15,
                            akashi: a15,
                            ako: a15,
                            amagasaki: a15,
                            aogaki: a15,
                            asago: a15,
                            ashiya: a15,
                            awaji: a15,
                            fukusaki: a15,
                            goshiki: a15,
                            harima: a15,
                            himeji: a15,
                            ichikawa: a15,
                            inagawa: a15,
                            itami: a15,
                            kakogawa: a15,
                            kamigori: a15,
                            kamikawa: a15,
                            kasai: a15,
                            kasuga: a15,
                            kawanishi: a15,
                            miki: a15,
                            minamiawaji: a15,
                            nishinomiya: a15,
                            nishiwaki: a15,
                            ono: a15,
                            sanda: a15,
                            sannan: a15,
                            sasayama: a15,
                            sayo: a15,
                            shingu: a15,
                            shinonsen: a15,
                            shiso: a15,
                            sumoto: a15,
                            taishi: a15,
                            taka: a15,
                            takarazuka: a15,
                            takasago: a15,
                            takino: a15,
                            tamba: a15,
                            tatsuno: a15,
                            toyooka: a15,
                            yabu: a15,
                            yashiro: a15,
                            yoka: a15,
                            yokawa: a15
                        }
                    },
                    ibaraki: {
                        $: 1,
                        succ: {
                            ami: a15,
                            asahi: a15,
                            bando: a15,
                            chikusei: a15,
                            daigo: a15,
                            fujishiro: a15,
                            hitachi: a15,
                            hitachinaka: a15,
                            hitachiomiya: a15,
                            hitachiota: a15,
                            ibaraki: a15,
                            ina: a15,
                            inashiki: a15,
                            itako: a15,
                            iwama: a15,
                            joso: a15,
                            kamisu: a15,
                            kasama: a15,
                            kashima: a15,
                            kasumigaura: a15,
                            koga: a15,
                            miho: a15,
                            mito: a15,
                            moriya: a15,
                            naka: a15,
                            namegata: a15,
                            oarai: a15,
                            ogawa: a15,
                            omitama: a15,
                            ryugasaki: a15,
                            sakai: a15,
                            sakuragawa: a15,
                            shimodate: a15,
                            shimotsuma: a15,
                            shirosato: a15,
                            sowa: a15,
                            suifu: a15,
                            takahagi: a15,
                            tamatsukuri: a15,
                            tokai: a15,
                            tomobe: a15,
                            tone: a15,
                            toride: a15,
                            tsuchiura: a15,
                            tsukuba: a15,
                            uchihara: a15,
                            ushiku: a15,
                            yachiyo: a15,
                            yamagata: a15,
                            yawara: a15,
                            yuki: a15
                        }
                    },
                    ishikawa: {
                        $: 1,
                        succ: {
                            anamizu: a15,
                            hakui: a15,
                            hakusan: a15,
                            kaga: a15,
                            kahoku: a15,
                            kanazawa: a15,
                            kawakita: a15,
                            komatsu: a15,
                            nakanoto: a15,
                            nanao: a15,
                            nomi: a15,
                            nonoichi: a15,
                            noto: a15,
                            shika: a15,
                            suzu: a15,
                            tsubata: a15,
                            tsurugi: a15,
                            uchinada: a15,
                            wajima: a15
                        }
                    },
                    iwate: {
                        $: 1,
                        succ: {
                            fudai: a15,
                            fujisawa: a15,
                            hanamaki: a15,
                            hiraizumi: a15,
                            hirono: a15,
                            ichinohe: a15,
                            ichinoseki: a15,
                            iwaizumi: a15,
                            iwate: a15,
                            joboji: a15,
                            kamaishi: a15,
                            kanegasaki: a15,
                            karumai: a15,
                            kawai: a15,
                            kitakami: a15,
                            kuji: a15,
                            kunohe: a15,
                            kuzumaki: a15,
                            miyako: a15,
                            mizusawa: a15,
                            morioka: a15,
                            ninohe: a15,
                            noda: a15,
                            ofunato: a15,
                            oshu: a15,
                            otsuchi: a15,
                            rikuzentakata: a15,
                            shiwa: a15,
                            shizukuishi: a15,
                            sumita: a15,
                            tanohata: a15,
                            tono: a15,
                            yahaba: a15,
                            yamada: a15
                        }
                    },
                    kagawa: {
                        $: 1,
                        succ: {
                            ayagawa: a15,
                            higashikagawa: a15,
                            kanonji: a15,
                            kotohira: a15,
                            manno: a15,
                            marugame: a15,
                            mitoyo: a15,
                            naoshima: a15,
                            sanuki: a15,
                            tadotsu: a15,
                            takamatsu: a15,
                            tonosho: a15,
                            uchinomi: a15,
                            utazu: a15,
                            zentsuji: a15
                        }
                    },
                    kagoshima: {
                        $: 1,
                        succ: {
                            akune: a15,
                            amami: a15,
                            hioki: a15,
                            isa: a15,
                            isen: a15,
                            izumi: a15,
                            kagoshima: a15,
                            kanoya: a15,
                            kawanabe: a15,
                            kinko: a15,
                            kouyama: a15,
                            makurazaki: a15,
                            matsumoto: a15,
                            minamitane: a15,
                            nakatane: a15,
                            nishinoomote: a15,
                            satsumasendai: a15,
                            soo: a15,
                            tarumizu: a15,
                            yusui: a15
                        }
                    },
                    kanagawa: {
                        $: 1,
                        succ: {
                            aikawa: a15,
                            atsugi: a15,
                            ayase: a15,
                            chigasaki: a15,
                            ebina: a15,
                            fujisawa: a15,
                            hadano: a15,
                            hakone: a15,
                            hiratsuka: a15,
                            isehara: a15,
                            kaisei: a15,
                            kamakura: a15,
                            kiyokawa: a15,
                            matsuda: a15,
                            minamiashigara: a15,
                            miura: a15,
                            nakai: a15,
                            ninomiya: a15,
                            odawara: a15,
                            oi: a15,
                            oiso: a15,
                            sagamihara: a15,
                            samukawa: a15,
                            tsukui: a15,
                            yamakita: a15,
                            yamato: a15,
                            yokosuka: a15,
                            yugawara: a15,
                            zama: a15,
                            zushi: a15
                        }
                    },
                    kochi: {
                        $: 1,
                        succ: {
                            aki: a15,
                            geisei: a15,
                            hidaka: a15,
                            higashitsuno: a15,
                            ino: a15,
                            kagami: a15,
                            kami: a15,
                            kitagawa: a15,
                            kochi: a15,
                            mihara: a15,
                            motoyama: a15,
                            muroto: a15,
                            nahari: a15,
                            nakamura: a15,
                            nankoku: a15,
                            nishitosa: a15,
                            niyodogawa: a15,
                            ochi: a15,
                            okawa: a15,
                            otoyo: a15,
                            otsuki: a15,
                            sakawa: a15,
                            sukumo: a15,
                            susaki: a15,
                            tosa: a15,
                            tosashimizu: a15,
                            toyo: a15,
                            tsuno: a15,
                            umaji: a15,
                            yasuda: a15,
                            yusuhara: a15
                        }
                    },
                    kumamoto: {
                        $: 1,
                        succ: {
                            amakusa: a15,
                            arao: a15,
                            aso: a15,
                            choyo: a15,
                            gyokuto: a15,
                            kamiamakusa: a15,
                            kikuchi: a15,
                            kumamoto: a15,
                            mashiki: a15,
                            mifune: a15,
                            minamata: a15,
                            minamioguni: a15,
                            nagasu: a15,
                            nishihara: a15,
                            oguni: a15,
                            ozu: a15,
                            sumoto: a15,
                            takamori: a15,
                            uki: a15,
                            uto: a15,
                            yamaga: a15,
                            yamato: a15,
                            yatsushiro: a15
                        }
                    },
                    kyoto: {
                        $: 1,
                        succ: {
                            ayabe: a15,
                            fukuchiyama: a15,
                            higashiyama: a15,
                            ide: a15,
                            ine: a15,
                            joyo: a15,
                            kameoka: a15,
                            kamo: a15,
                            kita: a15,
                            kizu: a15,
                            kumiyama: a15,
                            kyotamba: a15,
                            kyotanabe: a15,
                            kyotango: a15,
                            maizuru: a15,
                            minami: a15,
                            minamiyamashiro: a15,
                            miyazu: a15,
                            muko: a15,
                            nagaokakyo: a15,
                            nakagyo: a15,
                            nantan: a15,
                            oyamazaki: a15,
                            sakyo: a15,
                            seika: a15,
                            tanabe: a15,
                            uji: a15,
                            ujitawara: a15,
                            wazuka: a15,
                            yamashina: a15,
                            yawata: a15
                        }
                    },
                    mie: {
                        $: 1,
                        succ: {
                            asahi: a15,
                            inabe: a15,
                            ise: a15,
                            kameyama: a15,
                            kawagoe: a15,
                            kiho: a15,
                            kisosaki: a15,
                            kiwa: a15,
                            komono: a15,
                            kumano: a15,
                            kuwana: a15,
                            matsusaka: a15,
                            meiwa: a15,
                            mihama: a15,
                            minamiise: a15,
                            misugi: a15,
                            miyama: a15,
                            nabari: a15,
                            shima: a15,
                            suzuka: a15,
                            tado: a15,
                            taiki: a15,
                            taki: a15,
                            tamaki: a15,
                            toba: a15,
                            tsu: a15,
                            udono: a15,
                            ureshino: a15,
                            watarai: a15,
                            yokkaichi: a15
                        }
                    },
                    miyagi: {
                        $: 1,
                        succ: {
                            furukawa: a15,
                            higashimatsushima: a15,
                            ishinomaki: a15,
                            iwanuma: a15,
                            kakuda: a15,
                            kami: a15,
                            kawasaki: a15,
                            marumori: a15,
                            matsushima: a15,
                            minamisanriku: a15,
                            misato: a15,
                            murata: a15,
                            natori: a15,
                            ogawara: a15,
                            ohira: a15,
                            onagawa: a15,
                            osaki: a15,
                            rifu: a15,
                            semine: a15,
                            shibata: a15,
                            shichikashuku: a15,
                            shikama: a15,
                            shiogama: a15,
                            shiroishi: a15,
                            tagajo: a15,
                            taiwa: a15,
                            tome: a15,
                            tomiya: a15,
                            wakuya: a15,
                            watari: a15,
                            yamamoto: a15,
                            zao: a15
                        }
                    },
                    miyazaki: {
                        $: 1,
                        succ: {
                            aya: a15,
                            ebino: a15,
                            gokase: a15,
                            hyuga: a15,
                            kadogawa: a15,
                            kawaminami: a15,
                            kijo: a15,
                            kitagawa: a15,
                            kitakata: a15,
                            kitaura: a15,
                            kobayashi: a15,
                            kunitomi: a15,
                            kushima: a15,
                            mimata: a15,
                            miyakonojo: a15,
                            miyazaki: a15,
                            morotsuka: a15,
                            nichinan: a15,
                            nishimera: a15,
                            nobeoka: a15,
                            saito: a15,
                            shiiba: a15,
                            shintomi: a15,
                            takaharu: a15,
                            takanabe: a15,
                            takazaki: a15,
                            tsuno: a15
                        }
                    },
                    nagano: {
                        $: 1,
                        succ: {
                            achi: a15,
                            agematsu: a15,
                            anan: a15,
                            aoki: a15,
                            asahi: a15,
                            azumino: a15,
                            chikuhoku: a15,
                            chikuma: a15,
                            chino: a15,
                            fujimi: a15,
                            hakuba: a15,
                            hara: a15,
                            hiraya: a15,
                            iida: a15,
                            iijima: a15,
                            iiyama: a15,
                            iizuna: a15,
                            ikeda: a15,
                            ikusaka: a15,
                            ina: a15,
                            karuizawa: a15,
                            kawakami: a15,
                            kiso: a15,
                            kisofukushima: a15,
                            kitaaiki: a15,
                            komagane: a15,
                            komoro: a15,
                            matsukawa: a15,
                            matsumoto: a15,
                            miasa: a15,
                            minamiaiki: a15,
                            minamimaki: a15,
                            minamiminowa: a15,
                            minowa: a15,
                            miyada: a15,
                            miyota: a15,
                            mochizuki: a15,
                            nagano: a15,
                            nagawa: a15,
                            nagiso: a15,
                            nakagawa: a15,
                            nakano: a15,
                            nozawaonsen: a15,
                            obuse: a15,
                            ogawa: a15,
                            okaya: a15,
                            omachi: a15,
                            omi: a15,
                            ookuwa: a15,
                            ooshika: a15,
                            otaki: a15,
                            otari: a15,
                            sakae: a15,
                            sakaki: a15,
                            saku: a15,
                            sakuho: a15,
                            shimosuwa: a15,
                            shinanomachi: a15,
                            shiojiri: a15,
                            suwa: a15,
                            suzaka: a15,
                            takagi: a15,
                            takamori: a15,
                            takayama: a15,
                            tateshina: a15,
                            tatsuno: a15,
                            togakushi: a15,
                            togura: a15,
                            tomi: a15,
                            ueda: a15,
                            wada: a15,
                            yamagata: a15,
                            yamanouchi: a15,
                            yasaka: a15,
                            yasuoka: a15
                        }
                    },
                    nagasaki: {
                        $: 1,
                        succ: {
                            chijiwa: a15,
                            futsu: a15,
                            goto: a15,
                            hasami: a15,
                            hirado: a15,
                            iki: a15,
                            isahaya: a15,
                            kawatana: a15,
                            kuchinotsu: a15,
                            matsuura: a15,
                            nagasaki: a15,
                            obama: a15,
                            omura: a15,
                            oseto: a15,
                            saikai: a15,
                            sasebo: a15,
                            seihi: a15,
                            shimabara: a15,
                            shinkamigoto: a15,
                            togitsu: a15,
                            tsushima: a15,
                            unzen: a15
                        }
                    },
                    nara: {
                        $: 1,
                        succ: {
                            ando: a15,
                            gose: a15,
                            heguri: a15,
                            higashiyoshino: a15,
                            ikaruga: a15,
                            ikoma: a15,
                            kamikitayama: a15,
                            kanmaki: a15,
                            kashiba: a15,
                            kashihara: a15,
                            katsuragi: a15,
                            kawai: a15,
                            kawakami: a15,
                            kawanishi: a15,
                            koryo: a15,
                            kurotaki: a15,
                            mitsue: a15,
                            miyake: a15,
                            nara: a15,
                            nosegawa: a15,
                            oji: a15,
                            ouda: a15,
                            oyodo: a15,
                            sakurai: a15,
                            sango: a15,
                            shimoichi: a15,
                            shimokitayama: a15,
                            shinjo: a15,
                            soni: a15,
                            takatori: a15,
                            tawaramoto: a15,
                            tenkawa: a15,
                            tenri: a15,
                            uda: a15,
                            yamatokoriyama: a15,
                            yamatotakada: a15,
                            yamazoe: a15,
                            yoshino: a15
                        }
                    },
                    niigata: {
                        $: 1,
                        succ: {
                            aga: a15,
                            agano: a15,
                            gosen: a15,
                            itoigawa: a15,
                            izumozaki: a15,
                            joetsu: a15,
                            kamo: a15,
                            kariwa: a15,
                            kashiwazaki: a15,
                            minamiuonuma: a15,
                            mitsuke: a15,
                            muika: a15,
                            murakami: a15,
                            myoko: a15,
                            nagaoka: a15,
                            niigata: a15,
                            ojiya: a15,
                            omi: a15,
                            sado: a15,
                            sanjo: a15,
                            seiro: a15,
                            seirou: a15,
                            sekikawa: a15,
                            shibata: a15,
                            tagami: a15,
                            tainai: a15,
                            tochio: a15,
                            tokamachi: a15,
                            tsubame: a15,
                            tsunan: a15,
                            uonuma: a15,
                            yahiko: a15,
                            yoita: a15,
                            yuzawa: a15
                        }
                    },
                    oita: {
                        $: 1,
                        succ: {
                            beppu: a15,
                            bungoono: a15,
                            bungotakada: a15,
                            hasama: a15,
                            hiji: a15,
                            himeshima: a15,
                            hita: a15,
                            kamitsue: a15,
                            kokonoe: a15,
                            kuju: a15,
                            kunisaki: a15,
                            kusu: a15,
                            oita: a15,
                            saiki: a15,
                            taketa: a15,
                            tsukumi: a15,
                            usa: a15,
                            usuki: a15,
                            yufu: a15
                        }
                    },
                    okayama: {
                        $: 1,
                        succ: {
                            akaiwa: a15,
                            asakuchi: a15,
                            bizen: a15,
                            hayashima: a15,
                            ibara: a15,
                            kagamino: a15,
                            kasaoka: a15,
                            kibichuo: a15,
                            kumenan: a15,
                            kurashiki: a15,
                            maniwa: a15,
                            misaki: a15,
                            nagi: a15,
                            niimi: a15,
                            nishiawakura: a15,
                            okayama: a15,
                            satosho: a15,
                            setouchi: a15,
                            shinjo: a15,
                            shoo: a15,
                            soja: a15,
                            takahashi: a15,
                            tamano: a15,
                            tsuyama: a15,
                            wake: a15,
                            yakage: a15
                        }
                    },
                    okinawa: {
                        $: 1,
                        succ: {
                            aguni: a15,
                            ginowan: a15,
                            ginoza: a15,
                            gushikami: a15,
                            haebaru: a15,
                            higashi: a15,
                            hirara: a15,
                            iheya: a15,
                            ishigaki: a15,
                            ishikawa: a15,
                            itoman: a15,
                            izena: a15,
                            kadena: a15,
                            kin: a15,
                            kitadaito: a15,
                            kitanakagusuku: a15,
                            kumejima: a15,
                            kunigami: a15,
                            minamidaito: a15,
                            motobu: a15,
                            nago: a15,
                            naha: a15,
                            nakagusuku: a15,
                            nakijin: a15,
                            nanjo: a15,
                            nishihara: a15,
                            ogimi: a15,
                            okinawa: a15,
                            onna: a15,
                            shimoji: a15,
                            taketomi: a15,
                            tarama: a15,
                            tokashiki: a15,
                            tomigusuku: a15,
                            tonaki: a15,
                            urasoe: a15,
                            uruma: a15,
                            yaese: a15,
                            yomitan: a15,
                            yonabaru: a15,
                            yonaguni: a15,
                            zamami: a15
                        }
                    },
                    osaka: {
                        $: 1,
                        succ: {
                            abeno: a15,
                            chihayaakasaka: a15,
                            chuo: a15,
                            daito: a15,
                            fujiidera: a15,
                            habikino: a15,
                            hannan: a15,
                            higashiosaka: a15,
                            higashisumiyoshi: a15,
                            higashiyodogawa: a15,
                            hirakata: a15,
                            ibaraki: a15,
                            ikeda: a15,
                            izumi: a15,
                            izumiotsu: a15,
                            izumisano: a15,
                            kadoma: a15,
                            kaizuka: a15,
                            kanan: a15,
                            kashiwara: a15,
                            katano: a15,
                            kawachinagano: a15,
                            kishiwada: a15,
                            kita: a15,
                            kumatori: a15,
                            matsubara: a15,
                            minato: a15,
                            minoh: a15,
                            misaki: a15,
                            moriguchi: a15,
                            neyagawa: a15,
                            nishi: a15,
                            nose: a15,
                            osakasayama: a15,
                            sakai: a15,
                            sayama: a15,
                            sennan: a15,
                            settsu: a15,
                            shijonawate: a15,
                            shimamoto: a15,
                            suita: a15,
                            tadaoka: a15,
                            taishi: a15,
                            tajiri: a15,
                            takaishi: a15,
                            takatsuki: a15,
                            tondabayashi: a15,
                            toyonaka: a15,
                            toyono: a15,
                            yao: a15
                        }
                    },
                    saga: {
                        $: 1,
                        succ: {
                            ariake: a15,
                            arita: a15,
                            fukudomi: a15,
                            genkai: a15,
                            hamatama: a15,
                            hizen: a15,
                            imari: a15,
                            kamimine: a15,
                            kanzaki: a15,
                            karatsu: a15,
                            kashima: a15,
                            kitagata: a15,
                            kitahata: a15,
                            kiyama: a15,
                            kouhoku: a15,
                            kyuragi: a15,
                            nishiarita: a15,
                            ogi: a15,
                            omachi: a15,
                            ouchi: a15,
                            saga: a15,
                            shiroishi: a15,
                            taku: a15,
                            tara: a15,
                            tosu: a15,
                            yoshinogari: a15
                        }
                    },
                    saitama: {
                        $: 1,
                        succ: {
                            arakawa: a15,
                            asaka: a15,
                            chichibu: a15,
                            fujimi: a15,
                            fujimino: a15,
                            fukaya: a15,
                            hanno: a15,
                            hanyu: a15,
                            hasuda: a15,
                            hatogaya: a15,
                            hatoyama: a15,
                            hidaka: a15,
                            higashichichibu: a15,
                            higashimatsuyama: a15,
                            honjo: a15,
                            ina: a15,
                            iruma: a15,
                            iwatsuki: a15,
                            kamiizumi: a15,
                            kamikawa: a15,
                            kamisato: a15,
                            kasukabe: a15,
                            kawagoe: a15,
                            kawaguchi: a15,
                            kawajima: a15,
                            kazo: a15,
                            kitamoto: a15,
                            koshigaya: a15,
                            kounosu: a15,
                            kuki: a15,
                            kumagaya: a15,
                            matsubushi: a15,
                            minano: a15,
                            misato: a15,
                            miyashiro: a15,
                            miyoshi: a15,
                            moroyama: a15,
                            nagatoro: a15,
                            namegawa: a15,
                            niiza: a15,
                            ogano: a15,
                            ogawa: a15,
                            ogose: a15,
                            okegawa: a15,
                            omiya: a15,
                            otaki: a15,
                            ranzan: a15,
                            ryokami: a15,
                            saitama: a15,
                            sakado: a15,
                            satte: a15,
                            sayama: a15,
                            shiki: a15,
                            shiraoka: a15,
                            soka: a15,
                            sugito: a15,
                            toda: a15,
                            tokigawa: a15,
                            tokorozawa: a15,
                            tsurugashima: a15,
                            urawa: a15,
                            warabi: a15,
                            yashio: a15,
                            yokoze: a15,
                            yono: a15,
                            yorii: a15,
                            yoshida: a15,
                            yoshikawa: a15,
                            yoshimi: a15
                        }
                    },
                    shiga: {
                        $: 1,
                        succ: {
                            aisho: a15,
                            gamo: a15,
                            higashiomi: a15,
                            hikone: a15,
                            koka: a15,
                            konan: a15,
                            kosei: a15,
                            koto: a15,
                            kusatsu: a15,
                            maibara: a15,
                            moriyama: a15,
                            nagahama: a15,
                            nishiazai: a15,
                            notogawa: a15,
                            omihachiman: a15,
                            otsu: a15,
                            ritto: a15,
                            ryuoh: a15,
                            takashima: a15,
                            takatsuki: a15,
                            torahime: a15,
                            toyosato: a15,
                            yasu: a15
                        }
                    },
                    shimane: {
                        $: 1,
                        succ: {
                            akagi: a15,
                            ama: a15,
                            gotsu: a15,
                            hamada: a15,
                            higashiizumo: a15,
                            hikawa: a15,
                            hikimi: a15,
                            izumo: a15,
                            kakinoki: a15,
                            masuda: a15,
                            matsue: a15,
                            misato: a15,
                            nishinoshima: a15,
                            ohda: a15,
                            okinoshima: a15,
                            okuizumo: a15,
                            shimane: a15,
                            tamayu: a15,
                            tsuwano: a15,
                            unnan: a15,
                            yakumo: a15,
                            yasugi: a15,
                            yatsuka: a15
                        }
                    },
                    shizuoka: {
                        $: 1,
                        succ: {
                            arai: a15,
                            atami: a15,
                            fuji: a15,
                            fujieda: a15,
                            fujikawa: a15,
                            fujinomiya: a15,
                            fukuroi: a15,
                            gotemba: a15,
                            haibara: a15,
                            hamamatsu: a15,
                            higashiizu: a15,
                            ito: a15,
                            iwata: a15,
                            izu: a15,
                            izunokuni: a15,
                            kakegawa: a15,
                            kannami: a15,
                            kawanehon: a15,
                            kawazu: a15,
                            kikugawa: a15,
                            kosai: a15,
                            makinohara: a15,
                            matsuzaki: a15,
                            minamiizu: a15,
                            mishima: a15,
                            morimachi: a15,
                            nishiizu: a15,
                            numazu: a15,
                            omaezaki: a15,
                            shimada: a15,
                            shimizu: a15,
                            shimoda: a15,
                            shizuoka: a15,
                            susono: a15,
                            yaizu: a15,
                            yoshida: a15
                        }
                    },
                    tochigi: {
                        $: 1,
                        succ: {
                            ashikaga: a15,
                            bato: a15,
                            haga: a15,
                            ichikai: a15,
                            iwafune: a15,
                            kaminokawa: a15,
                            kanuma: a15,
                            karasuyama: a15,
                            kuroiso: a15,
                            mashiko: a15,
                            mibu: a15,
                            moka: a15,
                            motegi: a15,
                            nasu: a15,
                            nasushiobara: a15,
                            nikko: a15,
                            nishikata: a15,
                            nogi: a15,
                            ohira: a15,
                            ohtawara: a15,
                            oyama: a15,
                            sakura: a15,
                            sano: a15,
                            shimotsuke: a15,
                            shioya: a15,
                            takanezawa: a15,
                            tochigi: a15,
                            tsuga: a15,
                            ujiie: a15,
                            utsunomiya: a15,
                            yaita: a15
                        }
                    },
                    tokushima: {
                        $: 1,
                        succ: {
                            aizumi: a15,
                            anan: a15,
                            ichiba: a15,
                            itano: a15,
                            kainan: a15,
                            komatsushima: a15,
                            matsushige: a15,
                            mima: a15,
                            minami: a15,
                            miyoshi: a15,
                            mugi: a15,
                            nakagawa: a15,
                            naruto: a15,
                            sanagochi: a15,
                            shishikui: a15,
                            tokushima: a15,
                            wajiki: a15
                        }
                    },
                    tokyo: {
                        $: 1,
                        succ: {
                            adachi: a15,
                            akiruno: a15,
                            akishima: a15,
                            aogashima: a15,
                            arakawa: a15,
                            bunkyo: a15,
                            chiyoda: a15,
                            chofu: a15,
                            chuo: a15,
                            edogawa: a15,
                            fuchu: a15,
                            fussa: a15,
                            hachijo: a15,
                            hachioji: a15,
                            hamura: a15,
                            higashikurume: a15,
                            higashimurayama: a15,
                            higashiyamato: a15,
                            hino: a15,
                            hinode: a15,
                            hinohara: a15,
                            inagi: a15,
                            itabashi: a15,
                            katsushika: a15,
                            kita: a15,
                            kiyose: a15,
                            kodaira: a15,
                            koganei: a15,
                            kokubunji: a15,
                            komae: a15,
                            koto: a15,
                            kouzushima: a15,
                            kunitachi: a15,
                            machida: a15,
                            meguro: a15,
                            minato: a15,
                            mitaka: a15,
                            mizuho: a15,
                            musashimurayama: a15,
                            musashino: a15,
                            nakano: a15,
                            nerima: a15,
                            ogasawara: a15,
                            okutama: a15,
                            ome: a15,
                            oshima: a15,
                            ota: a15,
                            setagaya: a15,
                            shibuya: a15,
                            shinagawa: a15,
                            shinjuku: a15,
                            suginami: a15,
                            sumida: a15,
                            tachikawa: a15,
                            taito: a15,
                            tama: a15,
                            toshima: a15
                        }
                    },
                    tottori: {
                        $: 1,
                        succ: {
                            chizu: a15,
                            hino: a15,
                            kawahara: a15,
                            koge: a15,
                            kotoura: a15,
                            misasa: a15,
                            nanbu: a15,
                            nichinan: a15,
                            sakaiminato: a15,
                            tottori: a15,
                            wakasa: a15,
                            yazu: a15,
                            yonago: a15
                        }
                    },
                    toyama: {
                        $: 1,
                        succ: {
                            asahi: a15,
                            fuchu: a15,
                            fukumitsu: a15,
                            funahashi: a15,
                            himi: a15,
                            imizu: a15,
                            inami: a15,
                            johana: a15,
                            kamiichi: a15,
                            kurobe: a15,
                            nakaniikawa: a15,
                            namerikawa: a15,
                            nanto: a15,
                            nyuzen: a15,
                            oyabe: a15,
                            taira: a15,
                            takaoka: a15,
                            tateyama: a15,
                            toga: a15,
                            tonami: a15,
                            toyama: a15,
                            unazuki: a15,
                            uozu: a15,
                            yamada: a15
                        }
                    },
                    wakayama: {
                        $: 1,
                        succ: {
                            arida: a15,
                            aridagawa: a15,
                            gobo: a15,
                            hashimoto: a15,
                            hidaka: a15,
                            hirogawa: a15,
                            inami: a15,
                            iwade: a15,
                            kainan: a15,
                            kamitonda: a15,
                            katsuragi: a15,
                            kimino: a15,
                            kinokawa: a15,
                            kitayama: a15,
                            koya: a15,
                            koza: a15,
                            kozagawa: a15,
                            kudoyama: a15,
                            kushimoto: a15,
                            mihama: a15,
                            misato: a15,
                            nachikatsuura: a15,
                            shingu: a15,
                            shirahama: a15,
                            taiji: a15,
                            tanabe: a15,
                            wakayama: a15,
                            yuasa: a15,
                            yura: a15
                        }
                    },
                    yamagata: {
                        $: 1,
                        succ: {
                            asahi: a15,
                            funagata: a15,
                            higashine: a15,
                            iide: a15,
                            kahoku: a15,
                            kaminoyama: a15,
                            kaneyama: a15,
                            kawanishi: a15,
                            mamurogawa: a15,
                            mikawa: a15,
                            murayama: a15,
                            nagai: a15,
                            nakayama: a15,
                            nanyo: a15,
                            nishikawa: a15,
                            obanazawa: a15,
                            oe: a15,
                            oguni: a15,
                            ohkura: a15,
                            oishida: a15,
                            sagae: a15,
                            sakata: a15,
                            sakegawa: a15,
                            shinjo: a15,
                            shirataka: a15,
                            shonai: a15,
                            takahata: a15,
                            tendo: a15,
                            tozawa: a15,
                            tsuruoka: a15,
                            yamagata: a15,
                            yamanobe: a15,
                            yonezawa: a15,
                            yuza: a15
                        }
                    },
                    yamaguchi: {
                        $: 1,
                        succ: {
                            abu: a15,
                            hagi: a15,
                            hikari: a15,
                            hofu: a15,
                            iwakuni: a15,
                            kudamatsu: a15,
                            mitou: a15,
                            nagato: a15,
                            oshima: a15,
                            shimonoseki: a15,
                            shunan: a15,
                            tabuse: a15,
                            tokuyama: a15,
                            toyota: a15,
                            ube: a15,
                            yuu: a15
                        }
                    },
                    yamanashi: {
                        $: 1,
                        succ: {
                            chuo: a15,
                            doshi: a15,
                            fuefuki: a15,
                            fujikawa: a15,
                            fujikawaguchiko: a15,
                            fujiyoshida: a15,
                            hayakawa: a15,
                            hokuto: a15,
                            ichikawamisato: a15,
                            kai: a15,
                            kofu: a15,
                            koshu: a15,
                            kosuge: a15,
                            "minami-alps": a15,
                            minobu: a15,
                            nakamichi: a15,
                            nanbu: a15,
                            narusawa: a15,
                            nirasaki: a15,
                            nishikatsura: a15,
                            oshino: a15,
                            otsuki: a15,
                            showa: a15,
                            tabayama: a15,
                            tsuru: a15,
                            uenohara: a15,
                            yamanakako: a15,
                            yamanashi: a15
                        }
                    },
                    "xn--4pvxs": a15,
                    "栃木": a15,
                    "xn--vgu402c": a15,
                    "愛知": a15,
                    "xn--c3s14m": a15,
                    "愛媛": a15,
                    "xn--f6qx53a": a15,
                    "兵庫": a15,
                    "xn--8pvr4u": a15,
                    "熊本": a15,
                    "xn--uist22h": a15,
                    "茨城": a15,
                    "xn--djrs72d6uy": a15,
                    "北海道": a15,
                    "xn--mkru45i": a15,
                    "千葉": a15,
                    "xn--0trq7p7nn": a15,
                    "和歌山": a15,
                    "xn--8ltr62k": a15,
                    "長崎": a15,
                    "xn--2m4a15e": a15,
                    "長野": a15,
                    "xn--efvn9s": a15,
                    "新潟": a15,
                    "xn--32vp30h": a15,
                    "青森": a15,
                    "xn--4it797k": a15,
                    "静岡": a15,
                    "xn--1lqs71d": a15,
                    "東京": a15,
                    "xn--5rtp49c": a15,
                    "石川": a15,
                    "xn--5js045d": a15,
                    "埼玉": a15,
                    "xn--ehqz56n": a15,
                    "三重": a15,
                    "xn--1lqs03n": a15,
                    "京都": a15,
                    "xn--qqqt11m": a15,
                    "佐賀": a15,
                    "xn--kbrq7o": a15,
                    "大分": a15,
                    "xn--pssu33l": a15,
                    "大阪": a15,
                    "xn--ntsq17g": a15,
                    "奈良": a15,
                    "xn--uisz3g": a15,
                    "宮城": a15,
                    "xn--6btw5a": a15,
                    "宮崎": a15,
                    "xn--1ctwo": a15,
                    "富山": a15,
                    "xn--6orx2r": a15,
                    "山口": a15,
                    "xn--rht61e": a15,
                    "山形": a15,
                    "xn--rht27z": a15,
                    "山梨": a15,
                    "xn--djty4k": a15,
                    "岩手": a15,
                    "xn--nit225k": a15,
                    "岐阜": a15,
                    "xn--rht3d": a15,
                    "岡山": a15,
                    "xn--klty5x": a15,
                    "島根": a15,
                    "xn--kltx9a": a15,
                    "広島": a15,
                    "xn--kltp7d": a15,
                    "徳島": a15,
                    "xn--uuwu58a": a15,
                    "沖縄": a15,
                    "xn--zbx025d": a15,
                    "滋賀": a15,
                    "xn--ntso0iqx3a": a15,
                    "神奈川": a15,
                    "xn--elqq16h": a15,
                    "福井": a15,
                    "xn--4it168d": a15,
                    "福岡": a15,
                    "xn--klt787d": a15,
                    "福島": a15,
                    "xn--rny31h": a15,
                    "秋田": a15,
                    "xn--7t0a264c": a15,
                    "群馬": a15,
                    "xn--5rtq34k": a15,
                    "香川": a15,
                    "xn--k7yn95e": a15,
                    "高知": a15,
                    "xn--tor131o": a15,
                    "鳥取": a15,
                    "xn--d5qv7z876c": a15,
                    "鹿児島": a15,
                    kawasaki: r6,
                    kitakyushu: r6,
                    kobe: r6,
                    nagoya: r6,
                    sapporo: r6,
                    sendai: r6,
                    yokohama: r6,
                    buyshop: o16,
                    fashionstore: o16,
                    handcrafted: o16,
                    kawaiishop: o16,
                    supersale: o16,
                    theshop: o16,
                    usercontent: o16,
                    angry: o16,
                    babyblue: o16,
                    babymilk: o16,
                    backdrop: o16,
                    bambina: o16,
                    bitter: o16,
                    blush: o16,
                    boo: o16,
                    boy: o16,
                    boyfriend: o16,
                    but: o16,
                    candypop: o16,
                    capoo: o16,
                    catfood: o16,
                    cheap: o16,
                    chicappa: o16,
                    chillout: o16,
                    chips: o16,
                    chowder: o16,
                    chu: o16,
                    ciao: o16,
                    cocotte: o16,
                    coolblog: o16,
                    cranky: o16,
                    cutegirl: o16,
                    daa: o16,
                    deca: o16,
                    deci: o16,
                    digick: o16,
                    egoism: o16,
                    fakefur: o16,
                    fem: o16,
                    flier: o16,
                    floppy: o16,
                    fool: o16,
                    frenchkiss: o16,
                    girlfriend: o16,
                    girly: o16,
                    gloomy: o16,
                    gonna: o16,
                    greater: o16,
                    hacca: o16,
                    heavy: o16,
                    her: o16,
                    hiho: o16,
                    hippy: o16,
                    holy: o16,
                    hungry: o16,
                    icurus: o16,
                    itigo: o16,
                    jellybean: o16,
                    kikirara: o16,
                    kill: o16,
                    kilo: o16,
                    kuron: o16,
                    littlestar: o16,
                    lolitapunk: o16,
                    lomo: o16,
                    lovepop: o16,
                    lovesick: o16,
                    main: o16,
                    mods: o16,
                    mond: o16,
                    mongolian: o16,
                    moo: o16,
                    namaste: o16,
                    nikita: o16,
                    nobushi: o16,
                    noor: o16,
                    oops: o16,
                    parallel: o16,
                    parasite: o16,
                    pecori: o16,
                    peewee: o16,
                    penne: o16,
                    pepper: o16,
                    perma: o16,
                    pigboat: o16,
                    pinoko: o16,
                    punyu: o16,
                    pupu: o16,
                    pussycat: o16,
                    pya: o16,
                    raindrop: o16,
                    readymade: o16,
                    sadist: o16,
                    schoolbus: o16,
                    secret: o16,
                    staba: o16,
                    stripper: o16,
                    sub: o16,
                    sunnyday: o16,
                    thick: o16,
                    tonkotsu: o16,
                    under: o16,
                    upper: o16,
                    velvet: o16,
                    verse: o16,
                    versus: o16,
                    vivian: o16,
                    watson: o16,
                    weblike: o16,
                    whitesnow: o16,
                    zombie: o16,
                    blogspot: o16
                }
            },
            ke: {
                $: 1,
                succ: {
                    ac: a15,
                    co: s8,
                    go: a15,
                    info: a15,
                    me: a15,
                    mobi: a15,
                    ne: a15,
                    or: a15,
                    sc: a15
                }
            },
            kg: {
                $: 1,
                succ: {
                    org: a15,
                    net: a15,
                    com: a15,
                    edu: a15,
                    gov: a15,
                    mil: a15,
                    blog: o16,
                    io: o16,
                    jp: o16,
                    tv: o16,
                    uk: o16,
                    us: o16
                }
            },
            kh: r6,
            ki: S,
            km: {
                $: 1,
                succ: {
                    org: a15,
                    nom: a15,
                    gov: a15,
                    prd: a15,
                    tm: a15,
                    edu: a15,
                    mil: a15,
                    ass: a15,
                    com: a15,
                    coop: a15,
                    asso: a15,
                    presse: a15,
                    medecin: a15,
                    notaires: a15,
                    pharmaciens: a15,
                    veterinaire: a15,
                    gouv: a15
                }
            },
            kn: {
                $: 1,
                succ: {
                    net: a15,
                    org: a15,
                    edu: a15,
                    gov: a15
                }
            },
            kp: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    gov: a15,
                    org: a15,
                    rep: a15,
                    tra: a15
                }
            },
            kr: {
                $: 1,
                succ: {
                    ac: a15,
                    co: a15,
                    es: a15,
                    go: a15,
                    hs: a15,
                    kg: a15,
                    mil: a15,
                    ms: a15,
                    ne: a15,
                    or: a15,
                    pe: a15,
                    re: a15,
                    sc: a15,
                    busan: a15,
                    chungbuk: a15,
                    chungnam: a15,
                    daegu: a15,
                    daejeon: a15,
                    gangwon: a15,
                    gwangju: a15,
                    gyeongbuk: a15,
                    gyeonggi: a15,
                    gyeongnam: a15,
                    incheon: a15,
                    jeju: a15,
                    jeonbuk: a15,
                    jeonnam: a15,
                    seoul: a15,
                    ulsan: a15,
                    blogspot: o16
                }
            },
            kw: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    emb: a15,
                    gov: a15,
                    ind: a15,
                    net: a15,
                    org: a15
                }
            },
            ky: v,
            kz: {
                $: 1,
                succ: {
                    org: a15,
                    edu: a15,
                    net: a15,
                    gov: a15,
                    mil: a15,
                    com: a15,
                    jcloud: o16,
                    kazteleport: {
                        $: 0,
                        succ: {
                            upaas: o16
                        }
                    }
                }
            },
            la: {
                $: 1,
                succ: {
                    int: a15,
                    net: a15,
                    info: a15,
                    edu: a15,
                    gov: a15,
                    per: a15,
                    com: a15,
                    org: a15,
                    bnr: o16,
                    c: o16
                }
            },
            lb: i12,
            lc: {
                $: 1,
                succ: {
                    com: a15,
                    net: a15,
                    co: a15,
                    org: a15,
                    edu: a15,
                    gov: a15,
                    oy: o16
                }
            },
            li: {
                $: 1,
                succ: {
                    blogspot: o16,
                    caa: o16
                }
            },
            lk: {
                $: 1,
                succ: {
                    gov: a15,
                    sch: a15,
                    net: a15,
                    int: a15,
                    com: a15,
                    org: a15,
                    edu: a15,
                    ngo: a15,
                    soc: a15,
                    web: a15,
                    ltd: a15,
                    assn: a15,
                    grp: a15,
                    hotel: a15,
                    ac: a15
                }
            },
            lr: i12,
            ls: {
                $: 1,
                succ: {
                    ac: a15,
                    biz: a15,
                    co: a15,
                    edu: a15,
                    gov: a15,
                    info: a15,
                    net: a15,
                    org: a15,
                    sc: a15,
                    de: o16
                }
            },
            lt: C,
            lu: s8,
            lv: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    gov: a15,
                    org: a15,
                    mil: a15,
                    id: a15,
                    net: a15,
                    asn: a15,
                    conf: a15
                }
            },
            ly: {
                $: 1,
                succ: {
                    com: a15,
                    net: a15,
                    gov: a15,
                    plc: a15,
                    edu: a15,
                    sch: a15,
                    med: a15,
                    org: a15,
                    id: a15
                }
            },
            ma: {
                $: 1,
                succ: {
                    co: a15,
                    net: a15,
                    gov: a15,
                    org: a15,
                    ac: a15,
                    press: a15
                }
            },
            mc: {
                $: 1,
                succ: {
                    tm: a15,
                    asso: a15
                }
            },
            md: {
                $: 1,
                succ: {
                    blogspot: o16,
                    at: o16,
                    de: o16,
                    jp: o16,
                    to: o16
                }
            },
            me: {
                $: 1,
                succ: {
                    co: a15,
                    net: a15,
                    org: a15,
                    edu: a15,
                    ac: a15,
                    gov: a15,
                    its: a15,
                    priv: a15,
                    c66: o16,
                    daplie: {
                        $: 2,
                        succ: {
                            localhost: o16
                        }
                    },
                    edgestack: o16,
                    filegear: o16,
                    "filegear-au": o16,
                    "filegear-de": o16,
                    "filegear-gb": o16,
                    "filegear-ie": o16,
                    "filegear-jp": o16,
                    "filegear-sg": o16,
                    glitch: o16,
                    ravendb: o16,
                    lohmus: o16,
                    barsy: o16,
                    mcpe: o16,
                    mcdir: o16,
                    soundcast: o16,
                    tcp4: o16,
                    brasilia: o16,
                    ddns: o16,
                    dnsfor: o16,
                    hopto: o16,
                    loginto: o16,
                    noip: o16,
                    webhop: o16,
                    vp4: o16,
                    diskstation: o16,
                    dscloud: o16,
                    i234: o16,
                    myds: o16,
                    synology: o16,
                    tbits: o16,
                    transip: y,
                    wedeploy: o16,
                    yombo: o16,
                    nohost: o16
                }
            },
            mg: {
                $: 1,
                succ: {
                    org: a15,
                    nom: a15,
                    gov: a15,
                    prd: a15,
                    tm: a15,
                    edu: a15,
                    mil: a15,
                    com: a15,
                    co: a15
                }
            },
            mh: a15,
            mil: a15,
            mk: {
                $: 1,
                succ: {
                    com: a15,
                    org: a15,
                    net: a15,
                    edu: a15,
                    gov: a15,
                    inf: a15,
                    name: a15,
                    blogspot: o16
                }
            },
            ml: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    gouv: a15,
                    gov: a15,
                    net: a15,
                    org: a15,
                    presse: a15
                }
            },
            mm: r6,
            mn: {
                $: 1,
                succ: {
                    gov: a15,
                    edu: a15,
                    org: a15,
                    nyc: o16
                }
            },
            mo: i12,
            mobi: {
                $: 1,
                succ: {
                    barsy: o16,
                    dscloud: o16
                }
            },
            mp: {
                $: 1,
                succ: {
                    ju: o16
                }
            },
            mq: a15,
            mr: C,
            ms: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    gov: a15,
                    net: a15,
                    org: a15,
                    lab: o16,
                    minisite: o16
                }
            },
            mt: {
                $: 1,
                succ: {
                    com: s8,
                    edu: a15,
                    net: a15,
                    org: a15
                }
            },
            mu: {
                $: 1,
                succ: {
                    com: a15,
                    net: a15,
                    org: a15,
                    gov: a15,
                    ac: a15,
                    co: a15,
                    or: a15
                }
            },
            museum: {
                $: 1,
                succ: {
                    academy: a15,
                    agriculture: a15,
                    air: a15,
                    airguard: a15,
                    alabama: a15,
                    alaska: a15,
                    amber: a15,
                    ambulance: a15,
                    american: a15,
                    americana: a15,
                    americanantiques: a15,
                    americanart: a15,
                    amsterdam: a15,
                    and: a15,
                    annefrank: a15,
                    anthro: a15,
                    anthropology: a15,
                    antiques: a15,
                    aquarium: a15,
                    arboretum: a15,
                    archaeological: a15,
                    archaeology: a15,
                    architecture: a15,
                    art: a15,
                    artanddesign: a15,
                    artcenter: a15,
                    artdeco: a15,
                    arteducation: a15,
                    artgallery: a15,
                    arts: a15,
                    artsandcrafts: a15,
                    asmatart: a15,
                    assassination: a15,
                    assisi: a15,
                    association: a15,
                    astronomy: a15,
                    atlanta: a15,
                    austin: a15,
                    australia: a15,
                    automotive: a15,
                    aviation: a15,
                    axis: a15,
                    badajoz: a15,
                    baghdad: a15,
                    bahn: a15,
                    bale: a15,
                    baltimore: a15,
                    barcelona: a15,
                    baseball: a15,
                    basel: a15,
                    baths: a15,
                    bauern: a15,
                    beauxarts: a15,
                    beeldengeluid: a15,
                    bellevue: a15,
                    bergbau: a15,
                    berkeley: a15,
                    berlin: a15,
                    bern: a15,
                    bible: a15,
                    bilbao: a15,
                    bill: a15,
                    birdart: a15,
                    birthplace: a15,
                    bonn: a15,
                    boston: a15,
                    botanical: a15,
                    botanicalgarden: a15,
                    botanicgarden: a15,
                    botany: a15,
                    brandywinevalley: a15,
                    brasil: a15,
                    bristol: a15,
                    british: a15,
                    britishcolumbia: a15,
                    broadcast: a15,
                    brunel: a15,
                    brussel: a15,
                    brussels: a15,
                    bruxelles: a15,
                    building: a15,
                    burghof: a15,
                    bus: a15,
                    bushey: a15,
                    cadaques: a15,
                    california: a15,
                    cambridge: a15,
                    can: a15,
                    canada: a15,
                    capebreton: a15,
                    carrier: a15,
                    cartoonart: a15,
                    casadelamoneda: a15,
                    castle: a15,
                    castres: a15,
                    celtic: a15,
                    center: a15,
                    chattanooga: a15,
                    cheltenham: a15,
                    chesapeakebay: a15,
                    chicago: a15,
                    children: a15,
                    childrens: a15,
                    childrensgarden: a15,
                    chiropractic: a15,
                    chocolate: a15,
                    christiansburg: a15,
                    cincinnati: a15,
                    cinema: a15,
                    circus: a15,
                    civilisation: a15,
                    civilization: a15,
                    civilwar: a15,
                    clinton: a15,
                    clock: a15,
                    coal: a15,
                    coastaldefence: a15,
                    cody: a15,
                    coldwar: a15,
                    collection: a15,
                    colonialwilliamsburg: a15,
                    coloradoplateau: a15,
                    columbia: a15,
                    columbus: a15,
                    communication: a15,
                    communications: a15,
                    community: a15,
                    computer: a15,
                    computerhistory: a15,
                    "xn--comunicaes-v6a2o": a15,
                    "comunicações": a15,
                    contemporary: a15,
                    contemporaryart: a15,
                    convent: a15,
                    copenhagen: a15,
                    corporation: a15,
                    "xn--correios-e-telecomunicaes-ghc29a": a15,
                    "correios-e-telecomunicações": a15,
                    corvette: a15,
                    costume: a15,
                    countryestate: a15,
                    county: a15,
                    crafts: a15,
                    cranbrook: a15,
                    creation: a15,
                    cultural: a15,
                    culturalcenter: a15,
                    culture: a15,
                    cyber: a15,
                    cymru: a15,
                    dali: a15,
                    dallas: a15,
                    database: a15,
                    ddr: a15,
                    decorativearts: a15,
                    delaware: a15,
                    delmenhorst: a15,
                    denmark: a15,
                    depot: a15,
                    design: a15,
                    detroit: a15,
                    dinosaur: a15,
                    discovery: a15,
                    dolls: a15,
                    donostia: a15,
                    durham: a15,
                    eastafrica: a15,
                    eastcoast: a15,
                    education: a15,
                    educational: a15,
                    egyptian: a15,
                    eisenbahn: a15,
                    elburg: a15,
                    elvendrell: a15,
                    embroidery: a15,
                    encyclopedic: a15,
                    england: a15,
                    entomology: a15,
                    environment: a15,
                    environmentalconservation: a15,
                    epilepsy: a15,
                    essex: a15,
                    estate: a15,
                    ethnology: a15,
                    exeter: a15,
                    exhibition: a15,
                    family: a15,
                    farm: a15,
                    farmequipment: a15,
                    farmers: a15,
                    farmstead: a15,
                    field: a15,
                    figueres: a15,
                    filatelia: a15,
                    film: a15,
                    fineart: a15,
                    finearts: a15,
                    finland: a15,
                    flanders: a15,
                    florida: a15,
                    force: a15,
                    fortmissoula: a15,
                    fortworth: a15,
                    foundation: a15,
                    francaise: a15,
                    frankfurt: a15,
                    franziskaner: a15,
                    freemasonry: a15,
                    freiburg: a15,
                    fribourg: a15,
                    frog: a15,
                    fundacio: a15,
                    furniture: a15,
                    gallery: a15,
                    garden: a15,
                    gateway: a15,
                    geelvinck: a15,
                    gemological: a15,
                    geology: a15,
                    georgia: a15,
                    giessen: a15,
                    glas: a15,
                    glass: a15,
                    gorge: a15,
                    grandrapids: a15,
                    graz: a15,
                    guernsey: a15,
                    halloffame: a15,
                    hamburg: a15,
                    handson: a15,
                    harvestcelebration: a15,
                    hawaii: a15,
                    health: a15,
                    heimatunduhren: a15,
                    hellas: a15,
                    helsinki: a15,
                    hembygdsforbund: a15,
                    heritage: a15,
                    histoire: a15,
                    historical: a15,
                    historicalsociety: a15,
                    historichouses: a15,
                    historisch: a15,
                    historisches: a15,
                    history: a15,
                    historyofscience: a15,
                    horology: a15,
                    house: a15,
                    humanities: a15,
                    illustration: a15,
                    imageandsound: a15,
                    indian: a15,
                    indiana: a15,
                    indianapolis: a15,
                    indianmarket: a15,
                    intelligence: a15,
                    interactive: a15,
                    iraq: a15,
                    iron: a15,
                    isleofman: a15,
                    jamison: a15,
                    jefferson: a15,
                    jerusalem: a15,
                    jewelry: a15,
                    jewish: a15,
                    jewishart: a15,
                    jfk: a15,
                    journalism: a15,
                    judaica: a15,
                    judygarland: a15,
                    juedisches: a15,
                    juif: a15,
                    karate: a15,
                    karikatur: a15,
                    kids: a15,
                    koebenhavn: a15,
                    koeln: a15,
                    kunst: a15,
                    kunstsammlung: a15,
                    kunstunddesign: a15,
                    labor: a15,
                    labour: a15,
                    lajolla: a15,
                    lancashire: a15,
                    landes: a15,
                    lans: a15,
                    "xn--lns-qla": a15,
                    "läns": a15,
                    larsson: a15,
                    lewismiller: a15,
                    lincoln: a15,
                    linz: a15,
                    living: a15,
                    livinghistory: a15,
                    localhistory: a15,
                    london: a15,
                    losangeles: a15,
                    louvre: a15,
                    loyalist: a15,
                    lucerne: a15,
                    luxembourg: a15,
                    luzern: a15,
                    mad: a15,
                    madrid: a15,
                    mallorca: a15,
                    manchester: a15,
                    mansion: a15,
                    mansions: a15,
                    manx: a15,
                    marburg: a15,
                    maritime: a15,
                    maritimo: a15,
                    maryland: a15,
                    marylhurst: a15,
                    media: a15,
                    medical: a15,
                    medizinhistorisches: a15,
                    meeres: a15,
                    memorial: a15,
                    mesaverde: a15,
                    michigan: a15,
                    midatlantic: a15,
                    military: a15,
                    mill: a15,
                    miners: a15,
                    mining: a15,
                    minnesota: a15,
                    missile: a15,
                    missoula: a15,
                    modern: a15,
                    moma: a15,
                    money: a15,
                    monmouth: a15,
                    monticello: a15,
                    montreal: a15,
                    moscow: a15,
                    motorcycle: a15,
                    muenchen: a15,
                    muenster: a15,
                    mulhouse: a15,
                    muncie: a15,
                    museet: a15,
                    museumcenter: a15,
                    museumvereniging: a15,
                    music: a15,
                    national: a15,
                    nationalfirearms: a15,
                    nationalheritage: a15,
                    nativeamerican: a15,
                    naturalhistory: a15,
                    naturalhistorymuseum: a15,
                    naturalsciences: a15,
                    nature: a15,
                    naturhistorisches: a15,
                    natuurwetenschappen: a15,
                    naumburg: a15,
                    naval: a15,
                    nebraska: a15,
                    neues: a15,
                    newhampshire: a15,
                    newjersey: a15,
                    newmexico: a15,
                    newport: a15,
                    newspaper: a15,
                    newyork: a15,
                    niepce: a15,
                    norfolk: a15,
                    north: a15,
                    nrw: a15,
                    nyc: a15,
                    nyny: a15,
                    oceanographic: a15,
                    oceanographique: a15,
                    omaha: a15,
                    online: a15,
                    ontario: a15,
                    openair: a15,
                    oregon: a15,
                    oregontrail: a15,
                    otago: a15,
                    oxford: a15,
                    pacific: a15,
                    paderborn: a15,
                    palace: a15,
                    paleo: a15,
                    palmsprings: a15,
                    panama: a15,
                    paris: a15,
                    pasadena: a15,
                    pharmacy: a15,
                    philadelphia: a15,
                    philadelphiaarea: a15,
                    philately: a15,
                    phoenix: a15,
                    photography: a15,
                    pilots: a15,
                    pittsburgh: a15,
                    planetarium: a15,
                    plantation: a15,
                    plants: a15,
                    plaza: a15,
                    portal: a15,
                    portland: a15,
                    portlligat: a15,
                    "posts-and-telecommunications": a15,
                    preservation: a15,
                    presidio: a15,
                    press: a15,
                    project: a15,
                    public: a15,
                    pubol: a15,
                    quebec: a15,
                    railroad: a15,
                    railway: a15,
                    research: a15,
                    resistance: a15,
                    riodejaneiro: a15,
                    rochester: a15,
                    rockart: a15,
                    roma: a15,
                    russia: a15,
                    saintlouis: a15,
                    salem: a15,
                    salvadordali: a15,
                    salzburg: a15,
                    sandiego: a15,
                    sanfrancisco: a15,
                    santabarbara: a15,
                    santacruz: a15,
                    santafe: a15,
                    saskatchewan: a15,
                    satx: a15,
                    savannahga: a15,
                    schlesisches: a15,
                    schoenbrunn: a15,
                    schokoladen: a15,
                    school: a15,
                    schweiz: a15,
                    science: a15,
                    scienceandhistory: a15,
                    scienceandindustry: a15,
                    sciencecenter: a15,
                    sciencecenters: a15,
                    "science-fiction": a15,
                    sciencehistory: a15,
                    sciences: a15,
                    sciencesnaturelles: a15,
                    scotland: a15,
                    seaport: a15,
                    settlement: a15,
                    settlers: a15,
                    shell: a15,
                    sherbrooke: a15,
                    sibenik: a15,
                    silk: a15,
                    ski: a15,
                    skole: a15,
                    society: a15,
                    sologne: a15,
                    soundandvision: a15,
                    southcarolina: a15,
                    southwest: a15,
                    space: a15,
                    spy: a15,
                    square: a15,
                    stadt: a15,
                    stalbans: a15,
                    starnberg: a15,
                    state: a15,
                    stateofdelaware: a15,
                    station: a15,
                    steam: a15,
                    steiermark: a15,
                    stjohn: a15,
                    stockholm: a15,
                    stpetersburg: a15,
                    stuttgart: a15,
                    suisse: a15,
                    surgeonshall: a15,
                    surrey: a15,
                    svizzera: a15,
                    sweden: a15,
                    sydney: a15,
                    tank: a15,
                    tcm: a15,
                    technology: a15,
                    telekommunikation: a15,
                    television: a15,
                    texas: a15,
                    textile: a15,
                    theater: a15,
                    time: a15,
                    timekeeping: a15,
                    topology: a15,
                    torino: a15,
                    touch: a15,
                    town: a15,
                    transport: a15,
                    tree: a15,
                    trolley: a15,
                    trust: a15,
                    trustee: a15,
                    uhren: a15,
                    ulm: a15,
                    undersea: a15,
                    university: a15,
                    usa: a15,
                    usantiques: a15,
                    usarts: a15,
                    uscountryestate: a15,
                    usculture: a15,
                    usdecorativearts: a15,
                    usgarden: a15,
                    ushistory: a15,
                    ushuaia: a15,
                    uslivinghistory: a15,
                    utah: a15,
                    uvic: a15,
                    valley: a15,
                    vantaa: a15,
                    versailles: a15,
                    viking: a15,
                    village: a15,
                    virginia: a15,
                    virtual: a15,
                    virtuel: a15,
                    vlaanderen: a15,
                    volkenkunde: a15,
                    wales: a15,
                    wallonie: a15,
                    war: a15,
                    washingtondc: a15,
                    watchandclock: a15,
                    "watch-and-clock": a15,
                    western: a15,
                    westfalen: a15,
                    whaling: a15,
                    wildlife: a15,
                    williamsburg: a15,
                    windmill: a15,
                    workshop: a15,
                    york: a15,
                    yorkshire: a15,
                    yosemite: a15,
                    youth: a15,
                    zoological: a15,
                    zoology: a15,
                    "xn--9dbhblg6di": a15,
                    "ירושלים": a15,
                    "xn--h1aegh": a15,
                    "иком": a15
                }
            },
            mv: {
                $: 1,
                succ: {
                    aero: a15,
                    biz: a15,
                    com: a15,
                    coop: a15,
                    edu: a15,
                    gov: a15,
                    info: a15,
                    int: a15,
                    mil: a15,
                    museum: a15,
                    name: a15,
                    net: a15,
                    org: a15,
                    pro: a15
                }
            },
            mw: {
                $: 1,
                succ: {
                    ac: a15,
                    biz: a15,
                    co: a15,
                    com: a15,
                    coop: a15,
                    edu: a15,
                    gov: a15,
                    int: a15,
                    museum: a15,
                    net: a15,
                    org: a15
                }
            },
            mx: {
                $: 1,
                succ: {
                    com: a15,
                    org: a15,
                    gob: a15,
                    edu: a15,
                    net: a15,
                    blogspot: o16
                }
            },
            my: {
                $: 1,
                succ: {
                    biz: a15,
                    com: a15,
                    edu: a15,
                    gov: a15,
                    mil: a15,
                    name: a15,
                    net: a15,
                    org: a15,
                    blogspot: o16
                }
            },
            mz: {
                $: 1,
                succ: {
                    ac: a15,
                    adv: a15,
                    co: a15,
                    edu: a15,
                    gov: a15,
                    mil: a15,
                    net: a15,
                    org: a15
                }
            },
            na: {
                $: 1,
                succ: {
                    info: a15,
                    pro: a15,
                    name: a15,
                    school: a15,
                    or: a15,
                    dr: a15,
                    us: a15,
                    mx: a15,
                    ca: a15,
                    in: a15,
                    cc: a15,
                    tv: a15,
                    ws: a15,
                    mobi: a15,
                    co: a15,
                    com: a15,
                    org: a15
                }
            },
            name: {
                $: 1,
                succ: {
                    her: A,
                    his: A
                }
            },
            nc: {
                $: 1,
                succ: {
                    asso: a15,
                    nom: a15
                }
            },
            ne: a15,
            net: {
                $: 1,
                succ: {
                    adobeaemcloud: o16,
                    alwaysdata: o16,
                    cloudfront: o16,
                    t3l3p0rt: o16,
                    appudo: o16,
                    "atlassian-dev": {
                        $: 0,
                        succ: {
                            prod: {
                                $: 0,
                                succ: {
                                    cdn: o16
                                }
                            }
                        }
                    },
                    myfritz: o16,
                    onavstack: o16,
                    shopselect: o16,
                    blackbaudcdn: o16,
                    boomla: o16,
                    bplaced: o16,
                    square7: o16,
                    gb: o16,
                    hu: o16,
                    jp: o16,
                    se: o16,
                    uk: o16,
                    in: o16,
                    clickrising: o16,
                    cloudaccess: o16,
                    "cdn77-ssl": o16,
                    cdn77: {
                        $: 0,
                        succ: {
                            r: o16
                        }
                    },
                    "feste-ip": o16,
                    "knx-server": o16,
                    "static-access": o16,
                    cryptonomic: e12,
                    dattolocal: o16,
                    mydatto: o16,
                    debian: o16,
                    bitbridge: o16,
                    "at-band-camp": o16,
                    blogdns: o16,
                    "broke-it": o16,
                    buyshouses: o16,
                    dnsalias: o16,
                    dnsdojo: o16,
                    "does-it": o16,
                    dontexist: o16,
                    dynalias: o16,
                    dynathome: o16,
                    endofinternet: o16,
                    "from-az": o16,
                    "from-co": o16,
                    "from-la": o16,
                    "from-ny": o16,
                    "gets-it": o16,
                    "ham-radio-op": o16,
                    homeftp: o16,
                    homeip: o16,
                    homelinux: o16,
                    homeunix: o16,
                    "in-the-band": o16,
                    "is-a-chef": o16,
                    "is-a-geek": o16,
                    "isa-geek": o16,
                    "kicks-ass": o16,
                    "office-on-the": o16,
                    podzone: o16,
                    "scrapper-site": o16,
                    selfip: o16,
                    "sells-it": o16,
                    servebbs: o16,
                    serveftp: o16,
                    thruhere: o16,
                    webhop: o16,
                    definima: o16,
                    casacam: o16,
                    dynu: o16,
                    dynv6: o16,
                    twmail: o16,
                    ru: o16,
                    channelsdvr: {
                        $: 2,
                        succ: {
                            u: o16
                        }
                    },
                    fastlylb: {
                        $: 2,
                        succ: {
                            map: o16
                        }
                    },
                    fastly: {
                        $: 0,
                        succ: {
                            freetls: o16,
                            map: o16,
                            prod: {
                                $: 0,
                                succ: {
                                    a: o16,
                                    global: o16
                                }
                            },
                            ssl: {
                                $: 0,
                                succ: {
                                    a: o16,
                                    b: o16,
                                    global: o16
                                }
                            }
                        }
                    },
                    edgeapp: o16,
                    flynnhosting: o16,
                    "cdn-edges": o16,
                    heteml: o16,
                    cloudfunctions: o16,
                    moonscale: o16,
                    "in-dsl": o16,
                    "in-vpn": o16,
                    ipifony: o16,
                    iobb: o16,
                    cloudjiffy: {
                        $: 2,
                        succ: {
                            "fra1-de": o16,
                            "west1-us": o16
                        }
                    },
                    elastx: {
                        $: 0,
                        succ: {
                            "jls-sto1": o16,
                            "jls-sto2": o16,
                            "jls-sto3": o16
                        }
                    },
                    faststacks: o16,
                    massivegrid: {
                        $: 0,
                        succ: {
                            paas: {
                                $: 0,
                                succ: {
                                    "fr-1": o16,
                                    "lon-1": o16,
                                    "lon-2": o16,
                                    "ny-1": o16,
                                    "ny-2": o16,
                                    "sg-1": o16
                                }
                            }
                        }
                    },
                    saveincloud: {
                        $: 0,
                        succ: {
                            jelastic: o16,
                            "nordeste-idc": o16
                        }
                    },
                    scaleforce: x,
                    tsukaeru: w,
                    kinghost: o16,
                    uni5: o16,
                    krellian: o16,
                    barsy: o16,
                    memset: o16,
                    azurewebsites: o16,
                    "azure-mobile": o16,
                    cloudapp: o16,
                    azurestaticapps: {
                        $: 2,
                        succ: {
                            1: o16,
                            centralus: o16,
                            eastasia: o16,
                            eastus2: o16,
                            westeurope: o16,
                            westus2: o16
                        }
                    },
                    dnsup: o16,
                    hicam: o16,
                    "now-dns": o16,
                    ownip: o16,
                    vpndns: o16,
                    "eating-organic": o16,
                    mydissent: o16,
                    myeffect: o16,
                    mymediapc: o16,
                    mypsx: o16,
                    mysecuritycamera: o16,
                    nhlfan: o16,
                    "no-ip": o16,
                    pgafan: o16,
                    privatizehealthinsurance: o16,
                    bounceme: o16,
                    ddns: o16,
                    redirectme: o16,
                    serveblog: o16,
                    serveminecraft: o16,
                    sytes: o16,
                    cloudycluster: o16,
                    ovh: {
                        $: 0,
                        succ: {
                            webpaas: e12,
                            hosting: e12
                        }
                    },
                    bar0: o16,
                    bar1: o16,
                    bar2: o16,
                    rackmaze: o16,
                    schokokeks: o16,
                    "firewall-gateway": o16,
                    seidat: o16,
                    senseering: o16,
                    siteleaf: o16,
                    "vps-host": {
                        $: 2,
                        succ: {
                            jelastic: {
                                $: 0,
                                succ: {
                                    atl: o16,
                                    njs: o16,
                                    ric: o16
                                }
                            }
                        }
                    },
                    myspreadshop: o16,
                    srcf: {
                        $: 0,
                        succ: {
                            soc: o16,
                            user: o16
                        }
                    },
                    supabase: o16,
                    dsmynas: o16,
                    familyds: o16,
                    tailscale: {
                        $: 0,
                        succ: {
                            beta: o16
                        }
                    },
                    ts: o16,
                    torproject: {
                        $: 2,
                        succ: {
                            pages: o16
                        }
                    },
                    "reserve-online": o16,
                    "community-pro": o16,
                    meinforum: o16,
                    yandexcloud: {
                        $: 2,
                        succ: {
                            storage: o16,
                            website: o16
                        }
                    },
                    za: o16
                }
            },
            nf: {
                $: 1,
                succ: {
                    com: a15,
                    net: a15,
                    per: a15,
                    rec: a15,
                    web: a15,
                    arts: a15,
                    firm: a15,
                    info: a15,
                    other: a15,
                    store: a15
                }
            },
            ng: {
                $: 1,
                succ: {
                    com: s8,
                    edu: a15,
                    gov: a15,
                    i: a15,
                    mil: a15,
                    mobi: a15,
                    name: a15,
                    net: a15,
                    org: a15,
                    sch: a15,
                    col: o16,
                    firm: o16,
                    gen: o16,
                    ltd: o16,
                    ngo: o16
                }
            },
            ni: {
                $: 1,
                succ: {
                    ac: a15,
                    biz: a15,
                    co: a15,
                    com: a15,
                    edu: a15,
                    gob: a15,
                    in: a15,
                    info: a15,
                    int: a15,
                    mil: a15,
                    net: a15,
                    nom: a15,
                    org: a15,
                    web: a15
                }
            },
            nl: {
                $: 1,
                succ: {
                    co: o16,
                    "hosting-cluster": o16,
                    blogspot: o16,
                    khplay: o16,
                    myspreadshop: o16,
                    transurl: e12,
                    cistron: o16,
                    demon: o16
                }
            },
            no: {
                $: 1,
                succ: {
                    fhs: a15,
                    vgs: a15,
                    fylkesbibl: a15,
                    folkebibl: a15,
                    museum: a15,
                    idrett: a15,
                    priv: a15,
                    mil: a15,
                    stat: a15,
                    dep: a15,
                    kommune: a15,
                    herad: a15,
                    aa: H,
                    ah: H,
                    bu: H,
                    fm: H,
                    hl: H,
                    hm: H,
                    "jan-mayen": H,
                    mr: H,
                    nl: H,
                    nt: H,
                    of: H,
                    ol: H,
                    oslo: H,
                    rl: H,
                    sf: H,
                    st: H,
                    svalbard: H,
                    tm: H,
                    tr: H,
                    va: H,
                    vf: H,
                    akrehamn: a15,
                    "xn--krehamn-dxa": a15,
                    "åkrehamn": a15,
                    algard: a15,
                    "xn--lgrd-poac": a15,
                    "ålgård": a15,
                    arna: a15,
                    brumunddal: a15,
                    bryne: a15,
                    bronnoysund: a15,
                    "xn--brnnysund-m8ac": a15,
                    "brønnøysund": a15,
                    drobak: a15,
                    "xn--drbak-wua": a15,
                    "drøbak": a15,
                    egersund: a15,
                    fetsund: a15,
                    floro: a15,
                    "xn--flor-jra": a15,
                    "florø": a15,
                    fredrikstad: a15,
                    hokksund: a15,
                    honefoss: a15,
                    "xn--hnefoss-q1a": a15,
                    "hønefoss": a15,
                    jessheim: a15,
                    jorpeland: a15,
                    "xn--jrpeland-54a": a15,
                    "jørpeland": a15,
                    kirkenes: a15,
                    kopervik: a15,
                    krokstadelva: a15,
                    langevag: a15,
                    "xn--langevg-jxa": a15,
                    "langevåg": a15,
                    leirvik: a15,
                    mjondalen: a15,
                    "xn--mjndalen-64a": a15,
                    "mjøndalen": a15,
                    "mo-i-rana": a15,
                    mosjoen: a15,
                    "xn--mosjen-eya": a15,
                    "mosjøen": a15,
                    nesoddtangen: a15,
                    orkanger: a15,
                    osoyro: a15,
                    "xn--osyro-wua": a15,
                    "osøyro": a15,
                    raholt: a15,
                    "xn--rholt-mra": a15,
                    "råholt": a15,
                    sandnessjoen: a15,
                    "xn--sandnessjen-ogb": a15,
                    "sandnessjøen": a15,
                    skedsmokorset: a15,
                    slattum: a15,
                    spjelkavik: a15,
                    stathelle: a15,
                    stavern: a15,
                    stjordalshalsen: a15,
                    "xn--stjrdalshalsen-sqb": a15,
                    "stjørdalshalsen": a15,
                    tananger: a15,
                    tranby: a15,
                    vossevangen: a15,
                    afjord: a15,
                    "xn--fjord-lra": a15,
                    "åfjord": a15,
                    agdenes: a15,
                    al: a15,
                    "xn--l-1fa": a15,
                    "ål": a15,
                    alesund: a15,
                    "xn--lesund-hua": a15,
                    "ålesund": a15,
                    alstahaug: a15,
                    alta: a15,
                    "xn--lt-liac": a15,
                    "áltá": a15,
                    alaheadju: a15,
                    "xn--laheadju-7ya": a15,
                    "álaheadju": a15,
                    alvdal: a15,
                    amli: a15,
                    "xn--mli-tla": a15,
                    "åmli": a15,
                    amot: a15,
                    "xn--mot-tla": a15,
                    "åmot": a15,
                    andebu: a15,
                    andoy: a15,
                    "xn--andy-ira": a15,
                    "andøy": a15,
                    andasuolo: a15,
                    ardal: a15,
                    "xn--rdal-poa": a15,
                    "årdal": a15,
                    aremark: a15,
                    arendal: a15,
                    "xn--s-1fa": a15,
                    "ås": a15,
                    aseral: a15,
                    "xn--seral-lra": a15,
                    "åseral": a15,
                    asker: a15,
                    askim: a15,
                    askvoll: a15,
                    askoy: a15,
                    "xn--asky-ira": a15,
                    "askøy": a15,
                    asnes: a15,
                    "xn--snes-poa": a15,
                    "åsnes": a15,
                    audnedaln: a15,
                    aukra: a15,
                    aure: a15,
                    aurland: a15,
                    "aurskog-holand": a15,
                    "xn--aurskog-hland-jnb": a15,
                    "aurskog-høland": a15,
                    austevoll: a15,
                    austrheim: a15,
                    averoy: a15,
                    "xn--avery-yua": a15,
                    "averøy": a15,
                    balestrand: a15,
                    ballangen: a15,
                    balat: a15,
                    "xn--blt-elab": a15,
                    "bálát": a15,
                    balsfjord: a15,
                    bahccavuotna: a15,
                    "xn--bhccavuotna-k7a": a15,
                    "báhccavuotna": a15,
                    bamble: a15,
                    bardu: a15,
                    beardu: a15,
                    beiarn: a15,
                    bajddar: a15,
                    "xn--bjddar-pta": a15,
                    "bájddar": a15,
                    baidar: a15,
                    "xn--bidr-5nac": a15,
                    "báidár": a15,
                    berg: a15,
                    bergen: a15,
                    berlevag: a15,
                    "xn--berlevg-jxa": a15,
                    "berlevåg": a15,
                    bearalvahki: a15,
                    "xn--bearalvhki-y4a": a15,
                    "bearalváhki": a15,
                    bindal: a15,
                    birkenes: a15,
                    bjarkoy: a15,
                    "xn--bjarky-fya": a15,
                    "bjarkøy": a15,
                    bjerkreim: a15,
                    bjugn: a15,
                    bodo: a15,
                    "xn--bod-2na": a15,
                    "bodø": a15,
                    badaddja: a15,
                    "xn--bdddj-mrabd": a15,
                    "bådåddjå": a15,
                    budejju: a15,
                    bokn: a15,
                    bremanger: a15,
                    bronnoy: a15,
                    "xn--brnny-wuac": a15,
                    "brønnøy": a15,
                    bygland: a15,
                    bykle: a15,
                    barum: a15,
                    "xn--brum-voa": a15,
                    "bærum": a15,
                    telemark: {
                        $: 0,
                        succ: {
                            bo: a15,
                            "xn--b-5ga": a15,
                            "bø": a15
                        }
                    },
                    nordland: {
                        $: 0,
                        succ: {
                            bo: a15,
                            "xn--b-5ga": a15,
                            "bø": a15,
                            heroy: a15,
                            "xn--hery-ira": a15,
                            "herøy": a15
                        }
                    },
                    bievat: a15,
                    "xn--bievt-0qa": a15,
                    "bievát": a15,
                    bomlo: a15,
                    "xn--bmlo-gra": a15,
                    "bømlo": a15,
                    batsfjord: a15,
                    "xn--btsfjord-9za": a15,
                    "båtsfjord": a15,
                    bahcavuotna: a15,
                    "xn--bhcavuotna-s4a": a15,
                    "báhcavuotna": a15,
                    dovre: a15,
                    drammen: a15,
                    drangedal: a15,
                    dyroy: a15,
                    "xn--dyry-ira": a15,
                    "dyrøy": a15,
                    donna: a15,
                    "xn--dnna-gra": a15,
                    "dønna": a15,
                    eid: a15,
                    eidfjord: a15,
                    eidsberg: a15,
                    eidskog: a15,
                    eidsvoll: a15,
                    eigersund: a15,
                    elverum: a15,
                    enebakk: a15,
                    engerdal: a15,
                    etne: a15,
                    etnedal: a15,
                    evenes: a15,
                    evenassi: a15,
                    "xn--eveni-0qa01ga": a15,
                    "evenášši": a15,
                    "evje-og-hornnes": a15,
                    farsund: a15,
                    fauske: a15,
                    fuossko: a15,
                    fuoisku: a15,
                    fedje: a15,
                    fet: a15,
                    finnoy: a15,
                    "xn--finny-yua": a15,
                    "finnøy": a15,
                    fitjar: a15,
                    fjaler: a15,
                    fjell: a15,
                    flakstad: a15,
                    flatanger: a15,
                    flekkefjord: a15,
                    flesberg: a15,
                    flora: a15,
                    fla: a15,
                    "xn--fl-zia": a15,
                    "flå": a15,
                    folldal: a15,
                    forsand: a15,
                    fosnes: a15,
                    frei: a15,
                    frogn: a15,
                    froland: a15,
                    frosta: a15,
                    frana: a15,
                    "xn--frna-woa": a15,
                    "fræna": a15,
                    froya: a15,
                    "xn--frya-hra": a15,
                    "frøya": a15,
                    fusa: a15,
                    fyresdal: a15,
                    forde: a15,
                    "xn--frde-gra": a15,
                    "førde": a15,
                    gamvik: a15,
                    gangaviika: a15,
                    "xn--ggaviika-8ya47h": a15,
                    "gáŋgaviika": a15,
                    gaular: a15,
                    gausdal: a15,
                    gildeskal: a15,
                    "xn--gildeskl-g0a": a15,
                    "gildeskål": a15,
                    giske: a15,
                    gjemnes: a15,
                    gjerdrum: a15,
                    gjerstad: a15,
                    gjesdal: a15,
                    gjovik: a15,
                    "xn--gjvik-wua": a15,
                    "gjøvik": a15,
                    gloppen: a15,
                    gol: a15,
                    gran: a15,
                    grane: a15,
                    granvin: a15,
                    gratangen: a15,
                    grimstad: a15,
                    grong: a15,
                    kraanghke: a15,
                    "xn--kranghke-b0a": a15,
                    "kråanghke": a15,
                    grue: a15,
                    gulen: a15,
                    hadsel: a15,
                    halden: a15,
                    halsa: a15,
                    hamar: a15,
                    hamaroy: a15,
                    habmer: a15,
                    "xn--hbmer-xqa": a15,
                    "hábmer": a15,
                    hapmir: a15,
                    "xn--hpmir-xqa": a15,
                    "hápmir": a15,
                    hammerfest: a15,
                    hammarfeasta: a15,
                    "xn--hmmrfeasta-s4ac": a15,
                    "hámmárfeasta": a15,
                    haram: a15,
                    hareid: a15,
                    harstad: a15,
                    hasvik: a15,
                    aknoluokta: a15,
                    "xn--koluokta-7ya57h": a15,
                    "ákŋoluokta": a15,
                    hattfjelldal: a15,
                    aarborte: a15,
                    haugesund: a15,
                    hemne: a15,
                    hemnes: a15,
                    hemsedal: a15,
                    "more-og-romsdal": {
                        $: 0,
                        succ: {
                            heroy: a15,
                            sande: a15
                        }
                    },
                    "xn--mre-og-romsdal-qqb": {
                        $: 0,
                        succ: {
                            "xn--hery-ira": a15,
                            sande: a15
                        }
                    },
                    "møre-og-romsdal": {
                        $: 0,
                        succ: {
                            "herøy": a15,
                            sande: a15
                        }
                    },
                    hitra: a15,
                    hjartdal: a15,
                    hjelmeland: a15,
                    hobol: a15,
                    "xn--hobl-ira": a15,
                    "hobøl": a15,
                    hof: a15,
                    hol: a15,
                    hole: a15,
                    holmestrand: a15,
                    holtalen: a15,
                    "xn--holtlen-hxa": a15,
                    "holtålen": a15,
                    hornindal: a15,
                    horten: a15,
                    hurdal: a15,
                    hurum: a15,
                    hvaler: a15,
                    hyllestad: a15,
                    hagebostad: a15,
                    "xn--hgebostad-g3a": a15,
                    "hægebostad": a15,
                    hoyanger: a15,
                    "xn--hyanger-q1a": a15,
                    "høyanger": a15,
                    hoylandet: a15,
                    "xn--hylandet-54a": a15,
                    "høylandet": a15,
                    ha: a15,
                    "xn--h-2fa": a15,
                    "hå": a15,
                    ibestad: a15,
                    inderoy: a15,
                    "xn--indery-fya": a15,
                    "inderøy": a15,
                    iveland: a15,
                    jevnaker: a15,
                    jondal: a15,
                    jolster: a15,
                    "xn--jlster-bya": a15,
                    "jølster": a15,
                    karasjok: a15,
                    karasjohka: a15,
                    "xn--krjohka-hwab49j": a15,
                    "kárášjohka": a15,
                    karlsoy: a15,
                    galsa: a15,
                    "xn--gls-elac": a15,
                    "gálsá": a15,
                    karmoy: a15,
                    "xn--karmy-yua": a15,
                    "karmøy": a15,
                    kautokeino: a15,
                    guovdageaidnu: a15,
                    klepp: a15,
                    klabu: a15,
                    "xn--klbu-woa": a15,
                    "klæbu": a15,
                    kongsberg: a15,
                    kongsvinger: a15,
                    kragero: a15,
                    "xn--krager-gya": a15,
                    "kragerø": a15,
                    kristiansand: a15,
                    kristiansund: a15,
                    krodsherad: a15,
                    "xn--krdsherad-m8a": a15,
                    "krødsherad": a15,
                    kvalsund: a15,
                    rahkkeravju: a15,
                    "xn--rhkkervju-01af": a15,
                    "ráhkkerávju": a15,
                    kvam: a15,
                    kvinesdal: a15,
                    kvinnherad: a15,
                    kviteseid: a15,
                    kvitsoy: a15,
                    "xn--kvitsy-fya": a15,
                    "kvitsøy": a15,
                    kvafjord: a15,
                    "xn--kvfjord-nxa": a15,
                    "kvæfjord": a15,
                    giehtavuoatna: a15,
                    kvanangen: a15,
                    "xn--kvnangen-k0a": a15,
                    "kvænangen": a15,
                    navuotna: a15,
                    "xn--nvuotna-hwa": a15,
                    "návuotna": a15,
                    kafjord: a15,
                    "xn--kfjord-iua": a15,
                    "kåfjord": a15,
                    gaivuotna: a15,
                    "xn--givuotna-8ya": a15,
                    "gáivuotna": a15,
                    larvik: a15,
                    lavangen: a15,
                    lavagis: a15,
                    loabat: a15,
                    "xn--loabt-0qa": a15,
                    "loabát": a15,
                    lebesby: a15,
                    davvesiida: a15,
                    leikanger: a15,
                    leirfjord: a15,
                    leka: a15,
                    leksvik: a15,
                    lenvik: a15,
                    leangaviika: a15,
                    "xn--leagaviika-52b": a15,
                    "leaŋgaviika": a15,
                    lesja: a15,
                    levanger: a15,
                    lier: a15,
                    lierne: a15,
                    lillehammer: a15,
                    lillesand: a15,
                    lindesnes: a15,
                    lindas: a15,
                    "xn--linds-pra": a15,
                    "lindås": a15,
                    lom: a15,
                    loppa: a15,
                    lahppi: a15,
                    "xn--lhppi-xqa": a15,
                    "láhppi": a15,
                    lund: a15,
                    lunner: a15,
                    luroy: a15,
                    "xn--lury-ira": a15,
                    "lurøy": a15,
                    luster: a15,
                    lyngdal: a15,
                    lyngen: a15,
                    ivgu: a15,
                    lardal: a15,
                    lerdal: a15,
                    "xn--lrdal-sra": a15,
                    "lærdal": a15,
                    lodingen: a15,
                    "xn--ldingen-q1a": a15,
                    "lødingen": a15,
                    lorenskog: a15,
                    "xn--lrenskog-54a": a15,
                    "lørenskog": a15,
                    loten: a15,
                    "xn--lten-gra": a15,
                    "løten": a15,
                    malvik: a15,
                    masoy: a15,
                    "xn--msy-ula0h": a15,
                    "måsøy": a15,
                    muosat: a15,
                    "xn--muost-0qa": a15,
                    "muosát": a15,
                    mandal: a15,
                    marker: a15,
                    marnardal: a15,
                    masfjorden: a15,
                    meland: a15,
                    meldal: a15,
                    melhus: a15,
                    meloy: a15,
                    "xn--mely-ira": a15,
                    "meløy": a15,
                    meraker: a15,
                    "xn--merker-kua": a15,
                    "meråker": a15,
                    moareke: a15,
                    "xn--moreke-jua": a15,
                    "moåreke": a15,
                    midsund: a15,
                    "midtre-gauldal": a15,
                    modalen: a15,
                    modum: a15,
                    molde: a15,
                    moskenes: a15,
                    moss: a15,
                    mosvik: a15,
                    malselv: a15,
                    "xn--mlselv-iua": a15,
                    "målselv": a15,
                    malatvuopmi: a15,
                    "xn--mlatvuopmi-s4a": a15,
                    "málatvuopmi": a15,
                    namdalseid: a15,
                    aejrie: a15,
                    namsos: a15,
                    namsskogan: a15,
                    naamesjevuemie: a15,
                    "xn--nmesjevuemie-tcba": a15,
                    "nååmesjevuemie": a15,
                    laakesvuemie: a15,
                    nannestad: a15,
                    narvik: a15,
                    narviika: a15,
                    naustdal: a15,
                    "nedre-eiker": a15,
                    akershus: D,
                    buskerud: D,
                    nesna: a15,
                    nesodden: a15,
                    nesseby: a15,
                    unjarga: a15,
                    "xn--unjrga-rta": a15,
                    "unjárga": a15,
                    nesset: a15,
                    nissedal: a15,
                    nittedal: a15,
                    "nord-aurdal": a15,
                    "nord-fron": a15,
                    "nord-odal": a15,
                    norddal: a15,
                    nordkapp: a15,
                    davvenjarga: a15,
                    "xn--davvenjrga-y4a": a15,
                    "davvenjárga": a15,
                    "nordre-land": a15,
                    nordreisa: a15,
                    raisa: a15,
                    "xn--risa-5na": a15,
                    "ráisa": a15,
                    "nore-og-uvdal": a15,
                    notodden: a15,
                    naroy: a15,
                    "xn--nry-yla5g": a15,
                    "nærøy": a15,
                    notteroy: a15,
                    "xn--nttery-byae": a15,
                    "nøtterøy": a15,
                    odda: a15,
                    oksnes: a15,
                    "xn--ksnes-uua": a15,
                    "øksnes": a15,
                    oppdal: a15,
                    oppegard: a15,
                    "xn--oppegrd-ixa": a15,
                    "oppegård": a15,
                    orkdal: a15,
                    orland: a15,
                    "xn--rland-uua": a15,
                    "ørland": a15,
                    orskog: a15,
                    "xn--rskog-uua": a15,
                    "ørskog": a15,
                    orsta: a15,
                    "xn--rsta-fra": a15,
                    "ørsta": a15,
                    hedmark: {
                        $: 0,
                        succ: {
                            os: a15,
                            valer: a15,
                            "xn--vler-qoa": a15,
                            "våler": a15
                        }
                    },
                    hordaland: {
                        $: 0,
                        succ: {
                            os: a15
                        }
                    },
                    osen: a15,
                    osteroy: a15,
                    "xn--ostery-fya": a15,
                    "osterøy": a15,
                    "ostre-toten": a15,
                    "xn--stre-toten-zcb": a15,
                    "østre-toten": a15,
                    overhalla: a15,
                    "ovre-eiker": a15,
                    "xn--vre-eiker-k8a": a15,
                    "øvre-eiker": a15,
                    oyer: a15,
                    "xn--yer-zna": a15,
                    "øyer": a15,
                    oygarden: a15,
                    "xn--ygarden-p1a": a15,
                    "øygarden": a15,
                    "oystre-slidre": a15,
                    "xn--ystre-slidre-ujb": a15,
                    "øystre-slidre": a15,
                    porsanger: a15,
                    porsangu: a15,
                    "xn--porsgu-sta26f": a15,
                    "porsáŋgu": a15,
                    porsgrunn: a15,
                    radoy: a15,
                    "xn--rady-ira": a15,
                    "radøy": a15,
                    rakkestad: a15,
                    rana: a15,
                    ruovat: a15,
                    randaberg: a15,
                    rauma: a15,
                    rendalen: a15,
                    rennebu: a15,
                    rennesoy: a15,
                    "xn--rennesy-v1a": a15,
                    "rennesøy": a15,
                    rindal: a15,
                    ringebu: a15,
                    ringerike: a15,
                    ringsaker: a15,
                    rissa: a15,
                    risor: a15,
                    "xn--risr-ira": a15,
                    "risør": a15,
                    roan: a15,
                    rollag: a15,
                    rygge: a15,
                    ralingen: a15,
                    "xn--rlingen-mxa": a15,
                    "rælingen": a15,
                    rodoy: a15,
                    "xn--rdy-0nab": a15,
                    "rødøy": a15,
                    romskog: a15,
                    "xn--rmskog-bya": a15,
                    "rømskog": a15,
                    roros: a15,
                    "xn--rros-gra": a15,
                    "røros": a15,
                    rost: a15,
                    "xn--rst-0na": a15,
                    "røst": a15,
                    royken: a15,
                    "xn--ryken-vua": a15,
                    "røyken": a15,
                    royrvik: a15,
                    "xn--ryrvik-bya": a15,
                    "røyrvik": a15,
                    rade: a15,
                    "xn--rde-ula": a15,
                    "råde": a15,
                    salangen: a15,
                    siellak: a15,
                    saltdal: a15,
                    salat: a15,
                    "xn--slt-elab": a15,
                    "sálát": a15,
                    "xn--slat-5na": a15,
                    "sálat": a15,
                    samnanger: a15,
                    vestfold: {
                        $: 0,
                        succ: {
                            sande: a15
                        }
                    },
                    sandefjord: a15,
                    sandnes: a15,
                    sandoy: a15,
                    "xn--sandy-yua": a15,
                    "sandøy": a15,
                    sarpsborg: a15,
                    sauda: a15,
                    sauherad: a15,
                    sel: a15,
                    selbu: a15,
                    selje: a15,
                    seljord: a15,
                    sigdal: a15,
                    siljan: a15,
                    sirdal: a15,
                    skaun: a15,
                    skedsmo: a15,
                    ski: a15,
                    skien: a15,
                    skiptvet: a15,
                    skjervoy: a15,
                    "xn--skjervy-v1a": a15,
                    "skjervøy": a15,
                    skierva: a15,
                    "xn--skierv-uta": a15,
                    "skiervá": a15,
                    skjak: a15,
                    "xn--skjk-soa": a15,
                    "skjåk": a15,
                    skodje: a15,
                    skanland: a15,
                    "xn--sknland-fxa": a15,
                    "skånland": a15,
                    skanit: a15,
                    "xn--sknit-yqa": a15,
                    "skánit": a15,
                    smola: a15,
                    "xn--smla-hra": a15,
                    "smøla": a15,
                    snillfjord: a15,
                    snasa: a15,
                    "xn--snsa-roa": a15,
                    "snåsa": a15,
                    snoasa: a15,
                    snaase: a15,
                    "xn--snase-nra": a15,
                    "snåase": a15,
                    sogndal: a15,
                    sokndal: a15,
                    sola: a15,
                    solund: a15,
                    songdalen: a15,
                    sortland: a15,
                    spydeberg: a15,
                    stange: a15,
                    stavanger: a15,
                    steigen: a15,
                    steinkjer: a15,
                    stjordal: a15,
                    "xn--stjrdal-s1a": a15,
                    "stjørdal": a15,
                    stokke: a15,
                    "stor-elvdal": a15,
                    stord: a15,
                    stordal: a15,
                    storfjord: a15,
                    omasvuotna: a15,
                    strand: a15,
                    stranda: a15,
                    stryn: a15,
                    sula: a15,
                    suldal: a15,
                    sund: a15,
                    sunndal: a15,
                    surnadal: a15,
                    sveio: a15,
                    svelvik: a15,
                    sykkylven: a15,
                    sogne: a15,
                    "xn--sgne-gra": a15,
                    "søgne": a15,
                    somna: a15,
                    "xn--smna-gra": a15,
                    "sømna": a15,
                    "sondre-land": a15,
                    "xn--sndre-land-0cb": a15,
                    "søndre-land": a15,
                    "sor-aurdal": a15,
                    "xn--sr-aurdal-l8a": a15,
                    "sør-aurdal": a15,
                    "sor-fron": a15,
                    "xn--sr-fron-q1a": a15,
                    "sør-fron": a15,
                    "sor-odal": a15,
                    "xn--sr-odal-q1a": a15,
                    "sør-odal": a15,
                    "sor-varanger": a15,
                    "xn--sr-varanger-ggb": a15,
                    "sør-varanger": a15,
                    "matta-varjjat": a15,
                    "xn--mtta-vrjjat-k7af": a15,
                    "mátta-várjjat": a15,
                    sorfold: a15,
                    "xn--srfold-bya": a15,
                    "sørfold": a15,
                    sorreisa: a15,
                    "xn--srreisa-q1a": a15,
                    "sørreisa": a15,
                    sorum: a15,
                    "xn--srum-gra": a15,
                    "sørum": a15,
                    tana: a15,
                    deatnu: a15,
                    time: a15,
                    tingvoll: a15,
                    tinn: a15,
                    tjeldsund: a15,
                    dielddanuorri: a15,
                    tjome: a15,
                    "xn--tjme-hra": a15,
                    "tjøme": a15,
                    tokke: a15,
                    tolga: a15,
                    torsken: a15,
                    tranoy: a15,
                    "xn--trany-yua": a15,
                    "tranøy": a15,
                    tromso: a15,
                    "xn--troms-zua": a15,
                    "tromsø": a15,
                    tromsa: a15,
                    romsa: a15,
                    trondheim: a15,
                    troandin: a15,
                    trysil: a15,
                    trana: a15,
                    "xn--trna-woa": a15,
                    "træna": a15,
                    trogstad: a15,
                    "xn--trgstad-r1a": a15,
                    "trøgstad": a15,
                    tvedestrand: a15,
                    tydal: a15,
                    tynset: a15,
                    tysfjord: a15,
                    divtasvuodna: a15,
                    divttasvuotna: a15,
                    tysnes: a15,
                    tysvar: a15,
                    "xn--tysvr-vra": a15,
                    "tysvær": a15,
                    tonsberg: a15,
                    "xn--tnsberg-q1a": a15,
                    "tønsberg": a15,
                    ullensaker: a15,
                    ullensvang: a15,
                    ulvik: a15,
                    utsira: a15,
                    vadso: a15,
                    "xn--vads-jra": a15,
                    "vadsø": a15,
                    cahcesuolo: a15,
                    "xn--hcesuolo-7ya35b": a15,
                    "čáhcesuolo": a15,
                    vaksdal: a15,
                    valle: a15,
                    vang: a15,
                    vanylven: a15,
                    vardo: a15,
                    "xn--vard-jra": a15,
                    "vardø": a15,
                    varggat: a15,
                    "xn--vrggt-xqad": a15,
                    "várggát": a15,
                    vefsn: a15,
                    vaapste: a15,
                    vega: a15,
                    vegarshei: a15,
                    "xn--vegrshei-c0a": a15,
                    "vegårshei": a15,
                    vennesla: a15,
                    verdal: a15,
                    verran: a15,
                    vestby: a15,
                    vestnes: a15,
                    "vestre-slidre": a15,
                    "vestre-toten": a15,
                    vestvagoy: a15,
                    "xn--vestvgy-ixa6o": a15,
                    "vestvågøy": a15,
                    vevelstad: a15,
                    vik: a15,
                    vikna: a15,
                    vindafjord: a15,
                    volda: a15,
                    voss: a15,
                    varoy: a15,
                    "xn--vry-yla5g": a15,
                    "værøy": a15,
                    vagan: a15,
                    "xn--vgan-qoa": a15,
                    "vågan": a15,
                    voagat: a15,
                    vagsoy: a15,
                    "xn--vgsy-qoa0j": a15,
                    "vågsøy": a15,
                    vaga: a15,
                    "xn--vg-yiab": a15,
                    "vågå": a15,
                    ostfold: {
                        $: 0,
                        succ: {
                            valer: a15
                        }
                    },
                    "xn--stfold-9xa": {
                        $: 0,
                        succ: {
                            "xn--vler-qoa": a15
                        }
                    },
                    "østfold": {
                        $: 0,
                        succ: {
                            "våler": a15
                        }
                    },
                    co: o16,
                    blogspot: o16,
                    myspreadshop: o16
                }
            },
            np: r6,
            nr: S,
            nu: {
                $: 1,
                succ: {
                    merseine: o16,
                    mine: o16,
                    shacknet: o16,
                    enterprisecloud: o16
                }
            },
            nz: {
                $: 1,
                succ: {
                    ac: a15,
                    co: s8,
                    cri: a15,
                    geek: a15,
                    gen: a15,
                    govt: a15,
                    health: a15,
                    iwi: a15,
                    kiwi: a15,
                    maori: a15,
                    mil: a15,
                    "xn--mori-qsa": a15,
                    "māori": a15,
                    net: a15,
                    org: a15,
                    parliament: a15,
                    school: a15
                }
            },
            om: {
                $: 1,
                succ: {
                    co: a15,
                    com: a15,
                    edu: a15,
                    gov: a15,
                    med: a15,
                    museum: a15,
                    net: a15,
                    org: a15,
                    pro: a15
                }
            },
            onion: a15,
            org: {
                $: 1,
                succ: {
                    altervista: o16,
                    amune: {
                        $: 0,
                        succ: {
                            tele: o16
                        }
                    },
                    pimienta: o16,
                    poivron: o16,
                    potager: o16,
                    sweetpepper: o16,
                    ae: o16,
                    us: o16,
                    certmgr: o16,
                    cdn77: {
                        $: 0,
                        succ: {
                            c: o16,
                            rsc: o16
                        }
                    },
                    "cdn77-secure": {
                        $: 0,
                        succ: {
                            origin: {
                                $: 0,
                                succ: {
                                    ssl: o16
                                }
                            }
                        }
                    },
                    cloudns: o16,
                    duckdns: o16,
                    tunk: o16,
                    dyndns: {
                        $: 2,
                        succ: {
                            go: o16,
                            home: o16
                        }
                    },
                    blogdns: o16,
                    blogsite: o16,
                    boldlygoingnowhere: o16,
                    dnsalias: o16,
                    dnsdojo: o16,
                    doesntexist: o16,
                    dontexist: o16,
                    doomdns: o16,
                    dvrdns: o16,
                    dynalias: o16,
                    endofinternet: o16,
                    endoftheinternet: o16,
                    "from-me": o16,
                    "game-host": o16,
                    gotdns: o16,
                    "hobby-site": o16,
                    homedns: o16,
                    homeftp: o16,
                    homelinux: o16,
                    homeunix: o16,
                    "is-a-bruinsfan": o16,
                    "is-a-candidate": o16,
                    "is-a-celticsfan": o16,
                    "is-a-chef": o16,
                    "is-a-geek": o16,
                    "is-a-knight": o16,
                    "is-a-linux-user": o16,
                    "is-a-patsfan": o16,
                    "is-a-soxfan": o16,
                    "is-found": o16,
                    "is-lost": o16,
                    "is-saved": o16,
                    "is-very-bad": o16,
                    "is-very-evil": o16,
                    "is-very-good": o16,
                    "is-very-nice": o16,
                    "is-very-sweet": o16,
                    "isa-geek": o16,
                    "kicks-ass": o16,
                    misconfused: o16,
                    podzone: o16,
                    readmyblog: o16,
                    selfip: o16,
                    sellsyourhome: o16,
                    servebbs: o16,
                    serveftp: o16,
                    servegame: o16,
                    "stuff-4-sale": o16,
                    webhop: o16,
                    ddnss: o16,
                    accesscam: o16,
                    camdvr: o16,
                    freeddns: o16,
                    mywire: o16,
                    webredirect: o16,
                    eu: {
                        $: 2,
                        succ: {
                            al: o16,
                            asso: o16,
                            at: o16,
                            au: o16,
                            be: o16,
                            bg: o16,
                            ca: o16,
                            cd: o16,
                            ch: o16,
                            cn: o16,
                            cy: o16,
                            cz: o16,
                            de: o16,
                            dk: o16,
                            edu: o16,
                            ee: o16,
                            es: o16,
                            fi: o16,
                            fr: o16,
                            gr: o16,
                            hr: o16,
                            hu: o16,
                            ie: o16,
                            il: o16,
                            in: o16,
                            int: o16,
                            is: o16,
                            it: o16,
                            jp: o16,
                            kr: o16,
                            lt: o16,
                            lu: o16,
                            lv: o16,
                            mc: o16,
                            me: o16,
                            mk: o16,
                            mt: o16,
                            my: o16,
                            net: o16,
                            ng: o16,
                            nl: o16,
                            no: o16,
                            nz: o16,
                            paris: o16,
                            pl: o16,
                            pt: o16,
                            "q-a": o16,
                            ro: o16,
                            ru: o16,
                            se: o16,
                            si: o16,
                            sk: o16,
                            tr: o16,
                            uk: o16,
                            us: o16
                        }
                    },
                    twmail: o16,
                    fedorainfracloud: o16,
                    fedorapeople: o16,
                    fedoraproject: {
                        $: 0,
                        succ: {
                            cloud: o16,
                            os: b,
                            stg: {
                                $: 0,
                                succ: {
                                    os: b
                                }
                            }
                        }
                    },
                    freedesktop: o16,
                    hepforge: o16,
                    "in-dsl": o16,
                    "in-vpn": o16,
                    js: o16,
                    barsy: o16,
                    mayfirst: o16,
                    "mozilla-iot": o16,
                    bmoattachments: o16,
                    dynserv: o16,
                    "now-dns": o16,
                    "cable-modem": o16,
                    collegefan: o16,
                    couchpotatofries: o16,
                    mlbfan: o16,
                    mysecuritycamera: o16,
                    nflfan: o16,
                    "read-books": o16,
                    ufcfan: o16,
                    hopto: o16,
                    myftp: o16,
                    "no-ip": o16,
                    zapto: o16,
                    httpbin: o16,
                    pubtls: o16,
                    "my-firewall": o16,
                    myfirewall: o16,
                    spdns: o16,
                    "small-web": o16,
                    dsmynas: o16,
                    familyds: o16,
                    teckids: l2,
                    tuxfamily: o16,
                    diskstation: o16,
                    hk: o16,
                    wmflabs: o16,
                    toolforge: o16,
                    wmcloud: o16,
                    za: o16
                }
            },
            pa: {
                $: 1,
                succ: {
                    ac: a15,
                    gob: a15,
                    com: a15,
                    org: a15,
                    sld: a15,
                    edu: a15,
                    net: a15,
                    ing: a15,
                    abo: a15,
                    med: a15,
                    nom: a15
                }
            },
            pe: {
                $: 1,
                succ: {
                    edu: a15,
                    gob: a15,
                    nom: a15,
                    mil: a15,
                    org: a15,
                    com: a15,
                    net: a15,
                    blogspot: o16
                }
            },
            pf: {
                $: 1,
                succ: {
                    com: a15,
                    org: a15,
                    edu: a15
                }
            },
            pg: r6,
            ph: {
                $: 1,
                succ: {
                    com: a15,
                    net: a15,
                    org: a15,
                    gov: a15,
                    edu: a15,
                    ngo: a15,
                    mil: a15,
                    i: a15
                }
            },
            pk: {
                $: 1,
                succ: {
                    com: a15,
                    net: a15,
                    edu: a15,
                    org: a15,
                    fam: a15,
                    biz: a15,
                    web: a15,
                    gov: a15,
                    gob: a15,
                    gok: a15,
                    gon: a15,
                    gop: a15,
                    gos: a15,
                    info: a15
                }
            },
            pl: {
                $: 1,
                succ: {
                    com: a15,
                    net: a15,
                    org: a15,
                    aid: a15,
                    agro: a15,
                    atm: a15,
                    auto: a15,
                    biz: a15,
                    edu: a15,
                    gmina: a15,
                    gsm: a15,
                    info: a15,
                    mail: a15,
                    miasta: a15,
                    media: a15,
                    mil: a15,
                    nieruchomosci: a15,
                    nom: a15,
                    pc: a15,
                    powiat: a15,
                    priv: a15,
                    realestate: a15,
                    rel: a15,
                    sex: a15,
                    shop: a15,
                    sklep: a15,
                    sos: a15,
                    szkola: a15,
                    targi: a15,
                    tm: a15,
                    tourism: a15,
                    travel: a15,
                    turystyka: a15,
                    gov: {
                        $: 1,
                        succ: {
                            ap: a15,
                            ic: a15,
                            is: a15,
                            us: a15,
                            kmpsp: a15,
                            kppsp: a15,
                            kwpsp: a15,
                            psp: a15,
                            wskr: a15,
                            kwp: a15,
                            mw: a15,
                            ug: a15,
                            um: a15,
                            umig: a15,
                            ugim: a15,
                            upow: a15,
                            uw: a15,
                            starostwo: a15,
                            pa: a15,
                            po: a15,
                            psse: a15,
                            pup: a15,
                            rzgw: a15,
                            sa: a15,
                            so: a15,
                            sr: a15,
                            wsa: a15,
                            sko: a15,
                            uzs: a15,
                            wiih: a15,
                            winb: a15,
                            pinb: a15,
                            wios: a15,
                            witd: a15,
                            wzmiuw: a15,
                            piw: a15,
                            wiw: a15,
                            griw: a15,
                            wif: a15,
                            oum: a15,
                            sdn: a15,
                            zp: a15,
                            uppo: a15,
                            mup: a15,
                            wuoz: a15,
                            konsulat: a15,
                            oirm: a15
                        }
                    },
                    augustow: a15,
                    "babia-gora": a15,
                    bedzin: a15,
                    beskidy: a15,
                    bialowieza: a15,
                    bialystok: a15,
                    bielawa: a15,
                    bieszczady: a15,
                    boleslawiec: a15,
                    bydgoszcz: a15,
                    bytom: a15,
                    cieszyn: a15,
                    czeladz: a15,
                    czest: a15,
                    dlugoleka: a15,
                    elblag: a15,
                    elk: a15,
                    glogow: a15,
                    gniezno: a15,
                    gorlice: a15,
                    grajewo: a15,
                    ilawa: a15,
                    jaworzno: a15,
                    "jelenia-gora": a15,
                    jgora: a15,
                    kalisz: a15,
                    "kazimierz-dolny": a15,
                    karpacz: a15,
                    kartuzy: a15,
                    kaszuby: a15,
                    katowice: a15,
                    kepno: a15,
                    ketrzyn: a15,
                    klodzko: a15,
                    kobierzyce: a15,
                    kolobrzeg: a15,
                    konin: a15,
                    konskowola: a15,
                    kutno: a15,
                    lapy: a15,
                    lebork: a15,
                    legnica: a15,
                    lezajsk: a15,
                    limanowa: a15,
                    lomza: a15,
                    lowicz: a15,
                    lubin: a15,
                    lukow: a15,
                    malbork: a15,
                    malopolska: a15,
                    mazowsze: a15,
                    mazury: a15,
                    mielec: a15,
                    mielno: a15,
                    mragowo: a15,
                    naklo: a15,
                    nowaruda: a15,
                    nysa: a15,
                    olawa: a15,
                    olecko: a15,
                    olkusz: a15,
                    olsztyn: a15,
                    opoczno: a15,
                    opole: a15,
                    ostroda: a15,
                    ostroleka: a15,
                    ostrowiec: a15,
                    ostrowwlkp: a15,
                    pila: a15,
                    pisz: a15,
                    podhale: a15,
                    podlasie: a15,
                    polkowice: a15,
                    pomorze: a15,
                    pomorskie: a15,
                    prochowice: a15,
                    pruszkow: a15,
                    przeworsk: a15,
                    pulawy: a15,
                    radom: a15,
                    "rawa-maz": a15,
                    rybnik: a15,
                    rzeszow: a15,
                    sanok: a15,
                    sejny: a15,
                    slask: a15,
                    slupsk: a15,
                    sosnowiec: a15,
                    "stalowa-wola": a15,
                    skoczow: a15,
                    starachowice: a15,
                    stargard: a15,
                    suwalki: a15,
                    swidnica: a15,
                    swiebodzin: a15,
                    swinoujscie: a15,
                    szczecin: a15,
                    szczytno: a15,
                    tarnobrzeg: a15,
                    tgory: a15,
                    turek: a15,
                    tychy: a15,
                    ustka: a15,
                    walbrzych: a15,
                    warmia: a15,
                    warszawa: a15,
                    waw: a15,
                    wegrow: a15,
                    wielun: a15,
                    wlocl: a15,
                    wloclawek: a15,
                    wodzislaw: a15,
                    wolomin: a15,
                    wroclaw: a15,
                    zachpomor: a15,
                    zagan: a15,
                    zarow: a15,
                    zgora: a15,
                    zgorzelec: a15,
                    beep: o16,
                    "ecommerce-shop": o16,
                    shoparena: o16,
                    homesklep: o16,
                    sdscloud: o16,
                    unicloud: o16,
                    krasnik: o16,
                    leczna: o16,
                    lubartow: o16,
                    lublin: o16,
                    poniatowa: o16,
                    swidnik: o16,
                    co: o16,
                    art: o16,
                    gliwice: o16,
                    krakow: o16,
                    poznan: o16,
                    wroc: o16,
                    zakopane: o16,
                    myspreadshop: o16,
                    gda: o16,
                    gdansk: o16,
                    gdynia: o16,
                    med: o16,
                    sopot: o16
                }
            },
            pm: {
                $: 1,
                succ: {
                    own: o16
                }
            },
            pn: {
                $: 1,
                succ: {
                    gov: a15,
                    co: a15,
                    org: a15,
                    edu: a15,
                    net: a15
                }
            },
            post: a15,
            pr: {
                $: 1,
                succ: {
                    com: a15,
                    net: a15,
                    org: a15,
                    gov: a15,
                    edu: a15,
                    isla: a15,
                    pro: a15,
                    biz: a15,
                    info: a15,
                    name: a15,
                    est: a15,
                    prof: a15,
                    ac: a15
                }
            },
            pro: {
                $: 1,
                succ: {
                    aaa: a15,
                    aca: a15,
                    acct: a15,
                    avocat: a15,
                    bar: a15,
                    cpa: a15,
                    eng: a15,
                    jur: a15,
                    law: a15,
                    med: a15,
                    recht: a15,
                    cloudns: o16,
                    dnstrace: {
                        $: 0,
                        succ: {
                            bci: o16
                        }
                    },
                    barsy: o16
                }
            },
            ps: {
                $: 1,
                succ: {
                    edu: a15,
                    gov: a15,
                    sec: a15,
                    plo: a15,
                    com: a15,
                    org: a15,
                    net: a15
                }
            },
            pt: {
                $: 1,
                succ: {
                    net: a15,
                    gov: a15,
                    org: a15,
                    edu: a15,
                    int: a15,
                    publ: a15,
                    com: a15,
                    nome: a15,
                    blogspot: o16
                }
            },
            pw: {
                $: 1,
                succ: {
                    co: a15,
                    ne: a15,
                    or: a15,
                    ed: a15,
                    go: a15,
                    belau: a15,
                    cloudns: o16,
                    x443: o16
                }
            },
            py: {
                $: 1,
                succ: {
                    com: a15,
                    coop: a15,
                    edu: a15,
                    gov: a15,
                    mil: a15,
                    net: a15,
                    org: a15
                }
            },
            qa: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    gov: a15,
                    mil: a15,
                    name: a15,
                    net: a15,
                    org: a15,
                    sch: a15,
                    blogspot: o16
                }
            },
            re: {
                $: 1,
                succ: {
                    asso: a15,
                    com: a15,
                    nom: a15,
                    blogspot: o16
                }
            },
            ro: {
                $: 1,
                succ: {
                    arts: a15,
                    com: a15,
                    firm: a15,
                    info: a15,
                    nom: a15,
                    nt: a15,
                    org: a15,
                    rec: a15,
                    store: a15,
                    tm: a15,
                    www: a15,
                    co: o16,
                    shop: o16,
                    blogspot: o16,
                    barsy: o16
                }
            },
            rs: {
                $: 1,
                succ: {
                    ac: a15,
                    co: a15,
                    edu: a15,
                    gov: a15,
                    in: a15,
                    org: a15,
                    brendly: {
                        $: 0,
                        succ: {
                            shop: o16
                        }
                    },
                    blogspot: o16,
                    ua: o16,
                    ox: o16
                }
            },
            ru: {
                $: 1,
                succ: {
                    ac: o16,
                    edu: o16,
                    gov: o16,
                    int: o16,
                    mil: o16,
                    test: o16,
                    eurodir: o16,
                    adygeya: o16,
                    bashkiria: o16,
                    bir: o16,
                    cbg: o16,
                    com: o16,
                    dagestan: o16,
                    grozny: o16,
                    kalmykia: o16,
                    kustanai: o16,
                    marine: o16,
                    mordovia: o16,
                    msk: o16,
                    mytis: o16,
                    nalchik: o16,
                    nov: o16,
                    pyatigorsk: o16,
                    spb: o16,
                    vladikavkaz: o16,
                    vladimir: o16,
                    blogspot: o16,
                    na4u: o16,
                    mircloud: o16,
                    regruhosting: w,
                    myjino: {
                        $: 2,
                        succ: {
                            hosting: e12,
                            landing: e12,
                            spectrum: e12,
                            vps: e12
                        }
                    },
                    cldmail: {
                        $: 0,
                        succ: {
                            hb: o16
                        }
                    },
                    mcdir: {
                        $: 2,
                        succ: {
                            vps: o16
                        }
                    },
                    mcpre: o16,
                    net: o16,
                    org: o16,
                    pp: o16,
                    lk3: o16,
                    ras: o16
                }
            },
            rw: {
                $: 1,
                succ: {
                    ac: a15,
                    co: a15,
                    coop: a15,
                    gov: a15,
                    mil: a15,
                    net: a15,
                    org: a15
                }
            },
            sa: {
                $: 1,
                succ: {
                    com: a15,
                    net: a15,
                    org: a15,
                    gov: a15,
                    med: a15,
                    pub: a15,
                    edu: a15,
                    sch: a15
                }
            },
            sb: i12,
            sc: i12,
            sd: {
                $: 1,
                succ: {
                    com: a15,
                    net: a15,
                    org: a15,
                    edu: a15,
                    med: a15,
                    tv: a15,
                    gov: a15,
                    info: a15
                }
            },
            se: {
                $: 1,
                succ: {
                    a: a15,
                    ac: a15,
                    b: a15,
                    bd: a15,
                    brand: a15,
                    c: a15,
                    d: a15,
                    e: a15,
                    f: a15,
                    fh: a15,
                    fhsk: a15,
                    fhv: a15,
                    g: a15,
                    h: a15,
                    i: a15,
                    k: a15,
                    komforb: a15,
                    kommunalforbund: a15,
                    komvux: a15,
                    l: a15,
                    lanbib: a15,
                    m: a15,
                    n: a15,
                    naturbruksgymn: a15,
                    o: a15,
                    org: a15,
                    p: a15,
                    parti: a15,
                    pp: a15,
                    press: a15,
                    r: a15,
                    s: a15,
                    t: a15,
                    tm: a15,
                    u: a15,
                    w: a15,
                    x: a15,
                    y: a15,
                    z: a15,
                    com: o16,
                    blogspot: o16,
                    conf: o16,
                    iopsys: o16,
                    itcouldbewor: o16,
                    myspreadshop: o16,
                    paba: {
                        $: 0,
                        succ: {
                            su: o16
                        }
                    }
                }
            },
            sg: {
                $: 1,
                succ: {
                    com: a15,
                    net: a15,
                    org: a15,
                    gov: a15,
                    edu: a15,
                    per: a15,
                    blogspot: o16,
                    enscaled: o16
                }
            },
            sh: {
                $: 1,
                succ: {
                    com: a15,
                    net: a15,
                    gov: a15,
                    org: a15,
                    mil: a15,
                    bip: o16,
                    hashbang: o16,
                    platform: {
                        $: 0,
                        succ: {
                            bc: o16,
                            ent: o16,
                            eu: o16,
                            us: o16
                        }
                    },
                    now: o16,
                    vxl: o16,
                    wedeploy: o16
                }
            },
            si: {
                $: 1,
                succ: {
                    gitapp: o16,
                    gitpage: o16,
                    blogspot: o16
                }
            },
            sj: a15,
            sk: s8,
            sl: i12,
            sm: a15,
            sn: {
                $: 1,
                succ: {
                    art: a15,
                    com: a15,
                    edu: a15,
                    gouv: a15,
                    org: a15,
                    perso: a15,
                    univ: a15,
                    blogspot: o16
                }
            },
            so: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    gov: a15,
                    me: a15,
                    net: a15,
                    org: a15,
                    sch: o16
                }
            },
            sr: a15,
            ss: {
                $: 1,
                succ: {
                    biz: a15,
                    com: a15,
                    edu: a15,
                    gov: a15,
                    me: a15,
                    net: a15,
                    org: a15,
                    sch: a15
                }
            },
            st: {
                $: 1,
                succ: {
                    co: a15,
                    com: a15,
                    consulado: a15,
                    edu: a15,
                    embaixada: a15,
                    mil: a15,
                    net: a15,
                    org: a15,
                    principe: a15,
                    saotome: a15,
                    store: a15,
                    noho: o16
                }
            },
            su: {
                $: 1,
                succ: {
                    abkhazia: o16,
                    adygeya: o16,
                    aktyubinsk: o16,
                    arkhangelsk: o16,
                    armenia: o16,
                    ashgabad: o16,
                    azerbaijan: o16,
                    balashov: o16,
                    bashkiria: o16,
                    bryansk: o16,
                    bukhara: o16,
                    chimkent: o16,
                    dagestan: o16,
                    "east-kazakhstan": o16,
                    exnet: o16,
                    georgia: o16,
                    grozny: o16,
                    ivanovo: o16,
                    jambyl: o16,
                    kalmykia: o16,
                    kaluga: o16,
                    karacol: o16,
                    karaganda: o16,
                    karelia: o16,
                    khakassia: o16,
                    krasnodar: o16,
                    kurgan: o16,
                    kustanai: o16,
                    lenug: o16,
                    mangyshlak: o16,
                    mordovia: o16,
                    msk: o16,
                    murmansk: o16,
                    nalchik: o16,
                    navoi: o16,
                    "north-kazakhstan": o16,
                    nov: o16,
                    obninsk: o16,
                    penza: o16,
                    pokrovsk: o16,
                    sochi: o16,
                    spb: o16,
                    tashkent: o16,
                    termez: o16,
                    togliatti: o16,
                    troitsk: o16,
                    tselinograd: o16,
                    tula: o16,
                    tuva: o16,
                    vladikavkaz: o16,
                    vladimir: o16,
                    vologda: o16
                }
            },
            sv: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    gob: a15,
                    org: a15,
                    red: a15
                }
            },
            sx: n7,
            sy: I,
            sz: {
                $: 1,
                succ: {
                    co: a15,
                    ac: a15,
                    org: a15
                }
            },
            tc: {
                $: 1,
                succ: {
                    ch: o16,
                    me: o16,
                    we: o16
                }
            },
            td: s8,
            tel: a15,
            tf: a15,
            tg: a15,
            th: {
                $: 1,
                succ: {
                    ac: a15,
                    co: a15,
                    go: a15,
                    in: a15,
                    mi: a15,
                    net: a15,
                    or: a15,
                    online: o16,
                    shop: o16
                }
            },
            tj: {
                $: 1,
                succ: {
                    ac: a15,
                    biz: a15,
                    co: a15,
                    com: a15,
                    edu: a15,
                    go: a15,
                    gov: a15,
                    int: a15,
                    mil: a15,
                    name: a15,
                    net: a15,
                    nic: a15,
                    org: a15,
                    test: a15,
                    web: a15
                }
            },
            tk: a15,
            tl: n7,
            tm: {
                $: 1,
                succ: {
                    com: a15,
                    co: a15,
                    org: a15,
                    net: a15,
                    nom: a15,
                    gov: a15,
                    mil: a15,
                    edu: a15
                }
            },
            tn: {
                $: 1,
                succ: {
                    com: a15,
                    ens: a15,
                    fin: a15,
                    gov: a15,
                    ind: a15,
                    info: a15,
                    intl: a15,
                    mincom: a15,
                    nat: a15,
                    net: a15,
                    org: a15,
                    perso: a15,
                    tourism: a15,
                    orangecloud: o16
                }
            },
            to: {
                $: 1,
                succ: {
                    611: o16,
                    com: a15,
                    gov: a15,
                    net: a15,
                    org: a15,
                    edu: a15,
                    mil: a15,
                    oya: o16,
                    rdv: o16,
                    vpnplus: o16,
                    quickconnect: m2,
                    nyan: o16
                }
            },
            tr: {
                $: 1,
                succ: {
                    av: a15,
                    bbs: a15,
                    bel: a15,
                    biz: a15,
                    com: s8,
                    dr: a15,
                    edu: a15,
                    gen: a15,
                    gov: a15,
                    info: a15,
                    mil: a15,
                    k12: a15,
                    kep: a15,
                    name: a15,
                    net: a15,
                    org: a15,
                    pol: a15,
                    tel: a15,
                    tsk: a15,
                    tv: a15,
                    web: a15,
                    nc: n7
                }
            },
            tt: {
                $: 1,
                succ: {
                    co: a15,
                    com: a15,
                    org: a15,
                    net: a15,
                    biz: a15,
                    info: a15,
                    pro: a15,
                    int: a15,
                    coop: a15,
                    jobs: a15,
                    mobi: a15,
                    travel: a15,
                    museum: a15,
                    aero: a15,
                    name: a15,
                    gov: a15,
                    edu: a15
                }
            },
            tv: {
                $: 1,
                succ: {
                    dyndns: o16,
                    "better-than": o16,
                    "on-the-web": o16,
                    "worse-than": o16
                }
            },
            tw: {
                $: 1,
                succ: {
                    edu: a15,
                    gov: a15,
                    mil: a15,
                    com: {
                        $: 1,
                        succ: {
                            mymailer: o16
                        }
                    },
                    net: a15,
                    org: a15,
                    idv: a15,
                    game: a15,
                    ebiz: a15,
                    club: a15,
                    "xn--zf0ao64a": a15,
                    "網路": a15,
                    "xn--uc0atv": a15,
                    "組織": a15,
                    "xn--czrw28b": a15,
                    "商業": a15,
                    url: o16,
                    blogspot: o16
                }
            },
            tz: {
                $: 1,
                succ: {
                    ac: a15,
                    co: a15,
                    go: a15,
                    hotel: a15,
                    info: a15,
                    me: a15,
                    mil: a15,
                    mobi: a15,
                    ne: a15,
                    or: a15,
                    sc: a15,
                    tv: a15
                }
            },
            ua: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    gov: a15,
                    in: a15,
                    net: a15,
                    org: a15,
                    cherkassy: a15,
                    cherkasy: a15,
                    chernigov: a15,
                    chernihiv: a15,
                    chernivtsi: a15,
                    chernovtsy: a15,
                    ck: a15,
                    cn: a15,
                    cr: a15,
                    crimea: a15,
                    cv: a15,
                    dn: a15,
                    dnepropetrovsk: a15,
                    dnipropetrovsk: a15,
                    donetsk: a15,
                    dp: a15,
                    if: a15,
                    "ivano-frankivsk": a15,
                    kh: a15,
                    kharkiv: a15,
                    kharkov: a15,
                    kherson: a15,
                    khmelnitskiy: a15,
                    khmelnytskyi: a15,
                    kiev: a15,
                    kirovograd: a15,
                    km: a15,
                    kr: a15,
                    krym: a15,
                    ks: a15,
                    kv: a15,
                    kyiv: a15,
                    lg: a15,
                    lt: a15,
                    lugansk: a15,
                    lutsk: a15,
                    lv: a15,
                    lviv: a15,
                    mk: a15,
                    mykolaiv: a15,
                    nikolaev: a15,
                    od: a15,
                    odesa: a15,
                    odessa: a15,
                    pl: a15,
                    poltava: a15,
                    rivne: a15,
                    rovno: a15,
                    rv: a15,
                    sb: a15,
                    sebastopol: a15,
                    sevastopol: a15,
                    sm: a15,
                    sumy: a15,
                    te: a15,
                    ternopil: a15,
                    uz: a15,
                    uzhgorod: a15,
                    vinnica: a15,
                    vinnytsia: a15,
                    vn: a15,
                    volyn: a15,
                    yalta: a15,
                    zaporizhzhe: a15,
                    zaporizhzhia: a15,
                    zhitomir: a15,
                    zhytomyr: a15,
                    zp: a15,
                    zt: a15,
                    cc: o16,
                    inf: o16,
                    ltd: o16,
                    cx: o16,
                    biz: o16,
                    co: o16,
                    pp: o16,
                    v: o16
                }
            },
            ug: {
                $: 1,
                succ: {
                    co: a15,
                    or: a15,
                    ac: a15,
                    sc: a15,
                    go: a15,
                    ne: a15,
                    com: a15,
                    org: a15,
                    blogspot: o16
                }
            },
            uk: {
                $: 1,
                succ: {
                    ac: a15,
                    co: {
                        $: 1,
                        succ: {
                            bytemark: {
                                $: 0,
                                succ: {
                                    dh: o16,
                                    vm: o16
                                }
                            },
                            blogspot: o16,
                            layershift: x,
                            barsy: o16,
                            barsyonline: o16,
                            retrosnub: q,
                            "nh-serv": o16,
                            "no-ip": o16,
                            wellbeingzone: o16,
                            adimo: o16,
                            myspreadshop: o16,
                            gwiddle: o16
                        }
                    },
                    gov: {
                        $: 1,
                        succ: {
                            campaign: o16,
                            service: o16,
                            api: o16,
                            homeoffice: o16
                        }
                    },
                    ltd: a15,
                    me: a15,
                    net: a15,
                    nhs: a15,
                    org: {
                        $: 1,
                        succ: {
                            glug: o16,
                            lug: o16,
                            lugs: o16,
                            affinitylottery: o16,
                            raffleentry: o16,
                            weeklylottery: o16
                        }
                    },
                    plc: a15,
                    police: a15,
                    sch: r6,
                    conn: o16,
                    copro: o16,
                    hosp: o16,
                    "independent-commission": o16,
                    "independent-inquest": o16,
                    "independent-inquiry": o16,
                    "independent-panel": o16,
                    "independent-review": o16,
                    "public-inquiry": o16,
                    "royal-commission": o16,
                    pymnt: o16,
                    barsy: o16
                }
            },
            us: {
                $: 1,
                succ: {
                    dni: a15,
                    fed: a15,
                    isa: a15,
                    kids: a15,
                    nsn: a15,
                    ak: W,
                    al: W,
                    ar: W,
                    as: W,
                    az: W,
                    ca: W,
                    co: W,
                    ct: W,
                    dc: W,
                    de: {
                        $: 1,
                        succ: {
                            k12: a15,
                            cc: a15,
                            lib: o16
                        }
                    },
                    fl: W,
                    ga: W,
                    gu: W,
                    hi: L,
                    ia: W,
                    id: W,
                    il: W,
                    in: W,
                    ks: W,
                    ky: W,
                    la: W,
                    ma: {
                        $: 1,
                        succ: {
                            k12: {
                                $: 1,
                                succ: {
                                    pvt: a15,
                                    chtr: a15,
                                    paroch: a15
                                }
                            },
                            cc: a15,
                            lib: a15
                        }
                    },
                    md: W,
                    me: W,
                    mi: {
                        $: 1,
                        succ: {
                            k12: a15,
                            cc: a15,
                            lib: a15,
                            "ann-arbor": a15,
                            cog: a15,
                            dst: a15,
                            eaton: a15,
                            gen: a15,
                            mus: a15,
                            tec: a15,
                            washtenaw: a15
                        }
                    },
                    mn: W,
                    mo: W,
                    ms: W,
                    mt: W,
                    nc: W,
                    nd: L,
                    ne: W,
                    nh: W,
                    nj: W,
                    nm: W,
                    nv: W,
                    ny: W,
                    oh: W,
                    ok: W,
                    or: W,
                    pa: W,
                    pr: W,
                    ri: L,
                    sc: W,
                    sd: L,
                    tn: W,
                    tx: W,
                    ut: W,
                    vi: W,
                    vt: W,
                    va: W,
                    wa: W,
                    wi: W,
                    wv: {
                        $: 1,
                        succ: {
                            cc: a15
                        }
                    },
                    wy: W,
                    graphox: o16,
                    cloudns: o16,
                    drud: o16,
                    "is-by": o16,
                    "land-4-sale": o16,
                    "stuff-4-sale": o16,
                    enscaled: {
                        $: 0,
                        succ: {
                            phx: o16
                        }
                    },
                    mircloud: o16,
                    freeddns: o16,
                    golffan: o16,
                    noip: o16,
                    pointto: o16,
                    platterp: o16
                }
            },
            uy: {
                $: 1,
                succ: {
                    com: s8,
                    edu: a15,
                    gub: a15,
                    mil: a15,
                    net: a15,
                    org: a15
                }
            },
            uz: {
                $: 1,
                succ: {
                    co: a15,
                    com: a15,
                    net: a15,
                    org: a15
                }
            },
            va: a15,
            vc: {
                $: 1,
                succ: {
                    com: a15,
                    net: a15,
                    org: a15,
                    gov: a15,
                    mil: a15,
                    edu: a15,
                    gv: {
                        $: 2,
                        succ: {
                            d: o16
                        }
                    },
                    "0e": o16
                }
            },
            ve: {
                $: 1,
                succ: {
                    arts: a15,
                    bib: a15,
                    co: a15,
                    com: a15,
                    e12: a15,
                    edu: a15,
                    firm: a15,
                    gob: a15,
                    gov: a15,
                    info: a15,
                    int: a15,
                    mil: a15,
                    net: a15,
                    nom: a15,
                    org: a15,
                    rar: a15,
                    rec: a15,
                    store: a15,
                    tec: a15,
                    web: a15
                }
            },
            vg: {
                $: 1,
                succ: {
                    at: o16
                }
            },
            vi: {
                $: 1,
                succ: {
                    co: a15,
                    com: a15,
                    k12: a15,
                    net: a15,
                    org: a15
                }
            },
            vn: {
                $: 1,
                succ: {
                    com: a15,
                    net: a15,
                    org: a15,
                    edu: a15,
                    gov: a15,
                    int: a15,
                    ac: a15,
                    biz: a15,
                    info: a15,
                    name: a15,
                    pro: a15,
                    health: a15,
                    blogspot: o16
                }
            },
            vu: {
                $: 1,
                succ: {
                    com: a15,
                    edu: a15,
                    net: a15,
                    org: a15,
                    cn: o16,
                    blog: o16,
                    dev: o16,
                    me: o16
                }
            },
            wf: a15,
            ws: {
                $: 1,
                succ: {
                    com: a15,
                    net: a15,
                    org: a15,
                    gov: a15,
                    edu: a15,
                    advisor: e12,
                    cloud66: o16,
                    dyndns: o16,
                    mypets: o16
                }
            },
            yt: {
                $: 1,
                succ: {
                    org: o16
                }
            },
            "xn--mgbaam7a8h": a15,
            "امارات": a15,
            "xn--y9a3aq": a15,
            "հայ": a15,
            "xn--54b7fta0cc": a15,
            "বাংলা": a15,
            "xn--90ae": a15,
            "бг": a15,
            "xn--mgbcpq6gpa1a": a15,
            "البحرين": a15,
            "xn--90ais": a15,
            "бел": a15,
            "xn--fiqs8s": a15,
            "中国": a15,
            "xn--fiqz9s": a15,
            "中國": a15,
            "xn--lgbbat1ad8j": a15,
            "الجزائر": a15,
            "xn--wgbh1c": a15,
            "مصر": a15,
            "xn--e1a4c": a15,
            "ею": a15,
            "xn--qxa6a": a15,
            "ευ": a15,
            "xn--mgbah1a3hjkrd": a15,
            "موريتانيا": a15,
            "xn--node": a15,
            "გე": a15,
            "xn--qxam": a15,
            "ελ": a15,
            "xn--j6w193g": {
                $: 1,
                succ: {
                    "xn--55qx5d": a15,
                    "xn--wcvs22d": a15,
                    "xn--mxtq1m": a15,
                    "xn--gmqw5a": a15,
                    "xn--od0alg": a15,
                    "xn--uc0atv": a15
                }
            },
            "香港": {
                $: 1,
                succ: {
                    "公司": a15,
                    "教育": a15,
                    "政府": a15,
                    "個人": a15,
                    "網絡": a15,
                    "組織": a15
                }
            },
            "xn--2scrj9c": a15,
            "ಭಾರತ": a15,
            "xn--3hcrj9c": a15,
            "ଭାରତ": a15,
            "xn--45br5cyl": a15,
            "ভাৰত": a15,
            "xn--h2breg3eve": a15,
            "भारतम्": a15,
            "xn--h2brj9c8c": a15,
            "भारोत": a15,
            "xn--mgbgu82a": a15,
            "ڀارت": a15,
            "xn--rvc1e0am3e": a15,
            "ഭാരതം": a15,
            "xn--h2brj9c": a15,
            "भारत": a15,
            "xn--mgbbh1a": a15,
            "بارت": a15,
            "xn--mgbbh1a71e": a15,
            "بھارت": a15,
            "xn--fpcrj9c3d": a15,
            "భారత్": a15,
            "xn--gecrj9c": a15,
            "ભારત": a15,
            "xn--s9brj9c": a15,
            "ਭਾਰਤ": a15,
            "xn--45brj9c": a15,
            "ভারত": a15,
            "xn--xkc2dl3a5ee0h": a15,
            "இந்தியா": a15,
            "xn--mgba3a4f16a": a15,
            "ایران": a15,
            "xn--mgba3a4fra": a15,
            "ايران": a15,
            "xn--mgbtx2b": a15,
            "عراق": a15,
            "xn--mgbayh7gpa": a15,
            "الاردن": a15,
            "xn--3e0b707e": a15,
            "한국": a15,
            "xn--80ao21a": a15,
            "қаз": a15,
            "xn--q7ce6a": a15,
            "ລາວ": a15,
            "xn--fzc2c9e2c": a15,
            "ලංකා": a15,
            "xn--xkc2al3hye2a": a15,
            "இலங்கை": a15,
            "xn--mgbc0a9azcg": a15,
            "المغرب": a15,
            "xn--d1alf": a15,
            "мкд": a15,
            "xn--l1acc": a15,
            "мон": a15,
            "xn--mix891f": a15,
            "澳門": a15,
            "xn--mix082f": a15,
            "澳门": a15,
            "xn--mgbx4cd0ab": a15,
            "مليسيا": a15,
            "xn--mgb9awbf": a15,
            "عمان": a15,
            "xn--mgbai9azgqp6j": a15,
            "پاکستان": a15,
            "xn--mgbai9a5eva00b": a15,
            "پاكستان": a15,
            "xn--ygbi2ammx": a15,
            "فلسطين": a15,
            "xn--90a3ac": {
                $: 1,
                succ: {
                    "xn--o1ac": a15,
                    "xn--c1avg": a15,
                    "xn--90azh": a15,
                    "xn--d1at": a15,
                    "xn--o1ach": a15,
                    "xn--80au": a15
                }
            },
            "срб": {
                $: 1,
                succ: {
                    "пр": a15,
                    "орг": a15,
                    "обр": a15,
                    "од": a15,
                    "упр": a15,
                    "ак": a15
                }
            },
            "xn--p1ai": a15,
            "рф": a15,
            "xn--wgbl6a": a15,
            "قطر": a15,
            "xn--mgberp4a5d4ar": a15,
            "السعودية": a15,
            "xn--mgberp4a5d4a87g": a15,
            "السعودیة": a15,
            "xn--mgbqly7c0a67fbc": a15,
            "السعودیۃ": a15,
            "xn--mgbqly7cvafr": a15,
            "السعوديه": a15,
            "xn--mgbpl2fh": a15,
            "سودان": a15,
            "xn--yfro4i67o": a15,
            "新加坡": a15,
            "xn--clchc0ea0b2g2a9gcd": a15,
            "சிங்கப்பூர்": a15,
            "xn--ogbpf8fl": a15,
            "سورية": a15,
            "xn--mgbtf8fl": a15,
            "سوريا": a15,
            "xn--o3cw4h": {
                $: 1,
                succ: {
                    "xn--12c1fe0br": a15,
                    "xn--12co0c3b4eva": a15,
                    "xn--h3cuzk1di": a15,
                    "xn--o3cyx2a": a15,
                    "xn--m3ch0j3a": a15,
                    "xn--12cfi8ixb8l": a15
                }
            },
            "ไทย": {
                $: 1,
                succ: {
                    "ศึกษา": a15,
                    "ธุรกิจ": a15,
                    "รัฐบาล": a15,
                    "ทหาร": a15,
                    "เน็ต": a15,
                    "องค์กร": a15
                }
            },
            "xn--pgbs0dh": a15,
            "تونس": a15,
            "xn--kpry57d": a15,
            "台灣": a15,
            "xn--kprw13d": a15,
            "台湾": a15,
            "xn--nnx388a": a15,
            "臺灣": a15,
            "xn--j1amh": a15,
            "укр": a15,
            "xn--mgb2ddes": a15,
            "اليمن": a15,
            xxx: a15,
            ye: I,
            za: {
                $: 0,
                succ: {
                    ac: a15,
                    agric: a15,
                    alt: a15,
                    co: s8,
                    edu: a15,
                    gov: a15,
                    grondar: a15,
                    law: a15,
                    mil: a15,
                    net: a15,
                    ngo: a15,
                    nic: a15,
                    nis: a15,
                    nom: a15,
                    org: a15,
                    school: a15,
                    tm: a15,
                    web: a15
                }
            },
            zm: {
                $: 1,
                succ: {
                    ac: a15,
                    biz: a15,
                    co: a15,
                    com: a15,
                    edu: a15,
                    gov: a15,
                    info: a15,
                    mil: a15,
                    net: a15,
                    org: a15,
                    sch: a15
                }
            },
            zw: {
                $: 1,
                succ: {
                    ac: a15,
                    co: a15,
                    gov: a15,
                    mil: a15,
                    org: a15
                }
            },
            aaa: a15,
            aarp: a15,
            abarth: a15,
            abb: a15,
            abbott: a15,
            abbvie: a15,
            abc: a15,
            able: a15,
            abogado: a15,
            abudhabi: a15,
            academy: {
                $: 1,
                succ: {
                    official: o16
                }
            },
            accenture: a15,
            accountant: a15,
            accountants: a15,
            aco: a15,
            actor: a15,
            adac: a15,
            ads: a15,
            adult: a15,
            aeg: a15,
            aetna: a15,
            afl: a15,
            africa: a15,
            agakhan: a15,
            agency: a15,
            aig: a15,
            airbus: a15,
            airforce: a15,
            airtel: a15,
            akdn: a15,
            alfaromeo: a15,
            alibaba: a15,
            alipay: a15,
            allfinanz: a15,
            allstate: a15,
            ally: a15,
            alsace: a15,
            alstom: a15,
            amazon: a15,
            americanexpress: a15,
            americanfamily: a15,
            amex: a15,
            amfam: a15,
            amica: a15,
            amsterdam: a15,
            analytics: a15,
            android: a15,
            anquan: a15,
            anz: a15,
            aol: a15,
            apartments: a15,
            app: {
                $: 1,
                succ: {
                    beget: e12,
                    clerk: o16,
                    clerkstage: o16,
                    wnext: o16,
                    platform0: o16,
                    deta: o16,
                    ondigitalocean: o16,
                    encr: o16,
                    edgecompute: o16,
                    fireweb: o16,
                    onflashdrive: o16,
                    framer: o16,
                    run: {
                        $: 2,
                        succ: {
                            a: o16
                        }
                    },
                    web: o16,
                    hasura: o16,
                    loginline: o16,
                    netlify: o16,
                    developer: e12,
                    noop: o16,
                    northflank: e12,
                    telebit: o16,
                    typedream: o16,
                    vercel: o16,
                    bookonline: o16
                }
            },
            apple: a15,
            aquarelle: a15,
            arab: a15,
            aramco: a15,
            archi: a15,
            army: a15,
            art: a15,
            arte: a15,
            asda: a15,
            associates: a15,
            athleta: a15,
            attorney: a15,
            auction: a15,
            audi: a15,
            audible: a15,
            audio: a15,
            auspost: a15,
            author: a15,
            auto: a15,
            autos: a15,
            avianca: a15,
            aws: a15,
            axa: a15,
            azure: a15,
            baby: a15,
            baidu: a15,
            banamex: a15,
            bananarepublic: a15,
            band: a15,
            bank: a15,
            bar: a15,
            barcelona: a15,
            barclaycard: a15,
            barclays: a15,
            barefoot: a15,
            bargains: a15,
            baseball: a15,
            basketball: {
                $: 1,
                succ: {
                    aus: o16,
                    nz: o16
                }
            },
            bauhaus: a15,
            bayern: a15,
            bbc: a15,
            bbt: a15,
            bbva: a15,
            bcg: a15,
            bcn: a15,
            beats: a15,
            beauty: a15,
            beer: a15,
            bentley: a15,
            berlin: a15,
            best: a15,
            bestbuy: a15,
            bet: a15,
            bharti: a15,
            bible: a15,
            bid: a15,
            bike: a15,
            bing: a15,
            bingo: a15,
            bio: a15,
            black: a15,
            blackfriday: a15,
            blockbuster: a15,
            blog: a15,
            bloomberg: a15,
            blue: a15,
            bms: a15,
            bmw: a15,
            bnpparibas: a15,
            boats: a15,
            boehringer: a15,
            bofa: a15,
            bom: a15,
            bond: a15,
            boo: a15,
            book: a15,
            booking: a15,
            bosch: a15,
            bostik: a15,
            boston: a15,
            bot: a15,
            boutique: a15,
            box: a15,
            bradesco: a15,
            bridgestone: a15,
            broadway: a15,
            broker: a15,
            brother: a15,
            brussels: a15,
            bugatti: a15,
            build: a15,
            builders: {
                $: 1,
                succ: {
                    cloudsite: o16
                }
            },
            business: c3,
            buy: a15,
            buzz: a15,
            bzh: a15,
            cab: a15,
            cafe: a15,
            cal: a15,
            call: a15,
            calvinklein: a15,
            cam: a15,
            camera: a15,
            camp: a15,
            cancerresearch: a15,
            canon: a15,
            capetown: a15,
            capital: a15,
            capitalone: a15,
            car: a15,
            caravan: a15,
            cards: a15,
            care: a15,
            career: a15,
            careers: a15,
            cars: a15,
            casa: {
                $: 1,
                succ: {
                    nabu: {
                        $: 0,
                        succ: {
                            ui: o16
                        }
                    }
                }
            },
            case: a15,
            cash: a15,
            casino: a15,
            catering: a15,
            catholic: a15,
            cba: a15,
            cbn: a15,
            cbre: a15,
            cbs: a15,
            center: a15,
            ceo: a15,
            cern: a15,
            cfa: a15,
            cfd: a15,
            chanel: a15,
            channel: a15,
            charity: a15,
            chase: a15,
            chat: a15,
            cheap: a15,
            chintai: a15,
            christmas: a15,
            chrome: a15,
            church: a15,
            cipriani: a15,
            circle: a15,
            cisco: a15,
            citadel: a15,
            citi: a15,
            citic: a15,
            city: a15,
            cityeats: a15,
            claims: a15,
            cleaning: a15,
            click: a15,
            clinic: a15,
            clinique: a15,
            clothing: a15,
            cloud: {
                $: 1,
                succ: {
                    banzai: e12,
                    elementor: o16,
                    encoway: {
                        $: 0,
                        succ: {
                            eu: o16
                        }
                    },
                    statics: e12,
                    ravendb: o16,
                    axarnet: {
                        $: 0,
                        succ: {
                            "es-1": o16
                        }
                    },
                    diadem: o16,
                    jelastic: {
                        $: 0,
                        succ: {
                            vip: o16
                        }
                    },
                    jele: o16,
                    "jenv-aruba": {
                        $: 0,
                        succ: {
                            aruba: {
                                $: 0,
                                succ: {
                                    eur: {
                                        $: 0,
                                        succ: {
                                            it1: o16
                                        }
                                    }
                                }
                            },
                            it1: o16
                        }
                    },
                    keliweb: {
                        $: 2,
                        succ: {
                            cs: o16
                        }
                    },
                    oxa: {
                        $: 2,
                        succ: {
                            tn: o16,
                            uk: o16
                        }
                    },
                    primetel: {
                        $: 2,
                        succ: {
                            uk: o16
                        }
                    },
                    reclaim: {
                        $: 0,
                        succ: {
                            ca: o16,
                            uk: o16,
                            us: o16
                        }
                    },
                    trendhosting: {
                        $: 0,
                        succ: {
                            ch: o16,
                            de: o16
                        }
                    },
                    jotelulu: o16,
                    kuleuven: o16,
                    linkyard: o16,
                    magentosite: e12,
                    perspecta: o16,
                    vapor: o16,
                    "on-rancher": e12,
                    scw: {
                        $: 0,
                        succ: {
                            baremetal: {
                                $: 0,
                                succ: {
                                    "fr-par-1": o16,
                                    "fr-par-2": o16,
                                    "nl-ams-1": o16
                                }
                            },
                            "fr-par": {
                                $: 0,
                                succ: {
                                    fnc: {
                                        $: 2,
                                        succ: {
                                            functions: o16
                                        }
                                    },
                                    k8s: u2,
                                    s3: o16,
                                    "s3-website": o16,
                                    whm: o16
                                }
                            },
                            instances: {
                                $: 0,
                                succ: {
                                    priv: o16,
                                    pub: o16
                                }
                            },
                            k8s: o16,
                            "nl-ams": {
                                $: 0,
                                succ: {
                                    k8s: u2,
                                    s3: o16,
                                    "s3-website": o16,
                                    whm: o16
                                }
                            },
                            "pl-waw": {
                                $: 0,
                                succ: {
                                    k8s: u2,
                                    s3: o16,
                                    "s3-website": o16
                                }
                            },
                            scalebook: o16,
                            smartlabeling: o16
                        }
                    },
                    sensiosite: e12,
                    trafficplex: o16,
                    urown: o16,
                    voorloper: o16
                }
            },
            club: {
                $: 1,
                succ: {
                    cloudns: o16,
                    jele: o16,
                    barsy: o16,
                    pony: o16
                }
            },
            clubmed: a15,
            coach: a15,
            codes: {
                $: 1,
                succ: {
                    owo: e12
                }
            },
            coffee: a15,
            college: a15,
            cologne: a15,
            comcast: a15,
            commbank: a15,
            community: {
                $: 1,
                succ: {
                    nog: o16,
                    ravendb: o16,
                    myforum: o16
                }
            },
            company: a15,
            compare: a15,
            computer: a15,
            comsec: a15,
            condos: a15,
            construction: a15,
            consulting: a15,
            contact: a15,
            contractors: a15,
            cooking: a15,
            cookingchannel: a15,
            cool: {
                $: 1,
                succ: {
                    elementor: o16,
                    de: o16
                }
            },
            corsica: a15,
            country: a15,
            coupon: a15,
            coupons: a15,
            courses: a15,
            cpa: a15,
            credit: a15,
            creditcard: a15,
            creditunion: a15,
            cricket: a15,
            crown: a15,
            crs: a15,
            cruise: a15,
            cruises: a15,
            cuisinella: a15,
            cymru: a15,
            cyou: a15,
            dabur: a15,
            dad: a15,
            dance: a15,
            data: a15,
            date: a15,
            dating: a15,
            datsun: a15,
            day: a15,
            dclk: a15,
            dds: a15,
            deal: a15,
            dealer: a15,
            deals: a15,
            degree: a15,
            delivery: a15,
            dell: a15,
            deloitte: a15,
            delta: a15,
            democrat: a15,
            dental: a15,
            dentist: a15,
            desi: a15,
            design: {
                $: 1,
                succ: {
                    bss: o16
                }
            },
            dev: {
                $: 1,
                succ: {
                    lcl: e12,
                    lclstage: e12,
                    stg: e12,
                    stgstage: e12,
                    pages: o16,
                    workers: o16,
                    curv: o16,
                    deno: o16,
                    "deno-staging": o16,
                    deta: o16,
                    fly: o16,
                    githubpreview: o16,
                    gateway: e12,
                    iserv: o16,
                    localcert: {
                        $: 0,
                        succ: {
                            user: e12
                        }
                    },
                    loginline: o16,
                    mediatech: o16,
                    "platter-app": o16,
                    shiftcrypto: o16,
                    vercel: o16,
                    webhare: e12
                }
            },
            dhl: a15,
            diamonds: a15,
            diet: a15,
            digital: {
                $: 1,
                succ: {
                    cloudapps: {
                        $: 2,
                        succ: {
                            london: o16
                        }
                    }
                }
            },
            direct: a15,
            directory: a15,
            discount: a15,
            discover: a15,
            dish: a15,
            diy: a15,
            dnp: a15,
            docs: a15,
            doctor: a15,
            dog: a15,
            domains: a15,
            dot: a15,
            download: a15,
            drive: a15,
            dtv: a15,
            dubai: a15,
            dunlop: a15,
            dupont: a15,
            durban: a15,
            dvag: a15,
            dvr: a15,
            earth: {
                $: 1,
                succ: {
                    dapps: {
                        $: 0,
                        succ: {
                            "*": o16,
                            bzz: e12
                        }
                    }
                }
            },
            eat: a15,
            eco: a15,
            edeka: a15,
            education: c3,
            email: a15,
            emerck: a15,
            energy: a15,
            engineer: a15,
            engineering: a15,
            enterprises: a15,
            epson: a15,
            equipment: a15,
            ericsson: a15,
            erni: a15,
            esq: a15,
            estate: {
                $: 1,
                succ: {
                    compute: e12
                }
            },
            etisalat: a15,
            eurovision: a15,
            eus: {
                $: 1,
                succ: {
                    party: $
                }
            },
            events: {
                $: 1,
                succ: {
                    koobin: o16,
                    co: o16
                }
            },
            exchange: a15,
            expert: a15,
            exposed: a15,
            express: a15,
            extraspace: a15,
            fage: a15,
            fail: a15,
            fairwinds: a15,
            faith: z,
            family: a15,
            fan: a15,
            fans: a15,
            farm: {
                $: 1,
                succ: {
                    storj: o16
                }
            },
            farmers: a15,
            fashion: {
                $: 1,
                succ: {
                    of: o16
                }
            },
            fast: a15,
            fedex: a15,
            feedback: a15,
            ferrari: a15,
            ferrero: a15,
            fiat: a15,
            fidelity: a15,
            fido: a15,
            film: a15,
            final: a15,
            finance: a15,
            financial: c3,
            fire: a15,
            firestone: a15,
            firmdale: a15,
            fish: a15,
            fishing: a15,
            fit: a15,
            fitness: a15,
            flickr: a15,
            flights: a15,
            flir: a15,
            florist: a15,
            flowers: a15,
            fly: a15,
            foo: a15,
            food: a15,
            foodnetwork: a15,
            football: a15,
            ford: a15,
            forex: a15,
            forsale: a15,
            forum: a15,
            foundation: a15,
            fox: a15,
            free: a15,
            fresenius: a15,
            frl: a15,
            frogans: a15,
            frontdoor: a15,
            frontier: a15,
            ftr: a15,
            fujitsu: a15,
            fun: a15,
            fund: a15,
            furniture: a15,
            futbol: a15,
            fyi: a15,
            gal: a15,
            gallery: a15,
            gallo: a15,
            gallup: a15,
            game: a15,
            games: a15,
            gap: a15,
            garden: a15,
            gay: a15,
            gbiz: a15,
            gdn: {
                $: 1,
                succ: {
                    cnpy: o16
                }
            },
            gea: a15,
            gent: a15,
            genting: a15,
            george: a15,
            ggee: a15,
            gift: a15,
            gifts: a15,
            gives: a15,
            giving: a15,
            glass: a15,
            gle: a15,
            global: a15,
            globo: a15,
            gmail: a15,
            gmbh: a15,
            gmo: a15,
            gmx: a15,
            godaddy: a15,
            gold: a15,
            goldpoint: a15,
            golf: a15,
            goo: a15,
            goodyear: a15,
            goog: {
                $: 1,
                succ: {
                    cloud: o16,
                    translate: o16,
                    usercontent: e12
                }
            },
            google: a15,
            gop: a15,
            got: a15,
            grainger: a15,
            graphics: a15,
            gratis: a15,
            green: a15,
            gripe: a15,
            grocery: a15,
            group: {
                $: 1,
                succ: {
                    discourse: o16
                }
            },
            guardian: a15,
            gucci: a15,
            guge: a15,
            guide: a15,
            guitars: a15,
            guru: a15,
            hair: a15,
            hamburg: a15,
            hangout: a15,
            haus: a15,
            hbo: a15,
            hdfc: a15,
            hdfcbank: a15,
            health: {
                $: 1,
                succ: {
                    hra: o16
                }
            },
            healthcare: a15,
            help: a15,
            helsinki: a15,
            here: a15,
            hermes: a15,
            hgtv: a15,
            hiphop: a15,
            hisamitsu: a15,
            hitachi: a15,
            hiv: a15,
            hkt: a15,
            hockey: a15,
            holdings: a15,
            holiday: a15,
            homedepot: a15,
            homegoods: a15,
            homes: a15,
            homesense: a15,
            honda: a15,
            horse: a15,
            hospital: a15,
            host: {
                $: 1,
                succ: {
                    cloudaccess: o16,
                    freesite: o16,
                    fastvps: o16,
                    myfast: o16,
                    tempurl: o16,
                    wpmudev: o16,
                    jele: o16,
                    mircloud: o16,
                    pcloud: o16,
                    half: o16
                }
            },
            hosting: {
                $: 1,
                succ: {
                    opencraft: o16
                }
            },
            hot: a15,
            hoteles: a15,
            hotels: a15,
            hotmail: a15,
            house: a15,
            how: a15,
            hsbc: a15,
            hughes: a15,
            hyatt: a15,
            hyundai: a15,
            ibm: a15,
            icbc: a15,
            ice: a15,
            icu: a15,
            ieee: a15,
            ifm: a15,
            ikano: a15,
            imamat: a15,
            imdb: a15,
            immo: a15,
            immobilien: a15,
            inc: a15,
            industries: a15,
            infiniti: a15,
            ing: a15,
            ink: a15,
            institute: a15,
            insurance: a15,
            insure: a15,
            international: a15,
            intuit: a15,
            investments: a15,
            ipiranga: a15,
            irish: a15,
            ismaili: a15,
            ist: a15,
            istanbul: a15,
            itau: a15,
            itv: a15,
            jaguar: a15,
            java: a15,
            jcb: a15,
            jeep: a15,
            jetzt: a15,
            jewelry: a15,
            jio: a15,
            jll: a15,
            jmp: a15,
            jnj: a15,
            joburg: a15,
            jot: a15,
            joy: a15,
            jpmorgan: a15,
            jprs: a15,
            juegos: a15,
            juniper: a15,
            kaufen: a15,
            kddi: a15,
            kerryhotels: a15,
            kerrylogistics: a15,
            kerryproperties: a15,
            kfh: a15,
            kia: a15,
            kids: a15,
            kim: a15,
            kinder: a15,
            kindle: a15,
            kitchen: a15,
            kiwi: a15,
            koeln: a15,
            komatsu: a15,
            kosher: a15,
            kpmg: a15,
            kpn: a15,
            krd: {
                $: 1,
                succ: {
                    co: o16,
                    edu: o16
                }
            },
            kred: a15,
            kuokgroup: a15,
            kyoto: a15,
            lacaixa: a15,
            lamborghini: a15,
            lamer: a15,
            lancaster: a15,
            lancia: a15,
            land: {
                $: 1,
                succ: {
                    static: {
                        $: 2,
                        succ: {
                            dev: o16,
                            sites: o16
                        }
                    }
                }
            },
            landrover: a15,
            lanxess: a15,
            lasalle: a15,
            lat: a15,
            latino: a15,
            latrobe: a15,
            law: a15,
            lawyer: a15,
            lds: a15,
            lease: a15,
            leclerc: a15,
            lefrak: a15,
            legal: a15,
            lego: a15,
            lexus: a15,
            lgbt: a15,
            lidl: a15,
            life: a15,
            lifeinsurance: a15,
            lifestyle: a15,
            lighting: a15,
            like: a15,
            lilly: a15,
            limited: a15,
            limo: a15,
            lincoln: a15,
            linde: a15,
            link: {
                $: 1,
                succ: {
                    cyon: o16,
                    mypep: o16,
                    dweb: e12
                }
            },
            lipsy: a15,
            live: {
                $: 1,
                succ: {
                    hlx: o16
                }
            },
            living: a15,
            llc: a15,
            llp: a15,
            loan: a15,
            loans: a15,
            locker: a15,
            locus: a15,
            loft: a15,
            lol: {
                $: 1,
                succ: {
                    omg: o16
                }
            },
            london: {
                $: 1,
                succ: {
                    in: o16,
                    of: o16
                }
            },
            lotte: a15,
            lotto: a15,
            love: a15,
            lpl: a15,
            lplfinancial: a15,
            ltd: a15,
            ltda: a15,
            lundbeck: a15,
            luxe: a15,
            luxury: a15,
            macys: a15,
            madrid: a15,
            maif: a15,
            maison: a15,
            makeup: a15,
            man: a15,
            management: {
                $: 1,
                succ: {
                    router: o16
                }
            },
            mango: a15,
            map: a15,
            market: a15,
            marketing: {
                $: 1,
                succ: {
                    from: o16,
                    with: o16
                }
            },
            markets: a15,
            marriott: a15,
            marshalls: a15,
            maserati: a15,
            mattel: a15,
            mba: a15,
            mckinsey: a15,
            med: a15,
            media: a15,
            meet: a15,
            melbourne: a15,
            meme: a15,
            memorial: a15,
            men: {
                $: 1,
                succ: {
                    for: o16,
                    repair: o16
                }
            },
            menu: P,
            merckmsd: a15,
            miami: a15,
            microsoft: a15,
            mini: a15,
            mint: a15,
            mit: a15,
            mitsubishi: a15,
            mlb: a15,
            mls: a15,
            mma: a15,
            mobile: a15,
            moda: a15,
            moe: a15,
            moi: a15,
            mom: {
                $: 1,
                succ: {
                    and: o16,
                    for: o16
                }
            },
            monash: a15,
            money: a15,
            monster: a15,
            mormon: a15,
            mortgage: a15,
            moscow: a15,
            moto: a15,
            motorcycles: a15,
            mov: a15,
            movie: a15,
            msd: a15,
            mtn: a15,
            mtr: a15,
            music: a15,
            mutual: a15,
            nab: a15,
            nagoya: a15,
            natura: a15,
            navy: a15,
            nba: a15,
            nec: a15,
            netbank: a15,
            netflix: a15,
            network: {
                $: 1,
                succ: {
                    alces: e12,
                    co: o16,
                    arvo: o16,
                    azimuth: o16,
                    tlon: o16
                }
            },
            neustar: a15,
            new: a15,
            news: {
                $: 1,
                succ: {
                    noticeable: o16
                }
            },
            next: a15,
            nextdirect: a15,
            nexus: a15,
            nfl: a15,
            ngo: a15,
            nhk: a15,
            nico: a15,
            nike: a15,
            nikon: a15,
            ninja: a15,
            nissan: a15,
            nissay: a15,
            nokia: a15,
            northwesternmutual: a15,
            norton: a15,
            now: a15,
            nowruz: a15,
            nowtv: a15,
            nra: a15,
            nrw: a15,
            ntt: a15,
            nyc: a15,
            obi: a15,
            observer: a15,
            office: a15,
            okinawa: a15,
            olayan: a15,
            olayangroup: a15,
            oldnavy: a15,
            ollo: a15,
            omega: a15,
            one: {
                $: 1,
                succ: {
                    onred: {
                        $: 2,
                        succ: {
                            staging: o16
                        }
                    },
                    for: o16,
                    under: o16,
                    service: o16,
                    homelink: o16
                }
            },
            ong: a15,
            onl: a15,
            online: {
                $: 1,
                succ: {
                    eero: o16,
                    "eero-stage": o16,
                    barsy: o16
                }
            },
            ooo: a15,
            open: a15,
            oracle: a15,
            orange: {
                $: 1,
                succ: {
                    tech: o16
                }
            },
            organic: a15,
            origins: a15,
            osaka: a15,
            otsuka: a15,
            ott: a15,
            ovh: {
                $: 1,
                succ: {
                    nerdpol: o16
                }
            },
            page: {
                $: 1,
                succ: {
                    hlx: o16,
                    hlx3: o16,
                    translated: o16,
                    codeberg: o16,
                    pdns: o16,
                    plesk: o16,
                    prvcy: o16,
                    rocky: o16,
                    magnet: o16
                }
            },
            panasonic: a15,
            paris: a15,
            pars: a15,
            partners: a15,
            parts: a15,
            party: z,
            passagens: a15,
            pay: a15,
            pccw: a15,
            pet: a15,
            pfizer: a15,
            pharmacy: a15,
            phd: a15,
            philips: a15,
            phone: a15,
            photo: a15,
            photography: a15,
            photos: a15,
            physio: a15,
            pics: a15,
            pictet: a15,
            pictures: {
                $: 1,
                succ: {
                    1337: o16
                }
            },
            pid: a15,
            pin: a15,
            ping: a15,
            pink: a15,
            pioneer: a15,
            pizza: a15,
            place: c3,
            play: a15,
            playstation: a15,
            plumbing: a15,
            plus: a15,
            pnc: a15,
            pohl: a15,
            poker: a15,
            politie: a15,
            porn: {
                $: 1,
                succ: {
                    indie: o16
                }
            },
            pramerica: a15,
            praxi: a15,
            press: a15,
            prime: a15,
            prod: a15,
            productions: a15,
            prof: a15,
            progressive: a15,
            promo: a15,
            properties: a15,
            property: a15,
            protection: a15,
            pru: a15,
            prudential: a15,
            pub: P,
            pwc: a15,
            qpon: a15,
            quebec: a15,
            quest: a15,
            racing: a15,
            radio: a15,
            read: a15,
            realestate: a15,
            realtor: a15,
            realty: a15,
            recipes: a15,
            red: a15,
            redstone: a15,
            redumbrella: a15,
            rehab: a15,
            reise: a15,
            reisen: a15,
            reit: a15,
            reliance: a15,
            ren: a15,
            rent: a15,
            rentals: a15,
            repair: a15,
            report: a15,
            republican: a15,
            rest: a15,
            restaurant: a15,
            review: z,
            reviews: a15,
            rexroth: a15,
            rich: a15,
            richardli: a15,
            ricoh: a15,
            ril: a15,
            rio: a15,
            rip: {
                $: 1,
                succ: {
                    clan: o16
                }
            },
            rocher: a15,
            rocks: {
                $: 1,
                succ: {
                    myddns: o16,
                    "lima-city": o16,
                    webspace: o16
                }
            },
            rodeo: a15,
            rogers: a15,
            room: a15,
            rsvp: a15,
            rugby: a15,
            ruhr: a15,
            run: {
                $: 1,
                succ: {
                    hs: o16,
                    development: o16,
                    ravendb: o16,
                    servers: o16,
                    build: e12,
                    code: e12,
                    database: e12,
                    migration: e12,
                    onporter: o16,
                    repl: o16
                }
            },
            rwe: a15,
            ryukyu: a15,
            saarland: a15,
            safe: a15,
            safety: a15,
            sakura: a15,
            sale: {
                $: 1,
                succ: {
                    for: o16
                }
            },
            salon: a15,
            samsclub: a15,
            samsung: a15,
            sandvik: a15,
            sandvikcoromant: a15,
            sanofi: a15,
            sap: a15,
            sarl: a15,
            sas: a15,
            save: a15,
            saxo: a15,
            sbi: a15,
            sbs: a15,
            sca: a15,
            scb: a15,
            schaeffler: a15,
            schmidt: a15,
            scholarships: a15,
            school: a15,
            schule: a15,
            schwarz: a15,
            science: z,
            scot: {
                $: 1,
                succ: {
                    edu: o16,
                    gov: {
                        $: 2,
                        succ: {
                            service: o16
                        }
                    }
                }
            },
            search: a15,
            seat: a15,
            secure: a15,
            security: a15,
            seek: a15,
            select: a15,
            sener: a15,
            services: {
                $: 1,
                succ: {
                    loginline: o16
                }
            },
            ses: a15,
            seven: a15,
            sew: a15,
            sex: a15,
            sexy: a15,
            sfr: a15,
            shangrila: a15,
            sharp: a15,
            shaw: a15,
            shell: a15,
            shia: a15,
            shiksha: a15,
            shoes: a15,
            shop: {
                $: 1,
                succ: {
                    base: o16,
                    hoplix: o16,
                    barsy: o16
                }
            },
            shopping: a15,
            shouji: a15,
            show: a15,
            showtime: a15,
            silk: a15,
            sina: a15,
            singles: a15,
            site: {
                $: 1,
                succ: {
                    cloudera: e12,
                    cyon: o16,
                    fnwk: o16,
                    folionetwork: o16,
                    fastvps: o16,
                    jele: o16,
                    lelux: o16,
                    loginline: o16,
                    barsy: o16,
                    mintere: o16,
                    omniwe: o16,
                    opensocial: o16,
                    platformsh: e12,
                    tst: e12,
                    byen: o16,
                    srht: o16,
                    novecore: o16
                }
            },
            ski: a15,
            skin: a15,
            sky: a15,
            skype: a15,
            sling: a15,
            smart: a15,
            smile: a15,
            sncf: a15,
            soccer: a15,
            social: a15,
            softbank: a15,
            software: a15,
            sohu: a15,
            solar: a15,
            solutions: {
                $: 1,
                succ: {
                    diher: e12
                }
            },
            song: a15,
            sony: a15,
            soy: a15,
            spa: a15,
            space: {
                $: 1,
                succ: {
                    myfast: o16,
                    uber: o16,
                    xs4all: o16
                }
            },
            sport: a15,
            spot: a15,
            srl: a15,
            stada: a15,
            staples: a15,
            star: a15,
            statebank: a15,
            statefarm: a15,
            stc: a15,
            stcgroup: a15,
            stockholm: a15,
            storage: a15,
            store: {
                $: 1,
                succ: {
                    sellfy: o16,
                    shopware: o16,
                    storebase: o16
                }
            },
            stream: a15,
            studio: a15,
            study: a15,
            style: a15,
            sucks: a15,
            supplies: a15,
            supply: a15,
            support: P,
            surf: a15,
            surgery: a15,
            suzuki: a15,
            swatch: a15,
            swiss: a15,
            sydney: a15,
            systems: {
                $: 1,
                succ: {
                    knightpoint: o16
                }
            },
            tab: a15,
            taipei: a15,
            talk: a15,
            taobao: a15,
            target: a15,
            tatamotors: a15,
            tatar: a15,
            tattoo: a15,
            tax: a15,
            taxi: a15,
            tci: a15,
            tdk: a15,
            team: {
                $: 1,
                succ: {
                    discourse: o16,
                    jelastic: o16
                }
            },
            tech: a15,
            technology: c3,
            temasek: a15,
            tennis: a15,
            teva: a15,
            thd: a15,
            theater: a15,
            theatre: a15,
            tiaa: a15,
            tickets: a15,
            tienda: a15,
            tiffany: a15,
            tips: a15,
            tires: a15,
            tirol: a15,
            tjmaxx: a15,
            tjx: a15,
            tkmaxx: a15,
            tmall: a15,
            today: {
                $: 1,
                succ: {
                    prequalifyme: o16
                }
            },
            tokyo: a15,
            tools: a15,
            top: {
                $: 1,
                succ: {
                    "now-dns": o16,
                    ntdll: o16
                }
            },
            toray: a15,
            toshiba: a15,
            total: a15,
            tours: a15,
            town: a15,
            toyota: a15,
            toys: a15,
            trade: z,
            trading: a15,
            training: a15,
            travel: a15,
            travelchannel: a15,
            travelers: a15,
            travelersinsurance: a15,
            trust: a15,
            trv: a15,
            tube: a15,
            tui: a15,
            tunes: a15,
            tushu: a15,
            tvs: a15,
            ubank: a15,
            ubs: a15,
            unicom: a15,
            university: a15,
            uno: a15,
            uol: a15,
            ups: a15,
            vacations: a15,
            vana: a15,
            vanguard: a15,
            vegas: a15,
            ventures: a15,
            verisign: a15,
            versicherung: a15,
            vet: a15,
            viajes: a15,
            video: a15,
            vig: a15,
            viking: a15,
            villas: a15,
            vin: a15,
            vip: a15,
            virgin: a15,
            visa: a15,
            vision: a15,
            viva: a15,
            vivo: a15,
            vlaanderen: a15,
            vodka: a15,
            volkswagen: a15,
            volvo: a15,
            vote: a15,
            voting: a15,
            voto: a15,
            voyage: a15,
            vuelos: a15,
            wales: a15,
            walmart: a15,
            walter: a15,
            wang: a15,
            wanggou: a15,
            watch: a15,
            watches: a15,
            weather: a15,
            weatherchannel: a15,
            webcam: a15,
            weber: a15,
            website: a15,
            wedding: a15,
            weibo: a15,
            weir: a15,
            whoswho: a15,
            wien: a15,
            wiki: a15,
            williamhill: a15,
            win: {
                $: 1,
                succ: {
                    that: o16
                }
            },
            windows: a15,
            wine: a15,
            winners: a15,
            wme: a15,
            wolterskluwer: a15,
            woodside: a15,
            work: {
                $: 1,
                succ: {
                    from: o16,
                    to: o16
                }
            },
            works: a15,
            world: a15,
            wow: a15,
            wtc: a15,
            wtf: a15,
            xbox: a15,
            xerox: a15,
            xfinity: a15,
            xihuan: a15,
            xin: a15,
            "xn--11b4c3d": a15,
            "कॉम": a15,
            "xn--1ck2e1b": a15,
            "セール": a15,
            "xn--1qqw23a": a15,
            "佛山": a15,
            "xn--30rr7y": a15,
            "慈善": a15,
            "xn--3bst00m": a15,
            "集团": a15,
            "xn--3ds443g": a15,
            "在线": a15,
            "xn--3pxu8k": a15,
            "点看": a15,
            "xn--42c2d9a": a15,
            "คอม": a15,
            "xn--45q11c": a15,
            "八卦": a15,
            "xn--4gbrim": a15,
            "موقع": a15,
            "xn--55qw42g": a15,
            "公益": a15,
            "xn--55qx5d": a15,
            "公司": a15,
            "xn--5su34j936bgsg": a15,
            "香格里拉": a15,
            "xn--5tzm5g": a15,
            "网站": a15,
            "xn--6frz82g": a15,
            "移动": a15,
            "xn--6qq986b3xl": a15,
            "我爱你": a15,
            "xn--80adxhks": a15,
            "москва": a15,
            "xn--80aqecdr1a": a15,
            "католик": a15,
            "xn--80asehdb": a15,
            "онлайн": a15,
            "xn--80aswg": a15,
            "сайт": a15,
            "xn--8y0a063a": a15,
            "联通": a15,
            "xn--9dbq2a": a15,
            "קום": a15,
            "xn--9et52u": a15,
            "时尚": a15,
            "xn--9krt00a": a15,
            "微博": a15,
            "xn--b4w605ferd": a15,
            "淡马锡": a15,
            "xn--bck1b9a5dre4c": a15,
            "ファッション": a15,
            "xn--c1avg": a15,
            "орг": a15,
            "xn--c2br7g": a15,
            "नेट": a15,
            "xn--cck2b3b": a15,
            "ストア": a15,
            "xn--cckwcxetd": a15,
            "アマゾン": a15,
            "xn--cg4bki": a15,
            "삼성": a15,
            "xn--czr694b": a15,
            "商标": a15,
            "xn--czrs0t": a15,
            "商店": a15,
            "xn--czru2d": a15,
            "商城": a15,
            "xn--d1acj3b": a15,
            "дети": a15,
            "xn--eckvdtc9d": a15,
            "ポイント": a15,
            "xn--efvy88h": a15,
            "新闻": a15,
            "xn--fct429k": a15,
            "家電": a15,
            "xn--fhbei": a15,
            "كوم": a15,
            "xn--fiq228c5hs": a15,
            "中文网": a15,
            "xn--fiq64b": a15,
            "中信": a15,
            "xn--fjq720a": a15,
            "娱乐": a15,
            "xn--flw351e": a15,
            "谷歌": a15,
            "xn--fzys8d69uvgm": a15,
            "電訊盈科": a15,
            "xn--g2xx48c": a15,
            "购物": a15,
            "xn--gckr3f0f": a15,
            "クラウド": a15,
            "xn--gk3at1e": a15,
            "通販": a15,
            "xn--hxt814e": a15,
            "网店": a15,
            "xn--i1b6b1a6a2e": a15,
            "संगठन": a15,
            "xn--imr513n": a15,
            "餐厅": a15,
            "xn--io0a7i": a15,
            "网络": a15,
            "xn--j1aef": a15,
            "ком": a15,
            "xn--jlq480n2rg": a15,
            "亚马逊": a15,
            "xn--jlq61u9w7b": a15,
            "诺基亚": a15,
            "xn--jvr189m": a15,
            "食品": a15,
            "xn--kcrx77d1x4a": a15,
            "飞利浦": a15,
            "xn--kput3i": a15,
            "手机": a15,
            "xn--mgba3a3ejt": a15,
            "ارامكو": a15,
            "xn--mgba7c0bbn0a": a15,
            "العليان": a15,
            "xn--mgbaakc7dvf": a15,
            "اتصالات": a15,
            "xn--mgbab2bd": a15,
            "بازار": a15,
            "xn--mgbca7dzdo": a15,
            "ابوظبي": a15,
            "xn--mgbi4ecexp": a15,
            "كاثوليك": a15,
            "xn--mgbt3dhd": a15,
            "همراه": a15,
            "xn--mk1bu44c": a15,
            "닷컴": a15,
            "xn--mxtq1m": a15,
            "政府": a15,
            "xn--ngbc5azd": a15,
            "شبكة": a15,
            "xn--ngbe9e0a": a15,
            "بيتك": a15,
            "xn--ngbrx": a15,
            "عرب": a15,
            "xn--nqv7f": a15,
            "机构": a15,
            "xn--nqv7fs00ema": a15,
            "组织机构": a15,
            "xn--nyqy26a": a15,
            "健康": a15,
            "xn--otu796d": a15,
            "招聘": a15,
            "xn--p1acf": {
                $: 1,
                succ: {
                    "xn--90amc": o16,
                    "xn--j1aef": o16,
                    "xn--j1ael8b": o16,
                    "xn--h1ahn": o16,
                    "xn--j1adp": o16,
                    "xn--c1avg": o16,
                    "xn--80aaa0cvac": o16,
                    "xn--h1aliz": o16,
                    "xn--90a1af": o16,
                    "xn--41a": o16
                }
            },
            "рус": {
                $: 1,
                succ: {
                    "биз": o16,
                    "ком": o16,
                    "крым": o16,
                    "мир": o16,
                    "мск": o16,
                    "орг": o16,
                    "самара": o16,
                    "сочи": o16,
                    "спб": o16,
                    "я": o16
                }
            },
            "xn--pssy2u": a15,
            "大拿": a15,
            "xn--q9jyb4c": a15,
            "みんな": a15,
            "xn--qcka1pmc": a15,
            "グーグル": a15,
            "xn--rhqv96g": a15,
            "世界": a15,
            "xn--rovu88b": a15,
            "書籍": a15,
            "xn--ses554g": a15,
            "网址": a15,
            "xn--t60b56a": a15,
            "닷넷": a15,
            "xn--tckwe": a15,
            "コム": a15,
            "xn--tiq49xqyj": a15,
            "天主教": a15,
            "xn--unup4y": a15,
            "游戏": a15,
            "xn--vermgensberater-ctb": a15,
            "vermögensberater": a15,
            "xn--vermgensberatung-pwb": a15,
            "vermögensberatung": a15,
            "xn--vhquv": a15,
            "企业": a15,
            "xn--vuq861b": a15,
            "信息": a15,
            "xn--w4r85el8fhu5dnra": a15,
            "嘉里大酒店": a15,
            "xn--w4rs40l": a15,
            "嘉里": a15,
            "xn--xhq521b": a15,
            "广东": a15,
            "xn--zfr164b": a15,
            "政务": a15,
            xyz: {
                $: 1,
                succ: {
                    blogsite: o16,
                    localzone: o16,
                    crafting: o16,
                    zapto: o16,
                    telebit: e12
                }
            },
            yachts: a15,
            yahoo: a15,
            yamaxun: a15,
            yandex: a15,
            yodobashi: a15,
            yoga: a15,
            yokohama: a15,
            you: a15,
            youtube: a15,
            yun: a15,
            zappos: a15,
            zara: a15,
            zero: a15,
            zip: a15,
            zone: {
                $: 1,
                succ: {
                    cloud66: o16,
                    hs: o16,
                    triton: e12,
                    lima: o16
                }
            },
            zuerich: a15
        }
    };
}();
function r(a16, o17, i13, e13) {
    let s9 = null, n8 = o17;
    for(; void 0 !== n8 && (0 != (n8.$ & e13) && (s9 = {
        index: i13 + 1,
        isIcann: 1 === n8.$,
        isPrivate: 2 === n8.$
    }), -1 !== i13);){
        const o18 = n8.succ;
        n8 = o18 && (o18[a16[i13]] || o18["*"]), i13 -= 1;
    }
    return s9;
}
function t(a17, o19, i14) {
    if (!0 === function(a18, o20, i15) {
        if (!1 === o20.allowPrivateDomains && a18.length > 3) {
            const o21 = a18.length - 1, e15 = a18.charCodeAt(o21), s10 = a18.charCodeAt(o21 - 1), n9 = a18.charCodeAt(o21 - 2), r7 = a18.charCodeAt(o21 - 3);
            if (109 === e15 && 111 === s10 && 99 === n9 && 46 === r7) return i15.isIcann = !0, i15.isPrivate = !1, i15.publicSuffix = "com", !0;
            if (103 === e15 && 114 === s10 && 111 === n9 && 46 === r7) return i15.isIcann = !0, i15.isPrivate = !1, i15.publicSuffix = "org", !0;
            if (117 === e15 && 100 === s10 && 101 === n9 && 46 === r7) return i15.isIcann = !0, i15.isPrivate = !1, i15.publicSuffix = "edu", !0;
            if (118 === e15 && 111 === s10 && 103 === n9 && 46 === r7) return i15.isIcann = !0, i15.isPrivate = !1, i15.publicSuffix = "gov", !0;
            if (116 === e15 && 101 === s10 && 110 === n9 && 46 === r7) return i15.isIcann = !0, i15.isPrivate = !1, i15.publicSuffix = "net", !0;
            if (101 === e15 && 100 === s10 && 46 === n9) return i15.isIcann = !0, i15.isPrivate = !1, i15.publicSuffix = "de", !0;
        }
        return !1;
    }(a17, o19, i14)) return;
    const e14 = a17.split("."), t5 = (!0 === o19.allowPrivateDomains ? 2 : 0) | (!0 === o19.allowIcannDomains ? 1 : 0), c4 = r(e14, s, e14.length - 1, t5);
    if (null !== c4) return i14.isIcann = c4.isIcann, i14.isPrivate = c4.isPrivate, void (i14.publicSuffix = e14.slice(c4.index + 1).join("."));
    const u3 = r(e14, n, e14.length - 1, t5);
    if (null !== u3) return i14.isIcann = u3.isIcann, i14.isPrivate = u3.isPrivate, void (i14.publicSuffix = e14.slice(u3.index).join("."));
    i14.isIcann = !1, i14.isPrivate = !1, i14.publicSuffix = e14[e14.length - 1];
}
function u(a19, o22 = {}) {
    return e(a19, 5, t, o22, {
        domain: null,
        domainWithoutSuffix: null,
        hostname: null,
        isIcann: null,
        isIp: null,
        isPrivate: null,
        publicSuffix: null,
        subdomain: null
    });
}
function isCryptoKey(key) {
    try {
        return key != null && typeof key.extractable === 'boolean' && typeof key.algorithm.name === 'string' && typeof key.type === 'string';
    } catch  {
        return false;
    }
}
const encoder = new TextEncoder();
const decoder = new TextDecoder();
function concat(...buffers) {
    const size = buffers.reduce((acc, { length  })=>acc + length
    , 0);
    const buf = new Uint8Array(size);
    let i79 = 0;
    buffers.forEach((buffer)=>{
        buf.set(buffer, i79);
        i79 += buffer.length;
    });
    return buf;
}
const encodeBase64 = (input)=>{
    let unencoded = input;
    if (typeof unencoded === 'string') {
        unencoded = encoder.encode(unencoded);
    }
    const CHUNK_SIZE = 0x8000;
    const arr = [];
    for(let i80 = 0; i80 < unencoded.length; i80 += CHUNK_SIZE){
        arr.push(String.fromCharCode.apply(null, unencoded.subarray(i80, i80 + 0x8000)));
    }
    return btoa(arr.join(''));
};
const decodeBase64 = (encoded)=>{
    const binary = atob(encoded);
    const bytes = new Uint8Array(binary.length);
    for(let i81 = 0; i81 < binary.length; i81++){
        bytes[i81] = binary.charCodeAt(i81);
    }
    return bytes;
};
const decode4 = (input)=>{
    let encoded = input;
    if (encoded instanceof Uint8Array) {
        encoded = decoder.decode(encoded);
    }
    encoded = encoded.replace(/-/g, '+').replace(/_/g, '/').replace(/\s/g, '');
    try {
        return decodeBase64(encoded);
    } catch  {
        throw new TypeError('The input to be decoded is not correctly encoded.');
    }
};
class JOSEError extends Error {
    static get code() {
        return 'ERR_JOSE_GENERIC';
    }
    code = 'ERR_JOSE_GENERIC';
    constructor(message){
        super(message);
        this.name = this.constructor.name;
        Error.captureStackTrace?.(this, this.constructor);
    }
}
class JWTClaimValidationFailed extends JOSEError {
    static get code() {
        return 'ERR_JWT_CLAIM_VALIDATION_FAILED';
    }
    code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';
    claim;
    reason;
    constructor(message, claim = 'unspecified', reason = 'unspecified'){
        super(message);
        this.claim = claim;
        this.reason = reason;
    }
}
class JWTExpired extends JOSEError {
    static get code() {
        return 'ERR_JWT_EXPIRED';
    }
    code = 'ERR_JWT_EXPIRED';
    claim;
    reason;
    constructor(message, claim = 'unspecified', reason = 'unspecified'){
        super(message);
        this.claim = claim;
        this.reason = reason;
    }
}
class JOSEAlgNotAllowed extends JOSEError {
    static get code() {
        return 'ERR_JOSE_ALG_NOT_ALLOWED';
    }
    code = 'ERR_JOSE_ALG_NOT_ALLOWED';
}
class JOSENotSupported extends JOSEError {
    static get code() {
        return 'ERR_JOSE_NOT_SUPPORTED';
    }
    code = 'ERR_JOSE_NOT_SUPPORTED';
}
class JWSInvalid extends JOSEError {
    static get code() {
        return 'ERR_JWS_INVALID';
    }
    code = 'ERR_JWS_INVALID';
}
class JWTInvalid extends JOSEError {
    static get code() {
        return 'ERR_JWT_INVALID';
    }
    code = 'ERR_JWT_INVALID';
}
class JWSSignatureVerificationFailed extends JOSEError {
    static get code() {
        return 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';
    }
    code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';
    message = 'signature verification failed';
}
crypto.getRandomValues.bind(crypto);
function isCloudflareWorkers() {
    return typeof WebSocketPair === 'function';
}
function isNodeJs() {
    try {
        return process.versions.node !== undefined;
    } catch  {
        return false;
    }
}
function unusable(name, prop = 'algorithm.name') {
    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
    return algorithm.name === name;
}
function getHashLength(hash) {
    return parseInt(hash.name.slice(4), 10);
}
function getNamedCurve(alg) {
    switch(alg){
        case 'ES256':
            return 'P-256';
        case 'ES384':
            return 'P-384';
        case 'ES512':
            return 'P-521';
        default:
            throw new Error('unreachable');
    }
}
function checkUsage(key, usages) {
    if (usages.length && !usages.some((expected)=>key.usages.includes(expected)
    )) {
        let msg = 'CryptoKey does not support this operation, its usages must include ';
        if (usages.length > 2) {
            const last = usages.pop();
            msg += `one of ${usages.join(', ')}, or ${last}.`;
        } else if (usages.length === 2) {
            msg += `one of ${usages[0]} or ${usages[1]}.`;
        } else {
            msg += `${usages[0]}.`;
        }
        throw new TypeError(msg);
    }
}
function checkSigCryptoKey(key, alg, ...usages) {
    switch(alg){
        case 'HS256':
        case 'HS384':
        case 'HS512':
            {
                if (!isAlgorithm(key.algorithm, 'HMAC')) throw unusable('HMAC');
                const expected = parseInt(alg.slice(2), 10);
                const actual = getHashLength(key.algorithm.hash);
                if (actual !== expected) throw unusable(`SHA-${expected}`, 'algorithm.hash');
                break;
            }
        case 'RS256':
        case 'RS384':
        case 'RS512':
            {
                if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5')) throw unusable('RSASSA-PKCS1-v1_5');
                const expected = parseInt(alg.slice(2), 10);
                const actual = getHashLength(key.algorithm.hash);
                if (actual !== expected) throw unusable(`SHA-${expected}`, 'algorithm.hash');
                break;
            }
        case 'PS256':
        case 'PS384':
        case 'PS512':
            {
                if (!isAlgorithm(key.algorithm, 'RSA-PSS')) throw unusable('RSA-PSS');
                const expected = parseInt(alg.slice(2), 10);
                const actual = getHashLength(key.algorithm.hash);
                if (actual !== expected) throw unusable(`SHA-${expected}`, 'algorithm.hash');
                break;
            }
        case isNodeJs() && 'EdDSA':
            {
                if (key.algorithm.name !== 'NODE-ED25519' && key.algorithm.name !== 'NODE-ED448') throw unusable('NODE-ED25519 or NODE-ED448');
                break;
            }
        case isCloudflareWorkers() && 'EdDSA':
            {
                if (!isAlgorithm(key.algorithm, 'NODE-ED25519')) throw unusable('NODE-ED25519');
                break;
            }
        case 'ES256':
        case 'ES384':
        case 'ES512':
            {
                if (!isAlgorithm(key.algorithm, 'ECDSA')) throw unusable('ECDSA');
                const expected = getNamedCurve(alg);
                const actual = key.algorithm.namedCurve;
                if (actual !== expected) throw unusable(expected, 'algorithm.namedCurve');
                break;
            }
        default:
            throw new TypeError('CryptoKey does not support this operation');
    }
    checkUsage(key, usages);
}
const __default5 = (actual, ...types2)=>{
    let msg = 'Key must be ';
    if (types2.length > 2) {
        const last = types2.pop();
        msg += `one of type ${types2.join(', ')}, or ${last}.`;
    } else if (types2.length === 2) {
        msg += `one of type ${types2[0]} or ${types2[1]}.`;
    } else {
        msg += `of type ${types2[0]}.`;
    }
    if (actual == null) {
        msg += ` Received ${actual}`;
    } else if (typeof actual === 'function' && actual.name) {
        msg += ` Received function ${actual.name}`;
    } else if (typeof actual === 'object' && actual != null) {
        if (actual.constructor && actual.constructor.name) {
            msg += ` Received an instance of ${actual.constructor.name}`;
        }
    }
    return msg;
};
const types = [
    'CryptoKey'
];
const __default6 = (key)=>{
    return isCryptoKey(key);
};
const isDisjoint = (...headers)=>{
    const sources = headers.filter(Boolean);
    if (sources.length === 0 || sources.length === 1) {
        return true;
    }
    let acc;
    for (const header of sources){
        const parameters = Object.keys(header);
        if (!acc || acc.size === 0) {
            acc = new Set(parameters);
            continue;
        }
        for (const parameter of parameters){
            if (acc.has(parameter)) {
                return false;
            }
            acc.add(parameter);
        }
    }
    return true;
};
function isObjectLike(value) {
    return typeof value === 'object' && value !== null;
}
function isObject(input) {
    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {
        return false;
    }
    if (Object.getPrototypeOf(input) === null) {
        return true;
    }
    let proto = input;
    while(Object.getPrototypeOf(proto) !== null){
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(input) === proto;
}
const __default7 = (alg, key)=>{
    if (alg.startsWith('RS') || alg.startsWith('PS')) {
        const { modulusLength  } = key.algorithm;
        if (typeof modulusLength !== 'number' || modulusLength < 2048) {
            throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
        }
    }
};
const __default8 = (b64, descriptor)=>{
    const newlined = (b64.match(/.{1,64}/g) || []).join('\n');
    return `-----BEGIN ${descriptor}-----\n${newlined}\n-----END ${descriptor}-----`;
};
const genericExport = async (keyType, keyFormat, key)=>{
    if (!isCryptoKey(key)) {
        throw new TypeError(__default5(key, ...types));
    }
    if (!key.extractable) {
        throw new TypeError('CryptoKey is not extractable');
    }
    if (key.type !== keyType) {
        throw new TypeError(`key is not a ${keyType} key`);
    }
    return __default8(encodeBase64(new Uint8Array(await crypto.subtle.exportKey(keyFormat, key))), `${keyType.toUpperCase()} KEY`);
};
const toSPKI = (key)=>{
    return genericExport('public', 'spki', key);
};
const findOid = (keyData, oid, from = 0)=>{
    if (from === 0) {
        oid.unshift(oid.length);
        oid.unshift(0x06);
    }
    let i82 = keyData.indexOf(oid[0], from);
    if (i82 === -1) return false;
    const sub = keyData.subarray(i82, i82 + oid.length);
    if (sub.length !== oid.length) return false;
    return sub.every((value, index)=>value === oid[index]
    ) || findOid(keyData, oid, i82 + 1);
};
const getNamedCurve1 = (keyData)=>{
    switch(true){
        case findOid(keyData, [
            0x2a,
            0x86,
            0x48,
            0xce,
            0x3d,
            0x03,
            0x01,
            0x07
        ]):
            return 'P-256';
        case findOid(keyData, [
            0x2b,
            0x81,
            0x04,
            0x00,
            0x22
        ]):
            return 'P-384';
        case findOid(keyData, [
            0x2b,
            0x81,
            0x04,
            0x00,
            0x23
        ]):
            return 'P-521';
        case (isCloudflareWorkers() || isNodeJs()) && findOid(keyData, [
            0x2b,
            0x65,
            0x70
        ]):
            return 'Ed25519';
        case isNodeJs() && findOid(keyData, [
            0x2b,
            0x65,
            0x71
        ]):
            return 'Ed448';
        default:
            throw new JOSENotSupported('Invalid or unsupported EC Key Curve or OKP Key Sub Type');
    }
};
const genericImport = async (replace, keyFormat, pem, alg, options)=>{
    let algorithm;
    let keyUsages;
    const keyData = new Uint8Array(atob(pem.replace(replace, '')).split('').map((c)=>c.charCodeAt(0)
    ));
    const isPublic = keyFormat === 'spki';
    switch(alg){
        case 'PS256':
        case 'PS384':
        case 'PS512':
            algorithm = {
                name: 'RSA-PSS',
                hash: `SHA-${alg.slice(-3)}`
            };
            keyUsages = isPublic ? [
                'verify'
            ] : [
                'sign'
            ];
            break;
        case 'RS256':
        case 'RS384':
        case 'RS512':
            algorithm = {
                name: 'RSASSA-PKCS1-v1_5',
                hash: `SHA-${alg.slice(-3)}`
            };
            keyUsages = isPublic ? [
                'verify'
            ] : [
                'sign'
            ];
            break;
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512':
            algorithm = {
                name: 'RSA-OAEP',
                hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`
            };
            keyUsages = isPublic ? [
                'encrypt',
                'wrapKey'
            ] : [
                'decrypt',
                'unwrapKey'
            ];
            break;
        case 'ES256':
            algorithm = {
                name: 'ECDSA',
                namedCurve: 'P-256'
            };
            keyUsages = isPublic ? [
                'verify'
            ] : [
                'sign'
            ];
            break;
        case 'ES384':
            algorithm = {
                name: 'ECDSA',
                namedCurve: 'P-384'
            };
            keyUsages = isPublic ? [
                'verify'
            ] : [
                'sign'
            ];
            break;
        case 'ES512':
            algorithm = {
                name: 'ECDSA',
                namedCurve: 'P-521'
            };
            keyUsages = isPublic ? [
                'verify'
            ] : [
                'sign'
            ];
            break;
        case 'ECDH-ES':
        case 'ECDH-ES+A128KW':
        case 'ECDH-ES+A192KW':
        case 'ECDH-ES+A256KW':
            algorithm = {
                name: 'ECDH',
                namedCurve: getNamedCurve1(keyData)
            };
            keyUsages = isPublic ? [] : [
                'deriveBits'
            ];
            break;
        case (isCloudflareWorkers() || isNodeJs()) && 'EdDSA':
            const namedCurve = getNamedCurve1(keyData).toUpperCase();
            algorithm = {
                name: `NODE-${namedCurve}`,
                namedCurve: `NODE-${namedCurve}`
            };
            keyUsages = isPublic ? [
                'verify'
            ] : [
                'sign'
            ];
            break;
        default:
            throw new JOSENotSupported('Invalid or unsupported "alg" (Algorithm) value');
    }
    return crypto.subtle.importKey(keyFormat, keyData, algorithm, options?.extractable ?? false, keyUsages);
};
const fromSPKI = (pem, alg, options)=>{
    return genericImport(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g, 'spki', pem, alg, options);
};
function subtleMapping(jwk) {
    let algorithm;
    let keyUsages;
    switch(jwk.kty){
        case 'oct':
            {
                switch(jwk.alg){
                    case 'HS256':
                    case 'HS384':
                    case 'HS512':
                        algorithm = {
                            name: 'HMAC',
                            hash: `SHA-${jwk.alg.slice(-3)}`
                        };
                        keyUsages = [
                            'sign',
                            'verify'
                        ];
                        break;
                    case 'A128CBC-HS256':
                    case 'A192CBC-HS384':
                    case 'A256CBC-HS512':
                        throw new JOSENotSupported(`${jwk.alg} keys cannot be imported as CryptoKey instances`);
                    case 'A128GCM':
                    case 'A192GCM':
                    case 'A256GCM':
                    case 'A128GCMKW':
                    case 'A192GCMKW':
                    case 'A256GCMKW':
                        algorithm = {
                            name: 'AES-GCM'
                        };
                        keyUsages = [
                            'encrypt',
                            'decrypt'
                        ];
                        break;
                    case 'A128KW':
                    case 'A192KW':
                    case 'A256KW':
                        algorithm = {
                            name: 'AES-KW'
                        };
                        keyUsages = [
                            'wrapKey',
                            'unwrapKey'
                        ];
                        break;
                    case 'PBES2-HS256+A128KW':
                    case 'PBES2-HS384+A192KW':
                    case 'PBES2-HS512+A256KW':
                        algorithm = {
                            name: 'PBKDF2'
                        };
                        keyUsages = [
                            'deriveBits'
                        ];
                        break;
                    default:
                        throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
                }
                break;
            }
        case 'RSA':
            {
                switch(jwk.alg){
                    case 'PS256':
                    case 'PS384':
                    case 'PS512':
                        algorithm = {
                            name: 'RSA-PSS',
                            hash: `SHA-${jwk.alg.slice(-3)}`
                        };
                        keyUsages = jwk.d ? [
                            'sign'
                        ] : [
                            'verify'
                        ];
                        break;
                    case 'RS256':
                    case 'RS384':
                    case 'RS512':
                        algorithm = {
                            name: 'RSASSA-PKCS1-v1_5',
                            hash: `SHA-${jwk.alg.slice(-3)}`
                        };
                        keyUsages = jwk.d ? [
                            'sign'
                        ] : [
                            'verify'
                        ];
                        break;
                    case 'RSA-OAEP':
                    case 'RSA-OAEP-256':
                    case 'RSA-OAEP-384':
                    case 'RSA-OAEP-512':
                        algorithm = {
                            name: 'RSA-OAEP',
                            hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
                        };
                        keyUsages = jwk.d ? [
                            'decrypt',
                            'unwrapKey'
                        ] : [
                            'encrypt',
                            'wrapKey'
                        ];
                        break;
                    default:
                        throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
                }
                break;
            }
        case 'EC':
            {
                switch(jwk.alg){
                    case 'ES256':
                        algorithm = {
                            name: 'ECDSA',
                            namedCurve: 'P-256'
                        };
                        keyUsages = jwk.d ? [
                            'sign'
                        ] : [
                            'verify'
                        ];
                        break;
                    case 'ES384':
                        algorithm = {
                            name: 'ECDSA',
                            namedCurve: 'P-384'
                        };
                        keyUsages = jwk.d ? [
                            'sign'
                        ] : [
                            'verify'
                        ];
                        break;
                    case 'ES512':
                        algorithm = {
                            name: 'ECDSA',
                            namedCurve: 'P-521'
                        };
                        keyUsages = jwk.d ? [
                            'sign'
                        ] : [
                            'verify'
                        ];
                        break;
                    case 'ECDH-ES':
                    case 'ECDH-ES+A128KW':
                    case 'ECDH-ES+A192KW':
                    case 'ECDH-ES+A256KW':
                        algorithm = {
                            name: 'ECDH',
                            namedCurve: jwk.crv
                        };
                        keyUsages = jwk.d ? [
                            'deriveBits'
                        ] : [];
                        break;
                    default:
                        throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
                }
                break;
            }
        case (isCloudflareWorkers() || isNodeJs()) && 'OKP':
            if (jwk.alg !== 'EdDSA') {
                throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
            }
            switch(jwk.crv){
                case 'Ed25519':
                    algorithm = {
                        name: 'NODE-ED25519',
                        namedCurve: 'NODE-ED25519'
                    };
                    keyUsages = jwk.d ? [
                        'sign'
                    ] : [
                        'verify'
                    ];
                    break;
                case isNodeJs() && 'Ed448':
                    algorithm = {
                        name: 'NODE-ED448',
                        namedCurve: 'NODE-ED448'
                    };
                    keyUsages = jwk.d ? [
                        'sign'
                    ] : [
                        'verify'
                    ];
                    break;
                default:
                    throw new JOSENotSupported('Invalid or unsupported JWK "crv" (Subtype of Key Pair) Parameter value');
            }
            break;
        default:
            throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
    }
    return {
        algorithm,
        keyUsages
    };
}
const parse5 = async (jwk)=>{
    const { algorithm , keyUsages  } = subtleMapping(jwk);
    const rest = [
        algorithm,
        jwk.ext ?? false,
        jwk.key_ops ?? keyUsages, 
    ];
    if (algorithm.name === 'PBKDF2') {
        return crypto.subtle.importKey('raw', decode4(jwk.k), ...rest);
    }
    const keyData = {
        ...jwk
    };
    delete keyData.alg;
    return crypto.subtle.importKey('jwk', keyData, ...rest);
};
async function importSPKI(spki, alg, options) {
    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {
        throw new TypeError('"spki" must be SPKI formatted string');
    }
    return fromSPKI(spki, alg, options);
}
async function importJWK(jwk, alg, octAsKeyObject) {
    if (!isObject(jwk)) {
        throw new TypeError('JWK must be an object');
    }
    alg ||= jwk.alg;
    if (typeof alg !== 'string' || !alg) {
        throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
    }
    switch(jwk.kty){
        case 'oct':
            if (typeof jwk.k !== 'string' || !jwk.k) {
                throw new TypeError('missing "k" (Key Value) Parameter value');
            }
            octAsKeyObject ??= jwk.ext !== true;
            if (octAsKeyObject) {
                return parse5({
                    ...jwk,
                    alg,
                    ext: false
                });
            }
            return decode4(jwk.k);
        case 'RSA':
            if (jwk.oth !== undefined) {
                throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
            }
        case 'EC':
        case 'OKP':
            return parse5({
                ...jwk,
                alg
            });
        default:
            throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
    }
}
const symmetricTypeCheck = (key)=>{
    if (key instanceof Uint8Array) return;
    if (!__default6(key)) {
        throw new TypeError(__default5(key, ...types, 'Uint8Array'));
    }
    if (key.type !== 'secret') {
        throw new TypeError(`${types.join(' or ')} instances for symmetric algorithms must be of type "secret"`);
    }
};
const asymmetricTypeCheck = (key, usage)=>{
    if (!__default6(key)) {
        throw new TypeError(__default5(key, ...types));
    }
    if (key.type === 'secret') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithms must not be of type "secret"`);
    }
    if (usage === 'sign' && key.type === 'public') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm signing must be of type "private"`);
    }
    if (usage === 'decrypt' && key.type === 'public') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm decryption must be of type "private"`);
    }
    if (key.algorithm && usage === 'verify' && key.type === 'private') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm verifying must be of type "public"`);
    }
    if (key.algorithm && usage === 'encrypt' && key.type === 'private') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm encryption must be of type "public"`);
    }
};
const checkKeyType = (alg, key, usage)=>{
    const symmetric = alg.startsWith('HS') || alg === 'dir' || alg.startsWith('PBES2') || /^A\d{3}(?:GCM)?KW$/.test(alg);
    if (symmetric) {
        symmetricTypeCheck(key);
    } else {
        asymmetricTypeCheck(key, usage);
    }
};
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
    if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) {
        throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
    }
    if (!protectedHeader || protectedHeader.crit === undefined) {
        return new Set();
    }
    if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input)=>typeof input !== 'string' || input.length === 0
    )) {
        throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
    }
    let recognized;
    if (recognizedOption !== undefined) {
        recognized = new Map([
            ...Object.entries(recognizedOption),
            ...recognizedDefault.entries()
        ]);
    } else {
        recognized = recognizedDefault;
    }
    for (const parameter of protectedHeader.crit){
        if (!recognized.has(parameter)) {
            throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
        }
        if (joseHeader[parameter] === undefined) {
            throw new Err(`Extension Header Parameter "${parameter}" is missing`);
        } else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
            throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
        }
    }
    return new Set(protectedHeader.crit);
}
const validateAlgorithms = (option, algorithms)=>{
    if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some((s11)=>typeof s11 !== 'string'
    ))) {
        throw new TypeError(`"${option}" option must be an array of strings`);
    }
    if (!algorithms) {
        return undefined;
    }
    return new Set(algorithms);
};
async function exportSPKI(key) {
    return toSPKI(key);
}
Symbol();
function subtleDsa(alg, algorithm) {
    const hash = `SHA-${alg.slice(-3)}`;
    switch(alg){
        case 'HS256':
        case 'HS384':
        case 'HS512':
            return {
                hash,
                name: 'HMAC'
            };
        case 'PS256':
        case 'PS384':
        case 'PS512':
            return {
                hash,
                name: 'RSA-PSS',
                saltLength: alg.slice(-3) >> 3
            };
        case 'RS256':
        case 'RS384':
        case 'RS512':
            return {
                hash,
                name: 'RSASSA-PKCS1-v1_5'
            };
        case 'ES256':
        case 'ES384':
        case 'ES512':
            return {
                hash,
                name: 'ECDSA',
                namedCurve: algorithm.namedCurve
            };
        case (isCloudflareWorkers() || isNodeJs()) && 'EdDSA':
            const { namedCurve  } = algorithm;
            return {
                name: namedCurve,
                namedCurve
            };
        default:
            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
}
function getCryptoKey(alg, key, usage) {
    if (isCryptoKey(key)) {
        checkSigCryptoKey(key, alg, usage);
        return key;
    }
    if (key instanceof Uint8Array) {
        if (!alg.startsWith('HS')) {
            throw new TypeError(__default5(key, ...types));
        }
        return crypto.subtle.importKey('raw', key, {
            hash: `SHA-${alg.slice(-3)}`,
            name: 'HMAC'
        }, false, [
            usage
        ]);
    }
    throw new TypeError(__default5(key, ...types, 'Uint8Array'));
}
const verify = async (alg, key, signature, data)=>{
    const cryptoKey = await getCryptoKey(alg, key, 'verify');
    __default7(alg, cryptoKey);
    const algorithm = subtleDsa(alg, cryptoKey.algorithm);
    try {
        return await crypto.subtle.verify(algorithm, cryptoKey, signature, data);
    } catch  {
        return false;
    }
};
async function flattenedVerify(jws, key, options) {
    if (!isObject(jws)) {
        throw new JWSInvalid('Flattened JWS must be an object');
    }
    if (jws.protected === undefined && jws.header === undefined) {
        throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
    }
    if (jws.protected !== undefined && typeof jws.protected !== 'string') {
        throw new JWSInvalid('JWS Protected Header incorrect type');
    }
    if (jws.payload === undefined) {
        throw new JWSInvalid('JWS Payload missing');
    }
    if (typeof jws.signature !== 'string') {
        throw new JWSInvalid('JWS Signature missing or incorrect type');
    }
    if (jws.header !== undefined && !isObject(jws.header)) {
        throw new JWSInvalid('JWS Unprotected Header incorrect type');
    }
    let parsedProt = {};
    if (jws.protected) {
        const protectedHeader = decode4(jws.protected);
        try {
            parsedProt = JSON.parse(decoder.decode(protectedHeader));
        } catch  {
            throw new JWSInvalid('JWS Protected Header is invalid');
        }
    }
    if (!isDisjoint(parsedProt, jws.header)) {
        throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');
    }
    const joseHeader = {
        ...parsedProt,
        ...jws.header
    };
    const extensions1 = validateCrit(JWSInvalid, new Map([
        [
            'b64',
            true
        ]
    ]), options?.crit, parsedProt, joseHeader);
    let b64 = true;
    if (extensions1.has('b64')) {
        b64 = parsedProt.b64;
        if (typeof b64 !== 'boolean') {
            throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
        }
    }
    const { alg  } = joseHeader;
    if (typeof alg !== 'string' || !alg) {
        throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    const algorithms = options && validateAlgorithms('algorithms', options.algorithms);
    if (algorithms && !algorithms.has(alg)) {
        throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
    }
    if (b64) {
        if (typeof jws.payload !== 'string') {
            throw new JWSInvalid('JWS Payload must be a string');
        }
    } else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {
        throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');
    }
    let resolvedKey = false;
    if (typeof key === 'function') {
        key = await key(parsedProt, jws);
        resolvedKey = true;
    }
    checkKeyType(alg, key, 'verify');
    const data = concat(encoder.encode(jws.protected ?? ''), encoder.encode('.'), typeof jws.payload === 'string' ? encoder.encode(jws.payload) : jws.payload);
    const signature = decode4(jws.signature);
    const verified = await verify(alg, key, signature, data);
    if (!verified) {
        throw new JWSSignatureVerificationFailed();
    }
    let payload;
    if (b64) {
        payload = decode4(jws.payload);
    } else if (typeof jws.payload === 'string') {
        payload = encoder.encode(jws.payload);
    } else {
        payload = jws.payload;
    }
    const result = {
        payload
    };
    if (jws.protected !== undefined) {
        result.protectedHeader = parsedProt;
    }
    if (jws.header !== undefined) {
        result.unprotectedHeader = jws.header;
    }
    if (resolvedKey) {
        return {
            ...result,
            key
        };
    }
    return result;
}
async function compactVerify(jws, key, options) {
    if (jws instanceof Uint8Array) {
        jws = decoder.decode(jws);
    }
    if (typeof jws !== 'string') {
        throw new JWSInvalid('Compact JWS must be a string or Uint8Array');
    }
    const { 0: protectedHeader , 1: payload , 2: signature , length  } = jws.split('.');
    if (length !== 3) {
        throw new JWSInvalid('Invalid Compact JWS');
    }
    const verified = await flattenedVerify({
        payload,
        protected: protectedHeader,
        signature
    }, key, options);
    const result = {
        payload: verified.payload,
        protectedHeader: verified.protectedHeader
    };
    if (typeof key === 'function') {
        return {
            ...result,
            key: verified.key
        };
    }
    return result;
}
const __default9 = (date)=>Math.floor(date.getTime() / 1000)
;
const hour = 60 * 60;
const day = hour * 24;
const week = day * 7;
const year = day * 365.25;
const REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
const __default10 = (str)=>{
    const matched = REGEX.exec(str);
    if (!matched) {
        throw new TypeError('Invalid time period format');
    }
    const value = parseFloat(matched[1]);
    const unit = matched[2].toLowerCase();
    switch(unit){
        case 'sec':
        case 'secs':
        case 'second':
        case 'seconds':
        case 's':
            return Math.round(value);
        case 'minute':
        case 'minutes':
        case 'min':
        case 'mins':
        case 'm':
            return Math.round(value * 60);
        case 'hour':
        case 'hours':
        case 'hr':
        case 'hrs':
        case 'h':
            return Math.round(value * hour);
        case 'day':
        case 'days':
        case 'd':
            return Math.round(value * day);
        case 'week':
        case 'weeks':
        case 'w':
            return Math.round(value * week);
        default:
            return Math.round(value * year);
    }
};
const normalizeTyp = (value)=>value.toLowerCase().replace(/^application\//, '')
;
const checkAudiencePresence = (audPayload, audOption)=>{
    if (typeof audPayload === 'string') {
        return audOption.includes(audPayload);
    }
    if (Array.isArray(audPayload)) {
        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
    }
    return false;
};
const __default11 = (protectedHeader, encodedPayload, options = {})=>{
    const { typ  } = options;
    if (typ && (typeof protectedHeader.typ !== 'string' || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
        throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', 'typ', 'check_failed');
    }
    let payload;
    try {
        payload = JSON.parse(decoder.decode(encodedPayload));
    } catch  {}
    if (!isObject(payload)) {
        throw new JWTInvalid('JWT Claims Set must be a top-level JSON object');
    }
    const { issuer  } = options;
    if (issuer && !(Array.isArray(issuer) ? issuer : [
        issuer
    ]).includes(payload.iss)) {
        throw new JWTClaimValidationFailed('unexpected "iss" claim value', 'iss', 'check_failed');
    }
    const { subject  } = options;
    if (subject && payload.sub !== subject) {
        throw new JWTClaimValidationFailed('unexpected "sub" claim value', 'sub', 'check_failed');
    }
    const { audience  } = options;
    if (audience && !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [
        audience
    ] : audience)) {
        throw new JWTClaimValidationFailed('unexpected "aud" claim value', 'aud', 'check_failed');
    }
    let tolerance;
    switch(typeof options.clockTolerance){
        case 'string':
            tolerance = __default10(options.clockTolerance);
            break;
        case 'number':
            tolerance = options.clockTolerance;
            break;
        case 'undefined':
            tolerance = 0;
            break;
        default:
            throw new TypeError('Invalid clockTolerance option type');
    }
    const { currentDate  } = options;
    const now = __default9(currentDate || new Date());
    if ((payload.iat !== undefined || options.maxTokenAge) && typeof payload.iat !== 'number') {
        throw new JWTClaimValidationFailed('"iat" claim must be a number', 'iat', 'invalid');
    }
    if (payload.nbf !== undefined) {
        if (typeof payload.nbf !== 'number') {
            throw new JWTClaimValidationFailed('"nbf" claim must be a number', 'nbf', 'invalid');
        }
        if (payload.nbf > now + tolerance) {
            throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', 'nbf', 'check_failed');
        }
    }
    if (payload.exp !== undefined) {
        if (typeof payload.exp !== 'number') {
            throw new JWTClaimValidationFailed('"exp" claim must be a number', 'exp', 'invalid');
        }
        if (payload.exp <= now - tolerance) {
            throw new JWTExpired('"exp" claim timestamp check failed', 'exp', 'check_failed');
        }
    }
    if (options.maxTokenAge) {
        const age = now - payload.iat;
        const max = typeof options.maxTokenAge === 'number' ? options.maxTokenAge : __default10(options.maxTokenAge);
        if (age - tolerance > max) {
            throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', 'iat', 'check_failed');
        }
        if (age < 0 - tolerance) {
            throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');
        }
    }
    return payload;
};
async function jwtVerify(jwt, key, options) {
    const verified = await compactVerify(jwt, key, options);
    if (verified.protectedHeader.crit?.includes('b64') && verified.protectedHeader.b64 === false) {
        throw new JWTInvalid('JWTs MUST NOT use unencoded payload');
    }
    const payload = __default11(verified.protectedHeader, verified.payload, options);
    const result = {
        payload,
        protectedHeader: verified.protectedHeader
    };
    if (typeof key === 'function') {
        return {
            ...result,
            key: verified.key
        };
    }
    return result;
}
function decodeProtectedHeader(token) {
    let protectedB64u;
    if (typeof token === 'string') {
        const parts = token.split('.');
        if (parts.length === 3 || parts.length === 5) {
            [protectedB64u] = parts;
        }
    } else if (typeof token === 'object' && token) {
        if ('protected' in token) {
            protectedB64u = token.protected;
        } else {
            throw new TypeError('Token does not contain a Protected Header');
        }
    }
    try {
        if (typeof protectedB64u !== 'string' || !protectedB64u) {
            throw new Error();
        }
        const result = JSON.parse(decoder.decode(decode4(protectedB64u)));
        if (!isObject(result)) {
            throw new Error();
        }
        return result;
    } catch  {
        throw new TypeError('Invalid Token or Protected Header formatting');
    }
}
function getParametersValue(parameters, name, defaultValue) {
    var _a;
    if (parameters instanceof Object === false) {
        return defaultValue;
    }
    return (_a = parameters[name]) !== null && _a !== void 0 ? _a : defaultValue;
}
function bufferToHexCodes(inputBuffer, inputOffset = 0, inputLength = inputBuffer.byteLength - inputOffset, insertSpace = false) {
    let result = "";
    for (const item of new Uint8Array(inputBuffer, inputOffset, inputLength)){
        const str = item.toString(16).toUpperCase();
        if (str.length === 1) {
            result += "0";
        }
        result += str;
        if (insertSpace) {
            result += " ";
        }
    }
    return result.trim();
}
function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
    if (!(inputBuffer instanceof ArrayBuffer)) {
        baseBlock.error = "Wrong parameter: inputBuffer must be \"ArrayBuffer\"";
        return false;
    }
    if (!inputBuffer.byteLength) {
        baseBlock.error = "Wrong parameter: inputBuffer has zero length";
        return false;
    }
    if (inputOffset < 0) {
        baseBlock.error = "Wrong parameter: inputOffset less than zero";
        return false;
    }
    if (inputLength < 0) {
        baseBlock.error = "Wrong parameter: inputLength less than zero";
        return false;
    }
    if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
        baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
        return false;
    }
    return true;
}
function utilFromBase(inputBuffer, inputBase) {
    let result = 0;
    if (inputBuffer.length === 1) {
        return inputBuffer[0];
    }
    for(let i83 = inputBuffer.length - 1; i83 >= 0; i83--){
        result += inputBuffer[inputBuffer.length - 1 - i83] * Math.pow(2, inputBase * i83);
    }
    return result;
}
function utilToBase(value, base9, reserved = -1) {
    const internalReserved = reserved;
    let internalValue = value;
    let result = 0;
    let biggest = Math.pow(2, base9);
    for(let i84 = 1; i84 < 8; i84++){
        if (value < biggest) {
            let retBuf;
            if (internalReserved < 0) {
                retBuf = new ArrayBuffer(i84);
                result = i84;
            } else {
                if (internalReserved < i84) {
                    return new ArrayBuffer(0);
                }
                retBuf = new ArrayBuffer(internalReserved);
                result = internalReserved;
            }
            const retView = new Uint8Array(retBuf);
            for(let j = i84 - 1; j >= 0; j--){
                const basis = Math.pow(2, j * base9);
                retView[result - j - 1] = Math.floor(internalValue / basis);
                internalValue -= retView[result - j - 1] * basis;
            }
            return retBuf;
        }
        biggest *= Math.pow(2, base9);
    }
    return new ArrayBuffer(0);
}
function utilConcatBuf(...buffers) {
    let outputLength = 0;
    let prevLength = 0;
    for (const buffer of buffers){
        outputLength += buffer.byteLength;
    }
    const retBuf = new ArrayBuffer(outputLength);
    const retView = new Uint8Array(retBuf);
    for (const buffer1 of buffers){
        retView.set(new Uint8Array(buffer1), prevLength);
        prevLength += buffer1.byteLength;
    }
    return retBuf;
}
function utilConcatView(...views) {
    let outputLength = 0;
    let prevLength = 0;
    for (const view of views){
        outputLength += view.length;
    }
    const retBuf = new ArrayBuffer(outputLength);
    const retView = new Uint8Array(retBuf);
    for (const view1 of views){
        retView.set(view1, prevLength);
        prevLength += view1.length;
    }
    return retView;
}
function utilDecodeTC() {
    const buf = new Uint8Array(this.valueHex);
    if (this.valueHex.byteLength >= 2) {
        const condition1 = buf[0] === 0xFF && buf[1] & 0x80;
        const condition2 = buf[0] === 0x00 && (buf[1] & 0x80) === 0x00;
        if (condition1 || condition2) {
            this.warnings.push("Needlessly long format");
        }
    }
    const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
    const bigIntView = new Uint8Array(bigIntBuffer);
    for(let i85 = 0; i85 < this.valueHex.byteLength; i85++){
        bigIntView[i85] = 0;
    }
    bigIntView[0] = buf[0] & 0x80;
    const bigInt = utilFromBase(bigIntView, 8);
    const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
    const smallIntView = new Uint8Array(smallIntBuffer);
    for(let j = 0; j < this.valueHex.byteLength; j++){
        smallIntView[j] = buf[j];
    }
    smallIntView[0] &= 0x7F;
    const smallInt = utilFromBase(smallIntView, 8);
    return smallInt - bigInt;
}
function utilEncodeTC(value) {
    const modValue = value < 0 ? value * -1 : value;
    let bigInt = 128;
    for(let i86 = 1; i86 < 8; i86++){
        if (modValue <= bigInt) {
            if (value < 0) {
                const smallInt = bigInt - modValue;
                const retBuf = utilToBase(smallInt, 8, i86);
                const retView = new Uint8Array(retBuf);
                retView[0] |= 0x80;
                return retBuf;
            }
            let retBuf = utilToBase(modValue, 8, i86);
            let retView = new Uint8Array(retBuf);
            if (retView[0] & 0x80) {
                const tempBuf = retBuf.slice(0);
                const tempView = new Uint8Array(tempBuf);
                retBuf = new ArrayBuffer(retBuf.byteLength + 1);
                retView = new Uint8Array(retBuf);
                for(let k = 0; k < tempBuf.byteLength; k++){
                    retView[k + 1] = tempView[k];
                }
                retView[0] = 0x00;
            }
            return retBuf;
        }
        bigInt *= Math.pow(2, 8);
    }
    return new ArrayBuffer(0);
}
function isEqualBuffer(inputBuffer1, inputBuffer2) {
    if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {
        return false;
    }
    const view1 = new Uint8Array(inputBuffer1);
    const view2 = new Uint8Array(inputBuffer2);
    for(let i87 = 0; i87 < view1.length; i87++){
        if (view1[i87] !== view2[i87]) {
            return false;
        }
    }
    return true;
}
function padNumber(inputNumber, fullLength) {
    const str = inputNumber.toString(10);
    if (fullLength < str.length) {
        return "";
    }
    const dif = fullLength - str.length;
    const padding = new Array(dif);
    for(let i88 = 0; i88 < dif; i88++){
        padding[i88] = "0";
    }
    const paddingString = padding.join("");
    return paddingString.concat(str);
}
const base64Template = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
const base64UrlTemplate = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";
function toBase64(input, useUrlTemplate = false, skipPadding = false, skipLeadingZeros = false) {
    let i90 = 0;
    let flag1 = 0;
    let flag2 = 0;
    let output = "";
    const template = useUrlTemplate ? base64UrlTemplate : base64Template;
    if (skipLeadingZeros) {
        let nonZeroPosition = 0;
        for(let i89 = 0; i89 < input.length; i89++){
            if (input.charCodeAt(i89) !== 0) {
                nonZeroPosition = i89;
                break;
            }
        }
        input = input.slice(nonZeroPosition);
    }
    while(i90 < input.length){
        const chr1 = input.charCodeAt(i90++);
        if (i90 >= input.length) {
            flag1 = 1;
        }
        const chr2 = input.charCodeAt(i90++);
        if (i90 >= input.length) {
            flag2 = 1;
        }
        const chr3 = input.charCodeAt(i90++);
        const enc1 = chr1 >> 2;
        const enc2 = (chr1 & 0x03) << 4 | chr2 >> 4;
        let enc3 = (chr2 & 0x0F) << 2 | chr3 >> 6;
        let enc4 = chr3 & 0x3F;
        if (flag1 === 1) {
            enc3 = enc4 = 64;
        } else {
            if (flag2 === 1) {
                enc4 = 64;
            }
        }
        if (skipPadding) {
            if (enc3 === 64) {
                output += `${template.charAt(enc1)}${template.charAt(enc2)}`;
            } else {
                if (enc4 === 64) {
                    output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}`;
                } else {
                    output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
                }
            }
        } else {
            output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
        }
    }
    return output;
}
function fromBase64(input, useUrlTemplate = false, cutTailZeros = false) {
    const template = useUrlTemplate ? base64UrlTemplate : base64Template;
    function indexOf(toSearch) {
        for(let i91 = 0; i91 < 64; i91++){
            if (template.charAt(i91) === toSearch) return i91;
        }
        return 64;
    }
    function test(incoming) {
        return incoming === 64 ? 0x00 : incoming;
    }
    let i1 = 0;
    let output = "";
    while(i1 < input.length){
        const enc1 = indexOf(input.charAt(i1++));
        const enc2 = i1 >= input.length ? 0x00 : indexOf(input.charAt(i1++));
        const enc3 = i1 >= input.length ? 0x00 : indexOf(input.charAt(i1++));
        const enc4 = i1 >= input.length ? 0x00 : indexOf(input.charAt(i1++));
        const chr1 = test(enc1) << 2 | test(enc2) >> 4;
        const chr2 = (test(enc2) & 0x0F) << 4 | test(enc3) >> 2;
        const chr3 = (test(enc3) & 0x03) << 6 | test(enc4);
        output += String.fromCharCode(chr1);
        if (enc3 !== 64) {
            output += String.fromCharCode(chr2);
        }
        if (enc4 !== 64) {
            output += String.fromCharCode(chr3);
        }
    }
    if (cutTailZeros) {
        const outputLength = output.length;
        let nonZeroStart = -1;
        for(let i92 = outputLength - 1; i92 >= 0; i92--){
            if (output.charCodeAt(i92) !== 0) {
                nonZeroStart = i92;
                break;
            }
        }
        if (nonZeroStart !== -1) {
            output = output.slice(0, nonZeroStart + 1);
        } else {
            output = "";
        }
    }
    return output;
}
function arrayBufferToString(buffer) {
    let resultString = "";
    const view = new Uint8Array(buffer);
    for (const element of view){
        resultString += String.fromCharCode(element);
    }
    return resultString;
}
function stringToArrayBuffer(str) {
    const stringLength = str.length;
    const resultBuffer = new ArrayBuffer(stringLength);
    const resultView = new Uint8Array(resultBuffer);
    for(let i93 = 0; i93 < stringLength; i93++){
        resultView[i93] = str.charCodeAt(i93);
    }
    return resultBuffer;
}
const log2 = Math.log(2);
function nearestPowerOf2(length) {
    const base10 = Math.log(length) / log2;
    const floor1 = Math.floor(base10);
    const round = Math.round(base10);
    return floor1 === round ? floor1 : round;
}
function clearProps(object, propsArray) {
    for (const prop of propsArray){
        delete object[prop];
    }
}
function assertBigInt() {
    if (typeof BigInt === "undefined") {
        throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
    }
}
const powers2 = [
    new Uint8Array([
        1
    ])
];
const digitsString = "0123456789";
class LocalBaseBlock {
    constructor(parameters = {}){
        this.blockLength = getParametersValue(parameters, "blockLength", 0);
        this.error = getParametersValue(parameters, "error", "");
        this.warnings = getParametersValue(parameters, "warnings", []);
        if ("valueBeforeDecode" in parameters) this.valueBeforeDecode = parameters.valueBeforeDecode.slice(0);
        else this.valueBeforeDecode = new ArrayBuffer(0);
    }
    static blockName() {
        return "baseBlock";
    }
    toJSON() {
        return {
            blockName: this.constructor.blockName(),
            blockLength: this.blockLength,
            error: this.error,
            warnings: this.warnings,
            valueBeforeDecode: bufferToHexCodes(this.valueBeforeDecode, 0, this.valueBeforeDecode.byteLength)
        };
    }
}
const HexBlock = (BaseClass)=>class LocalHexBlockMixin extends BaseClass {
        constructor(parameters = {}){
            super(parameters);
            this.isHexOnly = getParametersValue(parameters, "isHexOnly", false);
            if ("valueHex" in parameters) this.valueHex = parameters.valueHex.slice(0);
            else this.valueHex = new ArrayBuffer(0);
        }
        static blockName() {
            return "hexBlock";
        }
        fromBER(inputBuffer, inputOffset, inputLength) {
            if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1;
            const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
            if (intBuffer.length === 0) {
                this.warnings.push("Zero buffer length");
                return inputOffset;
            }
            this.valueHex = inputBuffer.slice(inputOffset, inputOffset + inputLength);
            this.blockLength = inputLength;
            return inputOffset + inputLength;
        }
        toBER(sizeOnly = false) {
            if (this.isHexOnly !== true) {
                this.error = "Flag \"isHexOnly\" is not set, abort";
                return new ArrayBuffer(0);
            }
            if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength);
            return this.valueHex.slice(0);
        }
        toJSON() {
            let object = {};
            try {
                object = super.toJSON();
            } catch (ex) {}
            object.blockName = this.constructor.blockName();
            object.isHexOnly = this.isHexOnly;
            object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);
            return object;
        }
    }
;
class LocalIdentificationBlock extends HexBlock(LocalBaseBlock) {
    constructor(parameters = {}){
        super();
        if ("idBlock" in parameters) {
            this.isHexOnly = getParametersValue(parameters.idBlock, "isHexOnly", false);
            this.valueHex = getParametersValue(parameters.idBlock, "valueHex", new ArrayBuffer(0));
            this.tagClass = getParametersValue(parameters.idBlock, "tagClass", -1);
            this.tagNumber = getParametersValue(parameters.idBlock, "tagNumber", -1);
            this.isConstructed = getParametersValue(parameters.idBlock, "isConstructed", false);
        } else {
            this.tagClass = -1;
            this.tagNumber = -1;
            this.isConstructed = false;
        }
    }
    static blockName() {
        return "identificationBlock";
    }
    toBER(sizeOnly = false) {
        let firstOctet = 0;
        let retBuf;
        let retView;
        switch(this.tagClass){
            case 1:
                firstOctet |= 0x00;
                break;
            case 2:
                firstOctet |= 0x40;
                break;
            case 3:
                firstOctet |= 0x80;
                break;
            case 4:
                firstOctet |= 0xC0;
                break;
            default:
                this.error = "Unknown tag class";
                return new ArrayBuffer(0);
        }
        if (this.isConstructed) firstOctet |= 0x20;
        if (this.tagNumber < 31 && !this.isHexOnly) {
            retBuf = new ArrayBuffer(1);
            retView = new Uint8Array(retBuf);
            if (!sizeOnly) {
                let number = this.tagNumber;
                number &= 0x1F;
                firstOctet |= number;
                retView[0] = firstOctet;
            }
            return retBuf;
        }
        if (this.isHexOnly === false) {
            const encodedBuf = utilToBase(this.tagNumber, 7);
            const encodedView = new Uint8Array(encodedBuf);
            const size = encodedBuf.byteLength;
            retBuf = new ArrayBuffer(size + 1);
            retView = new Uint8Array(retBuf);
            retView[0] = firstOctet | 0x1F;
            if (!sizeOnly) {
                for(let i94 = 0; i94 < size - 1; i94++)retView[i94 + 1] = encodedView[i94] | 0x80;
                retView[size] = encodedView[size - 1];
            }
            return retBuf;
        }
        retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);
        retView = new Uint8Array(retBuf);
        retView[0] = firstOctet | 0x1F;
        if (sizeOnly === false) {
            const curView = new Uint8Array(this.valueHex);
            for(let i95 = 0; i95 < curView.length - 1; i95++)retView[i95 + 1] = curView[i95] | 0x80;
            retView[this.valueHex.byteLength] = curView[curView.length - 1];
        }
        return retBuf;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1;
        const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
        if (intBuffer.length === 0) {
            this.error = "Zero buffer length";
            return -1;
        }
        const tagClassMask = intBuffer[0] & 0xC0;
        switch(tagClassMask){
            case 0x00:
                this.tagClass = 1;
                break;
            case 0x40:
                this.tagClass = 2;
                break;
            case 0x80:
                this.tagClass = 3;
                break;
            case 0xC0:
                this.tagClass = 4;
                break;
            default:
                this.error = "Unknown tag class";
                return -1;
        }
        this.isConstructed = (intBuffer[0] & 0x20) === 0x20;
        this.isHexOnly = false;
        const tagNumberMask = intBuffer[0] & 0x1F;
        if (tagNumberMask !== 0x1F) {
            this.tagNumber = tagNumberMask;
            this.blockLength = 1;
        } else {
            let count = 1;
            this.valueHex = new ArrayBuffer(255);
            let tagNumberBufferMaxLength = 255;
            let intTagNumberBuffer = new Uint8Array(this.valueHex);
            while(intBuffer[count] & 0x80){
                intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;
                count++;
                if (count >= intBuffer.length) {
                    this.error = "End of input reached before message was fully decoded";
                    return -1;
                }
                if (count === tagNumberBufferMaxLength) {
                    tagNumberBufferMaxLength += 255;
                    const tempBuffer = new ArrayBuffer(tagNumberBufferMaxLength);
                    const tempBufferView = new Uint8Array(tempBuffer);
                    for(let i96 = 0; i96 < intTagNumberBuffer.length; i96++)tempBufferView[i96] = intTagNumberBuffer[i96];
                    this.valueHex = new ArrayBuffer(tagNumberBufferMaxLength);
                    intTagNumberBuffer = new Uint8Array(this.valueHex);
                }
            }
            this.blockLength = count + 1;
            intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;
            const tempBuffer = new ArrayBuffer(count);
            const tempBufferView = new Uint8Array(tempBuffer);
            for(let i97 = 0; i97 < count; i97++)tempBufferView[i97] = intTagNumberBuffer[i97];
            this.valueHex = new ArrayBuffer(count);
            intTagNumberBuffer = new Uint8Array(this.valueHex);
            intTagNumberBuffer.set(tempBufferView);
            if (this.blockLength <= 9) this.tagNumber = utilFromBase(intTagNumberBuffer, 7);
            else {
                this.isHexOnly = true;
                this.warnings.push("Tag too long, represented as hex-coded");
            }
        }
        if (this.tagClass === 1 && this.isConstructed) {
            switch(this.tagNumber){
                case 1:
                case 2:
                case 5:
                case 6:
                case 9:
                case 13:
                case 14:
                case 23:
                case 24:
                case 31:
                case 32:
                case 33:
                case 34:
                    this.error = "Constructed encoding used for primitive type";
                    return -1;
                default:
            }
        }
        return inputOffset + this.blockLength;
    }
    toJSON() {
        let object = {};
        try {
            object = super.toJSON();
        } catch (ex) {}
        object.blockName = this.constructor.blockName();
        object.tagClass = this.tagClass;
        object.tagNumber = this.tagNumber;
        object.isConstructed = this.isConstructed;
        return object;
    }
}
class LocalLengthBlock extends LocalBaseBlock {
    constructor(parameters = {}){
        super();
        if ("lenBlock" in parameters) {
            this.isIndefiniteForm = getParametersValue(parameters.lenBlock, "isIndefiniteForm", false);
            this.longFormUsed = getParametersValue(parameters.lenBlock, "longFormUsed", false);
            this.length = getParametersValue(parameters.lenBlock, "length", 0);
        } else {
            this.isIndefiniteForm = false;
            this.longFormUsed = false;
            this.length = 0;
        }
    }
    static blockName() {
        return "lengthBlock";
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1;
        const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
        if (intBuffer.length === 0) {
            this.error = "Zero buffer length";
            return -1;
        }
        if (intBuffer[0] === 0xFF) {
            this.error = "Length block 0xFF is reserved by standard";
            return -1;
        }
        this.isIndefiniteForm = intBuffer[0] === 0x80;
        if (this.isIndefiniteForm === true) {
            this.blockLength = 1;
            return inputOffset + this.blockLength;
        }
        this.longFormUsed = !!(intBuffer[0] & 0x80);
        if (this.longFormUsed === false) {
            this.length = intBuffer[0];
            this.blockLength = 1;
            return inputOffset + this.blockLength;
        }
        const count = intBuffer[0] & 0x7F;
        if (count > 8) {
            this.error = "Too big integer";
            return -1;
        }
        if (count + 1 > intBuffer.length) {
            this.error = "End of input reached before message was fully decoded";
            return -1;
        }
        const lengthBufferView = new Uint8Array(count);
        for(let i98 = 0; i98 < count; i98++)lengthBufferView[i98] = intBuffer[i98 + 1];
        if (lengthBufferView[count - 1] === 0x00) this.warnings.push("Needlessly long encoded length");
        this.length = utilFromBase(lengthBufferView, 8);
        if (this.longFormUsed && this.length <= 127) this.warnings.push("Unnecessary usage of long length form");
        this.blockLength = count + 1;
        return inputOffset + this.blockLength;
    }
    toBER(sizeOnly = false) {
        let retBuf;
        let retView;
        if (this.length > 127) this.longFormUsed = true;
        if (this.isIndefiniteForm) {
            retBuf = new ArrayBuffer(1);
            if (sizeOnly === false) {
                retView = new Uint8Array(retBuf);
                retView[0] = 0x80;
            }
            return retBuf;
        }
        if (this.longFormUsed === true) {
            const encodedBuf = utilToBase(this.length, 8);
            if (encodedBuf.byteLength > 127) {
                this.error = "Too big length";
                return new ArrayBuffer(0);
            }
            retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
            if (sizeOnly === true) return retBuf;
            const encodedView = new Uint8Array(encodedBuf);
            retView = new Uint8Array(retBuf);
            retView[0] = encodedBuf.byteLength | 0x80;
            for(let i99 = 0; i99 < encodedBuf.byteLength; i99++)retView[i99 + 1] = encodedView[i99];
            return retBuf;
        }
        retBuf = new ArrayBuffer(1);
        if (sizeOnly === false) {
            retView = new Uint8Array(retBuf);
            retView[0] = this.length;
        }
        return retBuf;
    }
    toJSON() {
        let object = {};
        try {
            object = super.toJSON();
        } catch (ex) {}
        object.blockName = this.constructor.blockName();
        object.isIndefiniteForm = this.isIndefiniteForm;
        object.longFormUsed = this.longFormUsed;
        object.length = this.length;
        return object;
    }
}
class ValueBlock extends LocalBaseBlock {
    constructor(parameters = {}){
        super(parameters);
    }
    static blockName() {
        return "valueBlock";
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        throw TypeError("User need to make a specific function in a class which extends \"ValueBlock\"");
    }
    toBER(sizeOnly = false) {
        throw TypeError("User need to make a specific function in a class which extends \"ValueBlock\"");
    }
}
class BaseBlock extends LocalBaseBlock {
    constructor(parameters = {}, valueBlockType = ValueBlock){
        super(parameters);
        if ("name" in parameters) this.name = parameters.name;
        if ("optional" in parameters) this.optional = parameters.optional;
        if ("primitiveSchema" in parameters) this.primitiveSchema = parameters.primitiveSchema;
        this.idBlock = new LocalIdentificationBlock(parameters);
        this.lenBlock = new LocalLengthBlock(parameters);
        this.valueBlock = new valueBlockType(parameters);
    }
    static blockName() {
        return "BaseBlock";
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
            this.error = this.valueBlock.error;
            return resultOffset;
        }
        if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;
        if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;
        if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
    }
    toBER(sizeOnly = false) {
        let retBuf;
        const idBlockBuf = this.idBlock.toBER(sizeOnly);
        const valueBlockSizeBuf = this.valueBlock.toBER(true);
        this.lenBlock.length = valueBlockSizeBuf.byteLength;
        const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
        retBuf = utilConcatBuf(idBlockBuf, lenBlockBuf);
        let valueBlockBuf;
        if (sizeOnly === false) valueBlockBuf = this.valueBlock.toBER(sizeOnly);
        else valueBlockBuf = new ArrayBuffer(this.lenBlock.length);
        retBuf = utilConcatBuf(retBuf, valueBlockBuf);
        if (this.lenBlock.isIndefiniteForm === true) {
            const indefBuf = new ArrayBuffer(2);
            if (sizeOnly === false) {
                const indefView = new Uint8Array(indefBuf);
                indefView[0] = 0x00;
                indefView[1] = 0x00;
            }
            retBuf = utilConcatBuf(retBuf, indefBuf);
        }
        return retBuf;
    }
    toJSON() {
        let object = {};
        try {
            object = super.toJSON();
        } catch (ex) {}
        object.idBlock = this.idBlock.toJSON();
        object.lenBlock = this.lenBlock.toJSON();
        object.valueBlock = this.valueBlock.toJSON();
        if ("name" in this) object.name = this.name;
        if ("optional" in this) object.optional = this.optional;
        if ("primitiveSchema" in this) object.primitiveSchema = this.primitiveSchema.toJSON();
        return object;
    }
    toString() {
        return `${this.constructor.blockName()} : ${bufferToHexCodes(this.valueBlock.valueHex)}`;
    }
}
class LocalPrimitiveValueBlock extends ValueBlock {
    constructor(parameters = {}){
        super(parameters);
        if ("valueHex" in parameters) this.valueHex = parameters.valueHex.slice(0);
        else this.valueHex = new ArrayBuffer(0);
        this.isHexOnly = getParametersValue(parameters, "isHexOnly", true);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1;
        const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
        if (intBuffer.length === 0) {
            this.warnings.push("Zero buffer length");
            return inputOffset;
        }
        this.valueHex = new ArrayBuffer(intBuffer.length);
        const valueHexView = new Uint8Array(this.valueHex);
        for(let i100 = 0; i100 < intBuffer.length; i100++)valueHexView[i100] = intBuffer[i100];
        this.blockLength = inputLength;
        return inputOffset + inputLength;
    }
    toBER(sizeOnly = false) {
        return this.valueHex.slice(0);
    }
    static blockName() {
        return "PrimitiveValueBlock";
    }
    toJSON() {
        let object = {};
        try {
            object = super.toJSON();
        } catch (ex) {}
        object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);
        object.isHexOnly = this.isHexOnly;
        return object;
    }
}
class Primitive extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalPrimitiveValueBlock);
        this.idBlock.isConstructed = false;
    }
    static blockName() {
        return "PRIMITIVE";
    }
}
class LocalConstructedValueBlock extends ValueBlock {
    constructor(parameters = {}){
        super(parameters);
        this.value = getParametersValue(parameters, "value", []);
        this.isIndefiniteForm = getParametersValue(parameters, "isIndefiniteForm", false);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const initialOffset = inputOffset;
        const initialLength = inputLength;
        if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1;
        const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
        if (intBuffer.length === 0) {
            this.warnings.push("Zero buffer length");
            return inputOffset;
        }
        function checkLen(indefiniteLength, length) {
            if (indefiniteLength === true) return 1;
            return length;
        }
        let currentOffset = inputOffset;
        while(checkLen(this.isIndefiniteForm, inputLength) > 0){
            const returnObject = LocalFromBER(inputBuffer, currentOffset, inputLength);
            if (returnObject.offset === -1) {
                this.error = returnObject.result.error;
                this.warnings.concat(returnObject.result.warnings);
                return -1;
            }
            currentOffset = returnObject.offset;
            this.blockLength += returnObject.result.blockLength;
            inputLength -= returnObject.result.blockLength;
            this.value.push(returnObject.result);
            if (this.isIndefiniteForm === true && returnObject.result.constructor.blockName() === EndOfContent.blockName()) break;
        }
        if (this.isIndefiniteForm === true) {
            if (this.value[this.value.length - 1].constructor.blockName() === EndOfContent.blockName()) this.value.pop();
            else this.warnings.push("No EndOfContent block encoded");
        }
        this.valueBeforeDecode = inputBuffer.slice(initialOffset, initialOffset + initialLength);
        return currentOffset;
    }
    toBER(sizeOnly = false) {
        let retBuf = new ArrayBuffer(0);
        for(let i101 = 0; i101 < this.value.length; i101++){
            const valueBuf = this.value[i101].toBER(sizeOnly);
            retBuf = utilConcatBuf(retBuf, valueBuf);
        }
        return retBuf;
    }
    static blockName() {
        return "ConstructedValueBlock";
    }
    toJSON() {
        let object = {};
        try {
            object = super.toJSON();
        } catch (ex) {}
        object.isIndefiniteForm = this.isIndefiniteForm;
        object.value = [];
        for(let i102 = 0; i102 < this.value.length; i102++)object.value.push(this.value[i102].toJSON());
        return object;
    }
}
class Constructed extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalConstructedValueBlock);
        this.idBlock.isConstructed = true;
    }
    static blockName() {
        return "CONSTRUCTED";
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
            this.error = this.valueBlock.error;
            return resultOffset;
        }
        if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;
        if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;
        if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
    }
    toString() {
        const values = [];
        for (const value of this.valueBlock.value){
            values.push(value.toString().split("\n").map((o23)=>`  ${o23}`
            ).join("\n"));
        }
        const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.blockName();
        return values.length ? `${blockName} :\n${values.join("\n")}` : `${blockName} :`;
    }
}
class LocalEndOfContentValueBlock extends ValueBlock {
    constructor(parameters = {}){
        super(parameters);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        return inputOffset;
    }
    toBER(sizeOnly = false) {
        return new ArrayBuffer(0);
    }
    static blockName() {
        return "EndOfContentValueBlock";
    }
}
class EndOfContent extends BaseBlock {
    constructor(paramaters = {}){
        super(paramaters, LocalEndOfContentValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 0;
    }
    static blockName() {
        return "EndOfContent";
    }
}
class LocalBooleanValueBlock extends ValueBlock {
    constructor(parameters = {}){
        super(parameters);
        this.value = getParametersValue(parameters, "value", false);
        this.isHexOnly = getParametersValue(parameters, "isHexOnly", false);
        if ("valueHex" in parameters) this.valueHex = parameters.valueHex.slice(0);
        else {
            this.valueHex = new ArrayBuffer(1);
            if (this.value === true) {
                const view = new Uint8Array(this.valueHex);
                view[0] = 0xFF;
            }
        }
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1;
        const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
        if (inputLength > 1) this.warnings.push("Boolean value encoded in more then 1 octet");
        this.isHexOnly = true;
        this.valueHex = new ArrayBuffer(intBuffer.length);
        const view = new Uint8Array(this.valueHex);
        for(let i103 = 0; i103 < intBuffer.length; i103++)view[i103] = intBuffer[i103];
        if (utilDecodeTC.call(this) !== 0) this.value = true;
        else this.value = false;
        this.blockLength = inputLength;
        return inputOffset + inputLength;
    }
    toBER(sizeOnly = false) {
        return this.valueHex;
    }
    static blockName() {
        return "BooleanValueBlock";
    }
    toJSON() {
        let object = {};
        try {
            object = super.toJSON();
        } catch (ex) {}
        object.value = this.value;
        object.isHexOnly = this.isHexOnly;
        object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);
        return object;
    }
}
class Boolean1 extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalBooleanValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 1;
    }
    static blockName() {
        return "BOOLEAN";
    }
    toString() {
        return `${this.constructor.blockName()} : ${this.valueBlock.value}`;
    }
}
class Sequence extends Constructed {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 16;
    }
    static blockName() {
        return "SEQUENCE";
    }
}
class Set1 extends Constructed {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 17;
    }
    static blockName() {
        return "SET";
    }
}
class Null extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalBaseBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 5;
    }
    static blockName() {
        return "NULL";
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        if (this.lenBlock.length > 0) this.warnings.push("Non-zero length of value block for Null type");
        if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;
        if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;
        this.blockLength += inputLength;
        if (inputOffset + inputLength > inputBuffer.byteLength) {
            this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
            return -1;
        }
        return inputOffset + inputLength;
    }
    toBER(sizeOnly = false) {
        const retBuf = new ArrayBuffer(2);
        if (sizeOnly === true) return retBuf;
        const retView = new Uint8Array(retBuf);
        retView[0] = 0x05;
        retView[1] = 0x00;
        return retBuf;
    }
    toString() {
        return `${this.constructor.blockName()}`;
    }
}
class LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock) {
    constructor(parameters = {}){
        super(parameters);
        this.isConstructed = getParametersValue(parameters, "isConstructed", false);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = 0;
        if (this.isConstructed === true) {
            this.isHexOnly = false;
            resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
            if (resultOffset === -1) return resultOffset;
            for(let i104 = 0; i104 < this.value.length; i104++){
                const currentBlockName = this.value[i104].constructor.blockName();
                if (currentBlockName === EndOfContent.blockName()) {
                    if (this.isIndefiniteForm === true) break;
                    else {
                        this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
                        return -1;
                    }
                }
                if (currentBlockName !== OctetString.blockName()) {
                    this.error = "OCTET STRING may consists of OCTET STRINGs only";
                    return -1;
                }
            }
        } else {
            this.isHexOnly = true;
            resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
            this.blockLength = inputLength;
        }
        return resultOffset;
    }
    toBER(sizeOnly = false) {
        if (this.isConstructed === true) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);
        let retBuf = new ArrayBuffer(this.valueHex.byteLength);
        if (sizeOnly === true) return retBuf;
        if (this.valueHex.byteLength === 0) return retBuf;
        retBuf = this.valueHex.slice(0);
        return retBuf;
    }
    static blockName() {
        return "OctetStringValueBlock";
    }
    toJSON() {
        let object = {};
        try {
            object = super.toJSON();
        } catch (ex) {}
        object.isConstructed = this.isConstructed;
        object.isHexOnly = this.isHexOnly;
        object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);
        return object;
    }
}
class OctetString extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalOctetStringValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 4;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isConstructed = this.idBlock.isConstructed;
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        if (inputLength === 0) {
            if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;
            if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;
            return inputOffset;
        }
        if (!this.valueBlock.isConstructed) {
            const buf = inputBuffer.slice(inputOffset, inputOffset + inputLength);
            try {
                const asn = fromBER(buf);
                if (asn.offset !== -1 && asn.offset === inputLength) {
                    this.valueBlock.value = [
                        asn.result
                    ];
                }
            } catch (e) {}
        }
        return super.fromBER(inputBuffer, inputOffset, inputLength);
    }
    static blockName() {
        return "OCTET STRING";
    }
    isEqual(octetString) {
        if (octetString instanceof OctetString === false) return false;
        if (JSON.stringify(this) !== JSON.stringify(octetString)) return false;
        return true;
    }
    toString() {
        if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
            return Constructed.prototype.toString.call(this);
        } else {
            return `${this.constructor.blockName()} : ${bufferToHexCodes(this.valueBlock.valueHex)}`;
        }
    }
}
class LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock) {
    constructor(parameters = {}){
        super(parameters);
        this.unusedBits = getParametersValue(parameters, "unusedBits", 0);
        this.isConstructed = getParametersValue(parameters, "isConstructed", false);
        this.blockLength = this.valueHex.byteLength;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        if (inputLength === 0) return inputOffset;
        let resultOffset = -1;
        if (this.isConstructed === true) {
            resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
            if (resultOffset === -1) return resultOffset;
            for(let i105 = 0; i105 < this.value.length; i105++){
                const currentBlockName = this.value[i105].constructor.blockName();
                if (currentBlockName === EndOfContent.blockName()) {
                    if (this.isIndefiniteForm === true) break;
                    else {
                        this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
                        return -1;
                    }
                }
                if (currentBlockName !== BitString.blockName()) {
                    this.error = "BIT STRING may consists of BIT STRINGs only";
                    return -1;
                }
                if (this.unusedBits > 0 && this.value[i105].valueBlock.unusedBits > 0) {
                    this.error = "Using of \"unused bits\" inside constructive BIT STRING allowed for least one only";
                    return -1;
                }
                this.unusedBits = this.value[i105].valueBlock.unusedBits;
                if (this.unusedBits > 7) {
                    this.error = "Unused bits for BitString must be in range 0-7";
                    return -1;
                }
            }
            return resultOffset;
        }
        if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1;
        const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
        this.unusedBits = intBuffer[0];
        if (this.unusedBits > 7) {
            this.error = "Unused bits for BitString must be in range 0-7";
            return -1;
        }
        if (!this.unusedBits) {
            const buf = inputBuffer.slice(inputOffset + 1, inputOffset + inputLength);
            try {
                const asn = fromBER(buf);
                if (asn.offset !== -1 && asn.offset === inputLength - 1) {
                    this.value = [
                        asn.result
                    ];
                }
            } catch (e) {}
        }
        this.valueHex = new ArrayBuffer(intBuffer.length - 1);
        const view = new Uint8Array(this.valueHex);
        for(let i106 = 0; i106 < inputLength - 1; i106++)view[i106] = intBuffer[i106 + 1];
        this.blockLength = intBuffer.length;
        return inputOffset + inputLength;
    }
    toBER(sizeOnly = false) {
        if (this.isConstructed === true) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);
        if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength + 1);
        if (this.valueHex.byteLength === 0) return new ArrayBuffer(0);
        const curView = new Uint8Array(this.valueHex);
        const retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);
        const retView = new Uint8Array(retBuf);
        retView[0] = this.unusedBits;
        for(let i107 = 0; i107 < this.valueHex.byteLength; i107++)retView[i107 + 1] = curView[i107];
        return retBuf;
    }
    static blockName() {
        return "BitStringValueBlock";
    }
    toJSON() {
        let object = {};
        try {
            object = super.toJSON();
        } catch (ex) {}
        object.unusedBits = this.unusedBits;
        object.isConstructed = this.isConstructed;
        object.isHexOnly = this.isHexOnly;
        object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);
        return object;
    }
}
class BitString extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalBitStringValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 3;
    }
    static blockName() {
        return "BIT STRING";
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        if (inputLength === 0) return inputOffset;
        this.valueBlock.isConstructed = this.idBlock.isConstructed;
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        return super.fromBER(inputBuffer, inputOffset, inputLength);
    }
    isEqual(bitString) {
        if (bitString instanceof BitString === false) return false;
        if (JSON.stringify(this) !== JSON.stringify(bitString)) return false;
        return true;
    }
    toString() {
        if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
            return Constructed.prototype.toString.call(this);
        } else {
            const bits = [];
            const valueHex = new Uint8Array(this.valueBlock.valueHex);
            for (const __byte of valueHex){
                bits.push(__byte.toString(2).padStart(8, "0"));
            }
            return `${this.constructor.blockName()} : ${bits.join("")}`;
        }
    }
}
class LocalIntegerValueBlock extends HexBlock(ValueBlock) {
    constructor(parameters = {}){
        super(parameters);
        if ("value" in parameters) this.valueDec = parameters.value;
    }
    set valueHex(_value) {
        this._valueHex = _value.slice(0);
        if (_value.byteLength >= 4) {
            this.warnings.push("Too big Integer for decoding, hex only");
            this.isHexOnly = true;
            this._valueDec = 0;
        } else {
            this.isHexOnly = false;
            if (_value.byteLength > 0) this._valueDec = utilDecodeTC.call(this);
        }
    }
    get valueHex() {
        return this._valueHex;
    }
    set valueDec(_value) {
        this._valueDec = _value;
        this.isHexOnly = false;
        this._valueHex = utilEncodeTC(_value);
    }
    get valueDec() {
        return this._valueDec;
    }
    fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
        const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
        if (offset === -1) return offset;
        const view = new Uint8Array(this._valueHex);
        if (view[0] === 0x00 && (view[1] & 0x80) !== 0) {
            const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);
            const updatedView = new Uint8Array(updatedValueHex);
            updatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));
            this._valueHex = updatedValueHex.slice(0);
        } else {
            if (expectedLength !== 0) {
                if (this._valueHex.byteLength < expectedLength) {
                    if (expectedLength - this._valueHex.byteLength > 1) expectedLength = this._valueHex.byteLength + 1;
                    const updatedValueHex = new ArrayBuffer(expectedLength);
                    const updatedView = new Uint8Array(updatedValueHex);
                    updatedView.set(view, expectedLength - this._valueHex.byteLength);
                    this._valueHex = updatedValueHex.slice(0);
                }
            }
        }
        return offset;
    }
    toDER(sizeOnly = false) {
        const view = new Uint8Array(this._valueHex);
        switch(true){
            case (view[0] & 0x80) !== 0:
                {
                    const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength + 1);
                    const updatedView = new Uint8Array(updatedValueHex);
                    updatedView[0] = 0x00;
                    updatedView.set(view, 1);
                    this._valueHex = updatedValueHex.slice(0);
                }
                break;
            case view[0] === 0x00 && (view[1] & 0x80) === 0:
                {
                    const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);
                    const updatedView = new Uint8Array(updatedValueHex);
                    updatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));
                    this._valueHex = updatedValueHex.slice(0);
                }
                break;
            default:
        }
        return this.toBER(sizeOnly);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
        if (resultOffset === -1) return resultOffset;
        this.blockLength = inputLength;
        return inputOffset + inputLength;
    }
    toBER(sizeOnly = false) {
        return this.valueHex.slice(0);
    }
    static blockName() {
        return "IntegerValueBlock";
    }
    toJSON() {
        let object = {};
        try {
            object = super.toJSON();
        } catch (ex) {}
        object.valueDec = this.valueDec;
        return object;
    }
    toString() {
        function viewAdd(first, second) {
            const c = new Uint8Array([
                0
            ]);
            let firstView = new Uint8Array(first);
            let secondView = new Uint8Array(second);
            let firstViewCopy = firstView.slice(0);
            const firstViewCopyLength = firstViewCopy.length - 1;
            let secondViewCopy = secondView.slice(0);
            const secondViewCopyLength = secondViewCopy.length - 1;
            let value = 0;
            const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
            let counter = 0;
            for(let i108 = max; i108 >= 0; i108--, counter++){
                switch(true){
                    case counter < secondViewCopy.length:
                        value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
                        break;
                    default:
                        value = firstViewCopy[firstViewCopyLength - counter] + c[0];
                }
                c[0] = value / 10;
                switch(true){
                    case counter >= firstViewCopy.length:
                        firstViewCopy = utilConcatView(new Uint8Array([
                            value % 10
                        ]), firstViewCopy);
                        break;
                    default:
                        firstViewCopy[firstViewCopyLength - counter] = value % 10;
                }
            }
            if (c[0] > 0) firstViewCopy = utilConcatView(c, firstViewCopy);
            return firstViewCopy.slice(0);
        }
        function power2(n10) {
            if (n10 >= powers2.length) {
                for(let p = powers2.length; p <= n10; p++){
                    const c = new Uint8Array([
                        0
                    ]);
                    let digits = powers2[p - 1].slice(0);
                    for(let i109 = digits.length - 1; i109 >= 0; i109--){
                        const newValue = new Uint8Array([
                            (digits[i109] << 1) + c[0]
                        ]);
                        c[0] = newValue[0] / 10;
                        digits[i109] = newValue[0] % 10;
                    }
                    if (c[0] > 0) digits = utilConcatView(c, digits);
                    powers2.push(digits);
                }
            }
            return powers2[n10];
        }
        function viewSub(first, second) {
            let b = 0;
            let firstView = new Uint8Array(first);
            let secondView = new Uint8Array(second);
            let firstViewCopy = firstView.slice(0);
            const firstViewCopyLength = firstViewCopy.length - 1;
            let secondViewCopy = secondView.slice(0);
            const secondViewCopyLength = secondViewCopy.length - 1;
            let value;
            let counter = 0;
            for(let i113 = secondViewCopyLength; i113 >= 0; i113--, counter++){
                value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
                switch(true){
                    case value < 0:
                        b = 1;
                        firstViewCopy[firstViewCopyLength - counter] = value + 10;
                        break;
                    default:
                        b = 0;
                        firstViewCopy[firstViewCopyLength - counter] = value;
                }
            }
            if (b > 0) {
                for(let i114 = firstViewCopyLength - secondViewCopyLength + 1; i114 >= 0; i114--, counter++){
                    value = firstViewCopy[firstViewCopyLength - counter] - b;
                    if (value < 0) {
                        b = 1;
                        firstViewCopy[firstViewCopyLength - counter] = value + 10;
                    } else {
                        b = 0;
                        firstViewCopy[firstViewCopyLength - counter] = value;
                        break;
                    }
                }
            }
            return firstViewCopy.slice();
        }
        const firstBit = this._valueHex.byteLength * 8 - 1;
        let digits1 = new Uint8Array(this._valueHex.byteLength * 8 / 3);
        let bitNumber = 0;
        let currentByte;
        const asn1View = new Uint8Array(this._valueHex);
        let result = "";
        let flag = false;
        for(let byteNumber = this._valueHex.byteLength - 1; byteNumber >= 0; byteNumber--){
            currentByte = asn1View[byteNumber];
            for(let i115 = 0; i115 < 8; i115++){
                if ((currentByte & 1) === 1) {
                    switch(bitNumber){
                        case firstBit:
                            digits1 = viewSub(power2(bitNumber), digits1);
                            result = "-";
                            break;
                        default:
                            digits1 = viewAdd(digits1, power2(bitNumber));
                    }
                }
                bitNumber++;
                currentByte >>= 1;
            }
        }
        for(let i1 = 0; i1 < digits1.length; i1++){
            if (digits1[i1]) flag = true;
            if (flag) result += digitsString.charAt(digits1[i1]);
        }
        if (flag === false) result += digitsString.charAt(0);
        return result;
    }
}
class Integer extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalIntegerValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 2;
    }
    static blockName() {
        return "INTEGER";
    }
    isEqual(otherValue) {
        if (otherValue instanceof Integer) {
            if (this.valueBlock.isHexOnly && otherValue.valueBlock.isHexOnly) return isEqualBuffer(this.valueBlock.valueHex, otherValue.valueBlock.valueHex);
            if (this.valueBlock.isHexOnly === otherValue.valueBlock.isHexOnly) return this.valueBlock.valueDec === otherValue.valueBlock.valueDec;
            return false;
        }
        if (otherValue instanceof ArrayBuffer) return isEqualBuffer(this.valueBlock.valueHex, otherValue);
        return false;
    }
    convertToDER() {
        const integer = new Integer({
            valueHex: this.valueBlock.valueHex
        });
        integer.valueBlock.toDER();
        return integer;
    }
    convertFromDER() {
        const expectedLength = this.valueBlock.valueHex.byteLength % 2 ? this.valueBlock.valueHex.byteLength + 1 : this.valueBlock.valueHex.byteLength;
        const integer = new Integer({
            valueHex: this.valueBlock.valueHex
        });
        integer.valueBlock.fromDER(integer.valueBlock.valueHex, 0, integer.valueBlock.valueHex.byteLength, expectedLength);
        return integer;
    }
    toString() {
        assertBigInt();
        const hex = bufferToHexCodes(this.valueBlock.valueHex);
        const bigInt = BigInt(`0x${hex}`);
        return `${this.constructor.blockName()} : ${bigInt.toString()}`;
    }
}
class Enumerated extends Integer {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 10;
    }
    static blockName() {
        return "ENUMERATED";
    }
}
class LocalSidValueBlock extends HexBlock(LocalBaseBlock) {
    constructor(parameters = {}){
        super(parameters);
        this.valueDec = getParametersValue(parameters, "valueDec", -1);
        this.isFirstSid = getParametersValue(parameters, "isFirstSid", false);
    }
    static blockName() {
        return "sidBlock";
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        if (inputLength === 0) return inputOffset;
        if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1;
        const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
        this.valueHex = new ArrayBuffer(inputLength);
        let view = new Uint8Array(this.valueHex);
        for(let i116 = 0; i116 < inputLength; i116++){
            view[i116] = intBuffer[i116] & 0x7F;
            this.blockLength++;
            if ((intBuffer[i116] & 0x80) === 0x00) break;
        }
        const tempValueHex = new ArrayBuffer(this.blockLength);
        const tempView = new Uint8Array(tempValueHex);
        for(let i210 = 0; i210 < this.blockLength; i210++)tempView[i210] = view[i210];
        this.valueHex = tempValueHex.slice(0);
        view = new Uint8Array(this.valueHex);
        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {
            this.error = "End of input reached before message was fully decoded";
            return -1;
        }
        if (view[0] === 0x00) this.warnings.push("Needlessly long format of SID encoding");
        if (this.blockLength <= 8) this.valueDec = utilFromBase(view, 7);
        else {
            this.isHexOnly = true;
            this.warnings.push("Too big SID for decoding, hex only");
        }
        return inputOffset + this.blockLength;
    }
    set valueBigInt(value) {
        assertBigInt();
        let bits = BigInt(value).toString(2);
        while(bits.length % 7){
            bits = '0' + bits;
        }
        const bytes = new Uint8Array(bits.length / 7);
        for(let i117 = 0; i117 < bytes.length; i117++){
            bytes[i117] = parseInt(bits.slice(i117 * 7, i117 * 7 + 7), 2) + (i117 + 1 < bytes.length ? 0x80 : 0);
        }
        this.fromBER(bytes.buffer, 0, bytes.length);
    }
    toBER(sizeOnly = false) {
        let retBuf;
        let retView;
        if (this.isHexOnly) {
            if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength);
            const curView = new Uint8Array(this.valueHex);
            retBuf = new ArrayBuffer(this.blockLength);
            retView = new Uint8Array(retBuf);
            for(let i118 = 0; i118 < this.blockLength - 1; i118++)retView[i118] = curView[i118] | 0x80;
            retView[this.blockLength - 1] = curView[this.blockLength - 1];
            return retBuf;
        }
        const encodedBuf = utilToBase(this.valueDec, 7);
        if (encodedBuf.byteLength === 0) {
            this.error = "Error during encoding SID value";
            return new ArrayBuffer(0);
        }
        retBuf = new ArrayBuffer(encodedBuf.byteLength);
        if (sizeOnly === false) {
            const encodedView = new Uint8Array(encodedBuf);
            retView = new Uint8Array(retBuf);
            for(let i119 = 0; i119 < encodedBuf.byteLength - 1; i119++)retView[i119] = encodedView[i119] | 0x80;
            retView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];
        }
        return retBuf;
    }
    toString() {
        let result = "";
        if (this.isHexOnly === true) result = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);
        else {
            if (this.isFirstSid) {
                let sidValue = this.valueDec;
                if (this.valueDec <= 39) result = "0.";
                else {
                    if (this.valueDec <= 79) {
                        result = "1.";
                        sidValue -= 40;
                    } else {
                        result = "2.";
                        sidValue -= 80;
                    }
                }
                result += sidValue.toString();
            } else result = this.valueDec.toString();
        }
        return result;
    }
    toJSON() {
        let object = {};
        try {
            object = super.toJSON();
        } catch (ex) {}
        object.valueDec = this.valueDec;
        object.isFirstSid = this.isFirstSid;
        return object;
    }
}
class LocalObjectIdentifierValueBlock extends ValueBlock {
    constructor(parameters = {}){
        super(parameters);
        this.fromString(getParametersValue(parameters, "value", ""));
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = inputOffset;
        while(inputLength > 0){
            const sidBlock = new LocalSidValueBlock();
            resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
            if (resultOffset === -1) {
                this.blockLength = 0;
                this.error = sidBlock.error;
                return resultOffset;
            }
            if (this.value.length === 0) sidBlock.isFirstSid = true;
            this.blockLength += sidBlock.blockLength;
            inputLength -= sidBlock.blockLength;
            this.value.push(sidBlock);
        }
        return resultOffset;
    }
    toBER(sizeOnly = false) {
        let retBuf = new ArrayBuffer(0);
        for(let i120 = 0; i120 < this.value.length; i120++){
            const valueBuf = this.value[i120].toBER(sizeOnly);
            if (valueBuf.byteLength === 0) {
                this.error = this.value[i120].error;
                return new ArrayBuffer(0);
            }
            retBuf = utilConcatBuf(retBuf, valueBuf);
        }
        return retBuf;
    }
    fromString(string) {
        this.value = [];
        let pos1 = 0;
        let pos2 = 0;
        let sid = "";
        let flag = false;
        do {
            pos2 = string.indexOf(".", pos1);
            if (pos2 === -1) sid = string.substr(pos1);
            else sid = string.substr(pos1, pos2 - pos1);
            pos1 = pos2 + 1;
            if (flag) {
                const sidBlock = this.value[0];
                let plus = 0;
                switch(sidBlock.valueDec){
                    case 0:
                        break;
                    case 1:
                        plus = 40;
                        break;
                    case 2:
                        plus = 80;
                        break;
                    default:
                        this.value = [];
                        return false;
                }
                const parsedSID = parseInt(sid, 10);
                if (isNaN(parsedSID)) return true;
                sidBlock.valueDec = parsedSID + plus;
                flag = false;
            } else {
                const sidBlock = new LocalSidValueBlock();
                if (sid > Number.MAX_SAFE_INTEGER) {
                    assertBigInt();
                    const sidValue = BigInt(sid);
                    sidBlock.valueBigInt = sidValue;
                } else {
                    sidBlock.valueDec = parseInt(sid, 10);
                    if (isNaN(sidBlock.valueDec)) return true;
                }
                if (this.value.length === 0) {
                    sidBlock.isFirstSid = true;
                    flag = true;
                }
                this.value.push(sidBlock);
            }
        }while (pos2 !== -1)
        return true;
    }
    toString() {
        let result = "";
        let isHexOnly = false;
        for(let i121 = 0; i121 < this.value.length; i121++){
            isHexOnly = this.value[i121].isHexOnly;
            let sidStr = this.value[i121].toString();
            if (i121 !== 0) result = `${result}.`;
            if (isHexOnly) {
                sidStr = `{${sidStr}}`;
                if (this.value[i121].isFirstSid) result = `2.{${sidStr} - 80}`;
                else result += sidStr;
            } else result += sidStr;
        }
        return result;
    }
    static blockName() {
        return "ObjectIdentifierValueBlock";
    }
    toJSON() {
        let object = {};
        try {
            object = super.toJSON();
        } catch (ex) {}
        object.value = this.toString();
        object.sidArray = [];
        for(let i122 = 0; i122 < this.value.length; i122++)object.sidArray.push(this.value[i122].toJSON());
        return object;
    }
}
class ObjectIdentifier extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalObjectIdentifierValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 6;
    }
    static blockName() {
        return "OBJECT IDENTIFIER";
    }
    toString() {
        return `${this.constructor.blockName()} : ${this.valueBlock.toString()}`;
    }
}
class LocalUtf8StringValueBlock extends HexBlock(LocalBaseBlock) {
    constructor(parameters = {}){
        super(parameters);
        this.isHexOnly = true;
        this.value = "";
    }
    static blockName() {
        return "Utf8StringValueBlock";
    }
    toJSON() {
        let object = {};
        try {
            object = super.toJSON();
        } catch (ex) {}
        object.value = this.value;
        return object;
    }
}
class Utf8String extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalUtf8StringValueBlock);
        if ("value" in parameters) this.fromString(parameters.value);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 12;
    }
    static blockName() {
        return "UTF8String";
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
            this.error = this.valueBlock.error;
            return resultOffset;
        }
        this.fromBuffer(this.valueBlock.valueHex);
        if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;
        if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;
        if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
    }
    fromBuffer(inputBuffer) {
        this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));
        try {
            this.valueBlock.value = decodeURIComponent(escape(this.valueBlock.value));
        } catch (ex) {
            this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
        }
    }
    fromString(inputString) {
        const str = unescape(encodeURIComponent(inputString));
        const strLen = str.length;
        this.valueBlock.valueHex = new ArrayBuffer(strLen);
        const view = new Uint8Array(this.valueBlock.valueHex);
        for(let i123 = 0; i123 < strLen; i123++)view[i123] = str.charCodeAt(i123);
        this.valueBlock.value = inputString;
    }
    toString() {
        return `${this.constructor.blockName()} : ${this.valueBlock.value}`;
    }
}
class LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock) {
    constructor(parameters = {}){
        super(parameters);
        this.valueDec = getParametersValue(parameters, "valueDec", -1);
    }
    static blockName() {
        return "relativeSidBlock";
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        if (inputLength === 0) return inputOffset;
        if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1;
        const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
        this.valueHex = new ArrayBuffer(inputLength);
        let view = new Uint8Array(this.valueHex);
        for(let i124 = 0; i124 < inputLength; i124++){
            view[i124] = intBuffer[i124] & 0x7F;
            this.blockLength++;
            if ((intBuffer[i124] & 0x80) === 0x00) break;
        }
        const tempValueHex = new ArrayBuffer(this.blockLength);
        const tempView = new Uint8Array(tempValueHex);
        for(let i3 = 0; i3 < this.blockLength; i3++)tempView[i3] = view[i3];
        this.valueHex = tempValueHex.slice(0);
        view = new Uint8Array(this.valueHex);
        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {
            this.error = "End of input reached before message was fully decoded";
            return -1;
        }
        if (view[0] === 0x00) this.warnings.push("Needlessly long format of SID encoding");
        if (this.blockLength <= 8) this.valueDec = utilFromBase(view, 7);
        else {
            this.isHexOnly = true;
            this.warnings.push("Too big SID for decoding, hex only");
        }
        return inputOffset + this.blockLength;
    }
    toBER(sizeOnly = false) {
        let retBuf;
        let retView;
        if (this.isHexOnly) {
            if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength);
            const curView = new Uint8Array(this.valueHex);
            retBuf = new ArrayBuffer(this.blockLength);
            retView = new Uint8Array(retBuf);
            for(let i125 = 0; i125 < this.blockLength - 1; i125++)retView[i125] = curView[i125] | 0x80;
            retView[this.blockLength - 1] = curView[this.blockLength - 1];
            return retBuf;
        }
        const encodedBuf = utilToBase(this.valueDec, 7);
        if (encodedBuf.byteLength === 0) {
            this.error = "Error during encoding SID value";
            return new ArrayBuffer(0);
        }
        retBuf = new ArrayBuffer(encodedBuf.byteLength);
        if (sizeOnly === false) {
            const encodedView = new Uint8Array(encodedBuf);
            retView = new Uint8Array(retBuf);
            for(let i126 = 0; i126 < encodedBuf.byteLength - 1; i126++)retView[i126] = encodedView[i126] | 0x80;
            retView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];
        }
        return retBuf;
    }
    toString() {
        let result = "";
        if (this.isHexOnly === true) result = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);
        else {
            result = this.valueDec.toString();
        }
        return result;
    }
    toJSON() {
        let object = {};
        try {
            object = super.toJSON();
        } catch (ex) {}
        object.valueDec = this.valueDec;
        return object;
    }
}
class LocalRelativeObjectIdentifierValueBlock extends ValueBlock {
    constructor(parameters = {}){
        super(parameters);
        this.fromString(getParametersValue(parameters, "value", ""));
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = inputOffset;
        while(inputLength > 0){
            const sidBlock = new LocalRelativeSidValueBlock();
            resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
            if (resultOffset === -1) {
                this.blockLength = 0;
                this.error = sidBlock.error;
                return resultOffset;
            }
            this.blockLength += sidBlock.blockLength;
            inputLength -= sidBlock.blockLength;
            this.value.push(sidBlock);
        }
        return resultOffset;
    }
    toBER(sizeOnly = false) {
        let retBuf = new ArrayBuffer(0);
        for(let i127 = 0; i127 < this.value.length; i127++){
            const valueBuf = this.value[i127].toBER(sizeOnly);
            if (valueBuf.byteLength === 0) {
                this.error = this.value[i127].error;
                return new ArrayBuffer(0);
            }
            retBuf = utilConcatBuf(retBuf, valueBuf);
        }
        return retBuf;
    }
    fromString(string) {
        this.value = [];
        let pos1 = 0;
        let pos2 = 0;
        let sid = "";
        do {
            pos2 = string.indexOf(".", pos1);
            if (pos2 === -1) sid = string.substr(pos1);
            else sid = string.substr(pos1, pos2 - pos1);
            pos1 = pos2 + 1;
            const sidBlock = new LocalRelativeSidValueBlock();
            sidBlock.valueDec = parseInt(sid, 10);
            if (isNaN(sidBlock.valueDec)) return true;
            this.value.push(sidBlock);
        }while (pos2 !== -1)
        return true;
    }
    toString() {
        let result = "";
        let isHexOnly = false;
        for(let i128 = 0; i128 < this.value.length; i128++){
            isHexOnly = this.value[i128].isHexOnly;
            let sidStr = this.value[i128].toString();
            if (i128 !== 0) result = `${result}.`;
            if (isHexOnly) {
                sidStr = `{${sidStr}}`;
                result += sidStr;
            } else result += sidStr;
        }
        return result;
    }
    static blockName() {
        return "RelativeObjectIdentifierValueBlock";
    }
    toJSON() {
        let object = {};
        try {
            object = super.toJSON();
        } catch (ex) {}
        object.value = this.toString();
        object.sidArray = [];
        for(let i129 = 0; i129 < this.value.length; i129++)object.sidArray.push(this.value[i129].toJSON());
        return object;
    }
}
class RelativeObjectIdentifier extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalRelativeObjectIdentifierValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 13;
    }
    static blockName() {
        return "RelativeObjectIdentifier";
    }
}
class LocalBmpStringValueBlock extends HexBlock(LocalBaseBlock) {
    constructor(parameters = {}){
        super(parameters);
        this.isHexOnly = true;
        this.value = "";
    }
    static blockName() {
        return "BmpStringValueBlock";
    }
    toJSON() {
        let object = {};
        try {
            object = super.toJSON();
        } catch (ex) {}
        object.value = this.value;
        return object;
    }
}
class BmpString extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalBmpStringValueBlock);
        if ("value" in parameters) this.fromString(parameters.value);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 30;
    }
    static blockName() {
        return "BMPString";
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
            this.error = this.valueBlock.error;
            return resultOffset;
        }
        this.fromBuffer(this.valueBlock.valueHex);
        if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;
        if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;
        if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
    }
    fromBuffer(inputBuffer) {
        const copyBuffer = inputBuffer.slice(0);
        const valueView = new Uint8Array(copyBuffer);
        for(let i130 = 0; i130 < valueView.length; i130 += 2){
            const temp = valueView[i130];
            valueView[i130] = valueView[i130 + 1];
            valueView[i130 + 1] = temp;
        }
        this.valueBlock.value = String.fromCharCode.apply(null, new Uint16Array(copyBuffer));
    }
    fromString(inputString) {
        const strLength = inputString.length;
        this.valueBlock.valueHex = new ArrayBuffer(strLength * 2);
        const valueHexView = new Uint8Array(this.valueBlock.valueHex);
        for(let i131 = 0; i131 < strLength; i131++){
            const codeBuf = utilToBase(inputString.charCodeAt(i131), 8);
            const codeView = new Uint8Array(codeBuf);
            if (codeView.length > 2) continue;
            const dif = 2 - codeView.length;
            for(let j = codeView.length - 1; j >= 0; j--)valueHexView[i131 * 2 + j + dif] = codeView[j];
        }
        this.valueBlock.value = inputString;
    }
    toString() {
        return `${this.constructor.blockName()} : ${this.valueBlock.value}`;
    }
}
class LocalUniversalStringValueBlock extends HexBlock(LocalBaseBlock) {
    constructor(parameters = {}){
        super(parameters);
        this.isHexOnly = true;
        this.value = "";
    }
    static blockName() {
        return "UniversalStringValueBlock";
    }
    toJSON() {
        let object = {};
        try {
            object = super.toJSON();
        } catch (ex) {}
        object.value = this.value;
        return object;
    }
}
class UniversalString extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalUniversalStringValueBlock);
        if ("value" in parameters) this.fromString(parameters.value);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 28;
    }
    static blockName() {
        return "UniversalString";
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
            this.error = this.valueBlock.error;
            return resultOffset;
        }
        this.fromBuffer(this.valueBlock.valueHex);
        if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;
        if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;
        if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
    }
    fromBuffer(inputBuffer) {
        const copyBuffer = inputBuffer.slice(0);
        const valueView = new Uint8Array(copyBuffer);
        for(let i132 = 0; i132 < valueView.length; i132 += 4){
            valueView[i132] = valueView[i132 + 3];
            valueView[i132 + 1] = valueView[i132 + 2];
            valueView[i132 + 2] = 0x00;
            valueView[i132 + 3] = 0x00;
        }
        this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
    }
    fromString(inputString) {
        const strLength = inputString.length;
        this.valueBlock.valueHex = new ArrayBuffer(strLength * 4);
        const valueHexView = new Uint8Array(this.valueBlock.valueHex);
        for(let i133 = 0; i133 < strLength; i133++){
            const codeBuf = utilToBase(inputString.charCodeAt(i133), 8);
            const codeView = new Uint8Array(codeBuf);
            if (codeView.length > 4) continue;
            const dif = 4 - codeView.length;
            for(let j = codeView.length - 1; j >= 0; j--)valueHexView[i133 * 4 + j + dif] = codeView[j];
        }
        this.valueBlock.value = inputString;
    }
    toString() {
        return `${this.constructor.blockName()} : ${this.valueBlock.value}`;
    }
}
class LocalSimpleStringValueBlock extends HexBlock(LocalBaseBlock) {
    constructor(parameters = {}){
        super(parameters);
        this.value = "";
        this.isHexOnly = true;
    }
    static blockName() {
        return "SimpleStringValueBlock";
    }
    toJSON() {
        let object = {};
        try {
            object = super.toJSON();
        } catch (ex) {}
        object.value = this.value;
        return object;
    }
}
class LocalSimpleStringBlock extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalSimpleStringValueBlock);
        if ("value" in parameters) this.fromString(parameters.value);
    }
    static blockName() {
        return "SIMPLESTRING";
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
            this.error = this.valueBlock.error;
            return resultOffset;
        }
        this.fromBuffer(this.valueBlock.valueHex);
        if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;
        if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;
        if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
    }
    fromBuffer(inputBuffer) {
        this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));
    }
    fromString(inputString) {
        const strLen = inputString.length;
        this.valueBlock.valueHex = new ArrayBuffer(strLen);
        const view = new Uint8Array(this.valueBlock.valueHex);
        for(let i134 = 0; i134 < strLen; i134++)view[i134] = inputString.charCodeAt(i134);
        this.valueBlock.value = inputString;
    }
    toString() {
        return `${this.constructor.blockName()} : ${this.valueBlock.value}`;
    }
}
class NumericString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 18;
    }
    static blockName() {
        return "NumericString";
    }
}
class PrintableString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 19;
    }
    static blockName() {
        return "PrintableString";
    }
}
class TeletexString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 20;
    }
    static blockName() {
        return "TeletexString";
    }
}
class VideotexString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 21;
    }
    static blockName() {
        return "VideotexString";
    }
}
class IA5String extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 22;
    }
    static blockName() {
        return "IA5String";
    }
}
class GraphicString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 25;
    }
    static blockName() {
        return "GraphicString";
    }
}
class VisibleString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 26;
    }
    static blockName() {
        return "VisibleString";
    }
}
class GeneralString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 27;
    }
    static blockName() {
        return "GeneralString";
    }
}
class CharacterString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 29;
    }
    static blockName() {
        return "CharacterString";
    }
}
class UTCTime extends VisibleString {
    constructor(parameters = {}){
        super(parameters);
        this.year = 0;
        this.month = 0;
        this.day = 0;
        this.hour = 0;
        this.minute = 0;
        this.second = 0;
        if ("value" in parameters) {
            this.fromString(parameters.value);
            this.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);
            const view = new Uint8Array(this.valueBlock.valueHex);
            for(let i135 = 0; i135 < parameters.value.length; i135++)view[i135] = parameters.value.charCodeAt(i135);
        }
        if ("valueDate" in parameters) {
            this.fromDate(parameters.valueDate);
            this.valueBlock.valueHex = this.toBuffer();
        }
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 23;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
            this.error = this.valueBlock.error;
            return resultOffset;
        }
        this.fromBuffer(this.valueBlock.valueHex);
        if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;
        if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;
        if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
    }
    fromBuffer(inputBuffer) {
        this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));
    }
    toBuffer() {
        const str = this.toString();
        const buffer = new ArrayBuffer(str.length);
        const view = new Uint8Array(buffer);
        for(let i136 = 0; i136 < str.length; i136++)view[i136] = str.charCodeAt(i136);
        return buffer;
    }
    fromDate(inputDate) {
        this.year = inputDate.getUTCFullYear();
        this.month = inputDate.getUTCMonth() + 1;
        this.day = inputDate.getUTCDate();
        this.hour = inputDate.getUTCHours();
        this.minute = inputDate.getUTCMinutes();
        this.second = inputDate.getUTCSeconds();
    }
    toDate() {
        return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
    }
    fromString(inputString) {
        const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
        const parserArray = parser.exec(inputString);
        if (parserArray === null) {
            this.error = "Wrong input string for convertion";
            return;
        }
        const year1 = parseInt(parserArray[1], 10);
        if (year1 >= 50) this.year = 1900 + year1;
        else this.year = 2000 + year1;
        this.month = parseInt(parserArray[2], 10);
        this.day = parseInt(parserArray[3], 10);
        this.hour = parseInt(parserArray[4], 10);
        this.minute = parseInt(parserArray[5], 10);
        this.second = parseInt(parserArray[6], 10);
    }
    toString() {
        const outputArray = new Array(7);
        outputArray[0] = padNumber(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);
        outputArray[1] = padNumber(this.month, 2);
        outputArray[2] = padNumber(this.day, 2);
        outputArray[3] = padNumber(this.hour, 2);
        outputArray[4] = padNumber(this.minute, 2);
        outputArray[5] = padNumber(this.second, 2);
        outputArray[6] = "Z";
        return outputArray.join("");
    }
    static blockName() {
        return "UTCTime";
    }
    toJSON() {
        let object = {};
        try {
            object = super.toJSON();
        } catch (ex) {}
        object.year = this.year;
        object.month = this.month;
        object.day = this.day;
        object.hour = this.hour;
        object.minute = this.minute;
        object.second = this.second;
        return object;
    }
}
class GeneralizedTime extends VisibleString {
    constructor(parameters = {}){
        super(parameters);
        this.year = 0;
        this.month = 0;
        this.day = 0;
        this.hour = 0;
        this.minute = 0;
        this.second = 0;
        this.millisecond = 0;
        if ("value" in parameters) {
            this.fromString(parameters.value);
            this.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);
            const view = new Uint8Array(this.valueBlock.valueHex);
            for(let i137 = 0; i137 < parameters.value.length; i137++)view[i137] = parameters.value.charCodeAt(i137);
        }
        if ("valueDate" in parameters) {
            this.fromDate(parameters.valueDate);
            this.valueBlock.valueHex = this.toBuffer();
        }
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 24;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
            this.error = this.valueBlock.error;
            return resultOffset;
        }
        this.fromBuffer(this.valueBlock.valueHex);
        if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;
        if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;
        if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
    }
    fromBuffer(inputBuffer) {
        this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));
    }
    toBuffer() {
        const str = this.toString();
        const buffer = new ArrayBuffer(str.length);
        const view = new Uint8Array(buffer);
        for(let i138 = 0; i138 < str.length; i138++)view[i138] = str.charCodeAt(i138);
        return buffer;
    }
    fromDate(inputDate) {
        this.year = inputDate.getUTCFullYear();
        this.month = inputDate.getUTCMonth() + 1;
        this.day = inputDate.getUTCDate();
        this.hour = inputDate.getUTCHours();
        this.minute = inputDate.getUTCMinutes();
        this.second = inputDate.getUTCSeconds();
        this.millisecond = inputDate.getUTCMilliseconds();
    }
    toDate() {
        return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));
    }
    fromString(inputString) {
        let isUTC = false;
        let timeString = "";
        let dateTimeString = "";
        let fractionPart = 0;
        let parser;
        let hourDifference = 0;
        let minuteDifference = 0;
        if (inputString[inputString.length - 1] === "Z") {
            timeString = inputString.substr(0, inputString.length - 1);
            isUTC = true;
        } else {
            const number = new Number(inputString[inputString.length - 1]);
            if (isNaN(number.valueOf())) throw new Error("Wrong input string for convertion");
            timeString = inputString;
        }
        if (isUTC) {
            if (timeString.indexOf("+") !== -1) throw new Error("Wrong input string for convertion");
            if (timeString.indexOf("-") !== -1) throw new Error("Wrong input string for convertion");
        } else {
            let multiplier = 1;
            let differencePosition = timeString.indexOf("+");
            let differenceString = "";
            if (differencePosition === -1) {
                differencePosition = timeString.indexOf("-");
                multiplier = -1;
            }
            if (differencePosition !== -1) {
                differenceString = timeString.substr(differencePosition + 1);
                timeString = timeString.substr(0, differencePosition);
                if (differenceString.length !== 2 && differenceString.length !== 4) throw new Error("Wrong input string for convertion");
                let number = new Number(differenceString.substr(0, 2));
                if (isNaN(number.valueOf())) throw new Error("Wrong input string for convertion");
                hourDifference = multiplier * number;
                if (differenceString.length === 4) {
                    number = new Number(differenceString.substr(2, 2));
                    if (isNaN(number.valueOf())) throw new Error("Wrong input string for convertion");
                    minuteDifference = multiplier * number;
                }
            }
        }
        let fractionPointPosition = timeString.indexOf(".");
        if (fractionPointPosition === -1) fractionPointPosition = timeString.indexOf(",");
        if (fractionPointPosition !== -1) {
            const fractionPartCheck = new Number(`0${timeString.substr(fractionPointPosition)}`);
            if (isNaN(fractionPartCheck.valueOf())) throw new Error("Wrong input string for convertion");
            fractionPart = fractionPartCheck.valueOf();
            dateTimeString = timeString.substr(0, fractionPointPosition);
        } else dateTimeString = timeString;
        switch(true){
            case dateTimeString.length === 8:
                parser = /(\d{4})(\d{2})(\d{2})/ig;
                if (fractionPointPosition !== -1) throw new Error("Wrong input string for convertion");
                break;
            case dateTimeString.length === 10:
                parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
                if (fractionPointPosition !== -1) {
                    let fractionResult = 60 * fractionPart;
                    this.minute = Math.floor(fractionResult);
                    fractionResult = 60 * (fractionResult - this.minute);
                    this.second = Math.floor(fractionResult);
                    fractionResult = 1000 * (fractionResult - this.second);
                    this.millisecond = Math.floor(fractionResult);
                }
                break;
            case dateTimeString.length === 12:
                parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
                if (fractionPointPosition !== -1) {
                    let fractionResult = 60 * fractionPart;
                    this.second = Math.floor(fractionResult);
                    fractionResult = 1000 * (fractionResult - this.second);
                    this.millisecond = Math.floor(fractionResult);
                }
                break;
            case dateTimeString.length === 14:
                parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
                if (fractionPointPosition !== -1) {
                    const fractionResult = 1000 * fractionPart;
                    this.millisecond = Math.floor(fractionResult);
                }
                break;
            default:
                throw new Error("Wrong input string for convertion");
        }
        const parserArray = parser.exec(dateTimeString);
        if (parserArray === null) throw new Error("Wrong input string for convertion");
        for(let j = 1; j < parserArray.length; j++){
            switch(j){
                case 1:
                    this.year = parseInt(parserArray[j], 10);
                    break;
                case 2:
                    this.month = parseInt(parserArray[j], 10);
                    break;
                case 3:
                    this.day = parseInt(parserArray[j], 10);
                    break;
                case 4:
                    this.hour = parseInt(parserArray[j], 10) + hourDifference;
                    break;
                case 5:
                    this.minute = parseInt(parserArray[j], 10) + minuteDifference;
                    break;
                case 6:
                    this.second = parseInt(parserArray[j], 10);
                    break;
                default:
                    throw new Error("Wrong input string for convertion");
            }
        }
        if (isUTC === false) {
            const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
            this.year = tempDate.getUTCFullYear();
            this.month = tempDate.getUTCMonth();
            this.day = tempDate.getUTCDay();
            this.hour = tempDate.getUTCHours();
            this.minute = tempDate.getUTCMinutes();
            this.second = tempDate.getUTCSeconds();
            this.millisecond = tempDate.getUTCMilliseconds();
        }
    }
    toString() {
        const outputArray = [];
        outputArray.push(padNumber(this.year, 4));
        outputArray.push(padNumber(this.month, 2));
        outputArray.push(padNumber(this.day, 2));
        outputArray.push(padNumber(this.hour, 2));
        outputArray.push(padNumber(this.minute, 2));
        outputArray.push(padNumber(this.second, 2));
        if (this.millisecond !== 0) {
            outputArray.push(".");
            outputArray.push(padNumber(this.millisecond, 3));
        }
        outputArray.push("Z");
        return outputArray.join("");
    }
    static blockName() {
        return "GeneralizedTime";
    }
    toJSON() {
        let object = {};
        try {
            object = super.toJSON();
        } catch (ex) {}
        object.year = this.year;
        object.month = this.month;
        object.day = this.day;
        object.hour = this.hour;
        object.minute = this.minute;
        object.second = this.second;
        object.millisecond = this.millisecond;
        return object;
    }
}
class DATE extends Utf8String {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 31;
    }
    static blockName() {
        return "DATE";
    }
}
class TimeOfDay extends Utf8String {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 32;
    }
    static blockName() {
        return "TimeOfDay";
    }
}
class DateTime extends Utf8String {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 33;
    }
    static blockName() {
        return "DateTime";
    }
}
class Duration extends Utf8String {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 34;
    }
    static blockName() {
        return "Duration";
    }
}
class TIME extends Utf8String {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 14;
    }
    static blockName() {
        return "TIME";
    }
}
class Choice {
    constructor(parameters = {}){
        this.value = getParametersValue(parameters, "value", []);
        this.optional = getParametersValue(parameters, "optional", false);
    }
}
class Any {
    constructor(parameters = {}){
        this.name = getParametersValue(parameters, "name", "");
        this.optional = getParametersValue(parameters, "optional", false);
    }
}
class Repeated {
    constructor(parameters = {}){
        this.name = getParametersValue(parameters, "name", "");
        this.optional = getParametersValue(parameters, "optional", false);
        this.value = getParametersValue(parameters, "value", new Any());
        this.local = getParametersValue(parameters, "local", false);
    }
}
class RawData {
    constructor(parameters = {}){
        this.data = getParametersValue(parameters, "data", new ArrayBuffer(0));
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        this.data = inputBuffer.slice(inputOffset, inputLength);
        return inputOffset + inputLength;
    }
    toBER(sizeOnly = false) {
        return this.data;
    }
}
function LocalFromBER(inputBuffer, inputOffset, inputLength) {
    const incomingOffset = inputOffset;
    function localChangeType(inputObject, newType) {
        if (inputObject instanceof newType) return inputObject;
        const newObject = new newType();
        newObject.idBlock = inputObject.idBlock;
        newObject.lenBlock = inputObject.lenBlock;
        newObject.warnings = inputObject.warnings;
        newObject.valueBeforeDecode = inputObject.valueBeforeDecode.slice(0);
        return newObject;
    }
    let returnObject = new BaseBlock({}, Object);
    const baseBlock = new LocalBaseBlock();
    if (checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) === false) {
        returnObject.error = baseBlock.error;
        return {
            offset: -1,
            result: returnObject
        };
    }
    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
    if (intBuffer.length === 0) {
        returnObject.error = "Zero buffer length";
        return {
            offset: -1,
            result: returnObject
        };
    }
    let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
    returnObject.warnings.concat(returnObject.idBlock.warnings);
    if (resultOffset === -1) {
        returnObject.error = returnObject.idBlock.error;
        return {
            offset: -1,
            result: returnObject
        };
    }
    inputOffset = resultOffset;
    inputLength -= returnObject.idBlock.blockLength;
    resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
    returnObject.warnings.concat(returnObject.lenBlock.warnings);
    if (resultOffset === -1) {
        returnObject.error = returnObject.lenBlock.error;
        return {
            offset: -1,
            result: returnObject
        };
    }
    inputOffset = resultOffset;
    inputLength -= returnObject.lenBlock.blockLength;
    if (returnObject.idBlock.isConstructed === false && returnObject.lenBlock.isIndefiniteForm === true) {
        returnObject.error = "Indefinite length form used for primitive encoding form";
        return {
            offset: -1,
            result: returnObject
        };
    }
    let newASN1Type = BaseBlock;
    switch(returnObject.idBlock.tagClass){
        case 1:
            if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
                returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
                return {
                    offset: -1,
                    result: returnObject
                };
            }
            switch(returnObject.idBlock.tagNumber){
                case 0:
                    if (returnObject.idBlock.isConstructed === true && returnObject.lenBlock.length > 0) {
                        returnObject.error = "Type [UNIVERSAL 0] is reserved";
                        return {
                            offset: -1,
                            result: returnObject
                        };
                    }
                    newASN1Type = EndOfContent;
                    break;
                case 1:
                    newASN1Type = Boolean1;
                    break;
                case 2:
                    newASN1Type = Integer;
                    break;
                case 3:
                    newASN1Type = BitString;
                    break;
                case 4:
                    newASN1Type = OctetString;
                    break;
                case 5:
                    newASN1Type = Null;
                    break;
                case 6:
                    newASN1Type = ObjectIdentifier;
                    break;
                case 10:
                    newASN1Type = Enumerated;
                    break;
                case 12:
                    newASN1Type = Utf8String;
                    break;
                case 13:
                    newASN1Type = RelativeObjectIdentifier;
                    break;
                case 14:
                    newASN1Type = TIME;
                    break;
                case 15:
                    returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
                    return {
                        offset: -1,
                        result: returnObject
                    };
                case 16:
                    newASN1Type = Sequence;
                    break;
                case 17:
                    newASN1Type = Set1;
                    break;
                case 18:
                    newASN1Type = NumericString;
                    break;
                case 19:
                    newASN1Type = PrintableString;
                    break;
                case 20:
                    newASN1Type = TeletexString;
                    break;
                case 21:
                    newASN1Type = VideotexString;
                    break;
                case 22:
                    newASN1Type = IA5String;
                    break;
                case 23:
                    newASN1Type = UTCTime;
                    break;
                case 24:
                    newASN1Type = GeneralizedTime;
                    break;
                case 25:
                    newASN1Type = GraphicString;
                    break;
                case 26:
                    newASN1Type = VisibleString;
                    break;
                case 27:
                    newASN1Type = GeneralString;
                    break;
                case 28:
                    newASN1Type = UniversalString;
                    break;
                case 29:
                    newASN1Type = CharacterString;
                    break;
                case 30:
                    newASN1Type = BmpString;
                    break;
                case 31:
                    newASN1Type = DATE;
                    break;
                case 32:
                    newASN1Type = TimeOfDay;
                    break;
                case 33:
                    newASN1Type = DateTime;
                    break;
                case 34:
                    newASN1Type = Duration;
                    break;
                default:
                    {
                        let newObject;
                        if (returnObject.idBlock.isConstructed === true) newObject = new Constructed();
                        else newObject = new Primitive();
                        newObject.idBlock = returnObject.idBlock;
                        newObject.lenBlock = returnObject.lenBlock;
                        newObject.warnings = returnObject.warnings;
                        returnObject = newObject;
                    }
            }
            break;
        case 2:
        case 3:
        case 4:
        default:
            {
                if (returnObject.idBlock.isConstructed === true) newASN1Type = Constructed;
                else newASN1Type = Primitive;
            }
    }
    returnObject = localChangeType(returnObject, newASN1Type);
    resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm === true ? inputLength : returnObject.lenBlock.length);
    returnObject.valueBeforeDecode = inputBuffer.slice(incomingOffset, incomingOffset + returnObject.blockLength);
    return {
        offset: resultOffset,
        result: returnObject
    };
}
function fromBER(inputBuffer) {
    if (inputBuffer.byteLength === 0) {
        const result = new BaseBlock({}, Object);
        result.error = "Input buffer has zero length";
        return {
            offset: -1,
            result
        };
    }
    return LocalFromBER(inputBuffer, 0, inputBuffer.byteLength);
}
function compareSchema(root, inputData, inputSchema) {
    if (inputSchema instanceof Choice) {
        for(let j = 0; j < inputSchema.value.length; j++){
            const result = compareSchema(root, inputData, inputSchema.value[j]);
            if (result.verified === true) {
                return {
                    verified: true,
                    result: root
                };
            }
        }
        if (false === false) {
            const _result = {
                verified: false,
                result: {
                    error: "Wrong values for Choice type"
                }
            };
            if (inputSchema.hasOwnProperty("name")) _result.name = inputSchema.name;
            return _result;
        }
    }
    if (inputSchema instanceof Any) {
        if (inputSchema.hasOwnProperty("name")) root[inputSchema.name] = inputData;
        return {
            verified: true,
            result: root
        };
    }
    if (root instanceof Object === false) {
        return {
            verified: false,
            result: {
                error: "Wrong root object"
            }
        };
    }
    if (inputData instanceof Object === false) {
        return {
            verified: false,
            result: {
                error: "Wrong ASN.1 data"
            }
        };
    }
    if (inputSchema instanceof Object === false) {
        return {
            verified: false,
            result: {
                error: "Wrong ASN.1 schema"
            }
        };
    }
    if ("idBlock" in inputSchema === false) {
        return {
            verified: false,
            result: {
                error: "Wrong ASN.1 schema"
            }
        };
    }
    if ("fromBER" in inputSchema.idBlock === false) {
        return {
            verified: false,
            result: {
                error: "Wrong ASN.1 schema"
            }
        };
    }
    if ("toBER" in inputSchema.idBlock === false) {
        return {
            verified: false,
            result: {
                error: "Wrong ASN.1 schema"
            }
        };
    }
    const encodedId = inputSchema.idBlock.toBER(false);
    if (encodedId.byteLength === 0) {
        return {
            verified: false,
            result: {
                error: "Error encoding idBlock for ASN.1 schema"
            }
        };
    }
    const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
    if (decodedOffset === -1) {
        return {
            verified: false,
            result: {
                error: "Error decoding idBlock for ASN.1 schema"
            }
        };
    }
    if (inputSchema.idBlock.hasOwnProperty("tagClass") === false) {
        return {
            verified: false,
            result: {
                error: "Wrong ASN.1 schema"
            }
        };
    }
    if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {
        return {
            verified: false,
            result: root
        };
    }
    if (inputSchema.idBlock.hasOwnProperty("tagNumber") === false) {
        return {
            verified: false,
            result: {
                error: "Wrong ASN.1 schema"
            }
        };
    }
    if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {
        return {
            verified: false,
            result: root
        };
    }
    if (inputSchema.idBlock.hasOwnProperty("isConstructed") === false) {
        return {
            verified: false,
            result: {
                error: "Wrong ASN.1 schema"
            }
        };
    }
    if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {
        return {
            verified: false,
            result: root
        };
    }
    if ("isHexOnly" in inputSchema.idBlock === false) {
        return {
            verified: false,
            result: {
                error: "Wrong ASN.1 schema"
            }
        };
    }
    if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {
        return {
            verified: false,
            result: root
        };
    }
    if (inputSchema.idBlock.isHexOnly === true) {
        if ("valueHex" in inputSchema.idBlock === false) {
            return {
                verified: false,
                result: {
                    error: "Wrong ASN.1 schema"
                }
            };
        }
        const schemaView = new Uint8Array(inputSchema.idBlock.valueHex);
        const asn1View = new Uint8Array(inputData.idBlock.valueHex);
        if (schemaView.length !== asn1View.length) {
            return {
                verified: false,
                result: root
            };
        }
        for(let i139 = 0; i139 < schemaView.length; i139++){
            if (schemaView[i139] !== asn1View[1]) {
                return {
                    verified: false,
                    result: root
                };
            }
        }
    }
    if (inputSchema.hasOwnProperty("name")) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
        if (inputSchema.name !== "") root[inputSchema.name] = inputData;
    }
    if (inputSchema.idBlock.isConstructed === true) {
        let admission = 0;
        let result = {
            verified: false
        };
        let maxLength = inputSchema.valueBlock.value.length;
        if (maxLength > 0) {
            if (inputSchema.valueBlock.value[0] instanceof Repeated) maxLength = inputData.valueBlock.value.length;
        }
        if (maxLength === 0) {
            return {
                verified: true,
                result: root
            };
        }
        if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {
            let _optional = true;
            for(let i140 = 0; i140 < inputSchema.valueBlock.value.length; i140++)_optional = _optional && (inputSchema.valueBlock.value[i140].optional || false);
            if (_optional === true) {
                return {
                    verified: true,
                    result: root
                };
            }
            if (inputSchema.hasOwnProperty("name")) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
                if (inputSchema.name !== "") delete root[inputSchema.name];
            }
            root.error = "Inconsistent object length";
            return {
                verified: false,
                result: root
            };
        }
        for(let i141 = 0; i141 < maxLength; i141++){
            if (i141 - admission >= inputData.valueBlock.value.length) {
                if (inputSchema.valueBlock.value[i141].optional === false) {
                    const _result = {
                        verified: false,
                        result: root
                    };
                    root.error = "Inconsistent length between ASN.1 data and schema";
                    if (inputSchema.hasOwnProperty("name")) {
                        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
                        if (inputSchema.name !== "") {
                            delete root[inputSchema.name];
                            _result.name = inputSchema.name;
                        }
                    }
                    return _result;
                }
            } else {
                if (inputSchema.valueBlock.value[0] instanceof Repeated) {
                    result = compareSchema(root, inputData.valueBlock.value[i141], inputSchema.valueBlock.value[0].value);
                    if (result.verified === false) {
                        if (inputSchema.valueBlock.value[0].optional === true) admission++;
                        else {
                            if (inputSchema.hasOwnProperty("name")) {
                                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
                                if (inputSchema.name !== "") delete root[inputSchema.name];
                            }
                            return result;
                        }
                    }
                    if ("name" in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {
                        let arrayRoot = {};
                        if ("local" in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local === true) arrayRoot = inputData;
                        else arrayRoot = root;
                        if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined") arrayRoot[inputSchema.valueBlock.value[0].name] = [];
                        arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i141]);
                    }
                } else {
                    result = compareSchema(root, inputData.valueBlock.value[i141 - admission], inputSchema.valueBlock.value[i141]);
                    if (result.verified === false) {
                        if (inputSchema.valueBlock.value[i141].optional === true) admission++;
                        else {
                            if (inputSchema.hasOwnProperty("name")) {
                                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
                                if (inputSchema.name !== "") delete root[inputSchema.name];
                            }
                            return result;
                        }
                    }
                }
            }
        }
        if (result.verified === false) {
            const _result = {
                verified: false,
                result: root
            };
            if (inputSchema.hasOwnProperty("name")) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
                if (inputSchema.name !== "") {
                    delete root[inputSchema.name];
                    _result.name = inputSchema.name;
                }
            }
            return _result;
        }
        return {
            verified: true,
            result: root
        };
    }
    if ("primitiveSchema" in inputSchema && "valueHex" in inputData.valueBlock) {
        const asn1 = fromBER(inputData.valueBlock.valueHex);
        if (asn1.offset === -1) {
            const _result = {
                verified: false,
                result: asn1.result
            };
            if (inputSchema.hasOwnProperty("name")) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
                if (inputSchema.name !== "") {
                    delete root[inputSchema.name];
                    _result.name = inputSchema.name;
                }
            }
            return _result;
        }
        return compareSchema(root, asn1.result, inputSchema.primitiveSchema);
    }
    return {
        verified: true,
        result: root
    };
}
class AlgorithmIdentifier {
    constructor(parameters = {}){
        this.algorithmId = getParametersValue(parameters, "algorithmId", AlgorithmIdentifier.defaultValues("algorithmId"));
        if ("algorithmParams" in parameters) this.algorithmParams = getParametersValue(parameters, "algorithmParams", AlgorithmIdentifier.defaultValues("algorithmParams"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "algorithmId":
                return "";
            case "algorithmParams":
                return new Any();
            default:
                throw new Error(`Invalid member name for AlgorithmIdentifier class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "algorithmId":
                return memberValue === "";
            case "algorithmParams":
                return memberValue instanceof Any;
            default:
                throw new Error(`Invalid member name for AlgorithmIdentifier class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            optional: names.optional || false,
            value: [
                new ObjectIdentifier({
                    name: names.algorithmIdentifier || ""
                }),
                new Any({
                    name: names.algorithmParams || "",
                    optional: true
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "algorithm",
            "params"
        ]);
        const asn1 = compareSchema(schema, schema, AlgorithmIdentifier.schema({
            names: {
                algorithmIdentifier: "algorithm",
                algorithmParams: "params"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for AlgorithmIdentifier");
        this.algorithmId = asn1.result.algorithm.valueBlock.toString();
        if ("params" in asn1.result) this.algorithmParams = asn1.result.params;
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(new ObjectIdentifier({
            value: this.algorithmId
        }));
        if ("algorithmParams" in this && this.algorithmParams instanceof Any === false) outputArray.push(this.algorithmParams);
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const object = {
            algorithmId: this.algorithmId
        };
        if ("algorithmParams" in this && this.algorithmParams instanceof Any === false) object.algorithmParams = this.algorithmParams.toJSON();
        return object;
    }
    isEqual(algorithmIdentifier) {
        if (algorithmIdentifier instanceof AlgorithmIdentifier === false) return false;
        if (this.algorithmId !== algorithmIdentifier.algorithmId) return false;
        if ("algorithmParams" in this) {
            if ("algorithmParams" in algorithmIdentifier) return JSON.stringify(this.algorithmParams) === JSON.stringify(algorithmIdentifier.algorithmParams);
            return false;
        }
        if ("algorithmParams" in algorithmIdentifier) return false;
        return true;
    }
}
class ECPublicKey {
    constructor(parameters = {}){
        this.x = getParametersValue(parameters, "x", ECPublicKey.defaultValues("x"));
        this.y = getParametersValue(parameters, "y", ECPublicKey.defaultValues("y"));
        this.namedCurve = getParametersValue(parameters, "namedCurve", ECPublicKey.defaultValues("namedCurve"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
        if ("json" in parameters) this.fromJSON(parameters.json);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "x":
            case "y":
                return new ArrayBuffer(0);
            case "namedCurve":
                return "";
            default:
                throw new Error(`Invalid member name for ECCPublicKey class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "x":
            case "y":
                return isEqualBuffer(memberValue, ECPublicKey.defaultValues(memberName));
            case "namedCurve":
                return memberValue === "";
            default:
                throw new Error(`Invalid member name for ECCPublicKey class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        return new RawData();
    }
    fromSchema(schema) {
        if (schema instanceof ArrayBuffer === false) throw new Error("Object's schema was not verified against input data for ECPublicKey");
        const view = new Uint8Array(schema);
        if (view[0] !== 0x04) throw new Error("Object's schema was not verified against input data for ECPublicKey");
        let coordinateLength;
        switch(this.namedCurve){
            case "1.2.840.10045.3.1.7":
                coordinateLength = 32;
                break;
            case "1.3.132.0.34":
                coordinateLength = 48;
                break;
            case "1.3.132.0.35":
                coordinateLength = 66;
                break;
            default:
                throw new Error(`Incorrect curve OID: ${this.namedCurve}`);
        }
        if (schema.byteLength !== coordinateLength * 2 + 1) throw new Error("Object's schema was not verified against input data for ECPublicKey");
        this.x = schema.slice(1, coordinateLength + 1);
        this.y = schema.slice(1 + coordinateLength, coordinateLength * 2 + 1);
    }
    toSchema() {
        return new RawData({
            data: utilConcatBuf(new Uint8Array([
                0x04
            ]).buffer, this.x, this.y)
        });
    }
    toJSON() {
        let crvName = "";
        switch(this.namedCurve){
            case "1.2.840.10045.3.1.7":
                crvName = "P-256";
                break;
            case "1.3.132.0.34":
                crvName = "P-384";
                break;
            case "1.3.132.0.35":
                crvName = "P-521";
                break;
            default:
        }
        return {
            crv: crvName,
            x: toBase64(arrayBufferToString(this.x), true, true, false),
            y: toBase64(arrayBufferToString(this.y), true, true, false)
        };
    }
    fromJSON(json) {
        let coodinateLength = 0;
        if ("crv" in json) {
            switch(json.crv.toUpperCase()){
                case "P-256":
                    this.namedCurve = "1.2.840.10045.3.1.7";
                    coodinateLength = 32;
                    break;
                case "P-384":
                    this.namedCurve = "1.3.132.0.34";
                    coodinateLength = 48;
                    break;
                case "P-521":
                    this.namedCurve = "1.3.132.0.35";
                    coodinateLength = 66;
                    break;
                default:
            }
        } else throw new Error("Absent mandatory parameter \"crv\"");
        if ("x" in json) {
            const convertBuffer = stringToArrayBuffer(fromBase64(json.x, true));
            if (convertBuffer.byteLength < coodinateLength) {
                this.x = new ArrayBuffer(coodinateLength);
                const view = new Uint8Array(this.x);
                const convertBufferView = new Uint8Array(convertBuffer);
                view.set(convertBufferView, 1);
            } else this.x = convertBuffer.slice(0, coodinateLength);
        } else throw new Error("Absent mandatory parameter \"x\"");
        if ("y" in json) {
            const convertBuffer = stringToArrayBuffer(fromBase64(json.y, true));
            if (convertBuffer.byteLength < coodinateLength) {
                this.y = new ArrayBuffer(coodinateLength);
                const view = new Uint8Array(this.y);
                const convertBufferView = new Uint8Array(convertBuffer);
                view.set(convertBufferView, 1);
            } else this.y = convertBuffer.slice(0, coodinateLength);
        } else throw new Error("Absent mandatory parameter \"y\"");
    }
}
class RSAPublicKey {
    constructor(parameters = {}){
        this.modulus = getParametersValue(parameters, "modulus", RSAPublicKey.defaultValues("modulus"));
        this.publicExponent = getParametersValue(parameters, "publicExponent", RSAPublicKey.defaultValues("publicExponent"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
        if ("json" in parameters) this.fromJSON(parameters.json);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "modulus":
                return new Integer();
            case "publicExponent":
                return new Integer();
            default:
                throw new Error(`Invalid member name for RSAPublicKey class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Integer({
                    name: names.modulus || ""
                }),
                new Integer({
                    name: names.publicExponent || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "modulus",
            "publicExponent"
        ]);
        const asn1 = compareSchema(schema, schema, RSAPublicKey.schema({
            names: {
                modulus: "modulus",
                publicExponent: "publicExponent"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for RSAPublicKey");
        this.modulus = asn1.result.modulus.convertFromDER(256);
        this.publicExponent = asn1.result.publicExponent;
    }
    toSchema() {
        return new Sequence({
            value: [
                this.modulus.convertToDER(),
                this.publicExponent
            ]
        });
    }
    toJSON() {
        return {
            n: toBase64(arrayBufferToString(this.modulus.valueBlock.valueHex), true, true, true),
            e: toBase64(arrayBufferToString(this.publicExponent.valueBlock.valueHex), true, true, true)
        };
    }
    fromJSON(json) {
        if ("n" in json) {
            const array = stringToArrayBuffer(fromBase64(json.n, true));
            this.modulus = new Integer({
                valueHex: array.slice(0, Math.pow(2, nearestPowerOf2(array.byteLength)))
            });
        } else throw new Error("Absent mandatory parameter \"n\"");
        if ("e" in json) this.publicExponent = new Integer({
            valueHex: stringToArrayBuffer(fromBase64(json.e, true)).slice(0, 3)
        });
        else throw new Error("Absent mandatory parameter \"e\"");
    }
}
class Attribute {
    constructor(parameters = {}){
        this.type = getParametersValue(parameters, "type", Attribute.defaultValues("type"));
        this.values = getParametersValue(parameters, "values", Attribute.defaultValues("values"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "type":
                return "";
            case "values":
                return [];
            default:
                throw new Error(`Invalid member name for Attribute class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "type":
                return memberValue === "";
            case "values":
                return memberValue.length === 0;
            default:
                throw new Error(`Invalid member name for Attribute class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new ObjectIdentifier({
                    name: names.type || ""
                }),
                new Set1({
                    name: names.setName || "",
                    value: [
                        new Repeated({
                            name: names.values || "",
                            value: new Any()
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "type",
            "values"
        ]);
        const asn1 = compareSchema(schema, schema, Attribute.schema({
            names: {
                type: "type",
                values: "values"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for Attribute");
        this.type = asn1.result.type.valueBlock.toString();
        this.values = asn1.result.values;
    }
    toSchema() {
        return new Sequence({
            value: [
                new ObjectIdentifier({
                    value: this.type
                }),
                new Set1({
                    value: this.values
                })
            ]
        });
    }
    toJSON() {
        return {
            type: this.type,
            values: Array.from(this.values, (element)=>element.toJSON()
            )
        };
    }
}
class ECPrivateKey {
    constructor(parameters = {}){
        this.version = getParametersValue(parameters, "version", ECPrivateKey.defaultValues("version"));
        this.privateKey = getParametersValue(parameters, "privateKey", ECPrivateKey.defaultValues("privateKey"));
        if ("namedCurve" in parameters) this.namedCurve = getParametersValue(parameters, "namedCurve", ECPrivateKey.defaultValues("namedCurve"));
        if ("publicKey" in parameters) this.publicKey = getParametersValue(parameters, "publicKey", ECPrivateKey.defaultValues("publicKey"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
        if ("json" in parameters) this.fromJSON(parameters.json);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "version":
                return 1;
            case "privateKey":
                return new OctetString();
            case "namedCurve":
                return "";
            case "publicKey":
                return new ECPublicKey();
            default:
                throw new Error(`Invalid member name for ECCPrivateKey class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "version":
                return memberValue === ECPrivateKey.defaultValues(memberName);
            case "privateKey":
                return memberValue.isEqual(ECPrivateKey.defaultValues(memberName));
            case "namedCurve":
                return memberValue === "";
            case "publicKey":
                return ECPublicKey.compareWithDefault("namedCurve", memberValue.namedCurve) && ECPublicKey.compareWithDefault("x", memberValue.x) && ECPublicKey.compareWithDefault("y", memberValue.y);
            default:
                throw new Error(`Invalid member name for ECCPrivateKey class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Integer({
                    name: names.version || ""
                }),
                new OctetString({
                    name: names.privateKey || ""
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new ObjectIdentifier({
                            name: names.namedCurve || ""
                        })
                    ]
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: [
                        new BitString({
                            name: names.publicKey || ""
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "version",
            "privateKey",
            "namedCurve",
            "publicKey"
        ]);
        const asn1 = compareSchema(schema, schema, ECPrivateKey.schema({
            names: {
                version: "version",
                privateKey: "privateKey",
                namedCurve: "namedCurve",
                publicKey: "publicKey"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for ECPrivateKey");
        this.version = asn1.result.version.valueBlock.valueDec;
        this.privateKey = asn1.result.privateKey;
        if ("namedCurve" in asn1.result) this.namedCurve = asn1.result.namedCurve.valueBlock.toString();
        if ("publicKey" in asn1.result) {
            const publicKeyData = {
                schema: asn1.result.publicKey.valueBlock.valueHex
            };
            if ("namedCurve" in this) publicKeyData.namedCurve = this.namedCurve;
            this.publicKey = new ECPublicKey(publicKeyData);
        }
    }
    toSchema() {
        const outputArray = [
            new Integer({
                value: this.version
            }),
            this.privateKey
        ];
        if ("namedCurve" in this) {
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: [
                    new ObjectIdentifier({
                        value: this.namedCurve
                    })
                ]
            }));
        }
        if ("publicKey" in this) {
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                },
                value: [
                    new BitString({
                        valueHex: this.publicKey.toSchema().toBER(false)
                    })
                ]
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        if ("namedCurve" in this === false || ECPrivateKey.compareWithDefault("namedCurve", this.namedCurve)) throw new Error("Not enough information for making JSON: absent \"namedCurve\" value");
        let crvName = "";
        switch(this.namedCurve){
            case "1.2.840.10045.3.1.7":
                crvName = "P-256";
                break;
            case "1.3.132.0.34":
                crvName = "P-384";
                break;
            case "1.3.132.0.35":
                crvName = "P-521";
                break;
            default:
        }
        const privateKeyJSON = {
            crv: crvName,
            d: toBase64(arrayBufferToString(this.privateKey.valueBlock.valueHex), true, true, false)
        };
        if ("publicKey" in this) {
            const publicKeyJSON = this.publicKey.toJSON();
            privateKeyJSON.x = publicKeyJSON.x;
            privateKeyJSON.y = publicKeyJSON.y;
        }
        return privateKeyJSON;
    }
    fromJSON(json) {
        let coodinateLength = 0;
        if ("crv" in json) {
            switch(json.crv.toUpperCase()){
                case "P-256":
                    this.namedCurve = "1.2.840.10045.3.1.7";
                    coodinateLength = 32;
                    break;
                case "P-384":
                    this.namedCurve = "1.3.132.0.34";
                    coodinateLength = 48;
                    break;
                case "P-521":
                    this.namedCurve = "1.3.132.0.35";
                    coodinateLength = 66;
                    break;
                default:
            }
        } else throw new Error("Absent mandatory parameter \"crv\"");
        if ("d" in json) {
            const convertBuffer = stringToArrayBuffer(fromBase64(json.d, true));
            if (convertBuffer.byteLength < coodinateLength) {
                const buffer = new ArrayBuffer(coodinateLength);
                const view = new Uint8Array(buffer);
                const convertBufferView = new Uint8Array(convertBuffer);
                view.set(convertBufferView, 1);
                this.privateKey = new OctetString({
                    valueHex: buffer
                });
            } else this.privateKey = new OctetString({
                valueHex: convertBuffer.slice(0, coodinateLength)
            });
        } else throw new Error("Absent mandatory parameter \"d\"");
        if ("x" in json && "y" in json) this.publicKey = new ECPublicKey({
            json
        });
    }
}
class OtherPrimeInfo {
    constructor(parameters = {}){
        this.prime = getParametersValue(parameters, "prime", OtherPrimeInfo.defaultValues("prime"));
        this.exponent = getParametersValue(parameters, "exponent", OtherPrimeInfo.defaultValues("exponent"));
        this.coefficient = getParametersValue(parameters, "coefficient", OtherPrimeInfo.defaultValues("coefficient"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
        if ("json" in parameters) this.fromJSON(parameters.json);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "prime":
                return new Integer();
            case "exponent":
                return new Integer();
            case "coefficient":
                return new Integer();
            default:
                throw new Error(`Invalid member name for OtherPrimeInfo class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Integer({
                    name: names.prime || ""
                }),
                new Integer({
                    name: names.exponent || ""
                }),
                new Integer({
                    name: names.coefficient || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "prime",
            "exponent",
            "coefficient"
        ]);
        const asn1 = compareSchema(schema, schema, OtherPrimeInfo.schema({
            names: {
                prime: "prime",
                exponent: "exponent",
                coefficient: "coefficient"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for OtherPrimeInfo");
        this.prime = asn1.result.prime.convertFromDER();
        this.exponent = asn1.result.exponent.convertFromDER();
        this.coefficient = asn1.result.coefficient.convertFromDER();
    }
    toSchema() {
        return new Sequence({
            value: [
                this.prime.convertToDER(),
                this.exponent.convertToDER(),
                this.coefficient.convertToDER()
            ]
        });
    }
    toJSON() {
        return {
            r: toBase64(arrayBufferToString(this.prime.valueBlock.valueHex), true, true),
            d: toBase64(arrayBufferToString(this.exponent.valueBlock.valueHex), true, true),
            t: toBase64(arrayBufferToString(this.coefficient.valueBlock.valueHex), true, true)
        };
    }
    fromJSON(json) {
        if ("r" in json) this.prime = new Integer({
            valueHex: stringToArrayBuffer(fromBase64(json.r, true))
        });
        else throw new Error("Absent mandatory parameter \"r\"");
        if ("d" in json) this.exponent = new Integer({
            valueHex: stringToArrayBuffer(fromBase64(json.d, true))
        });
        else throw new Error("Absent mandatory parameter \"d\"");
        if ("t" in json) this.coefficient = new Integer({
            valueHex: stringToArrayBuffer(fromBase64(json.t, true))
        });
        else throw new Error("Absent mandatory parameter \"t\"");
    }
}
class RSAPrivateKey {
    constructor(parameters = {}){
        this.version = getParametersValue(parameters, "version", RSAPrivateKey.defaultValues("version"));
        this.modulus = getParametersValue(parameters, "modulus", RSAPrivateKey.defaultValues("modulus"));
        this.publicExponent = getParametersValue(parameters, "publicExponent", RSAPrivateKey.defaultValues("publicExponent"));
        this.privateExponent = getParametersValue(parameters, "privateExponent", RSAPrivateKey.defaultValues("privateExponent"));
        this.prime1 = getParametersValue(parameters, "prime1", RSAPrivateKey.defaultValues("prime1"));
        this.prime2 = getParametersValue(parameters, "prime2", RSAPrivateKey.defaultValues("prime2"));
        this.exponent1 = getParametersValue(parameters, "exponent1", RSAPrivateKey.defaultValues("exponent1"));
        this.exponent2 = getParametersValue(parameters, "exponent2", RSAPrivateKey.defaultValues("exponent2"));
        this.coefficient = getParametersValue(parameters, "coefficient", RSAPrivateKey.defaultValues("coefficient"));
        if ("otherPrimeInfos" in parameters) this.otherPrimeInfos = getParametersValue(parameters, "otherPrimeInfos", RSAPrivateKey.defaultValues("otherPrimeInfos"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
        if ("json" in parameters) this.fromJSON(parameters.json);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "version":
                return 0;
            case "modulus":
                return new Integer();
            case "publicExponent":
                return new Integer();
            case "privateExponent":
                return new Integer();
            case "prime1":
                return new Integer();
            case "prime2":
                return new Integer();
            case "exponent1":
                return new Integer();
            case "exponent2":
                return new Integer();
            case "coefficient":
                return new Integer();
            case "otherPrimeInfos":
                return [];
            default:
                throw new Error(`Invalid member name for RSAPrivateKey class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Integer({
                    name: names.version || ""
                }),
                new Integer({
                    name: names.modulus || ""
                }),
                new Integer({
                    name: names.publicExponent || ""
                }),
                new Integer({
                    name: names.privateExponent || ""
                }),
                new Integer({
                    name: names.prime1 || ""
                }),
                new Integer({
                    name: names.prime2 || ""
                }),
                new Integer({
                    name: names.exponent1 || ""
                }),
                new Integer({
                    name: names.exponent2 || ""
                }),
                new Integer({
                    name: names.coefficient || ""
                }),
                new Sequence({
                    optional: true,
                    value: [
                        new Repeated({
                            name: names.otherPrimeInfosName || "",
                            value: OtherPrimeInfo.schema(names.otherPrimeInfo || {})
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "version",
            "modulus",
            "publicExponent",
            "privateExponent",
            "prime1",
            "prime2",
            "exponent1",
            "exponent2",
            "coefficient",
            "otherPrimeInfos"
        ]);
        const asn1 = compareSchema(schema, schema, RSAPrivateKey.schema({
            names: {
                version: "version",
                modulus: "modulus",
                publicExponent: "publicExponent",
                privateExponent: "privateExponent",
                prime1: "prime1",
                prime2: "prime2",
                exponent1: "exponent1",
                exponent2: "exponent2",
                coefficient: "coefficient",
                otherPrimeInfo: {
                    names: {
                        blockName: "otherPrimeInfos"
                    }
                }
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for RSAPrivateKey");
        this.version = asn1.result.version.valueBlock.valueDec;
        this.modulus = asn1.result.modulus.convertFromDER(256);
        this.publicExponent = asn1.result.publicExponent;
        this.privateExponent = asn1.result.privateExponent.convertFromDER(256);
        this.prime1 = asn1.result.prime1.convertFromDER(128);
        this.prime2 = asn1.result.prime2.convertFromDER(128);
        this.exponent1 = asn1.result.exponent1.convertFromDER(128);
        this.exponent2 = asn1.result.exponent2.convertFromDER(128);
        this.coefficient = asn1.result.coefficient.convertFromDER(128);
        if ("otherPrimeInfos" in asn1.result) this.otherPrimeInfos = Array.from(asn1.result.otherPrimeInfos, (element)=>new OtherPrimeInfo({
                schema: element
            })
        );
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(new Integer({
            value: this.version
        }));
        outputArray.push(this.modulus.convertToDER());
        outputArray.push(this.publicExponent);
        outputArray.push(this.privateExponent.convertToDER());
        outputArray.push(this.prime1.convertToDER());
        outputArray.push(this.prime2.convertToDER());
        outputArray.push(this.exponent1.convertToDER());
        outputArray.push(this.exponent2.convertToDER());
        outputArray.push(this.coefficient.convertToDER());
        if ("otherPrimeInfos" in this) {
            outputArray.push(new Sequence({
                value: Array.from(this.otherPrimeInfos, (element)=>element.toSchema()
                )
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const jwk = {
            n: toBase64(arrayBufferToString(this.modulus.valueBlock.valueHex), true, true, true),
            e: toBase64(arrayBufferToString(this.publicExponent.valueBlock.valueHex), true, true, true),
            d: toBase64(arrayBufferToString(this.privateExponent.valueBlock.valueHex), true, true, true),
            p: toBase64(arrayBufferToString(this.prime1.valueBlock.valueHex), true, true, true),
            q: toBase64(arrayBufferToString(this.prime2.valueBlock.valueHex), true, true, true),
            dp: toBase64(arrayBufferToString(this.exponent1.valueBlock.valueHex), true, true, true),
            dq: toBase64(arrayBufferToString(this.exponent2.valueBlock.valueHex), true, true, true),
            qi: toBase64(arrayBufferToString(this.coefficient.valueBlock.valueHex), true, true, true)
        };
        if ("otherPrimeInfos" in this) jwk.oth = Array.from(this.otherPrimeInfos, (element)=>element.toJSON()
        );
        return jwk;
    }
    fromJSON(json) {
        if ("n" in json) this.modulus = new Integer({
            valueHex: stringToArrayBuffer(fromBase64(json.n, true, true))
        });
        else throw new Error("Absent mandatory parameter \"n\"");
        if ("e" in json) this.publicExponent = new Integer({
            valueHex: stringToArrayBuffer(fromBase64(json.e, true, true))
        });
        else throw new Error("Absent mandatory parameter \"e\"");
        if ("d" in json) this.privateExponent = new Integer({
            valueHex: stringToArrayBuffer(fromBase64(json.d, true, true))
        });
        else throw new Error("Absent mandatory parameter \"d\"");
        if ("p" in json) this.prime1 = new Integer({
            valueHex: stringToArrayBuffer(fromBase64(json.p, true, true))
        });
        else throw new Error("Absent mandatory parameter \"p\"");
        if ("q" in json) this.prime2 = new Integer({
            valueHex: stringToArrayBuffer(fromBase64(json.q, true, true))
        });
        else throw new Error("Absent mandatory parameter \"q\"");
        if ("dp" in json) this.exponent1 = new Integer({
            valueHex: stringToArrayBuffer(fromBase64(json.dp, true, true))
        });
        else throw new Error("Absent mandatory parameter \"dp\"");
        if ("dq" in json) this.exponent2 = new Integer({
            valueHex: stringToArrayBuffer(fromBase64(json.dq, true, true))
        });
        else throw new Error("Absent mandatory parameter \"dq\"");
        if ("qi" in json) this.coefficient = new Integer({
            valueHex: stringToArrayBuffer(fromBase64(json.qi, true, true))
        });
        else throw new Error("Absent mandatory parameter \"qi\"");
        if ("oth" in json) this.otherPrimeInfos = Array.from(json.oth, (element)=>new OtherPrimeInfo({
                json: element
            })
        );
    }
}
class PrivateKeyInfo {
    constructor(parameters = {}){
        this.version = getParametersValue(parameters, "version", PrivateKeyInfo.defaultValues("version"));
        this.privateKeyAlgorithm = getParametersValue(parameters, "privateKeyAlgorithm", PrivateKeyInfo.defaultValues("privateKeyAlgorithm"));
        this.privateKey = getParametersValue(parameters, "privateKey", PrivateKeyInfo.defaultValues("privateKey"));
        if ("attributes" in parameters) this.attributes = getParametersValue(parameters, "attributes", PrivateKeyInfo.defaultValues("attributes"));
        if ("parsedKey" in parameters) this.parsedKey = getParametersValue(parameters, "parsedKey", PrivateKeyInfo.defaultValues("parsedKey"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
        if ("json" in parameters) this.fromJSON(parameters.json);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "version":
                return 0;
            case "privateKeyAlgorithm":
                return new AlgorithmIdentifier();
            case "privateKey":
                return new OctetString();
            case "attributes":
                return [];
            case "parsedKey":
                return {};
            default:
                throw new Error(`Invalid member name for PrivateKeyInfo class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Integer({
                    name: names.version || ""
                }),
                AlgorithmIdentifier.schema(names.privateKeyAlgorithm || {}),
                new OctetString({
                    name: names.privateKey || ""
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Repeated({
                            name: names.attributes || "",
                            value: Attribute.schema()
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "version",
            "privateKeyAlgorithm",
            "privateKey",
            "attributes"
        ]);
        const asn1 = compareSchema(schema, schema, PrivateKeyInfo.schema({
            names: {
                version: "version",
                privateKeyAlgorithm: {
                    names: {
                        blockName: "privateKeyAlgorithm"
                    }
                },
                privateKey: "privateKey",
                attributes: "attributes"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PrivateKeyInfo");
        this.version = asn1.result.version.valueBlock.valueDec;
        this.privateKeyAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result.privateKeyAlgorithm
        });
        this.privateKey = asn1.result.privateKey;
        if ("attributes" in asn1.result) this.attributes = Array.from(asn1.result.attributes, (element)=>new Attribute({
                schema: element
            })
        );
        switch(this.privateKeyAlgorithm.algorithmId){
            case "1.2.840.113549.1.1.1":
                {
                    const privateKeyASN1 = fromBER(this.privateKey.valueBlock.valueHex);
                    if (privateKeyASN1.offset !== -1) this.parsedKey = new RSAPrivateKey({
                        schema: privateKeyASN1.result
                    });
                }
                break;
            case "1.2.840.10045.2.1":
                if ("algorithmParams" in this.privateKeyAlgorithm) {
                    if (this.privateKeyAlgorithm.algorithmParams instanceof ObjectIdentifier) {
                        const privateKeyASN1 = fromBER(this.privateKey.valueBlock.valueHex);
                        if (privateKeyASN1.offset !== -1) {
                            this.parsedKey = new ECPrivateKey({
                                namedCurve: this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),
                                schema: privateKeyASN1.result
                            });
                        }
                    }
                }
                break;
            default:
        }
    }
    toSchema() {
        const outputArray = [
            new Integer({
                value: this.version
            }),
            this.privateKeyAlgorithm.toSchema(),
            this.privateKey
        ];
        if ("attributes" in this) {
            outputArray.push(new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: Array.from(this.attributes, (element)=>element.toSchema()
                )
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        if ("parsedKey" in this === false) {
            const object = {
                version: this.version,
                privateKeyAlgorithm: this.privateKeyAlgorithm.toJSON(),
                privateKey: this.privateKey.toJSON()
            };
            if ("attributes" in this) object.attributes = Array.from(this.attributes, (element)=>element.toJSON()
            );
            return object;
        }
        const jwk = {};
        switch(this.privateKeyAlgorithm.algorithmId){
            case "1.2.840.10045.2.1":
                jwk.kty = "EC";
                break;
            case "1.2.840.113549.1.1.1":
                jwk.kty = "RSA";
                break;
            default:
        }
        const publicKeyJWK = this.parsedKey.toJSON();
        for (const key of Object.keys(publicKeyJWK))jwk[key] = publicKeyJWK[key];
        return jwk;
    }
    fromJSON(json) {
        if ("kty" in json) {
            switch(json.kty.toUpperCase()){
                case "EC":
                    this.parsedKey = new ECPrivateKey({
                        json
                    });
                    this.privateKeyAlgorithm = new AlgorithmIdentifier({
                        algorithmId: "1.2.840.10045.2.1",
                        algorithmParams: new ObjectIdentifier({
                            value: this.parsedKey.namedCurve
                        })
                    });
                    break;
                case "RSA":
                    this.parsedKey = new RSAPrivateKey({
                        json
                    });
                    this.privateKeyAlgorithm = new AlgorithmIdentifier({
                        algorithmId: "1.2.840.113549.1.1.1",
                        algorithmParams: new Null()
                    });
                    break;
                default:
                    throw new Error(`Invalid value for "kty" parameter: ${json.kty}`);
            }
            this.privateKey = new OctetString({
                valueHex: this.parsedKey.toSchema().toBER(false)
            });
        }
    }
}
class EncryptedContentInfo {
    constructor(parameters = {}){
        this.contentType = getParametersValue(parameters, "contentType", EncryptedContentInfo.defaultValues("contentType"));
        this.contentEncryptionAlgorithm = getParametersValue(parameters, "contentEncryptionAlgorithm", EncryptedContentInfo.defaultValues("contentEncryptionAlgorithm"));
        if ("encryptedContent" in parameters) {
            this.encryptedContent = parameters.encryptedContent;
            if (this.encryptedContent.idBlock.tagClass === 1 && this.encryptedContent.idBlock.tagNumber === 4) {
                if (this.encryptedContent.idBlock.isConstructed === false) {
                    const constrString = new OctetString({
                        idBlock: {
                            isConstructed: true
                        },
                        isConstructed: true
                    });
                    let offset = 0;
                    let length = this.encryptedContent.valueBlock.valueHex.byteLength;
                    while(length > 0){
                        const pieceView = new Uint8Array(this.encryptedContent.valueBlock.valueHex, offset, offset + 1024 > this.encryptedContent.valueBlock.valueHex.byteLength ? this.encryptedContent.valueBlock.valueHex.byteLength - offset : 1024);
                        const _array = new ArrayBuffer(pieceView.length);
                        const _view = new Uint8Array(_array);
                        for(let i142 = 0; i142 < _view.length; i142++)_view[i142] = pieceView[i142];
                        constrString.valueBlock.value.push(new OctetString({
                            valueHex: _array
                        }));
                        length -= pieceView.length;
                        offset += pieceView.length;
                    }
                    this.encryptedContent = constrString;
                }
            }
        }
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "contentType":
                return "";
            case "contentEncryptionAlgorithm":
                return new AlgorithmIdentifier();
            case "encryptedContent":
                return new OctetString();
            default:
                throw new Error(`Invalid member name for EncryptedContentInfo class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "contentType":
                return memberValue === "";
            case "contentEncryptionAlgorithm":
                return memberValue.algorithmId === "" && "algorithmParams" in memberValue === false;
            case "encryptedContent":
                return memberValue.isEqual(EncryptedContentInfo.defaultValues(memberName));
            default:
                throw new Error(`Invalid member name for EncryptedContentInfo class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new ObjectIdentifier({
                    name: names.contentType || ""
                }),
                AlgorithmIdentifier.schema(names.contentEncryptionAlgorithm || {}),
                new Choice({
                    value: [
                        new Constructed({
                            name: names.encryptedContent || "",
                            idBlock: {
                                tagClass: 3,
                                tagNumber: 0
                            },
                            value: [
                                new Repeated({
                                    value: new OctetString()
                                })
                            ]
                        }),
                        new Primitive({
                            name: names.encryptedContent || "",
                            idBlock: {
                                tagClass: 3,
                                tagNumber: 0
                            }
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "contentType",
            "contentEncryptionAlgorithm",
            "encryptedContent"
        ]);
        const asn1 = compareSchema(schema, schema, EncryptedContentInfo.schema({
            names: {
                contentType: "contentType",
                contentEncryptionAlgorithm: {
                    names: {
                        blockName: "contentEncryptionAlgorithm"
                    }
                },
                encryptedContent: "encryptedContent"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for EncryptedContentInfo");
        this.contentType = asn1.result.contentType.valueBlock.toString();
        this.contentEncryptionAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result.contentEncryptionAlgorithm
        });
        if ("encryptedContent" in asn1.result) {
            this.encryptedContent = asn1.result.encryptedContent;
            this.encryptedContent.idBlock.tagClass = 1;
            this.encryptedContent.idBlock.tagNumber = 4;
        }
    }
    toSchema() {
        const sequenceLengthBlock = {
            isIndefiniteForm: false
        };
        const outputArray = [];
        outputArray.push(new ObjectIdentifier({
            value: this.contentType
        }));
        outputArray.push(this.contentEncryptionAlgorithm.toSchema());
        if ("encryptedContent" in this) {
            sequenceLengthBlock.isIndefiniteForm = this.encryptedContent.idBlock.isConstructed;
            const encryptedValue = this.encryptedContent;
            encryptedValue.idBlock.tagClass = 3;
            encryptedValue.idBlock.tagNumber = 0;
            encryptedValue.lenBlock.isIndefiniteForm = this.encryptedContent.idBlock.isConstructed;
            outputArray.push(encryptedValue);
        }
        return new Sequence({
            lenBlock: sequenceLengthBlock,
            value: outputArray
        });
    }
    toJSON() {
        const _object = {
            contentType: this.contentType,
            contentEncryptionAlgorithm: this.contentEncryptionAlgorithm.toJSON()
        };
        if ("encryptedContent" in this) _object.encryptedContent = this.encryptedContent.toJSON();
        return _object;
    }
}
class RSASSAPSSParams {
    constructor(parameters = {}){
        this.hashAlgorithm = getParametersValue(parameters, "hashAlgorithm", RSASSAPSSParams.defaultValues("hashAlgorithm"));
        this.maskGenAlgorithm = getParametersValue(parameters, "maskGenAlgorithm", RSASSAPSSParams.defaultValues("maskGenAlgorithm"));
        this.saltLength = getParametersValue(parameters, "saltLength", RSASSAPSSParams.defaultValues("saltLength"));
        this.trailerField = getParametersValue(parameters, "trailerField", RSASSAPSSParams.defaultValues("trailerField"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "hashAlgorithm":
                return new AlgorithmIdentifier({
                    algorithmId: "1.3.14.3.2.26",
                    algorithmParams: new Null()
                });
            case "maskGenAlgorithm":
                return new AlgorithmIdentifier({
                    algorithmId: "1.2.840.113549.1.1.8",
                    algorithmParams: new AlgorithmIdentifier({
                        algorithmId: "1.3.14.3.2.26",
                        algorithmParams: new Null()
                    }).toSchema()
                });
            case "saltLength":
                return 20;
            case "trailerField":
                return 1;
            default:
                throw new Error(`Invalid member name for RSASSAPSSParams class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    optional: true,
                    value: [
                        AlgorithmIdentifier.schema(names.hashAlgorithm || {})
                    ]
                }),
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    optional: true,
                    value: [
                        AlgorithmIdentifier.schema(names.maskGenAlgorithm || {})
                    ]
                }),
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 2
                    },
                    optional: true,
                    value: [
                        new Integer({
                            name: names.saltLength || ""
                        })
                    ]
                }),
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 3
                    },
                    optional: true,
                    value: [
                        new Integer({
                            name: names.trailerField || ""
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "hashAlgorithm",
            "maskGenAlgorithm",
            "saltLength",
            "trailerField"
        ]);
        const asn1 = compareSchema(schema, schema, RSASSAPSSParams.schema({
            names: {
                hashAlgorithm: {
                    names: {
                        blockName: "hashAlgorithm"
                    }
                },
                maskGenAlgorithm: {
                    names: {
                        blockName: "maskGenAlgorithm"
                    }
                },
                saltLength: "saltLength",
                trailerField: "trailerField"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for RSASSAPSSParams");
        if ("hashAlgorithm" in asn1.result) this.hashAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result.hashAlgorithm
        });
        if ("maskGenAlgorithm" in asn1.result) this.maskGenAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result.maskGenAlgorithm
        });
        if ("saltLength" in asn1.result) this.saltLength = asn1.result.saltLength.valueBlock.valueDec;
        if ("trailerField" in asn1.result) this.trailerField = asn1.result.trailerField.valueBlock.valueDec;
    }
    toSchema() {
        const outputArray = [];
        if (!this.hashAlgorithm.isEqual(RSASSAPSSParams.defaultValues("hashAlgorithm"))) {
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: [
                    this.hashAlgorithm.toSchema()
                ]
            }));
        }
        if (!this.maskGenAlgorithm.isEqual(RSASSAPSSParams.defaultValues("maskGenAlgorithm"))) {
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                },
                value: [
                    this.maskGenAlgorithm.toSchema()
                ]
            }));
        }
        if (this.saltLength !== RSASSAPSSParams.defaultValues("saltLength")) {
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 2
                },
                value: [
                    new Integer({
                        value: this.saltLength
                    })
                ]
            }));
        }
        if (this.trailerField !== RSASSAPSSParams.defaultValues("trailerField")) {
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 3
                },
                value: [
                    new Integer({
                        value: this.trailerField
                    })
                ]
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const object = {};
        if (!this.hashAlgorithm.isEqual(RSASSAPSSParams.defaultValues("hashAlgorithm"))) object.hashAlgorithm = this.hashAlgorithm.toJSON();
        if (!this.maskGenAlgorithm.isEqual(RSASSAPSSParams.defaultValues("maskGenAlgorithm"))) object.maskGenAlgorithm = this.maskGenAlgorithm.toJSON();
        if (this.saltLength !== RSASSAPSSParams.defaultValues("saltLength")) object.saltLength = this.saltLength;
        if (this.trailerField !== RSASSAPSSParams.defaultValues("trailerField")) object.trailerField = this.trailerField;
        return object;
    }
}
class PBKDF2Params {
    constructor(parameters = {}){
        this.salt = getParametersValue(parameters, "salt", PBKDF2Params.defaultValues("salt"));
        this.iterationCount = getParametersValue(parameters, "iterationCount", PBKDF2Params.defaultValues("iterationCount"));
        if ("keyLength" in parameters) this.keyLength = getParametersValue(parameters, "keyLength", PBKDF2Params.defaultValues("keyLength"));
        if ("prf" in parameters) this.prf = getParametersValue(parameters, "prf", PBKDF2Params.defaultValues("prf"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "salt":
                return {};
            case "iterationCount":
                return -1;
            case "keyLength":
                return 0;
            case "prf":
                return new AlgorithmIdentifier({
                    algorithmId: "1.3.14.3.2.26",
                    algorithmParams: new Null()
                });
            default:
                throw new Error(`Invalid member name for PBKDF2Params class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Choice({
                    value: [
                        new OctetString({
                            name: names.saltPrimitive || ""
                        }),
                        AlgorithmIdentifier.schema(names.saltConstructed || {})
                    ]
                }),
                new Integer({
                    name: names.iterationCount || ""
                }),
                new Integer({
                    name: names.keyLength || "",
                    optional: true
                }),
                AlgorithmIdentifier.schema(names.prf || {
                    names: {
                        optional: true
                    }
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "salt",
            "iterationCount",
            "keyLength",
            "prf"
        ]);
        const asn1 = compareSchema(schema, schema, PBKDF2Params.schema({
            names: {
                saltPrimitive: "salt",
                saltConstructed: {
                    names: {
                        blockName: "salt"
                    }
                },
                iterationCount: "iterationCount",
                keyLength: "keyLength",
                prf: {
                    names: {
                        blockName: "prf",
                        optional: true
                    }
                }
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PBKDF2Params");
        this.salt = asn1.result.salt;
        this.iterationCount = asn1.result.iterationCount.valueBlock.valueDec;
        if ("keyLength" in asn1.result) this.keyLength = asn1.result.keyLength.valueBlock.valueDec;
        if ("prf" in asn1.result) this.prf = new AlgorithmIdentifier({
            schema: asn1.result.prf
        });
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(this.salt);
        outputArray.push(new Integer({
            value: this.iterationCount
        }));
        if ("keyLength" in this) {
            if (PBKDF2Params.defaultValues("keyLength") !== this.keyLength) outputArray.push(new Integer({
                value: this.keyLength
            }));
        }
        if ("prf" in this) {
            if (PBKDF2Params.defaultValues("prf").isEqual(this.prf) === false) outputArray.push(this.prf.toSchema());
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const _object = {
            salt: this.salt.toJSON(),
            iterationCount: this.iterationCount
        };
        if ("keyLength" in this) {
            if (PBKDF2Params.defaultValues("keyLength") !== this.keyLength) _object.keyLength = this.keyLength;
        }
        if ("prf" in this) {
            if (PBKDF2Params.defaultValues("prf").isEqual(this.prf) === false) _object.prf = this.prf.toJSON();
        }
        return _object;
    }
}
class PBES2Params {
    constructor(parameters = {}){
        this.keyDerivationFunc = getParametersValue(parameters, "keyDerivationFunc", PBES2Params.defaultValues("keyDerivationFunc"));
        this.encryptionScheme = getParametersValue(parameters, "encryptionScheme", PBES2Params.defaultValues("encryptionScheme"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "keyDerivationFunc":
                return new AlgorithmIdentifier();
            case "encryptionScheme":
                return new AlgorithmIdentifier();
            default:
                throw new Error(`Invalid member name for PBES2Params class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                AlgorithmIdentifier.schema(names.keyDerivationFunc || {}),
                AlgorithmIdentifier.schema(names.encryptionScheme || {})
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "keyDerivationFunc",
            "encryptionScheme"
        ]);
        const asn1 = compareSchema(schema, schema, PBES2Params.schema({
            names: {
                keyDerivationFunc: {
                    names: {
                        blockName: "keyDerivationFunc"
                    }
                },
                encryptionScheme: {
                    names: {
                        blockName: "encryptionScheme"
                    }
                }
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PBES2Params");
        this.keyDerivationFunc = new AlgorithmIdentifier({
            schema: asn1.result.keyDerivationFunc
        });
        this.encryptionScheme = new AlgorithmIdentifier({
            schema: asn1.result.encryptionScheme
        });
    }
    toSchema() {
        return new Sequence({
            value: [
                this.keyDerivationFunc.toSchema(),
                this.encryptionScheme.toSchema()
            ]
        });
    }
    toJSON() {
        return {
            keyDerivationFunc: this.keyDerivationFunc.toJSON(),
            encryptionScheme: this.encryptionScheme.toJSON()
        };
    }
}
let engine = {
    name: "none",
    crypto: null,
    subtle: null
};
function makePKCS12B2Key(cryptoEngine, hashAlgorithm, keyLength, password, salt, iterationCount) {
    let u4;
    let v;
    const result = [];
    switch(hashAlgorithm.toUpperCase()){
        case "SHA-1":
            u4 = 20;
            v = 64;
            break;
        case "SHA-256":
            u4 = 32;
            v = 64;
            break;
        case "SHA-384":
            u4 = 48;
            v = 128;
            break;
        case "SHA-512":
            u4 = 64;
            v = 128;
            break;
        default:
            throw new Error("Unsupported hashing algorithm");
    }
    const passwordViewInitial = new Uint8Array(password);
    const passwordTransformed = new ArrayBuffer(password.byteLength * 2 + 2);
    const passwordTransformedView = new Uint8Array(passwordTransformed);
    for(let i143 = 0; i143 < passwordViewInitial.length; i143++){
        passwordTransformedView[i143 * 2] = 0x00;
        passwordTransformedView[i143 * 2 + 1] = passwordViewInitial[i143];
    }
    passwordTransformedView[passwordTransformedView.length - 2] = 0x00;
    passwordTransformedView[passwordTransformedView.length - 1] = 0x00;
    password = passwordTransformed.slice(0);
    const D = new ArrayBuffer(v);
    const dView = new Uint8Array(D);
    for(let i1 = 0; i1 < D.byteLength; i1++)dView[i1] = 3;
    const saltLength = salt.byteLength;
    const sLen = v * Math.ceil(saltLength / v);
    const S = new ArrayBuffer(sLen);
    const sView = new Uint8Array(S);
    const saltView = new Uint8Array(salt);
    for(let i211 = 0; i211 < sLen; i211++)sView[i211] = saltView[i211 % saltLength];
    const passwordLength = password.byteLength;
    const pLen = v * Math.ceil(passwordLength / v);
    const P = new ArrayBuffer(pLen);
    const pView = new Uint8Array(P);
    const passwordView = new Uint8Array(password);
    for(let i3 = 0; i3 < pLen; i3++)pView[i3] = passwordView[i3 % passwordLength];
    const sPlusPLength = S.byteLength + P.byteLength;
    let I = new ArrayBuffer(sPlusPLength);
    let iView = new Uint8Array(I);
    iView.set(sView);
    iView.set(pView, sView.length);
    const c = Math.ceil((keyLength >> 3) / u4);
    let internalSequence = Promise.resolve(I);
    for(let i4 = 0; i4 <= c; i4++){
        internalSequence = internalSequence.then((_I)=>{
            const dAndI = new ArrayBuffer(D.byteLength + _I.byteLength);
            const dAndIView = new Uint8Array(dAndI);
            dAndIView.set(dView);
            dAndIView.set(iView, dView.length);
            return dAndI;
        });
        for(let j2 = 0; j2 < iterationCount; j2++)internalSequence = internalSequence.then((roundBuffer)=>cryptoEngine.digest({
                name: hashAlgorithm
            }, new Uint8Array(roundBuffer))
        );
        internalSequence = internalSequence.then((roundBuffer)=>{
            const B = new ArrayBuffer(v);
            const bView = new Uint8Array(B);
            for(let j = 0; j < B.byteLength; j++)bView[j] = roundBuffer[j % roundBuffer.length];
            const k = Math.ceil(saltLength / v) + Math.ceil(passwordLength / v);
            const iRound = [];
            let sliceStart = 0;
            let sliceLength = v;
            for(let j1 = 0; j1 < k; j1++){
                const chunk = Array.from(new Uint8Array(I.slice(sliceStart, sliceStart + sliceLength)));
                sliceStart += v;
                if (sliceStart + v > I.byteLength) sliceLength = I.byteLength - sliceStart;
                let x = 0x1ff;
                for(let l = B.byteLength - 1; l >= 0; l--){
                    x >>= 8;
                    x += bView[l] + chunk[l];
                    chunk[l] = x & 0xff;
                }
                iRound.push(...chunk);
            }
            I = new ArrayBuffer(iRound.length);
            iView = new Uint8Array(I);
            iView.set(iRound);
            result.push(...new Uint8Array(roundBuffer));
            return I;
        });
    }
    internalSequence = internalSequence.then(()=>{
        const resultBuffer = new ArrayBuffer(keyLength >> 3);
        const resultView = new Uint8Array(resultBuffer);
        resultView.set(new Uint8Array(result).slice(0, keyLength >> 3));
        return resultBuffer;
    });
    return internalSequence;
}
function setEngine(name, crypto, subtle) {
    if (typeof process !== "undefined" && "pid" in process && typeof global !== "undefined") {
        if (typeof global[process.pid] === "undefined") {
            global[process.pid] = {};
        } else {
            if (typeof global[process.pid] !== "object") {
                throw new Error(`Name global.${process.pid} already exists and it is not an object`);
            }
        }
        if (typeof global[process.pid].pkijs === "undefined") {
            global[process.pid].pkijs = {};
        } else {
            if (typeof global[process.pid].pkijs !== "object") {
                throw new Error(`Name global.${process.pid}.pkijs already exists and it is not an object`);
            }
        }
        global[process.pid].pkijs.engine = {
            name: name,
            crypto: crypto,
            subtle: subtle
        };
    } else {
        engine = {
            name: name,
            crypto: crypto,
            subtle: subtle
        };
    }
}
function getEngine() {
    if (typeof process !== "undefined" && "pid" in process && typeof global !== "undefined") {
        let _engine;
        try {
            _engine = global[process.pid].pkijs.engine;
        } catch (ex) {
            throw new Error("Please call \"setEngine\" before call to \"getEngine\"");
        }
        return _engine;
    }
    return engine;
}
function getCrypto() {
    const _engine = getEngine();
    if (_engine.subtle !== null) return _engine.subtle;
    return undefined;
}
class PublicKeyInfo {
    constructor(parameters = {}){
        this.algorithm = getParametersValue(parameters, "algorithm", PublicKeyInfo.defaultValues("algorithm"));
        this.subjectPublicKey = getParametersValue(parameters, "subjectPublicKey", PublicKeyInfo.defaultValues("subjectPublicKey"));
        if ("parsedKey" in parameters) this.parsedKey = getParametersValue(parameters, "parsedKey", PublicKeyInfo.defaultValues("parsedKey"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
        if ("json" in parameters) this.fromJSON(parameters.json);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "algorithm":
                return new AlgorithmIdentifier();
            case "subjectPublicKey":
                return new BitString();
            default:
                throw new Error(`Invalid member name for PublicKeyInfo class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                AlgorithmIdentifier.schema(names.algorithm || {}),
                new BitString({
                    name: names.subjectPublicKey || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "algorithm",
            "subjectPublicKey"
        ]);
        const asn1 = compareSchema(schema, schema, PublicKeyInfo.schema({
            names: {
                algorithm: {
                    names: {
                        blockName: "algorithm"
                    }
                },
                subjectPublicKey: "subjectPublicKey"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PublicKeyInfo");
        this.algorithm = new AlgorithmIdentifier({
            schema: asn1.result.algorithm
        });
        this.subjectPublicKey = asn1.result.subjectPublicKey;
        switch(this.algorithm.algorithmId){
            case "1.2.840.10045.2.1":
                if ("algorithmParams" in this.algorithm) {
                    if (this.algorithm.algorithmParams instanceof ObjectIdentifier) {
                        try {
                            this.parsedKey = new ECPublicKey({
                                namedCurve: this.algorithm.algorithmParams.valueBlock.toString(),
                                schema: this.subjectPublicKey.valueBlock.valueHex
                            });
                        } catch (ex) {}
                    }
                }
                break;
            case "1.2.840.113549.1.1.1":
                {
                    const publicKeyASN1 = fromBER(this.subjectPublicKey.valueBlock.valueHex);
                    if (publicKeyASN1.offset !== -1) {
                        try {
                            this.parsedKey = new RSAPublicKey({
                                schema: publicKeyASN1.result
                            });
                        } catch (ex) {}
                    }
                }
                break;
            default:
        }
    }
    toSchema() {
        return new Sequence({
            value: [
                this.algorithm.toSchema(),
                this.subjectPublicKey
            ]
        });
    }
    toJSON() {
        if ("parsedKey" in this === false) {
            return {
                algorithm: this.algorithm.toJSON(),
                subjectPublicKey: this.subjectPublicKey.toJSON()
            };
        }
        const jwk = {};
        switch(this.algorithm.algorithmId){
            case "1.2.840.10045.2.1":
                jwk.kty = "EC";
                break;
            case "1.2.840.113549.1.1.1":
                jwk.kty = "RSA";
                break;
            default:
        }
        const publicKeyJWK = this.parsedKey.toJSON();
        for (const key of Object.keys(publicKeyJWK))jwk[key] = publicKeyJWK[key];
        return jwk;
    }
    fromJSON(json) {
        if ("kty" in json) {
            switch(json.kty.toUpperCase()){
                case "EC":
                    this.parsedKey = new ECPublicKey({
                        json
                    });
                    this.algorithm = new AlgorithmIdentifier({
                        algorithmId: "1.2.840.10045.2.1",
                        algorithmParams: new ObjectIdentifier({
                            value: this.parsedKey.namedCurve
                        })
                    });
                    break;
                case "RSA":
                    this.parsedKey = new RSAPublicKey({
                        json
                    });
                    this.algorithm = new AlgorithmIdentifier({
                        algorithmId: "1.2.840.113549.1.1.1",
                        algorithmParams: new Null()
                    });
                    break;
                default:
                    throw new Error(`Invalid value for "kty" parameter: ${json.kty}`);
            }
            this.subjectPublicKey = new BitString({
                valueHex: this.parsedKey.toSchema().toBER(false)
            });
        }
    }
    importKey(publicKey) {
        let sequence = Promise.resolve();
        const _this = this;
        if (typeof publicKey === "undefined") return Promise.reject("Need to provide publicKey input parameter");
        const crypto = getCrypto();
        if (typeof crypto === "undefined") return Promise.reject("Unable to create WebCrypto object");
        sequence = sequence.then(()=>crypto.exportKey("spki", publicKey)
        );
        sequence = sequence.then((exportedKey)=>{
            const asn1 = fromBER(exportedKey);
            try {
                _this.fromSchema(asn1.result);
            } catch (exception) {
                return Promise.reject("Error during initializing object from schema");
            }
            return undefined;
        }, (error3)=>Promise.reject(`Error during exporting public key: ${error3}`)
        );
        return sequence;
    }
}
function createCMSECDSASignature(signatureBuffer) {
    if (signatureBuffer.byteLength % 2 !== 0) return new ArrayBuffer(0);
    const length = signatureBuffer.byteLength / 2;
    const rBuffer = new ArrayBuffer(length);
    const rView = new Uint8Array(rBuffer);
    rView.set(new Uint8Array(signatureBuffer, 0, length));
    const rInteger = new Integer({
        valueHex: rBuffer
    });
    const sBuffer = new ArrayBuffer(length);
    const sView = new Uint8Array(sBuffer);
    sView.set(new Uint8Array(signatureBuffer, length, length));
    const sInteger = new Integer({
        valueHex: sBuffer
    });
    return new Sequence({
        value: [
            rInteger.convertToDER(),
            sInteger.convertToDER()
        ]
    }).toBER(false);
}
function getRandomValues(view) {
    return getEngine().subtle.getRandomValues(view);
}
function getOIDByAlgorithm(algorithm) {
    return getEngine().subtle.getOIDByAlgorithm(algorithm);
}
function createECDSASignatureFromCMS(cmsSignature) {
    if (cmsSignature instanceof Sequence === false) return new ArrayBuffer(0);
    if (cmsSignature.valueBlock.value.length !== 2) return new ArrayBuffer(0);
    if (cmsSignature.valueBlock.value[0] instanceof Integer === false) return new ArrayBuffer(0);
    if (cmsSignature.valueBlock.value[1] instanceof Integer === false) return new ArrayBuffer(0);
    const rValue = cmsSignature.valueBlock.value[0].convertFromDER();
    const sValue = cmsSignature.valueBlock.value[1].convertFromDER();
    switch(true){
        case rValue.valueBlock.valueHex.byteLength < sValue.valueBlock.valueHex.byteLength:
            {
                if (sValue.valueBlock.valueHex.byteLength - rValue.valueBlock.valueHex.byteLength !== 1) throw new Error("Incorrect DER integer decoding");
                const correctedLength = sValue.valueBlock.valueHex.byteLength;
                const rValueView = new Uint8Array(rValue.valueBlock.valueHex);
                const rValueBufferCorrected = new ArrayBuffer(correctedLength);
                const rValueViewCorrected = new Uint8Array(rValueBufferCorrected);
                rValueViewCorrected.set(rValueView, 1);
                rValueViewCorrected[0] = 0x00;
                return utilConcatBuf(rValueBufferCorrected, sValue.valueBlock.valueHex);
            }
        case rValue.valueBlock.valueHex.byteLength > sValue.valueBlock.valueHex.byteLength:
            {
                if (rValue.valueBlock.valueHex.byteLength - sValue.valueBlock.valueHex.byteLength !== 1) throw new Error("Incorrect DER integer decoding");
                const correctedLength = rValue.valueBlock.valueHex.byteLength;
                const sValueView = new Uint8Array(sValue.valueBlock.valueHex);
                const sValueBufferCorrected = new ArrayBuffer(correctedLength);
                const sValueViewCorrected = new Uint8Array(sValueBufferCorrected);
                sValueViewCorrected.set(sValueView, 1);
                sValueViewCorrected[0] = 0x00;
                return utilConcatBuf(rValue.valueBlock.valueHex, sValueBufferCorrected);
            }
        default:
            {
                if (rValue.valueBlock.valueHex.byteLength % 2) {
                    const correctedLength = rValue.valueBlock.valueHex.byteLength + 1;
                    const rValueView = new Uint8Array(rValue.valueBlock.valueHex);
                    const rValueBufferCorrected = new ArrayBuffer(correctedLength);
                    const rValueViewCorrected = new Uint8Array(rValueBufferCorrected);
                    rValueViewCorrected.set(rValueView, 1);
                    rValueViewCorrected[0] = 0x00;
                    const sValueView = new Uint8Array(sValue.valueBlock.valueHex);
                    const sValueBufferCorrected = new ArrayBuffer(correctedLength);
                    const sValueViewCorrected = new Uint8Array(sValueBufferCorrected);
                    sValueViewCorrected.set(sValueView, 1);
                    sValueViewCorrected[0] = 0x00;
                    return utilConcatBuf(rValueBufferCorrected, sValueBufferCorrected);
                }
            }
    }
    return utilConcatBuf(rValue.valueBlock.valueHex, sValue.valueBlock.valueHex);
}
class CryptoEngine {
    constructor(parameters = {}){
        this.crypto = getParametersValue(parameters, "crypto", {});
        this.subtle = getParametersValue(parameters, "subtle", {});
        this.name = getParametersValue(parameters, "name", "");
    }
    importKey(format3, keyData, algorithm, extractable, keyUsages) {
        let jwk = {};
        if (keyData instanceof Uint8Array) keyData = keyData.buffer;
        switch(format3.toLowerCase()){
            case "raw":
                return this.subtle.importKey("raw", keyData, algorithm, extractable, keyUsages);
            case "spki":
                {
                    const asn1 = fromBER(keyData);
                    if (asn1.offset === -1) return Promise.reject("Incorrect keyData");
                    const publicKeyInfo = new PublicKeyInfo();
                    try {
                        publicKeyInfo.fromSchema(asn1.result);
                    } catch (ex) {
                        return Promise.reject("Incorrect keyData");
                    }
                    switch(algorithm.name.toUpperCase()){
                        case "RSA-PSS":
                            {
                                switch(algorithm.hash.name.toUpperCase()){
                                    case "SHA-1":
                                        jwk.alg = "PS1";
                                        break;
                                    case "SHA-256":
                                        jwk.alg = "PS256";
                                        break;
                                    case "SHA-384":
                                        jwk.alg = "PS384";
                                        break;
                                    case "SHA-512":
                                        jwk.alg = "PS512";
                                        break;
                                    default:
                                        return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);
                                }
                            }
                        case "RSASSA-PKCS1-V1_5":
                            {
                                keyUsages = [
                                    "verify"
                                ];
                                jwk.kty = "RSA";
                                jwk.ext = extractable;
                                jwk.key_ops = keyUsages;
                                if (publicKeyInfo.algorithm.algorithmId !== "1.2.840.113549.1.1.1") return Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);
                                if ("alg" in jwk === false) {
                                    switch(algorithm.hash.name.toUpperCase()){
                                        case "SHA-1":
                                            jwk.alg = "RS1";
                                            break;
                                        case "SHA-256":
                                            jwk.alg = "RS256";
                                            break;
                                        case "SHA-384":
                                            jwk.alg = "RS384";
                                            break;
                                        case "SHA-512":
                                            jwk.alg = "RS512";
                                            break;
                                        default:
                                            return Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);
                                    }
                                }
                                const publicKeyJSON = publicKeyInfo.toJSON();
                                for (const key of Object.keys(publicKeyJSON))jwk[key] = publicKeyJSON[key];
                            }
                            break;
                        case "ECDSA":
                            keyUsages = [
                                "verify"
                            ];
                        case "ECDH":
                            {
                                jwk = {
                                    kty: "EC",
                                    ext: extractable,
                                    key_ops: keyUsages
                                };
                                if (publicKeyInfo.algorithm.algorithmId !== "1.2.840.10045.2.1") return Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);
                                const publicKeyJSON = publicKeyInfo.toJSON();
                                for (const key of Object.keys(publicKeyJSON))jwk[key] = publicKeyJSON[key];
                            }
                            break;
                        case "RSA-OAEP":
                            {
                                jwk.kty = "RSA";
                                jwk.ext = extractable;
                                jwk.key_ops = keyUsages;
                                if (this.name.toLowerCase() === "safari") jwk.alg = "RSA-OAEP";
                                else {
                                    switch(algorithm.hash.name.toUpperCase()){
                                        case "SHA-1":
                                            jwk.alg = "RSA-OAEP";
                                            break;
                                        case "SHA-256":
                                            jwk.alg = "RSA-OAEP-256";
                                            break;
                                        case "SHA-384":
                                            jwk.alg = "RSA-OAEP-384";
                                            break;
                                        case "SHA-512":
                                            jwk.alg = "RSA-OAEP-512";
                                            break;
                                        default:
                                            return Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);
                                    }
                                }
                                const publicKeyJSON = publicKeyInfo.toJSON();
                                for (const key of Object.keys(publicKeyJSON))jwk[key] = publicKeyJSON[key];
                            }
                            break;
                        default:
                            return Promise.reject(`Incorrect algorithm name: ${algorithm.name.toUpperCase()}`);
                    }
                }
                break;
            case "pkcs8":
                {
                    const privateKeyInfo = new PrivateKeyInfo();
                    const asn1 = fromBER(keyData);
                    if (asn1.offset === -1) return Promise.reject("Incorrect keyData");
                    try {
                        privateKeyInfo.fromSchema(asn1.result);
                    } catch (ex) {
                        return Promise.reject("Incorrect keyData");
                    }
                    if ("parsedKey" in privateKeyInfo === false) return Promise.reject("Incorrect keyData");
                    switch(algorithm.name.toUpperCase()){
                        case "RSA-PSS":
                            {
                                switch(algorithm.hash.name.toUpperCase()){
                                    case "SHA-1":
                                        jwk.alg = "PS1";
                                        break;
                                    case "SHA-256":
                                        jwk.alg = "PS256";
                                        break;
                                    case "SHA-384":
                                        jwk.alg = "PS384";
                                        break;
                                    case "SHA-512":
                                        jwk.alg = "PS512";
                                        break;
                                    default:
                                        return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);
                                }
                            }
                        case "RSASSA-PKCS1-V1_5":
                            {
                                keyUsages = [
                                    "sign"
                                ];
                                jwk.kty = "RSA";
                                jwk.ext = extractable;
                                jwk.key_ops = keyUsages;
                                if (privateKeyInfo.privateKeyAlgorithm.algorithmId !== "1.2.840.113549.1.1.1") return Promise.reject(`Incorrect private key algorithm: ${privateKeyInfo.privateKeyAlgorithm.algorithmId}`);
                                if ("alg" in jwk === false) {
                                    switch(algorithm.hash.name.toUpperCase()){
                                        case "SHA-1":
                                            jwk.alg = "RS1";
                                            break;
                                        case "SHA-256":
                                            jwk.alg = "RS256";
                                            break;
                                        case "SHA-384":
                                            jwk.alg = "RS384";
                                            break;
                                        case "SHA-512":
                                            jwk.alg = "RS512";
                                            break;
                                        default:
                                            return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);
                                    }
                                }
                                const privateKeyJSON = privateKeyInfo.toJSON();
                                for (const key of Object.keys(privateKeyJSON))jwk[key] = privateKeyJSON[key];
                            }
                            break;
                        case "ECDSA":
                            keyUsages = [
                                "sign"
                            ];
                        case "ECDH":
                            {
                                jwk = {
                                    kty: "EC",
                                    ext: extractable,
                                    key_ops: keyUsages
                                };
                                if (privateKeyInfo.privateKeyAlgorithm.algorithmId !== "1.2.840.10045.2.1") return Promise.reject(`Incorrect algorithm: ${privateKeyInfo.privateKeyAlgorithm.algorithmId}`);
                                const privateKeyJSON = privateKeyInfo.toJSON();
                                for (const key of Object.keys(privateKeyJSON))jwk[key] = privateKeyJSON[key];
                            }
                            break;
                        case "RSA-OAEP":
                            {
                                jwk.kty = "RSA";
                                jwk.ext = extractable;
                                jwk.key_ops = keyUsages;
                                if (this.name.toLowerCase() === "safari") jwk.alg = "RSA-OAEP";
                                else {
                                    switch(algorithm.hash.name.toUpperCase()){
                                        case "SHA-1":
                                            jwk.alg = "RSA-OAEP";
                                            break;
                                        case "SHA-256":
                                            jwk.alg = "RSA-OAEP-256";
                                            break;
                                        case "SHA-384":
                                            jwk.alg = "RSA-OAEP-384";
                                            break;
                                        case "SHA-512":
                                            jwk.alg = "RSA-OAEP-512";
                                            break;
                                        default:
                                            return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);
                                    }
                                }
                                const privateKeyJSON = privateKeyInfo.toJSON();
                                for (const key of Object.keys(privateKeyJSON))jwk[key] = privateKeyJSON[key];
                            }
                            break;
                        default:
                            return Promise.reject(`Incorrect algorithm name: ${algorithm.name.toUpperCase()}`);
                    }
                }
                break;
            case "jwk":
                jwk = keyData;
                break;
            default:
                return Promise.reject(`Incorrect format: ${format3}`);
        }
        if (this.name.toLowerCase() === "safari") {
            return Promise.resolve().then(()=>this.subtle.importKey("jwk", stringToArrayBuffer(JSON.stringify(jwk)), algorithm, extractable, keyUsages)
            ).then((result)=>result
            , ()=>this.subtle.importKey("jwk", jwk, algorithm, extractable, keyUsages)
            );
        }
        return this.subtle.importKey("jwk", jwk, algorithm, extractable, keyUsages);
    }
    exportKey(format4, key) {
        let sequence = this.subtle.exportKey("jwk", key);
        if (this.name.toLowerCase() === "safari") {
            sequence = sequence.then((result)=>{
                if (result instanceof ArrayBuffer) return JSON.parse(arrayBufferToString(result));
                return result;
            });
        }
        switch(format4.toLowerCase()){
            case "raw":
                return this.subtle.exportKey("raw", key);
            case "spki":
                sequence = sequence.then((result)=>{
                    const publicKeyInfo = new PublicKeyInfo();
                    try {
                        publicKeyInfo.fromJSON(result);
                    } catch (ex) {
                        return Promise.reject("Incorrect key data");
                    }
                    return publicKeyInfo.toSchema().toBER(false);
                });
                break;
            case "pkcs8":
                sequence = sequence.then((result)=>{
                    const privateKeyInfo = new PrivateKeyInfo();
                    try {
                        privateKeyInfo.fromJSON(result);
                    } catch (ex) {
                        return Promise.reject("Incorrect key data");
                    }
                    return privateKeyInfo.toSchema().toBER(false);
                });
                break;
            case "jwk":
                break;
            default:
                return Promise.reject(`Incorrect format: ${format4}`);
        }
        return sequence;
    }
    convert(inputFormat, outputFormat, keyData, algorithm, extractable, keyUsages) {
        switch(inputFormat.toLowerCase()){
            case "raw":
                switch(outputFormat.toLowerCase()){
                    case "raw":
                        return Promise.resolve(keyData);
                    case "spki":
                        return Promise.resolve().then(()=>this.importKey("raw", keyData, algorithm, extractable, keyUsages)
                        ).then((result)=>this.exportKey("spki", result)
                        );
                    case "pkcs8":
                        return Promise.resolve().then(()=>this.importKey("raw", keyData, algorithm, extractable, keyUsages)
                        ).then((result)=>this.exportKey("pkcs8", result)
                        );
                    case "jwk":
                        return Promise.resolve().then(()=>this.importKey("raw", keyData, algorithm, extractable, keyUsages)
                        ).then((result)=>this.exportKey("jwk", result)
                        );
                    default:
                        return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);
                }
            case "spki":
                switch(outputFormat.toLowerCase()){
                    case "raw":
                        return Promise.resolve().then(()=>this.importKey("spki", keyData, algorithm, extractable, keyUsages)
                        ).then((result)=>this.exportKey("raw", result)
                        );
                    case "spki":
                        return Promise.resolve(keyData);
                    case "pkcs8":
                        return Promise.reject("Impossible to convert between SPKI/PKCS8");
                    case "jwk":
                        return Promise.resolve().then(()=>this.importKey("spki", keyData, algorithm, extractable, keyUsages)
                        ).then((result)=>this.exportKey("jwk", result)
                        );
                    default:
                        return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);
                }
            case "pkcs8":
                switch(outputFormat.toLowerCase()){
                    case "raw":
                        return Promise.resolve().then(()=>this.importKey("pkcs8", keyData, algorithm, extractable, keyUsages)
                        ).then((result)=>this.exportKey("raw", result)
                        );
                    case "spki":
                        return Promise.reject("Impossible to convert between SPKI/PKCS8");
                    case "pkcs8":
                        return Promise.resolve(keyData);
                    case "jwk":
                        return Promise.resolve().then(()=>this.importKey("pkcs8", keyData, algorithm, extractable, keyUsages)
                        ).then((result)=>this.exportKey("jwk", result)
                        );
                    default:
                        return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);
                }
            case "jwk":
                switch(outputFormat.toLowerCase()){
                    case "raw":
                        return Promise.resolve().then(()=>this.importKey("jwk", keyData, algorithm, extractable, keyUsages)
                        ).then((result)=>this.exportKey("raw", result)
                        );
                    case "spki":
                        return Promise.resolve().then(()=>this.importKey("jwk", keyData, algorithm, extractable, keyUsages)
                        ).then((result)=>this.exportKey("spki", result)
                        );
                    case "pkcs8":
                        return Promise.resolve().then(()=>this.importKey("jwk", keyData, algorithm, extractable, keyUsages)
                        ).then((result)=>this.exportKey("pkcs8", result)
                        );
                    case "jwk":
                        return Promise.resolve(keyData);
                    default:
                        return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);
                }
            default:
                return Promise.reject(`Incorrect inputFormat: ${inputFormat}`);
        }
    }
    encrypt(...args) {
        return this.subtle.encrypt(...args);
    }
    decrypt(...args) {
        return this.subtle.decrypt(...args);
    }
    sign(...args) {
        return this.subtle.sign(...args);
    }
    verify(...args) {
        return this.subtle.verify(...args);
    }
    digest(...args) {
        return this.subtle.digest(...args);
    }
    generateKey(...args) {
        return this.subtle.generateKey(...args);
    }
    deriveKey(...args) {
        return this.subtle.deriveKey(...args);
    }
    deriveBits(...args) {
        return this.subtle.deriveBits(...args);
    }
    wrapKey(...args) {
        return this.subtle.wrapKey(...args);
    }
    unwrapKey(...args) {
        return this.subtle.unwrapKey(...args);
    }
    getRandomValues(view) {
        if ("getRandomValues" in this.crypto === false) throw new Error("No support for getRandomValues");
        return this.crypto.getRandomValues(view);
    }
    getAlgorithmByOID(oid) {
        switch(oid){
            case "1.2.840.113549.1.1.1":
            case "1.2.840.113549.1.1.5":
                return {
                    name: "RSASSA-PKCS1-v1_5",
                    hash: {
                        name: "SHA-1"
                    }
                };
            case "1.2.840.113549.1.1.11":
                return {
                    name: "RSASSA-PKCS1-v1_5",
                    hash: {
                        name: "SHA-256"
                    }
                };
            case "1.2.840.113549.1.1.12":
                return {
                    name: "RSASSA-PKCS1-v1_5",
                    hash: {
                        name: "SHA-384"
                    }
                };
            case "1.2.840.113549.1.1.13":
                return {
                    name: "RSASSA-PKCS1-v1_5",
                    hash: {
                        name: "SHA-512"
                    }
                };
            case "1.2.840.113549.1.1.10":
                return {
                    name: "RSA-PSS"
                };
            case "1.2.840.113549.1.1.7":
                return {
                    name: "RSA-OAEP"
                };
            case "1.2.840.10045.2.1":
            case "1.2.840.10045.4.1":
                return {
                    name: "ECDSA",
                    hash: {
                        name: "SHA-1"
                    }
                };
            case "1.2.840.10045.4.3.2":
                return {
                    name: "ECDSA",
                    hash: {
                        name: "SHA-256"
                    }
                };
            case "1.2.840.10045.4.3.3":
                return {
                    name: "ECDSA",
                    hash: {
                        name: "SHA-384"
                    }
                };
            case "1.2.840.10045.4.3.4":
                return {
                    name: "ECDSA",
                    hash: {
                        name: "SHA-512"
                    }
                };
            case "1.3.133.16.840.63.0.2":
                return {
                    name: "ECDH",
                    kdf: "SHA-1"
                };
            case "1.3.132.1.11.1":
                return {
                    name: "ECDH",
                    kdf: "SHA-256"
                };
            case "1.3.132.1.11.2":
                return {
                    name: "ECDH",
                    kdf: "SHA-384"
                };
            case "1.3.132.1.11.3":
                return {
                    name: "ECDH",
                    kdf: "SHA-512"
                };
            case "2.16.840.1.101.3.4.1.2":
                return {
                    name: "AES-CBC",
                    length: 128
                };
            case "2.16.840.1.101.3.4.1.22":
                return {
                    name: "AES-CBC",
                    length: 192
                };
            case "2.16.840.1.101.3.4.1.42":
                return {
                    name: "AES-CBC",
                    length: 256
                };
            case "2.16.840.1.101.3.4.1.6":
                return {
                    name: "AES-GCM",
                    length: 128
                };
            case "2.16.840.1.101.3.4.1.26":
                return {
                    name: "AES-GCM",
                    length: 192
                };
            case "2.16.840.1.101.3.4.1.46":
                return {
                    name: "AES-GCM",
                    length: 256
                };
            case "2.16.840.1.101.3.4.1.4":
                return {
                    name: "AES-CFB",
                    length: 128
                };
            case "2.16.840.1.101.3.4.1.24":
                return {
                    name: "AES-CFB",
                    length: 192
                };
            case "2.16.840.1.101.3.4.1.44":
                return {
                    name: "AES-CFB",
                    length: 256
                };
            case "2.16.840.1.101.3.4.1.5":
                return {
                    name: "AES-KW",
                    length: 128
                };
            case "2.16.840.1.101.3.4.1.25":
                return {
                    name: "AES-KW",
                    length: 192
                };
            case "2.16.840.1.101.3.4.1.45":
                return {
                    name: "AES-KW",
                    length: 256
                };
            case "1.2.840.113549.2.7":
                return {
                    name: "HMAC",
                    hash: {
                        name: "SHA-1"
                    }
                };
            case "1.2.840.113549.2.9":
                return {
                    name: "HMAC",
                    hash: {
                        name: "SHA-256"
                    }
                };
            case "1.2.840.113549.2.10":
                return {
                    name: "HMAC",
                    hash: {
                        name: "SHA-384"
                    }
                };
            case "1.2.840.113549.2.11":
                return {
                    name: "HMAC",
                    hash: {
                        name: "SHA-512"
                    }
                };
            case "1.2.840.113549.1.9.16.3.5":
                return {
                    name: "DH"
                };
            case "1.3.14.3.2.26":
                return {
                    name: "SHA-1"
                };
            case "2.16.840.1.101.3.4.2.1":
                return {
                    name: "SHA-256"
                };
            case "2.16.840.1.101.3.4.2.2":
                return {
                    name: "SHA-384"
                };
            case "2.16.840.1.101.3.4.2.3":
                return {
                    name: "SHA-512"
                };
            case "1.2.840.113549.1.5.12":
                return {
                    name: "PBKDF2"
                };
            case "1.2.840.10045.3.1.7":
                return {
                    name: "P-256"
                };
            case "1.3.132.0.34":
                return {
                    name: "P-384"
                };
            case "1.3.132.0.35":
                return {
                    name: "P-521"
                };
            default:
        }
        return {};
    }
    getOIDByAlgorithm(algorithm) {
        let result = "";
        switch(algorithm.name.toUpperCase()){
            case "RSASSA-PKCS1-V1_5":
                switch(algorithm.hash.name.toUpperCase()){
                    case "SHA-1":
                        result = "1.2.840.113549.1.1.5";
                        break;
                    case "SHA-256":
                        result = "1.2.840.113549.1.1.11";
                        break;
                    case "SHA-384":
                        result = "1.2.840.113549.1.1.12";
                        break;
                    case "SHA-512":
                        result = "1.2.840.113549.1.1.13";
                        break;
                    default:
                }
                break;
            case "RSA-PSS":
                result = "1.2.840.113549.1.1.10";
                break;
            case "RSA-OAEP":
                result = "1.2.840.113549.1.1.7";
                break;
            case "ECDSA":
                switch(algorithm.hash.name.toUpperCase()){
                    case "SHA-1":
                        result = "1.2.840.10045.4.1";
                        break;
                    case "SHA-256":
                        result = "1.2.840.10045.4.3.2";
                        break;
                    case "SHA-384":
                        result = "1.2.840.10045.4.3.3";
                        break;
                    case "SHA-512":
                        result = "1.2.840.10045.4.3.4";
                        break;
                    default:
                }
                break;
            case "ECDH":
                switch(algorithm.kdf.toUpperCase()){
                    case "SHA-1":
                        result = "1.3.133.16.840.63.0.2";
                        break;
                    case "SHA-256":
                        result = "1.3.132.1.11.1";
                        break;
                    case "SHA-384":
                        result = "1.3.132.1.11.2";
                        break;
                    case "SHA-512":
                        result = "1.3.132.1.11.3";
                        break;
                    default:
                }
                break;
            case "AES-CTR":
                break;
            case "AES-CBC":
                switch(algorithm.length){
                    case 128:
                        result = "2.16.840.1.101.3.4.1.2";
                        break;
                    case 192:
                        result = "2.16.840.1.101.3.4.1.22";
                        break;
                    case 256:
                        result = "2.16.840.1.101.3.4.1.42";
                        break;
                    default:
                }
                break;
            case "AES-CMAC":
                break;
            case "AES-GCM":
                switch(algorithm.length){
                    case 128:
                        result = "2.16.840.1.101.3.4.1.6";
                        break;
                    case 192:
                        result = "2.16.840.1.101.3.4.1.26";
                        break;
                    case 256:
                        result = "2.16.840.1.101.3.4.1.46";
                        break;
                    default:
                }
                break;
            case "AES-CFB":
                switch(algorithm.length){
                    case 128:
                        result = "2.16.840.1.101.3.4.1.4";
                        break;
                    case 192:
                        result = "2.16.840.1.101.3.4.1.24";
                        break;
                    case 256:
                        result = "2.16.840.1.101.3.4.1.44";
                        break;
                    default:
                }
                break;
            case "AES-KW":
                switch(algorithm.length){
                    case 128:
                        result = "2.16.840.1.101.3.4.1.5";
                        break;
                    case 192:
                        result = "2.16.840.1.101.3.4.1.25";
                        break;
                    case 256:
                        result = "2.16.840.1.101.3.4.1.45";
                        break;
                    default:
                }
                break;
            case "HMAC":
                switch(algorithm.hash.name.toUpperCase()){
                    case "SHA-1":
                        result = "1.2.840.113549.2.7";
                        break;
                    case "SHA-256":
                        result = "1.2.840.113549.2.9";
                        break;
                    case "SHA-384":
                        result = "1.2.840.113549.2.10";
                        break;
                    case "SHA-512":
                        result = "1.2.840.113549.2.11";
                        break;
                    default:
                }
                break;
            case "DH":
                result = "1.2.840.113549.1.9.16.3.5";
                break;
            case "SHA-1":
                result = "1.3.14.3.2.26";
                break;
            case "SHA-256":
                result = "2.16.840.1.101.3.4.2.1";
                break;
            case "SHA-384":
                result = "2.16.840.1.101.3.4.2.2";
                break;
            case "SHA-512":
                result = "2.16.840.1.101.3.4.2.3";
                break;
            case "CONCAT":
                break;
            case "HKDF":
                break;
            case "PBKDF2":
                result = "1.2.840.113549.1.5.12";
                break;
            case "P-256":
                result = "1.2.840.10045.3.1.7";
                break;
            case "P-384":
                result = "1.3.132.0.34";
                break;
            case "P-521":
                result = "1.3.132.0.35";
                break;
            default:
        }
        return result;
    }
    getAlgorithmParameters(algorithmName, operation) {
        let result = {
            algorithm: {},
            usages: []
        };
        switch(algorithmName.toUpperCase()){
            case "RSASSA-PKCS1-V1_5":
                switch(operation.toLowerCase()){
                    case "generatekey":
                        result = {
                            algorithm: {
                                name: "RSASSA-PKCS1-v1_5",
                                modulusLength: 2048,
                                publicExponent: new Uint8Array([
                                    0x01,
                                    0x00,
                                    0x01
                                ]),
                                hash: {
                                    name: "SHA-256"
                                }
                            },
                            usages: [
                                "sign",
                                "verify"
                            ]
                        };
                        break;
                    case "verify":
                    case "sign":
                    case "importkey":
                        result = {
                            algorithm: {
                                name: "RSASSA-PKCS1-v1_5",
                                hash: {
                                    name: "SHA-256"
                                }
                            },
                            usages: [
                                "verify"
                            ]
                        };
                        break;
                    case "exportkey":
                    default:
                        return {
                            algorithm: {
                                name: "RSASSA-PKCS1-v1_5"
                            },
                            usages: []
                        };
                }
                break;
            case "RSA-PSS":
                switch(operation.toLowerCase()){
                    case "sign":
                    case "verify":
                        result = {
                            algorithm: {
                                name: "RSA-PSS",
                                hash: {
                                    name: "SHA-1"
                                },
                                saltLength: 20
                            },
                            usages: [
                                "sign",
                                "verify"
                            ]
                        };
                        break;
                    case "generatekey":
                        result = {
                            algorithm: {
                                name: "RSA-PSS",
                                modulusLength: 2048,
                                publicExponent: new Uint8Array([
                                    0x01,
                                    0x00,
                                    0x01
                                ]),
                                hash: {
                                    name: "SHA-1"
                                }
                            },
                            usages: [
                                "sign",
                                "verify"
                            ]
                        };
                        break;
                    case "importkey":
                        result = {
                            algorithm: {
                                name: "RSA-PSS",
                                hash: {
                                    name: "SHA-1"
                                }
                            },
                            usages: [
                                "verify"
                            ]
                        };
                        break;
                    case "exportkey":
                    default:
                        return {
                            algorithm: {
                                name: "RSA-PSS"
                            },
                            usages: []
                        };
                }
                break;
            case "RSA-OAEP":
                switch(operation.toLowerCase()){
                    case "encrypt":
                    case "decrypt":
                        result = {
                            algorithm: {
                                name: "RSA-OAEP"
                            },
                            usages: [
                                "encrypt",
                                "decrypt"
                            ]
                        };
                        break;
                    case "generatekey":
                        result = {
                            algorithm: {
                                name: "RSA-OAEP",
                                modulusLength: 2048,
                                publicExponent: new Uint8Array([
                                    0x01,
                                    0x00,
                                    0x01
                                ]),
                                hash: {
                                    name: "SHA-256"
                                }
                            },
                            usages: [
                                "encrypt",
                                "decrypt",
                                "wrapKey",
                                "unwrapKey"
                            ]
                        };
                        break;
                    case "importkey":
                        result = {
                            algorithm: {
                                name: "RSA-OAEP",
                                hash: {
                                    name: "SHA-256"
                                }
                            },
                            usages: [
                                "encrypt"
                            ]
                        };
                        break;
                    case "exportkey":
                    default:
                        return {
                            algorithm: {
                                name: "RSA-OAEP"
                            },
                            usages: []
                        };
                }
                break;
            case "ECDSA":
                switch(operation.toLowerCase()){
                    case "generatekey":
                        result = {
                            algorithm: {
                                name: "ECDSA",
                                namedCurve: "P-256"
                            },
                            usages: [
                                "sign",
                                "verify"
                            ]
                        };
                        break;
                    case "importkey":
                        result = {
                            algorithm: {
                                name: "ECDSA",
                                namedCurve: "P-256"
                            },
                            usages: [
                                "verify"
                            ]
                        };
                        break;
                    case "verify":
                    case "sign":
                        result = {
                            algorithm: {
                                name: "ECDSA",
                                hash: {
                                    name: "SHA-256"
                                }
                            },
                            usages: [
                                "sign"
                            ]
                        };
                        break;
                    default:
                        return {
                            algorithm: {
                                name: "ECDSA"
                            },
                            usages: []
                        };
                }
                break;
            case "ECDH":
                switch(operation.toLowerCase()){
                    case "exportkey":
                    case "importkey":
                    case "generatekey":
                        result = {
                            algorithm: {
                                name: "ECDH",
                                namedCurve: "P-256"
                            },
                            usages: [
                                "deriveKey",
                                "deriveBits"
                            ]
                        };
                        break;
                    case "derivekey":
                    case "derivebits":
                        result = {
                            algorithm: {
                                name: "ECDH",
                                namedCurve: "P-256",
                                public: []
                            },
                            usages: [
                                "encrypt",
                                "decrypt"
                            ]
                        };
                        break;
                    default:
                        return {
                            algorithm: {
                                name: "ECDH"
                            },
                            usages: []
                        };
                }
                break;
            case "AES-CTR":
                switch(operation.toLowerCase()){
                    case "importkey":
                    case "exportkey":
                    case "generatekey":
                        result = {
                            algorithm: {
                                name: "AES-CTR",
                                length: 256
                            },
                            usages: [
                                "encrypt",
                                "decrypt",
                                "wrapKey",
                                "unwrapKey"
                            ]
                        };
                        break;
                    case "decrypt":
                    case "encrypt":
                        result = {
                            algorithm: {
                                name: "AES-CTR",
                                counter: new Uint8Array(16),
                                length: 10
                            },
                            usages: [
                                "encrypt",
                                "decrypt",
                                "wrapKey",
                                "unwrapKey"
                            ]
                        };
                        break;
                    default:
                        return {
                            algorithm: {
                                name: "AES-CTR"
                            },
                            usages: []
                        };
                }
                break;
            case "AES-CBC":
                switch(operation.toLowerCase()){
                    case "importkey":
                    case "exportkey":
                    case "generatekey":
                        result = {
                            algorithm: {
                                name: "AES-CBC",
                                length: 256
                            },
                            usages: [
                                "encrypt",
                                "decrypt",
                                "wrapKey",
                                "unwrapKey"
                            ]
                        };
                        break;
                    case "decrypt":
                    case "encrypt":
                        result = {
                            algorithm: {
                                name: "AES-CBC",
                                iv: this.getRandomValues(new Uint8Array(16))
                            },
                            usages: [
                                "encrypt",
                                "decrypt",
                                "wrapKey",
                                "unwrapKey"
                            ]
                        };
                        break;
                    default:
                        return {
                            algorithm: {
                                name: "AES-CBC"
                            },
                            usages: []
                        };
                }
                break;
            case "AES-GCM":
                switch(operation.toLowerCase()){
                    case "importkey":
                    case "exportkey":
                    case "generatekey":
                        result = {
                            algorithm: {
                                name: "AES-GCM",
                                length: 256
                            },
                            usages: [
                                "encrypt",
                                "decrypt",
                                "wrapKey",
                                "unwrapKey"
                            ]
                        };
                        break;
                    case "decrypt":
                    case "encrypt":
                        result = {
                            algorithm: {
                                name: "AES-GCM",
                                iv: this.getRandomValues(new Uint8Array(16))
                            },
                            usages: [
                                "encrypt",
                                "decrypt",
                                "wrapKey",
                                "unwrapKey"
                            ]
                        };
                        break;
                    default:
                        return {
                            algorithm: {
                                name: "AES-GCM"
                            },
                            usages: []
                        };
                }
                break;
            case "AES-KW":
                switch(operation.toLowerCase()){
                    case "importkey":
                    case "exportkey":
                    case "generatekey":
                    case "wrapkey":
                    case "unwrapkey":
                        result = {
                            algorithm: {
                                name: "AES-KW",
                                length: 256
                            },
                            usages: [
                                "wrapKey",
                                "unwrapKey"
                            ]
                        };
                        break;
                    default:
                        return {
                            algorithm: {
                                name: "AES-KW"
                            },
                            usages: []
                        };
                }
                break;
            case "HMAC":
                switch(operation.toLowerCase()){
                    case "sign":
                    case "verify":
                        result = {
                            algorithm: {
                                name: "HMAC"
                            },
                            usages: [
                                "sign",
                                "verify"
                            ]
                        };
                        break;
                    case "importkey":
                    case "exportkey":
                    case "generatekey":
                        result = {
                            algorithm: {
                                name: "HMAC",
                                length: 32,
                                hash: {
                                    name: "SHA-256"
                                }
                            },
                            usages: [
                                "sign",
                                "verify"
                            ]
                        };
                        break;
                    default:
                        return {
                            algorithm: {
                                name: "HMAC"
                            },
                            usages: []
                        };
                }
                break;
            case "HKDF":
                switch(operation.toLowerCase()){
                    case "derivekey":
                        result = {
                            algorithm: {
                                name: "HKDF",
                                hash: "SHA-256",
                                salt: new Uint8Array([]),
                                info: new Uint8Array([])
                            },
                            usages: [
                                "encrypt",
                                "decrypt"
                            ]
                        };
                        break;
                    default:
                        return {
                            algorithm: {
                                name: "HKDF"
                            },
                            usages: []
                        };
                }
                break;
            case "PBKDF2":
                switch(operation.toLowerCase()){
                    case "derivekey":
                        result = {
                            algorithm: {
                                name: "PBKDF2",
                                hash: {
                                    name: "SHA-256"
                                },
                                salt: new Uint8Array([]),
                                iterations: 10000
                            },
                            usages: [
                                "encrypt",
                                "decrypt"
                            ]
                        };
                        break;
                    default:
                        return {
                            algorithm: {
                                name: "PBKDF2"
                            },
                            usages: []
                        };
                }
                break;
            default:
        }
        return result;
    }
    getHashAlgorithm(signatureAlgorithm) {
        let result = "";
        switch(signatureAlgorithm.algorithmId){
            case "1.2.840.10045.4.1":
            case "1.2.840.113549.1.1.5":
                result = "SHA-1";
                break;
            case "1.2.840.10045.4.3.2":
            case "1.2.840.113549.1.1.11":
                result = "SHA-256";
                break;
            case "1.2.840.10045.4.3.3":
            case "1.2.840.113549.1.1.12":
                result = "SHA-384";
                break;
            case "1.2.840.10045.4.3.4":
            case "1.2.840.113549.1.1.13":
                result = "SHA-512";
                break;
            case "1.2.840.113549.1.1.10":
                {
                    try {
                        const params = new RSASSAPSSParams({
                            schema: signatureAlgorithm.algorithmParams
                        });
                        if ("hashAlgorithm" in params) {
                            const algorithm = this.getAlgorithmByOID(params.hashAlgorithm.algorithmId);
                            if ("name" in algorithm === false) return "";
                            result = algorithm.name;
                        } else result = "SHA-1";
                    } catch (ex) {}
                }
                break;
            default:
        }
        return result;
    }
    encryptEncryptedContentInfo(parameters) {
        if (parameters instanceof Object === false) return Promise.reject("Parameters must have type \"Object\"");
        if ("password" in parameters === false) return Promise.reject("Absent mandatory parameter \"password\"");
        if ("contentEncryptionAlgorithm" in parameters === false) return Promise.reject("Absent mandatory parameter \"contentEncryptionAlgorithm\"");
        if ("hmacHashAlgorithm" in parameters === false) return Promise.reject("Absent mandatory parameter \"hmacHashAlgorithm\"");
        if ("iterationCount" in parameters === false) return Promise.reject("Absent mandatory parameter \"iterationCount\"");
        if ("contentToEncrypt" in parameters === false) return Promise.reject("Absent mandatory parameter \"contentToEncrypt\"");
        if ("contentType" in parameters === false) return Promise.reject("Absent mandatory parameter \"contentType\"");
        const contentEncryptionOID = this.getOIDByAlgorithm(parameters.contentEncryptionAlgorithm);
        if (contentEncryptionOID === "") return Promise.reject("Wrong \"contentEncryptionAlgorithm\" value");
        const pbkdf2OID = this.getOIDByAlgorithm({
            name: "PBKDF2"
        });
        if (pbkdf2OID === "") return Promise.reject("Can not find OID for PBKDF2");
        const hmacOID = this.getOIDByAlgorithm({
            name: "HMAC",
            hash: {
                name: parameters.hmacHashAlgorithm
            }
        });
        if (hmacOID === "") return Promise.reject(`Incorrect value for "hmacHashAlgorithm": ${parameters.hmacHashAlgorithm}`);
        let sequence = Promise.resolve();
        const ivBuffer = new ArrayBuffer(16);
        const ivView = new Uint8Array(ivBuffer);
        this.getRandomValues(ivView);
        const saltBuffer = new ArrayBuffer(64);
        const saltView = new Uint8Array(saltBuffer);
        this.getRandomValues(saltView);
        const contentView = new Uint8Array(parameters.contentToEncrypt);
        const pbkdf2Params = new PBKDF2Params({
            salt: new OctetString({
                valueHex: saltBuffer
            }),
            iterationCount: parameters.iterationCount,
            prf: new AlgorithmIdentifier({
                algorithmId: hmacOID,
                algorithmParams: new Null()
            })
        });
        sequence = sequence.then(()=>{
            const passwordView = new Uint8Array(parameters.password);
            return this.importKey("raw", passwordView, "PBKDF2", false, [
                "deriveKey"
            ]);
        }, (error4)=>Promise.reject(error4)
        );
        sequence = sequence.then((result)=>this.deriveKey({
                name: "PBKDF2",
                hash: {
                    name: parameters.hmacHashAlgorithm
                },
                salt: saltView,
                iterations: parameters.iterationCount
            }, result, parameters.contentEncryptionAlgorithm, false, [
                "encrypt"
            ])
        , (error5)=>Promise.reject(error5)
        );
        sequence = sequence.then((result)=>this.encrypt({
                name: parameters.contentEncryptionAlgorithm.name,
                iv: ivView
            }, result, contentView)
        , (error6)=>Promise.reject(error6)
        );
        sequence = sequence.then((result)=>{
            const pbes2Parameters = new PBES2Params({
                keyDerivationFunc: new AlgorithmIdentifier({
                    algorithmId: pbkdf2OID,
                    algorithmParams: pbkdf2Params.toSchema()
                }),
                encryptionScheme: new AlgorithmIdentifier({
                    algorithmId: contentEncryptionOID,
                    algorithmParams: new OctetString({
                        valueHex: ivBuffer
                    })
                })
            });
            return new EncryptedContentInfo({
                contentType: parameters.contentType,
                contentEncryptionAlgorithm: new AlgorithmIdentifier({
                    algorithmId: "1.2.840.113549.1.5.13",
                    algorithmParams: pbes2Parameters.toSchema()
                }),
                encryptedContent: new OctetString({
                    valueHex: result
                })
            });
        }, (error7)=>Promise.reject(error7)
        );
        return sequence;
    }
    decryptEncryptedContentInfo(parameters) {
        if (parameters instanceof Object === false) return Promise.reject("Parameters must have type \"Object\"");
        if ("password" in parameters === false) return Promise.reject("Absent mandatory parameter \"password\"");
        if ("encryptedContentInfo" in parameters === false) return Promise.reject("Absent mandatory parameter \"encryptedContentInfo\"");
        if (parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId !== "1.2.840.113549.1.5.13") return Promise.reject(`Unknown "contentEncryptionAlgorithm": ${parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
        let sequence = Promise.resolve();
        let pbes2Parameters;
        try {
            pbes2Parameters = new PBES2Params({
                schema: parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams
            });
        } catch (ex) {
            return Promise.reject("Incorrectly encoded \"pbes2Parameters\"");
        }
        let pbkdf2Params;
        try {
            pbkdf2Params = new PBKDF2Params({
                schema: pbes2Parameters.keyDerivationFunc.algorithmParams
            });
        } catch (ex1) {
            return Promise.reject("Incorrectly encoded \"pbkdf2Params\"");
        }
        const contentEncryptionAlgorithm = this.getAlgorithmByOID(pbes2Parameters.encryptionScheme.algorithmId);
        if ("name" in contentEncryptionAlgorithm === false) return Promise.reject(`Incorrect OID for "contentEncryptionAlgorithm": ${pbes2Parameters.encryptionScheme.algorithmId}`);
        const ivBuffer = pbes2Parameters.encryptionScheme.algorithmParams.valueBlock.valueHex;
        const ivView = new Uint8Array(ivBuffer);
        const saltBuffer = pbkdf2Params.salt.valueBlock.valueHex;
        const saltView = new Uint8Array(saltBuffer);
        const iterationCount = pbkdf2Params.iterationCount;
        let hmacHashAlgorithm = "SHA-1";
        if ("prf" in pbkdf2Params) {
            const algorithm = this.getAlgorithmByOID(pbkdf2Params.prf.algorithmId);
            if ("name" in algorithm === false) return Promise.reject("Incorrect OID for HMAC hash algorithm");
            hmacHashAlgorithm = algorithm.hash.name;
        }
        sequence = sequence.then(()=>this.importKey("raw", parameters.password, "PBKDF2", false, [
                "deriveKey"
            ])
        , (error8)=>Promise.reject(error8)
        );
        sequence = sequence.then((result)=>this.deriveKey({
                name: "PBKDF2",
                hash: {
                    name: hmacHashAlgorithm
                },
                salt: saltView,
                iterations: iterationCount
            }, result, contentEncryptionAlgorithm, false, [
                "decrypt"
            ])
        , (error9)=>Promise.reject(error9)
        );
        sequence = sequence.then((result)=>{
            let dataBuffer = new ArrayBuffer(0);
            if (parameters.encryptedContentInfo.encryptedContent.idBlock.isConstructed === false) dataBuffer = parameters.encryptedContentInfo.encryptedContent.valueBlock.valueHex;
            else {
                for (const content of parameters.encryptedContentInfo.encryptedContent.valueBlock.value)dataBuffer = utilConcatBuf(dataBuffer, content.valueBlock.valueHex);
            }
            return this.decrypt({
                name: contentEncryptionAlgorithm.name,
                iv: ivView
            }, result, dataBuffer);
        }, (error10)=>Promise.reject(error10)
        );
        return sequence;
    }
    stampDataWithPassword(parameters) {
        if (parameters instanceof Object === false) return Promise.reject("Parameters must have type \"Object\"");
        if ("password" in parameters === false) return Promise.reject("Absent mandatory parameter \"password\"");
        if ("hashAlgorithm" in parameters === false) return Promise.reject("Absent mandatory parameter \"hashAlgorithm\"");
        if ("salt" in parameters === false) return Promise.reject("Absent mandatory parameter \"iterationCount\"");
        if ("iterationCount" in parameters === false) return Promise.reject("Absent mandatory parameter \"salt\"");
        if ("contentToStamp" in parameters === false) return Promise.reject("Absent mandatory parameter \"contentToStamp\"");
        let length;
        switch(parameters.hashAlgorithm.toLowerCase()){
            case "sha-1":
                length = 160;
                break;
            case "sha-256":
                length = 256;
                break;
            case "sha-384":
                length = 384;
                break;
            case "sha-512":
                length = 512;
                break;
            default:
                return Promise.reject(`Incorrect "parameters.hashAlgorithm" parameter: ${parameters.hashAlgorithm}`);
        }
        let sequence = Promise.resolve();
        const hmacAlgorithm = {
            name: "HMAC",
            length,
            hash: {
                name: parameters.hashAlgorithm
            }
        };
        sequence = sequence.then(()=>makePKCS12B2Key(this, parameters.hashAlgorithm, length, parameters.password, parameters.salt, parameters.iterationCount)
        );
        sequence = sequence.then((result)=>this.importKey("raw", new Uint8Array(result), hmacAlgorithm, false, [
                "sign"
            ])
        );
        sequence = sequence.then((result)=>this.sign(hmacAlgorithm, result, new Uint8Array(parameters.contentToStamp))
        , (error11)=>Promise.reject(error11)
        );
        return sequence;
    }
    verifyDataStampedWithPassword(parameters) {
        if (parameters instanceof Object === false) return Promise.reject("Parameters must have type \"Object\"");
        if ("password" in parameters === false) return Promise.reject("Absent mandatory parameter \"password\"");
        if ("hashAlgorithm" in parameters === false) return Promise.reject("Absent mandatory parameter \"hashAlgorithm\"");
        if ("salt" in parameters === false) return Promise.reject("Absent mandatory parameter \"iterationCount\"");
        if ("iterationCount" in parameters === false) return Promise.reject("Absent mandatory parameter \"salt\"");
        if ("contentToVerify" in parameters === false) return Promise.reject("Absent mandatory parameter \"contentToVerify\"");
        if ("signatureToVerify" in parameters === false) return Promise.reject("Absent mandatory parameter \"signatureToVerify\"");
        let length;
        switch(parameters.hashAlgorithm.toLowerCase()){
            case "sha-1":
                length = 160;
                break;
            case "sha-256":
                length = 256;
                break;
            case "sha-384":
                length = 384;
                break;
            case "sha-512":
                length = 512;
                break;
            default:
                return Promise.reject(`Incorrect "parameters.hashAlgorithm" parameter: ${parameters.hashAlgorithm}`);
        }
        let sequence = Promise.resolve();
        const hmacAlgorithm = {
            name: "HMAC",
            length,
            hash: {
                name: parameters.hashAlgorithm
            }
        };
        sequence = sequence.then(()=>makePKCS12B2Key(this, parameters.hashAlgorithm, length, parameters.password, parameters.salt, parameters.iterationCount)
        );
        sequence = sequence.then((result)=>this.importKey("raw", new Uint8Array(result), hmacAlgorithm, false, [
                "verify"
            ])
        );
        sequence = sequence.then((result)=>this.verify(hmacAlgorithm, result, new Uint8Array(parameters.signatureToVerify), new Uint8Array(parameters.contentToVerify))
        , (error12)=>Promise.reject(error12)
        );
        return sequence;
    }
    getSignatureParameters(privateKey, hashAlgorithm = "SHA-1") {
        const oid = this.getOIDByAlgorithm({
            name: hashAlgorithm
        });
        if (oid === "") return Promise.reject(`Unsupported hash algorithm: ${hashAlgorithm}`);
        const signatureAlgorithm = new AlgorithmIdentifier();
        const parameters = this.getAlgorithmParameters(privateKey.algorithm.name, "sign");
        parameters.algorithm.hash.name = hashAlgorithm;
        switch(privateKey.algorithm.name.toUpperCase()){
            case "RSASSA-PKCS1-V1_5":
            case "ECDSA":
                signatureAlgorithm.algorithmId = this.getOIDByAlgorithm(parameters.algorithm);
                break;
            case "RSA-PSS":
                {
                    switch(hashAlgorithm.toUpperCase()){
                        case "SHA-256":
                            parameters.algorithm.saltLength = 32;
                            break;
                        case "SHA-384":
                            parameters.algorithm.saltLength = 48;
                            break;
                        case "SHA-512":
                            parameters.algorithm.saltLength = 64;
                            break;
                        default:
                    }
                    const paramsObject = {};
                    if (hashAlgorithm.toUpperCase() !== "SHA-1") {
                        const hashAlgorithmOID = this.getOIDByAlgorithm({
                            name: hashAlgorithm
                        });
                        if (hashAlgorithmOID === "") return Promise.reject(`Unsupported hash algorithm: ${hashAlgorithm}`);
                        paramsObject.hashAlgorithm = new AlgorithmIdentifier({
                            algorithmId: hashAlgorithmOID,
                            algorithmParams: new Null()
                        });
                        paramsObject.maskGenAlgorithm = new AlgorithmIdentifier({
                            algorithmId: "1.2.840.113549.1.1.8",
                            algorithmParams: paramsObject.hashAlgorithm.toSchema()
                        });
                    }
                    if (parameters.algorithm.saltLength !== 20) paramsObject.saltLength = parameters.algorithm.saltLength;
                    const pssParameters = new RSASSAPSSParams(paramsObject);
                    signatureAlgorithm.algorithmId = "1.2.840.113549.1.1.10";
                    signatureAlgorithm.algorithmParams = pssParameters.toSchema();
                }
                break;
            default:
                return Promise.reject(`Unsupported signature algorithm: ${privateKey.algorithm.name}`);
        }
        return Promise.resolve().then(()=>({
                signatureAlgorithm,
                parameters
            })
        );
    }
    signWithPrivateKey(data, privateKey, parameters) {
        return this.sign(parameters.algorithm, privateKey, new Uint8Array(data)).then((result)=>{
            if (parameters.algorithm.name === "ECDSA") result = createCMSECDSASignature(result);
            return result;
        }, (error13)=>Promise.reject(`Signing error: ${error13}`)
        );
    }
    fillPublicKeyParameters(publicKeyInfo, signatureAlgorithm) {
        const parameters = {};
        const shaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);
        if (shaAlgorithm === "") return Promise.reject(`Unsupported signature algorithm: ${signatureAlgorithm.algorithmId}`);
        let algorithmId;
        if (signatureAlgorithm.algorithmId === "1.2.840.113549.1.1.10") algorithmId = signatureAlgorithm.algorithmId;
        else algorithmId = publicKeyInfo.algorithm.algorithmId;
        const algorithmObject = this.getAlgorithmByOID(algorithmId);
        if ("name" in algorithmObject === "") return Promise.reject(`Unsupported public key algorithm: ${signatureAlgorithm.algorithmId}`);
        parameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, "importkey");
        if ("hash" in parameters.algorithm.algorithm) parameters.algorithm.algorithm.hash.name = shaAlgorithm;
        if (algorithmObject.name === "ECDSA") {
            let algorithmParamsChecked = false;
            if ("algorithmParams" in publicKeyInfo.algorithm === true) {
                if ("idBlock" in publicKeyInfo.algorithm.algorithmParams) {
                    if (publicKeyInfo.algorithm.algorithmParams.idBlock.tagClass === 1 && publicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber === 6) algorithmParamsChecked = true;
                }
            }
            if (algorithmParamsChecked === false) return Promise.reject("Incorrect type for ECDSA public key parameters");
            const curveObject = this.getAlgorithmByOID(publicKeyInfo.algorithm.algorithmParams.valueBlock.toString());
            if ("name" in curveObject === false) return Promise.reject(`Unsupported named curve algorithm: ${publicKeyInfo.algorithm.algorithmParams.valueBlock.toString()}`);
            parameters.algorithm.algorithm.namedCurve = curveObject.name;
        }
        return parameters;
    }
    getPublicKey(publicKeyInfo, signatureAlgorithm, parameters = null) {
        if (parameters === null) parameters = this.fillPublicKeyParameters(publicKeyInfo, signatureAlgorithm);
        const publicKeyInfoSchema = publicKeyInfo.toSchema();
        const publicKeyInfoBuffer = publicKeyInfoSchema.toBER(false);
        const publicKeyInfoView = new Uint8Array(publicKeyInfoBuffer);
        return this.importKey("spki", publicKeyInfoView, parameters.algorithm.algorithm, true, parameters.algorithm.usages);
    }
    verifyWithPublicKey(data, signature, publicKeyInfo, signatureAlgorithm, shaAlgorithm = null) {
        let sequence = Promise.resolve();
        if (shaAlgorithm === null) {
            shaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);
            if (shaAlgorithm === "") return Promise.reject(`Unsupported signature algorithm: ${signatureAlgorithm.algorithmId}`);
            sequence = sequence.then(()=>this.getPublicKey(publicKeyInfo, signatureAlgorithm)
            );
        } else {
            const parameters = {};
            let algorithmId;
            if (signatureAlgorithm.algorithmId === "1.2.840.113549.1.1.10") algorithmId = signatureAlgorithm.algorithmId;
            else algorithmId = publicKeyInfo.algorithm.algorithmId;
            const algorithmObject = this.getAlgorithmByOID(algorithmId);
            if ("name" in algorithmObject === "") return Promise.reject(`Unsupported public key algorithm: ${signatureAlgorithm.algorithmId}`);
            parameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, "importkey");
            if ("hash" in parameters.algorithm.algorithm) parameters.algorithm.algorithm.hash.name = shaAlgorithm;
            if (algorithmObject.name === "ECDSA") {
                let algorithmParamsChecked = false;
                if ("algorithmParams" in publicKeyInfo.algorithm === true) {
                    if ("idBlock" in publicKeyInfo.algorithm.algorithmParams) {
                        if (publicKeyInfo.algorithm.algorithmParams.idBlock.tagClass === 1 && publicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber === 6) algorithmParamsChecked = true;
                    }
                }
                if (algorithmParamsChecked === false) return Promise.reject("Incorrect type for ECDSA public key parameters");
                const curveObject = this.getAlgorithmByOID(publicKeyInfo.algorithm.algorithmParams.valueBlock.toString());
                if ("name" in curveObject === false) return Promise.reject(`Unsupported named curve algorithm: ${publicKeyInfo.algorithm.algorithmParams.valueBlock.toString()}`);
                parameters.algorithm.algorithm.namedCurve = curveObject.name;
            }
            sequence = sequence.then(()=>this.getPublicKey(publicKeyInfo, null, parameters)
            );
        }
        sequence = sequence.then((publicKey)=>{
            const algorithm = this.getAlgorithmParameters(publicKey.algorithm.name, "verify");
            if ("hash" in algorithm.algorithm) algorithm.algorithm.hash.name = shaAlgorithm;
            let signatureValue = signature.valueBlock.valueHex;
            if (publicKey.algorithm.name === "ECDSA") {
                const asn1 = fromBER(signatureValue);
                signatureValue = createECDSASignatureFromCMS(asn1.result);
            }
            if (publicKey.algorithm.name === "RSA-PSS") {
                let pssParameters;
                try {
                    pssParameters = new RSASSAPSSParams({
                        schema: signatureAlgorithm.algorithmParams
                    });
                } catch (ex) {
                    return Promise.reject(ex);
                }
                if ("saltLength" in pssParameters) algorithm.algorithm.saltLength = pssParameters.saltLength;
                else algorithm.algorithm.saltLength = 20;
                let hashAlgo = "SHA-1";
                if ("hashAlgorithm" in pssParameters) {
                    const hashAlgorithm = this.getAlgorithmByOID(pssParameters.hashAlgorithm.algorithmId);
                    if ("name" in hashAlgorithm === false) return Promise.reject(`Unrecognized hash algorithm: ${pssParameters.hashAlgorithm.algorithmId}`);
                    hashAlgo = hashAlgorithm.name;
                }
                algorithm.algorithm.hash.name = hashAlgo;
            }
            return this.verify(algorithm.algorithm, publicKey, new Uint8Array(signatureValue), new Uint8Array(data));
        });
        return sequence;
    }
}
(function initCryptoEngine() {
    if (typeof self !== "undefined") {
        if ("crypto" in self) {
            let engineName = "webcrypto";
            const cryptoObject = self.crypto;
            let subtleObject = null;
            if ("webkitSubtle" in self.crypto) {
                try {
                    subtleObject = self.crypto.webkitSubtle;
                } catch (ex) {
                    subtleObject = self.crypto.subtle;
                }
                engineName = "safari";
            }
            if ("subtle" in self.crypto) subtleObject = self.crypto.subtle;
            engine = {
                name: engineName,
                crypto: cryptoObject,
                subtle: new CryptoEngine({
                    name: engineName,
                    crypto: self.crypto,
                    subtle: subtleObject
                })
            };
        }
    }
    setEngine(engine.name, engine.crypto, engine.subtle);
})();
function stringPrep(inputString) {
    let isSpace = false;
    let cuttedResult = "";
    const result = inputString.trim();
    for(let i144 = 0; i144 < result.length; i144++){
        if (result.charCodeAt(i144) === 32) {
            if (isSpace === false) isSpace = true;
        } else {
            if (isSpace) {
                cuttedResult += " ";
                isSpace = false;
            }
            cuttedResult += result[i144];
        }
    }
    return cuttedResult.toLowerCase();
}
function getAlgorithmByOID(oid) {
    return getEngine().subtle.getAlgorithmByOID(oid);
}
function kdfWithCounter(hashFunction, Zbuffer, Counter, SharedInfo) {
    switch(hashFunction.toUpperCase()){
        case "SHA-1":
        case "SHA-256":
        case "SHA-384":
        case "SHA-512":
            break;
        default:
            return Promise.reject(`Unknown hash function: ${hashFunction}`);
    }
    if (Zbuffer instanceof ArrayBuffer === false) return Promise.reject("Please set \"Zbuffer\" as \"ArrayBuffer\"");
    if (Zbuffer.byteLength === 0) return Promise.reject("\"Zbuffer\" has zero length, error");
    if (SharedInfo instanceof ArrayBuffer === false) return Promise.reject("Please set \"SharedInfo\" as \"ArrayBuffer\"");
    if (Counter > 255) return Promise.reject("Please set \"Counter\" variable to value less or equal to 255");
    const counterBuffer = new ArrayBuffer(4);
    const counterView = new Uint8Array(counterBuffer);
    counterView[0] = 0x00;
    counterView[1] = 0x00;
    counterView[2] = 0x00;
    counterView[3] = Counter;
    let combinedBuffer = new ArrayBuffer(0);
    const crypto = getCrypto();
    if (typeof crypto === "undefined") return Promise.reject("Unable to create WebCrypto object");
    combinedBuffer = utilConcatBuf(combinedBuffer, Zbuffer);
    combinedBuffer = utilConcatBuf(combinedBuffer, counterBuffer);
    combinedBuffer = utilConcatBuf(combinedBuffer, SharedInfo);
    return crypto.digest({
        name: hashFunction
    }, combinedBuffer).then((result)=>({
            counter: Counter,
            result
        })
    );
}
function kdf(hashFunction, Zbuffer, keydatalen, SharedInfo) {
    let hashLength = 0;
    let maxCounter = 1;
    const kdfArray = [];
    switch(hashFunction.toUpperCase()){
        case "SHA-1":
            hashLength = 160;
            break;
        case "SHA-256":
            hashLength = 256;
            break;
        case "SHA-384":
            hashLength = 384;
            break;
        case "SHA-512":
            hashLength = 512;
            break;
        default:
            return Promise.reject(`Unknown hash function: ${hashFunction}`);
    }
    if (Zbuffer instanceof ArrayBuffer === false) return Promise.reject("Please set \"Zbuffer\" as \"ArrayBuffer\"");
    if (Zbuffer.byteLength === 0) return Promise.reject("\"Zbuffer\" has zero length, error");
    if (SharedInfo instanceof ArrayBuffer === false) return Promise.reject("Please set \"SharedInfo\" as \"ArrayBuffer\"");
    const quotient = keydatalen / hashLength;
    if (Math.floor(quotient) > 0) {
        maxCounter = Math.floor(quotient);
        if (quotient - maxCounter > 0) maxCounter++;
    }
    for(let i1 = 1; i1 <= maxCounter; i1++)kdfArray.push(kdfWithCounter(hashFunction, Zbuffer, i1, SharedInfo));
    return Promise.all(kdfArray).then((incomingResult)=>{
        let combinedBuffer = new ArrayBuffer(0);
        let currentCounter = 1;
        let found = true;
        while(found){
            found = false;
            for (const result of incomingResult){
                if (result.counter === currentCounter) {
                    combinedBuffer = utilConcatBuf(combinedBuffer, result.result);
                    found = true;
                    break;
                }
            }
            currentCounter++;
        }
        keydatalen >>= 3;
        if (combinedBuffer.byteLength > keydatalen) {
            const newBuffer = new ArrayBuffer(keydatalen);
            const newView = new Uint8Array(newBuffer);
            const combinedView = new Uint8Array(combinedBuffer);
            for(let i145 = 0; i145 < keydatalen; i145++)newView[i145] = combinedView[i145];
            return newBuffer;
        }
        return combinedBuffer;
    });
}
class AttributeTypeAndValue {
    constructor(parameters = {}){
        this.type = getParametersValue(parameters, "type", AttributeTypeAndValue.defaultValues("type"));
        this.value = getParametersValue(parameters, "value", AttributeTypeAndValue.defaultValues("value"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "type":
                return "";
            case "value":
                return {};
            default:
                throw new Error(`Invalid member name for AttributeTypeAndValue class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new ObjectIdentifier({
                    name: names.type || ""
                }),
                new Any({
                    name: names.value || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "type",
            "typeValue"
        ]);
        const asn1 = compareSchema(schema, schema, AttributeTypeAndValue.schema({
            names: {
                type: "type",
                value: "typeValue"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for AttributeTypeAndValue");
        this.type = asn1.result.type.valueBlock.toString();
        this.value = asn1.result.typeValue;
    }
    toSchema() {
        return new Sequence({
            value: [
                new ObjectIdentifier({
                    value: this.type
                }),
                this.value
            ]
        });
    }
    toJSON() {
        const _object = {
            type: this.type
        };
        if (Object.keys(this.value).length !== 0) _object.value = this.value.toJSON();
        else _object.value = this.value;
        return _object;
    }
    isEqual(compareTo) {
        if (compareTo instanceof AttributeTypeAndValue) {
            if (this.type !== compareTo.type) return false;
            if (this.value instanceof Utf8String && compareTo.value instanceof Utf8String || this.value instanceof BmpString && compareTo.value instanceof BmpString || this.value instanceof UniversalString && compareTo.value instanceof UniversalString || this.value instanceof NumericString && compareTo.value instanceof NumericString || this.value instanceof PrintableString && compareTo.value instanceof PrintableString || this.value instanceof TeletexString && compareTo.value instanceof TeletexString || this.value instanceof VideotexString && compareTo.value instanceof VideotexString || this.value instanceof IA5String && compareTo.value instanceof IA5String || this.value instanceof GraphicString && compareTo.value instanceof GraphicString || this.value instanceof VisibleString && compareTo.value instanceof VisibleString || this.value instanceof GeneralString && compareTo.value instanceof GeneralString || this.value instanceof CharacterString && compareTo.value instanceof CharacterString) {
                const value1 = stringPrep(this.value.valueBlock.value);
                const value2 = stringPrep(compareTo.value.valueBlock.value);
                if (value1.localeCompare(value2) !== 0) return false;
            } else {
                if (isEqualBuffer(this.value.valueBeforeDecode, compareTo.value.valueBeforeDecode) === false) return false;
            }
            return true;
        }
        if (compareTo instanceof ArrayBuffer) return isEqualBuffer(this.value.valueBeforeDecode, compareTo);
        return false;
    }
}
class RelativeDistinguishedNames {
    constructor(parameters = {}){
        this.typesAndValues = getParametersValue(parameters, "typesAndValues", RelativeDistinguishedNames.defaultValues("typesAndValues"));
        this.valueBeforeDecode = getParametersValue(parameters, "valueBeforeDecode", RelativeDistinguishedNames.defaultValues("valueBeforeDecode"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "typesAndValues":
                return [];
            case "valueBeforeDecode":
                return new ArrayBuffer(0);
            default:
                throw new Error(`Invalid member name for RelativeDistinguishedNames class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "typesAndValues":
                return memberValue.length === 0;
            case "valueBeforeDecode":
                return memberValue.byteLength === 0;
            default:
                throw new Error(`Invalid member name for RelativeDistinguishedNames class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Repeated({
                    name: names.repeatedSequence || "",
                    value: new Set1({
                        value: [
                            new Repeated({
                                name: names.repeatedSet || "",
                                value: AttributeTypeAndValue.schema(names.typeAndValue || {})
                            })
                        ]
                    })
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "RDN",
            "typesAndValues"
        ]);
        const asn1 = compareSchema(schema, schema, RelativeDistinguishedNames.schema({
            names: {
                blockName: "RDN",
                repeatedSet: "typesAndValues"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for RelativeDistinguishedNames");
        if ("typesAndValues" in asn1.result) this.typesAndValues = Array.from(asn1.result.typesAndValues, (element)=>new AttributeTypeAndValue({
                schema: element
            })
        );
        this.valueBeforeDecode = asn1.result.RDN.valueBeforeDecode;
    }
    toSchema() {
        if (this.valueBeforeDecode.byteLength === 0) {
            return new Sequence({
                value: [
                    new Set1({
                        value: Array.from(this.typesAndValues, (element)=>element.toSchema()
                        )
                    })
                ]
            });
        }
        const asn1 = fromBER(this.valueBeforeDecode);
        return asn1.result;
    }
    toJSON() {
        return {
            typesAndValues: Array.from(this.typesAndValues, (element)=>element.toJSON()
            )
        };
    }
    isEqual(compareTo) {
        if (compareTo instanceof RelativeDistinguishedNames) {
            if (this.typesAndValues.length !== compareTo.typesAndValues.length) return false;
            for (const [index, typeAndValue] of this.typesAndValues.entries()){
                if (typeAndValue.isEqual(compareTo.typesAndValues[index]) === false) return false;
            }
            return true;
        }
        if (compareTo instanceof ArrayBuffer) return isEqualBuffer(this.valueBeforeDecode, compareTo);
        return false;
    }
}
function builtInStandardAttributes(parameters = {}, optional = false) {
    const names = getParametersValue(parameters, "names", {});
    return new Sequence({
        optional,
        value: [
            new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 2,
                    tagNumber: 1
                },
                name: names.country_name || "",
                value: [
                    new Choice({
                        value: [
                            new NumericString(),
                            new PrintableString()
                        ]
                    })
                ]
            }),
            new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 2,
                    tagNumber: 2
                },
                name: names.administration_domain_name || "",
                value: [
                    new Choice({
                        value: [
                            new NumericString(),
                            new PrintableString()
                        ]
                    })
                ]
            }),
            new Primitive({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                name: names.network_address || "",
                isHexOnly: true
            }),
            new Primitive({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                },
                name: names.terminal_identifier || "",
                isHexOnly: true
            }),
            new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 2
                },
                name: names.private_domain_name || "",
                value: [
                    new Choice({
                        value: [
                            new NumericString(),
                            new PrintableString()
                        ]
                    })
                ]
            }),
            new Primitive({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 3
                },
                name: names.organization_name || "",
                isHexOnly: true
            }),
            new Primitive({
                optional: true,
                name: names.numeric_user_identifier || "",
                idBlock: {
                    tagClass: 3,
                    tagNumber: 4
                },
                isHexOnly: true
            }),
            new Constructed({
                optional: true,
                name: names.personal_name || "",
                idBlock: {
                    tagClass: 3,
                    tagNumber: 5
                },
                value: [
                    new Primitive({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        isHexOnly: true
                    }),
                    new Primitive({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        isHexOnly: true
                    }),
                    new Primitive({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 2
                        },
                        isHexOnly: true
                    }),
                    new Primitive({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 3
                        },
                        isHexOnly: true
                    })
                ]
            }),
            new Constructed({
                optional: true,
                name: names.organizational_unit_names || "",
                idBlock: {
                    tagClass: 3,
                    tagNumber: 6
                },
                value: [
                    new Repeated({
                        value: new PrintableString()
                    })
                ]
            })
        ]
    });
}
function builtInDomainDefinedAttributes(optional = false) {
    return new Sequence({
        optional,
        value: [
            new PrintableString(),
            new PrintableString()
        ]
    });
}
function extensionAttributes(optional = false) {
    return new Set1({
        optional,
        value: [
            new Primitive({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                isHexOnly: true
            }),
            new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                },
                value: [
                    new Any()
                ]
            })
        ]
    });
}
class GeneralName {
    constructor(parameters = {}){
        this.type = getParametersValue(parameters, "type", GeneralName.defaultValues("type"));
        this.value = getParametersValue(parameters, "value", GeneralName.defaultValues("value"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "type":
                return 9;
            case "value":
                return {};
            default:
                throw new Error(`Invalid member name for GeneralName class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "type":
                return memberValue === GeneralName.defaultValues(memberName);
            case "value":
                return Object.keys(memberValue).length === 0;
            default:
                throw new Error(`Invalid member name for GeneralName class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Choice({
            value: [
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    name: names.blockName || "",
                    value: [
                        new ObjectIdentifier(),
                        new Constructed({
                            idBlock: {
                                tagClass: 3,
                                tagNumber: 0
                            },
                            value: [
                                new Any()
                            ]
                        })
                    ]
                }),
                new Primitive({
                    name: names.blockName || "",
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    }
                }),
                new Primitive({
                    name: names.blockName || "",
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 2
                    }
                }),
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 3
                    },
                    name: names.blockName || "",
                    value: [
                        builtInStandardAttributes(names.builtInStandardAttributes || {}, false),
                        builtInDomainDefinedAttributes(true),
                        extensionAttributes(true)
                    ]
                }),
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 4
                    },
                    name: names.blockName || "",
                    value: [
                        RelativeDistinguishedNames.schema(names.directoryName || {})
                    ]
                }),
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 5
                    },
                    name: names.blockName || "",
                    value: [
                        new Constructed({
                            optional: true,
                            idBlock: {
                                tagClass: 3,
                                tagNumber: 0
                            },
                            value: [
                                new Choice({
                                    value: [
                                        new TeletexString(),
                                        new PrintableString(),
                                        new UniversalString(),
                                        new Utf8String(),
                                        new BmpString()
                                    ]
                                })
                            ]
                        }),
                        new Constructed({
                            idBlock: {
                                tagClass: 3,
                                tagNumber: 1
                            },
                            value: [
                                new Choice({
                                    value: [
                                        new TeletexString(),
                                        new PrintableString(),
                                        new UniversalString(),
                                        new Utf8String(),
                                        new BmpString()
                                    ]
                                })
                            ]
                        })
                    ]
                }),
                new Primitive({
                    name: names.blockName || "",
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 6
                    }
                }),
                new Primitive({
                    name: names.blockName || "",
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 7
                    }
                }),
                new Primitive({
                    name: names.blockName || "",
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 8
                    }
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "blockName",
            "otherName",
            "rfc822Name",
            "dNSName",
            "x400Address",
            "directoryName",
            "ediPartyName",
            "uniformResourceIdentifier",
            "iPAddress",
            "registeredID"
        ]);
        const asn1 = compareSchema(schema, schema, GeneralName.schema({
            names: {
                blockName: "blockName",
                otherName: "otherName",
                rfc822Name: "rfc822Name",
                dNSName: "dNSName",
                x400Address: "x400Address",
                directoryName: {
                    names: {
                        blockName: "directoryName"
                    }
                },
                ediPartyName: "ediPartyName",
                uniformResourceIdentifier: "uniformResourceIdentifier",
                iPAddress: "iPAddress",
                registeredID: "registeredID"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for GeneralName");
        this.type = asn1.result.blockName.idBlock.tagNumber;
        switch(this.type){
            case 0:
                this.value = asn1.result.blockName;
                break;
            case 1:
            case 2:
            case 6:
                {
                    const value = asn1.result.blockName;
                    value.idBlock.tagClass = 1;
                    value.idBlock.tagNumber = 22;
                    const valueBER = value.toBER(false);
                    this.value = fromBER(valueBER).result.valueBlock.value;
                }
                break;
            case 3:
                this.value = asn1.result.blockName;
                break;
            case 4:
                this.value = new RelativeDistinguishedNames({
                    schema: asn1.result.directoryName
                });
                break;
            case 5:
                this.value = asn1.result.ediPartyName;
                break;
            case 7:
                this.value = new OctetString({
                    valueHex: asn1.result.blockName.valueBlock.valueHex
                });
                break;
            case 8:
                {
                    const value = asn1.result.blockName;
                    value.idBlock.tagClass = 1;
                    value.idBlock.tagNumber = 6;
                    const valueBER = value.toBER(false);
                    this.value = fromBER(valueBER).result.valueBlock.toString();
                }
                break;
            default:
        }
    }
    toSchema() {
        switch(this.type){
            case 0:
            case 3:
            case 5:
                return new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: this.type
                    },
                    value: [
                        this.value
                    ]
                });
            case 1:
            case 2:
            case 6:
                {
                    const value = new IA5String({
                        value: this.value
                    });
                    value.idBlock.tagClass = 3;
                    value.idBlock.tagNumber = this.type;
                    return value;
                }
            case 4:
                return new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 4
                    },
                    value: [
                        this.value.toSchema()
                    ]
                });
            case 7:
                {
                    const value = this.value;
                    value.idBlock.tagClass = 3;
                    value.idBlock.tagNumber = this.type;
                    return value;
                }
            case 8:
                {
                    const value = new ObjectIdentifier({
                        value: this.value
                    });
                    value.idBlock.tagClass = 3;
                    value.idBlock.tagNumber = this.type;
                    return value;
                }
            default:
                return GeneralName.schema();
        }
    }
    toJSON() {
        const _object = {
            type: this.type
        };
        if (typeof this.value === "string") _object.value = this.value;
        else _object.value = this.value.toJSON();
        return _object;
    }
}
class AccessDescription {
    constructor(parameters = {}){
        this.accessMethod = getParametersValue(parameters, "accessMethod", AccessDescription.defaultValues("accessMethod"));
        this.accessLocation = getParametersValue(parameters, "accessLocation", AccessDescription.defaultValues("accessLocation"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "accessMethod":
                return "";
            case "accessLocation":
                return new GeneralName();
            default:
                throw new Error(`Invalid member name for AccessDescription class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new ObjectIdentifier({
                    name: names.accessMethod || ""
                }),
                GeneralName.schema(names.accessLocation || {})
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "accessMethod",
            "accessLocation"
        ]);
        const asn1 = compareSchema(schema, schema, AccessDescription.schema({
            names: {
                accessMethod: "accessMethod",
                accessLocation: {
                    names: {
                        blockName: "accessLocation"
                    }
                }
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for AccessDescription");
        this.accessMethod = asn1.result.accessMethod.valueBlock.toString();
        this.accessLocation = new GeneralName({
            schema: asn1.result.accessLocation
        });
    }
    toSchema() {
        return new Sequence({
            value: [
                new ObjectIdentifier({
                    value: this.accessMethod
                }),
                this.accessLocation.toSchema()
            ]
        });
    }
    toJSON() {
        return {
            accessMethod: this.accessMethod,
            accessLocation: this.accessLocation.toJSON()
        };
    }
}
class Accuracy {
    constructor(parameters = {}){
        if ("seconds" in parameters) this.seconds = getParametersValue(parameters, "seconds", Accuracy.defaultValues("seconds"));
        if ("millis" in parameters) this.millis = getParametersValue(parameters, "millis", Accuracy.defaultValues("millis"));
        if ("micros" in parameters) this.micros = getParametersValue(parameters, "micros", Accuracy.defaultValues("micros"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "seconds":
            case "millis":
            case "micros":
                return 0;
            default:
                throw new Error(`Invalid member name for Accuracy class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "seconds":
            case "millis":
            case "micros":
                return memberValue === Accuracy.defaultValues(memberName);
            default:
                throw new Error(`Invalid member name for Accuracy class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            optional: true,
            value: [
                new Integer({
                    optional: true,
                    name: names.seconds || ""
                }),
                new Primitive({
                    name: names.millis || "",
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    }
                }),
                new Primitive({
                    name: names.micros || "",
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    }
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "seconds",
            "millis",
            "micros"
        ]);
        const asn1 = compareSchema(schema, schema, Accuracy.schema({
            names: {
                seconds: "seconds",
                millis: "millis",
                micros: "micros"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for Accuracy");
        if ("seconds" in asn1.result) this.seconds = asn1.result.seconds.valueBlock.valueDec;
        if ("millis" in asn1.result) {
            const intMillis = new Integer({
                valueHex: asn1.result.millis.valueBlock.valueHex
            });
            this.millis = intMillis.valueBlock.valueDec;
        }
        if ("micros" in asn1.result) {
            const intMicros = new Integer({
                valueHex: asn1.result.micros.valueBlock.valueHex
            });
            this.micros = intMicros.valueBlock.valueDec;
        }
    }
    toSchema() {
        const outputArray = [];
        if ("seconds" in this) outputArray.push(new Integer({
            value: this.seconds
        }));
        if ("millis" in this) {
            const intMillis = new Integer({
                value: this.millis
            });
            outputArray.push(new Primitive({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                valueHex: intMillis.valueBlock.valueHex
            }));
        }
        if ("micros" in this) {
            const intMicros = new Integer({
                value: this.micros
            });
            outputArray.push(new Primitive({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                },
                valueHex: intMicros.valueBlock.valueHex
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const _object = {};
        if ("seconds" in this) _object.seconds = this.seconds;
        if ("millis" in this) _object.millis = this.millis;
        if ("micros" in this) _object.micros = this.micros;
        return _object;
    }
}
class AltName {
    constructor(parameters = {}){
        this.altNames = getParametersValue(parameters, "altNames", AltName.defaultValues("altNames"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "altNames":
                return [];
            default:
                throw new Error(`Invalid member name for AltName class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Repeated({
                    name: names.altNames || "",
                    value: GeneralName.schema()
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "altNames"
        ]);
        const asn1 = compareSchema(schema, schema, AltName.schema({
            names: {
                altNames: "altNames"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for AltName");
        if ("altNames" in asn1.result) this.altNames = Array.from(asn1.result.altNames, (element)=>new GeneralName({
                schema: element
            })
        );
    }
    toSchema() {
        return new Sequence({
            value: Array.from(this.altNames, (element)=>element.toSchema()
            )
        });
    }
    toJSON() {
        return {
            altNames: Array.from(this.altNames, (element)=>element.toJSON()
            )
        };
    }
}
class ContentInfo {
    constructor(parameters = {}){
        this.contentType = getParametersValue(parameters, "contentType", ContentInfo.defaultValues("contentType"));
        this.content = getParametersValue(parameters, "content", ContentInfo.defaultValues("content"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "contentType":
                return "";
            case "content":
                return new Any();
            default:
                throw new Error(`Invalid member name for ContentInfo class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "contentType":
                return memberValue === "";
            case "content":
                return memberValue instanceof Any;
            default:
                throw new Error(`Invalid member name for ContentInfo class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        if ("optional" in names === false) names.optional = false;
        return new Sequence({
            name: names.blockName || "ContentInfo",
            optional: names.optional,
            value: [
                new ObjectIdentifier({
                    name: names.contentType || "contentType"
                }),
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Any({
                            name: names.content || "content"
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "contentType",
            "content"
        ]);
        const asn1 = compareSchema(schema, schema, ContentInfo.schema());
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for ContentInfo");
        this.contentType = asn1.result.contentType.valueBlock.toString();
        this.content = asn1.result.content;
    }
    toSchema() {
        return new Sequence({
            value: [
                new ObjectIdentifier({
                    value: this.contentType
                }),
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        this.content
                    ]
                })
            ]
        });
    }
    toJSON() {
        const object = {
            contentType: this.contentType
        };
        if (!(this.content instanceof Any)) object.content = this.content.toJSON();
        return object;
    }
}
class EncryptedData {
    constructor(parameters = {}){
        this.version = getParametersValue(parameters, "version", EncryptedData.defaultValues("version"));
        this.encryptedContentInfo = getParametersValue(parameters, "encryptedContentInfo", EncryptedData.defaultValues("encryptedContentInfo"));
        if ("unprotectedAttrs" in parameters) this.unprotectedAttrs = getParametersValue(parameters, "unprotectedAttrs", EncryptedData.defaultValues("unprotectedAttrs"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "version":
                return 0;
            case "encryptedContentInfo":
                return new EncryptedContentInfo();
            case "unprotectedAttrs":
                return [];
            default:
                throw new Error(`Invalid member name for EncryptedData class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "version":
                return memberValue === 0;
            case "encryptedContentInfo":
                return EncryptedContentInfo.compareWithDefault("contentType", memberValue.contentType) && EncryptedContentInfo.compareWithDefault("contentEncryptionAlgorithm", memberValue.contentEncryptionAlgorithm) && EncryptedContentInfo.compareWithDefault("encryptedContent", memberValue.encryptedContent);
            case "unprotectedAttrs":
                return memberValue.length === 0;
            default:
                throw new Error(`Invalid member name for EncryptedData class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Integer({
                    name: names.version || ""
                }),
                EncryptedContentInfo.schema(names.encryptedContentInfo || {}),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: [
                        new Repeated({
                            name: names.unprotectedAttrs || "",
                            value: Attribute.schema()
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "version",
            "encryptedContentInfo",
            "unprotectedAttrs"
        ]);
        const asn1 = compareSchema(schema, schema, EncryptedData.schema({
            names: {
                version: "version",
                encryptedContentInfo: {
                    names: {
                        blockName: "encryptedContentInfo"
                    }
                },
                unprotectedAttrs: "unprotectedAttrs"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for EncryptedData");
        this.version = asn1.result.version.valueBlock.valueDec;
        this.encryptedContentInfo = new EncryptedContentInfo({
            schema: asn1.result.encryptedContentInfo
        });
        if ("unprotectedAttrs" in asn1.result) this.unprotectedAttrs = Array.from(asn1.result.unprotectedAttrs, (element)=>new Attribute({
                schema: element
            })
        );
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(new Integer({
            value: this.version
        }));
        outputArray.push(this.encryptedContentInfo.toSchema());
        if ("unprotectedAttrs" in this) {
            outputArray.push(new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                },
                value: Array.from(this.unprotectedAttrs, (element)=>element.toSchema()
                )
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const _object = {
            version: this.version,
            encryptedContentInfo: this.encryptedContentInfo.toJSON()
        };
        if ("unprotectedAttrs" in this) _object.unprotectedAttrs = Array.from(this.unprotectedAttrs, (element)=>element.toJSON()
        );
        return _object;
    }
    encrypt(parameters) {
        if (parameters instanceof Object === false) return Promise.reject("Parameters must have type \"Object\"");
        const engine1 = getEngine();
        if (typeof engine1 === "undefined") return Promise.reject("Unable to initialize cryptographic engine");
        parameters.contentType = "1.2.840.113549.1.7.1";
        if ("encryptEncryptedContentInfo" in engine1.subtle) {
            return engine1.subtle.encryptEncryptedContentInfo(parameters).then((result)=>{
                this.encryptedContentInfo = result;
            });
        }
        return Promise.reject(`No support for "encryptEncryptedContentInfo" in current crypto engine ${engine1.name}`);
    }
    decrypt(parameters) {
        if (parameters instanceof Object === false) return Promise.reject("Parameters must have type \"Object\"");
        const engine2 = getEngine();
        if (typeof engine2 === "undefined") return Promise.reject("Unable to initialize cryptographic engine");
        parameters.encryptedContentInfo = this.encryptedContentInfo;
        if ("decryptEncryptedContentInfo" in engine2.subtle) return engine2.subtle.decryptEncryptedContentInfo(parameters);
        return Promise.reject(`No support for "decryptEncryptedContentInfo" in current crypto engine ${engine2.name}`);
    }
}
class PKCS8ShroudedKeyBag {
    constructor(parameters = {}){
        this.encryptionAlgorithm = getParametersValue(parameters, "encryptionAlgorithm", PKCS8ShroudedKeyBag.defaultValues("encryptionAlgorithm"));
        this.encryptedData = getParametersValue(parameters, "encryptedData", PKCS8ShroudedKeyBag.defaultValues("encryptedData"));
        if ("parsedValue" in parameters) this.parsedValue = getParametersValue(parameters, "parsedValue", PKCS8ShroudedKeyBag.defaultValues("parsedValue"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "encryptionAlgorithm":
                return new AlgorithmIdentifier();
            case "encryptedData":
                return new OctetString();
            case "parsedValue":
                return {};
            default:
                throw new Error(`Invalid member name for PKCS8ShroudedKeyBag class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "encryptionAlgorithm":
                return AlgorithmIdentifier.compareWithDefault("algorithmId", memberValue.algorithmId) && "algorithmParams" in memberValue === false;
            case "encryptedData":
                return memberValue.isEqual(PKCS8ShroudedKeyBag.defaultValues(memberName));
            case "parsedValue":
                return memberValue instanceof Object && Object.keys(memberValue).length === 0;
            default:
                throw new Error(`Invalid member name for PKCS8ShroudedKeyBag class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                AlgorithmIdentifier.schema(names.encryptionAlgorithm || {
                    names: {
                        blockName: "encryptionAlgorithm"
                    }
                }),
                new Choice({
                    value: [
                        new OctetString({
                            name: names.encryptedData || "encryptedData"
                        }),
                        new OctetString({
                            idBlock: {
                                isConstructed: true
                            },
                            name: names.encryptedData || "encryptedData"
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "encryptionAlgorithm",
            "encryptedData"
        ]);
        const asn1 = compareSchema(schema, schema, PKCS8ShroudedKeyBag.schema({
            names: {
                encryptionAlgorithm: {
                    names: {
                        blockName: "encryptionAlgorithm"
                    }
                },
                encryptedData: "encryptedData"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PKCS8ShroudedKeyBag");
        this.encryptionAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result.encryptionAlgorithm
        });
        this.encryptedData = asn1.result.encryptedData;
    }
    toSchema() {
        return new Sequence({
            value: [
                this.encryptionAlgorithm.toSchema(),
                this.encryptedData
            ]
        });
    }
    toJSON() {
        return {
            encryptionAlgorithm: this.encryptionAlgorithm.toJSON(),
            encryptedData: this.encryptedData.toJSON()
        };
    }
    parseInternalValues(parameters) {
        let sequence = Promise.resolve();
        const cmsEncrypted = new EncryptedData({
            encryptedContentInfo: new EncryptedContentInfo({
                contentEncryptionAlgorithm: this.encryptionAlgorithm,
                encryptedContent: this.encryptedData
            })
        });
        sequence = sequence.then(()=>cmsEncrypted.decrypt(parameters)
        , (error14)=>Promise.reject(error14)
        );
        sequence = sequence.then((result)=>{
            const asn1 = fromBER(result);
            if (asn1.offset === -1) return Promise.reject("Error during parsing ASN.1 data");
            this.parsedValue = new PrivateKeyInfo({
                schema: asn1.result
            });
            return Promise.resolve();
        }, (error15)=>Promise.reject(error15)
        );
        return sequence;
    }
    makeInternalValues(parameters) {
        if ("parsedValue" in this === false) return Promise.reject("Please initialize \"parsedValue\" first");
        let sequence = Promise.resolve();
        const cmsEncrypted = new EncryptedData();
        sequence = sequence.then(()=>{
            parameters.contentToEncrypt = this.parsedValue.toSchema().toBER(false);
            return cmsEncrypted.encrypt(parameters);
        }, (error16)=>Promise.reject(error16)
        );
        sequence = sequence.then(()=>{
            this.encryptionAlgorithm = cmsEncrypted.encryptedContentInfo.contentEncryptionAlgorithm;
            this.encryptedData = cmsEncrypted.encryptedContentInfo.encryptedContent;
        });
        return sequence;
    }
}
class Time {
    constructor(parameters = {}){
        this.type = getParametersValue(parameters, "type", Time.defaultValues("type"));
        this.value = getParametersValue(parameters, "value", Time.defaultValues("value"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "type":
                return 0;
            case "value":
                return new Date(0, 0, 0);
            default:
                throw new Error(`Invalid member name for Time class: ${memberName}`);
        }
    }
    static schema(parameters = {}, optional = false) {
        const names = getParametersValue(parameters, "names", {});
        return new Choice({
            optional,
            value: [
                new UTCTime({
                    name: names.utcTimeName || ""
                }),
                new GeneralizedTime({
                    name: names.generalTimeName || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "utcTimeName",
            "generalTimeName"
        ]);
        const asn1 = compareSchema(schema, schema, Time.schema({
            names: {
                utcTimeName: "utcTimeName",
                generalTimeName: "generalTimeName"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for Time");
        if ("utcTimeName" in asn1.result) {
            this.type = 0;
            this.value = asn1.result.utcTimeName.toDate();
        }
        if ("generalTimeName" in asn1.result) {
            this.type = 1;
            this.value = asn1.result.generalTimeName.toDate();
        }
    }
    toSchema() {
        let result = {};
        if (this.type === 0) result = new UTCTime({
            valueDate: this.value
        });
        if (this.type === 1) result = new GeneralizedTime({
            valueDate: this.value
        });
        return result;
    }
    toJSON() {
        return {
            type: this.type,
            value: this.value
        };
    }
}
class SubjectDirectoryAttributes {
    constructor(parameters = {}){
        this.attributes = getParametersValue(parameters, "attributes", SubjectDirectoryAttributes.defaultValues("attributes"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "attributes":
                return [];
            default:
                throw new Error(`Invalid member name for SubjectDirectoryAttributes class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Repeated({
                    name: names.attributes || "",
                    value: Attribute.schema()
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "attributes"
        ]);
        const asn1 = compareSchema(schema, schema, SubjectDirectoryAttributes.schema({
            names: {
                attributes: "attributes"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for SubjectDirectoryAttributes");
        this.attributes = Array.from(asn1.result.attributes, (element)=>new Attribute({
                schema: element
            })
        );
    }
    toSchema() {
        return new Sequence({
            value: Array.from(this.attributes, (element)=>element.toSchema()
            )
        });
    }
    toJSON() {
        return {
            attributes: Array.from(this.attributes, (element)=>element.toJSON()
            )
        };
    }
}
class PrivateKeyUsagePeriod {
    constructor(parameters = {}){
        if ("notBefore" in parameters) this.notBefore = getParametersValue(parameters, "notBefore", PrivateKeyUsagePeriod.defaultValues("notBefore"));
        if ("notAfter" in parameters) this.notAfter = getParametersValue(parameters, "notAfter", PrivateKeyUsagePeriod.defaultValues("notAfter"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "notBefore":
                return new Date();
            case "notAfter":
                return new Date();
            default:
                throw new Error(`Invalid member name for PrivateKeyUsagePeriod class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Primitive({
                    name: names.notBefore || "",
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    }
                }),
                new Primitive({
                    name: names.notAfter || "",
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    }
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "notBefore",
            "notAfter"
        ]);
        const asn1 = compareSchema(schema, schema, PrivateKeyUsagePeriod.schema({
            names: {
                notBefore: "notBefore",
                notAfter: "notAfter"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PrivateKeyUsagePeriod");
        if ("notBefore" in asn1.result) {
            const localNotBefore = new GeneralizedTime();
            localNotBefore.fromBuffer(asn1.result.notBefore.valueBlock.valueHex);
            this.notBefore = localNotBefore.toDate();
        }
        if ("notAfter" in asn1.result) {
            const localNotAfter = new GeneralizedTime({
                valueHex: asn1.result.notAfter.valueBlock.valueHex
            });
            localNotAfter.fromBuffer(asn1.result.notAfter.valueBlock.valueHex);
            this.notAfter = localNotAfter.toDate();
        }
    }
    toSchema() {
        const outputArray = [];
        if ("notBefore" in this) {
            outputArray.push(new Primitive({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                valueHex: new GeneralizedTime({
                    valueDate: this.notBefore
                }).valueBlock.valueHex
            }));
        }
        if ("notAfter" in this) {
            outputArray.push(new Primitive({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                },
                valueHex: new GeneralizedTime({
                    valueDate: this.notAfter
                }).valueBlock.valueHex
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const object = {};
        if ("notBefore" in this) object.notBefore = this.notBefore;
        if ("notAfter" in this) object.notAfter = this.notAfter;
        return object;
    }
}
class BasicConstraints {
    constructor(parameters = {}){
        this.cA = getParametersValue(parameters, "cA", false);
        if ("pathLenConstraint" in parameters) this.pathLenConstraint = getParametersValue(parameters, "pathLenConstraint", 0);
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "cA":
                return false;
            default:
                throw new Error(`Invalid member name for BasicConstraints class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Boolean1({
                    optional: true,
                    name: names.cA || ""
                }),
                new Integer({
                    optional: true,
                    name: names.pathLenConstraint || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "cA",
            "pathLenConstraint"
        ]);
        const asn1 = compareSchema(schema, schema, BasicConstraints.schema({
            names: {
                cA: "cA",
                pathLenConstraint: "pathLenConstraint"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for BasicConstraints");
        if ("cA" in asn1.result) this.cA = asn1.result.cA.valueBlock.value;
        if ("pathLenConstraint" in asn1.result) {
            if (asn1.result.pathLenConstraint.valueBlock.isHexOnly) this.pathLenConstraint = asn1.result.pathLenConstraint;
            else this.pathLenConstraint = asn1.result.pathLenConstraint.valueBlock.valueDec;
        }
    }
    toSchema() {
        const outputArray = [];
        if (this.cA !== BasicConstraints.defaultValues("cA")) outputArray.push(new Boolean1({
            value: this.cA
        }));
        if ("pathLenConstraint" in this) {
            if (this.pathLenConstraint instanceof Integer) outputArray.push(this.pathLenConstraint);
            else outputArray.push(new Integer({
                value: this.pathLenConstraint
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const object = {};
        if (this.cA !== BasicConstraints.defaultValues("cA")) object.cA = this.cA;
        if ("pathLenConstraint" in this) {
            if (this.pathLenConstraint instanceof Integer) object.pathLenConstraint = this.pathLenConstraint.toJSON();
            else object.pathLenConstraint = this.pathLenConstraint;
        }
        return object;
    }
}
class IssuingDistributionPoint {
    constructor(parameters = {}){
        if ("distributionPoint" in parameters) this.distributionPoint = getParametersValue(parameters, "distributionPoint", IssuingDistributionPoint.defaultValues("distributionPoint"));
        this.onlyContainsUserCerts = getParametersValue(parameters, "onlyContainsUserCerts", IssuingDistributionPoint.defaultValues("onlyContainsUserCerts"));
        this.onlyContainsCACerts = getParametersValue(parameters, "onlyContainsCACerts", IssuingDistributionPoint.defaultValues("onlyContainsCACerts"));
        if ("onlySomeReasons" in parameters) this.onlySomeReasons = getParametersValue(parameters, "onlySomeReasons", IssuingDistributionPoint.defaultValues("onlySomeReasons"));
        this.indirectCRL = getParametersValue(parameters, "indirectCRL", IssuingDistributionPoint.defaultValues("indirectCRL"));
        this.onlyContainsAttributeCerts = getParametersValue(parameters, "onlyContainsAttributeCerts", IssuingDistributionPoint.defaultValues("onlyContainsAttributeCerts"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "distributionPoint":
                return [];
            case "onlyContainsUserCerts":
                return false;
            case "onlyContainsCACerts":
                return false;
            case "onlySomeReasons":
                return 0;
            case "indirectCRL":
                return false;
            case "onlyContainsAttributeCerts":
                return false;
            default:
                throw new Error(`Invalid member name for IssuingDistributionPoint class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Choice({
                            value: [
                                new Constructed({
                                    name: names.distributionPoint || "",
                                    idBlock: {
                                        tagClass: 3,
                                        tagNumber: 0
                                    },
                                    value: [
                                        new Repeated({
                                            name: names.distributionPointNames || "",
                                            value: GeneralName.schema()
                                        })
                                    ]
                                }),
                                new Constructed({
                                    name: names.distributionPoint || "",
                                    idBlock: {
                                        tagClass: 3,
                                        tagNumber: 1
                                    },
                                    value: RelativeDistinguishedNames.schema().valueBlock.value
                                })
                            ]
                        })
                    ]
                }),
                new Primitive({
                    name: names.onlyContainsUserCerts || "",
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    }
                }),
                new Primitive({
                    name: names.onlyContainsCACerts || "",
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 2
                    }
                }),
                new Primitive({
                    name: names.onlySomeReasons || "",
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 3
                    }
                }),
                new Primitive({
                    name: names.indirectCRL || "",
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 4
                    }
                }),
                new Primitive({
                    name: names.onlyContainsAttributeCerts || "",
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 5
                    }
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "distributionPoint",
            "distributionPointNames",
            "onlyContainsUserCerts",
            "onlyContainsCACerts",
            "onlySomeReasons",
            "indirectCRL",
            "onlyContainsAttributeCerts"
        ]);
        const asn1 = compareSchema(schema, schema, IssuingDistributionPoint.schema({
            names: {
                distributionPoint: "distributionPoint",
                distributionPointNames: "distributionPointNames",
                onlyContainsUserCerts: "onlyContainsUserCerts",
                onlyContainsCACerts: "onlyContainsCACerts",
                onlySomeReasons: "onlySomeReasons",
                indirectCRL: "indirectCRL",
                onlyContainsAttributeCerts: "onlyContainsAttributeCerts"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for IssuingDistributionPoint");
        if ("distributionPoint" in asn1.result) {
            switch(true){
                case asn1.result.distributionPoint.idBlock.tagNumber === 0:
                    this.distributionPoint = Array.from(asn1.result.distributionPointNames, (element)=>new GeneralName({
                            schema: element
                        })
                    );
                    break;
                case asn1.result.distributionPoint.idBlock.tagNumber === 1:
                    {
                        this.distributionPoint = new RelativeDistinguishedNames({
                            schema: new Sequence({
                                value: asn1.result.distributionPoint.valueBlock.value
                            })
                        });
                    }
                    break;
                default:
                    throw new Error("Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}");
            }
        }
        if ("onlyContainsUserCerts" in asn1.result) {
            const view = new Uint8Array(asn1.result.onlyContainsUserCerts.valueBlock.valueHex);
            this.onlyContainsUserCerts = view[0] !== 0x00;
        }
        if ("onlyContainsCACerts" in asn1.result) {
            const view = new Uint8Array(asn1.result.onlyContainsCACerts.valueBlock.valueHex);
            this.onlyContainsCACerts = view[0] !== 0x00;
        }
        if ("onlySomeReasons" in asn1.result) {
            const view = new Uint8Array(asn1.result.onlySomeReasons.valueBlock.valueHex);
            this.onlySomeReasons = view[0];
        }
        if ("indirectCRL" in asn1.result) {
            const view = new Uint8Array(asn1.result.indirectCRL.valueBlock.valueHex);
            this.indirectCRL = view[0] !== 0x00;
        }
        if ("onlyContainsAttributeCerts" in asn1.result) {
            const view = new Uint8Array(asn1.result.onlyContainsAttributeCerts.valueBlock.valueHex);
            this.onlyContainsAttributeCerts = view[0] !== 0x00;
        }
    }
    toSchema() {
        const outputArray = [];
        if ("distributionPoint" in this) {
            let value;
            if (this.distributionPoint instanceof Array) {
                value = new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: Array.from(this.distributionPoint, (element)=>element.toSchema()
                    )
                });
            } else {
                value = this.distributionPoint.toSchema();
                value.idBlock.tagClass = 3;
                value.idBlock.tagNumber = 1;
            }
            outputArray.push(value);
        }
        if (this.onlyContainsUserCerts !== IssuingDistributionPoint.defaultValues("onlyContainsUserCerts")) {
            outputArray.push(new Primitive({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                },
                valueHex: new Uint8Array([
                    0xFF
                ]).buffer
            }));
        }
        if (this.onlyContainsCACerts !== IssuingDistributionPoint.defaultValues("onlyContainsCACerts")) {
            outputArray.push(new Primitive({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 2
                },
                valueHex: new Uint8Array([
                    0xFF
                ]).buffer
            }));
        }
        if ("onlySomeReasons" in this) {
            const buffer = new ArrayBuffer(1);
            const view = new Uint8Array(buffer);
            view[0] = this.onlySomeReasons;
            outputArray.push(new Primitive({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 3
                },
                valueHex: buffer
            }));
        }
        if (this.indirectCRL !== IssuingDistributionPoint.defaultValues("indirectCRL")) {
            outputArray.push(new Primitive({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 4
                },
                valueHex: new Uint8Array([
                    0xFF
                ]).buffer
            }));
        }
        if (this.onlyContainsAttributeCerts !== IssuingDistributionPoint.defaultValues("onlyContainsAttributeCerts")) {
            outputArray.push(new Primitive({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 5
                },
                valueHex: new Uint8Array([
                    0xFF
                ]).buffer
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const object = {};
        if ("distributionPoint" in this) {
            if (this.distributionPoint instanceof Array) object.distributionPoint = Array.from(this.distributionPoint, (element)=>element.toJSON()
            );
            else object.distributionPoint = this.distributionPoint.toJSON();
        }
        if (this.onlyContainsUserCerts !== IssuingDistributionPoint.defaultValues("onlyContainsUserCerts")) object.onlyContainsUserCerts = this.onlyContainsUserCerts;
        if (this.onlyContainsCACerts !== IssuingDistributionPoint.defaultValues("onlyContainsCACerts")) object.onlyContainsCACerts = this.onlyContainsCACerts;
        if ("onlySomeReasons" in this) object.onlySomeReasons = this.onlySomeReasons;
        if (this.indirectCRL !== IssuingDistributionPoint.defaultValues("indirectCRL")) object.indirectCRL = this.indirectCRL;
        if (this.onlyContainsAttributeCerts !== IssuingDistributionPoint.defaultValues("onlyContainsAttributeCerts")) object.onlyContainsAttributeCerts = this.onlyContainsAttributeCerts;
        return object;
    }
}
class GeneralNames {
    constructor(parameters = {}){
        this.names = getParametersValue(parameters, "names", GeneralNames.defaultValues("names"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "names":
                return [];
            default:
                throw new Error(`Invalid member name for GeneralNames class: ${memberName}`);
        }
    }
    static schema(parameters = {}, optional = false) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            optional,
            name: names.blockName || "",
            value: [
                new Repeated({
                    name: names.generalNames || "",
                    value: GeneralName.schema()
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "names",
            "generalNames"
        ]);
        const asn1 = compareSchema(schema, schema, GeneralNames.schema({
            names: {
                blockName: "names",
                generalNames: "generalNames"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for GeneralNames");
        this.names = Array.from(asn1.result.generalNames, (element)=>new GeneralName({
                schema: element
            })
        );
    }
    toSchema() {
        return new Sequence({
            value: Array.from(this.names, (element)=>element.toSchema()
            )
        });
    }
    toJSON() {
        return {
            names: Array.from(this.names, (element)=>element.toJSON()
            )
        };
    }
}
class GeneralSubtree {
    constructor(parameters = {}){
        this.base = getParametersValue(parameters, "base", GeneralSubtree.defaultValues("base"));
        this.minimum = getParametersValue(parameters, "minimum", GeneralSubtree.defaultValues("minimum"));
        if ("maximum" in parameters) this.maximum = getParametersValue(parameters, "maximum", GeneralSubtree.defaultValues("maximum"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "base":
                return new GeneralName();
            case "minimum":
                return 0;
            case "maximum":
                return 0;
            default:
                throw new Error(`Invalid member name for GeneralSubtree class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                GeneralName.schema(names.base || {}),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Integer({
                            name: names.minimum || ""
                        })
                    ]
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: [
                        new Integer({
                            name: names.maximum || ""
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "base",
            "minimum",
            "maximum"
        ]);
        const asn1 = compareSchema(schema, schema, GeneralSubtree.schema({
            names: {
                base: {
                    names: {
                        blockName: "base"
                    }
                },
                minimum: "minimum",
                maximum: "maximum"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for GeneralSubtree");
        this.base = new GeneralName({
            schema: asn1.result.base
        });
        if ("minimum" in asn1.result) {
            if (asn1.result.minimum.valueBlock.isHexOnly) this.minimum = asn1.result.minimum;
            else this.minimum = asn1.result.minimum.valueBlock.valueDec;
        }
        if ("maximum" in asn1.result) {
            if (asn1.result.maximum.valueBlock.isHexOnly) this.maximum = asn1.result.maximum;
            else this.maximum = asn1.result.maximum.valueBlock.valueDec;
        }
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(this.base.toSchema());
        if (this.minimum !== 0) {
            let valueMinimum = 0;
            if (this.minimum instanceof Integer) valueMinimum = this.minimum;
            else valueMinimum = new Integer({
                value: this.minimum
            });
            outputArray.push(new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: [
                    valueMinimum
                ]
            }));
        }
        if ("maximum" in this) {
            let valueMaximum = 0;
            if (this.maximum instanceof Integer) valueMaximum = this.maximum;
            else valueMaximum = new Integer({
                value: this.maximum
            });
            outputArray.push(new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                },
                value: [
                    valueMaximum
                ]
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const object = {
            base: this.base.toJSON()
        };
        if (this.minimum !== 0) {
            if (typeof this.minimum === "number") object.minimum = this.minimum;
            else object.minimum = this.minimum.toJSON();
        }
        if ("maximum" in this) {
            if (typeof this.maximum === "number") object.maximum = this.maximum;
            else object.maximum = this.maximum.toJSON();
        }
        return object;
    }
}
class NameConstraints {
    constructor(parameters = {}){
        if ("permittedSubtrees" in parameters) this.permittedSubtrees = getParametersValue(parameters, "permittedSubtrees", NameConstraints.defaultValues("permittedSubtrees"));
        if ("excludedSubtrees" in parameters) this.excludedSubtrees = getParametersValue(parameters, "excludedSubtrees", NameConstraints.defaultValues("excludedSubtrees"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "permittedSubtrees":
                return [];
            case "excludedSubtrees":
                return [];
            default:
                throw new Error(`Invalid member name for NameConstraints class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Repeated({
                            name: names.permittedSubtrees || "",
                            value: GeneralSubtree.schema()
                        })
                    ]
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: [
                        new Repeated({
                            name: names.excludedSubtrees || "",
                            value: GeneralSubtree.schema()
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "permittedSubtrees",
            "excludedSubtrees"
        ]);
        const asn1 = compareSchema(schema, schema, NameConstraints.schema({
            names: {
                permittedSubtrees: "permittedSubtrees",
                excludedSubtrees: "excludedSubtrees"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for NameConstraints");
        if ("permittedSubtrees" in asn1.result) this.permittedSubtrees = Array.from(asn1.result.permittedSubtrees, (element)=>new GeneralSubtree({
                schema: element
            })
        );
        if ("excludedSubtrees" in asn1.result) this.excludedSubtrees = Array.from(asn1.result.excludedSubtrees, (element)=>new GeneralSubtree({
                schema: element
            })
        );
    }
    toSchema() {
        const outputArray = [];
        if ("permittedSubtrees" in this) {
            outputArray.push(new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: [
                    new Sequence({
                        value: Array.from(this.permittedSubtrees, (element)=>element.toSchema()
                        )
                    })
                ]
            }));
        }
        if ("excludedSubtrees" in this) {
            outputArray.push(new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                },
                value: [
                    new Sequence({
                        value: Array.from(this.excludedSubtrees, (element)=>element.toSchema()
                        )
                    })
                ]
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const object = {};
        if ("permittedSubtrees" in this) object.permittedSubtrees = Array.from(this.permittedSubtrees, (element)=>element.toJSON()
        );
        if ("excludedSubtrees" in this) object.excludedSubtrees = Array.from(this.excludedSubtrees, (element)=>element.toJSON()
        );
        return object;
    }
}
class DistributionPoint {
    constructor(parameters = {}){
        if ("distributionPoint" in parameters) this.distributionPoint = getParametersValue(parameters, "distributionPoint", DistributionPoint.defaultValues("distributionPoint"));
        if ("reasons" in parameters) this.reasons = getParametersValue(parameters, "reasons", DistributionPoint.defaultValues("reasons"));
        if ("cRLIssuer" in parameters) this.cRLIssuer = getParametersValue(parameters, "cRLIssuer", DistributionPoint.defaultValues("cRLIssuer"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "distributionPoint":
                return [];
            case "reasons":
                return new BitString();
            case "cRLIssuer":
                return [];
            default:
                throw new Error(`Invalid member name for DistributionPoint class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Choice({
                            value: [
                                new Constructed({
                                    name: names.distributionPoint || "",
                                    optional: true,
                                    idBlock: {
                                        tagClass: 3,
                                        tagNumber: 0
                                    },
                                    value: [
                                        new Repeated({
                                            name: names.distributionPointNames || "",
                                            value: GeneralName.schema()
                                        })
                                    ]
                                }),
                                new Constructed({
                                    name: names.distributionPoint || "",
                                    optional: true,
                                    idBlock: {
                                        tagClass: 3,
                                        tagNumber: 1
                                    },
                                    value: RelativeDistinguishedNames.schema().valueBlock.value
                                })
                            ]
                        })
                    ]
                }),
                new Primitive({
                    name: names.reasons || "",
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    }
                }),
                new Constructed({
                    name: names.cRLIssuer || "",
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 2
                    },
                    value: [
                        new Repeated({
                            name: names.cRLIssuerNames || "",
                            value: GeneralName.schema()
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "distributionPoint",
            "distributionPointNames",
            "reasons",
            "cRLIssuer",
            "cRLIssuerNames"
        ]);
        const asn1 = compareSchema(schema, schema, DistributionPoint.schema({
            names: {
                distributionPoint: "distributionPoint",
                distributionPointNames: "distributionPointNames",
                reasons: "reasons",
                cRLIssuer: "cRLIssuer",
                cRLIssuerNames: "cRLIssuerNames"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for DistributionPoint");
        if ("distributionPoint" in asn1.result) {
            if (asn1.result.distributionPoint.idBlock.tagNumber === 0) this.distributionPoint = Array.from(asn1.result.distributionPointNames, (element)=>new GeneralName({
                    schema: element
                })
            );
            if (asn1.result.distributionPoint.idBlock.tagNumber === 1) {
                this.distributionPoint = new RelativeDistinguishedNames({
                    schema: new Sequence({
                        value: asn1.result.distributionPoint.valueBlock.value
                    })
                });
            }
        }
        if ("reasons" in asn1.result) this.reasons = new BitString({
            valueHex: asn1.result.reasons.valueBlock.valueHex
        });
        if ("cRLIssuer" in asn1.result) this.cRLIssuer = Array.from(asn1.result.cRLIssuerNames, (element)=>new GeneralName({
                schema: element
            })
        );
    }
    toSchema() {
        const outputArray = [];
        if ("distributionPoint" in this) {
            let internalValue;
            if (this.distributionPoint instanceof Array) {
                internalValue = new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: Array.from(this.distributionPoint, (element)=>element.toSchema()
                    )
                });
            } else {
                internalValue = new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: [
                        this.distributionPoint.toSchema()
                    ]
                });
            }
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: [
                    internalValue
                ]
            }));
        }
        if ("reasons" in this) {
            outputArray.push(new Primitive({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                },
                valueHex: this.reasons.valueBlock.valueHex
            }));
        }
        if ("cRLIssuer" in this) {
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 2
                },
                value: Array.from(this.cRLIssuer, (element)=>element.toSchema()
                )
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const object = {};
        if ("distributionPoint" in this) {
            if (this.distributionPoint instanceof Array) object.distributionPoint = Array.from(this.distributionPoint, (element)=>element.toJSON()
            );
            else object.distributionPoint = this.distributionPoint.toJSON();
        }
        if ("reasons" in this) object.reasons = this.reasons.toJSON();
        if ("cRLIssuer" in this) object.cRLIssuer = Array.from(this.cRLIssuer, (element)=>element.toJSON()
        );
        return object;
    }
}
class CRLDistributionPoints {
    constructor(parameters = {}){
        this.distributionPoints = getParametersValue(parameters, "distributionPoints", CRLDistributionPoints.defaultValues("distributionPoints"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "distributionPoints":
                return [];
            default:
                throw new Error(`Invalid member name for CRLDistributionPoints class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Repeated({
                    name: names.distributionPoints || "",
                    value: DistributionPoint.schema()
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "distributionPoints"
        ]);
        const asn1 = compareSchema(schema, schema, CRLDistributionPoints.schema({
            names: {
                distributionPoints: "distributionPoints"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for CRLDistributionPoints");
        this.distributionPoints = Array.from(asn1.result.distributionPoints, (element)=>new DistributionPoint({
                schema: element
            })
        );
    }
    toSchema() {
        return new Sequence({
            value: Array.from(this.distributionPoints, (element)=>element.toSchema()
            )
        });
    }
    toJSON() {
        return {
            distributionPoints: Array.from(this.distributionPoints, (element)=>element.toJSON()
            )
        };
    }
}
class PolicyQualifierInfo {
    constructor(parameters = {}){
        this.policyQualifierId = getParametersValue(parameters, "policyQualifierId", PolicyQualifierInfo.defaultValues("policyQualifierId"));
        this.qualifier = getParametersValue(parameters, "qualifier", PolicyQualifierInfo.defaultValues("qualifier"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "policyQualifierId":
                return "";
            case "qualifier":
                return new Any();
            default:
                throw new Error(`Invalid member name for PolicyQualifierInfo class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new ObjectIdentifier({
                    name: names.policyQualifierId || ""
                }),
                new Any({
                    name: names.qualifier || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "policyQualifierId",
            "qualifier"
        ]);
        const asn1 = compareSchema(schema, schema, PolicyQualifierInfo.schema({
            names: {
                policyQualifierId: "policyQualifierId",
                qualifier: "qualifier"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PolicyQualifierInfo");
        this.policyQualifierId = asn1.result.policyQualifierId.valueBlock.toString();
        this.qualifier = asn1.result.qualifier;
    }
    toSchema() {
        return new Sequence({
            value: [
                new ObjectIdentifier({
                    value: this.policyQualifierId
                }),
                this.qualifier
            ]
        });
    }
    toJSON() {
        return {
            policyQualifierId: this.policyQualifierId,
            qualifier: this.qualifier.toJSON()
        };
    }
}
class PolicyInformation {
    constructor(parameters = {}){
        this.policyIdentifier = getParametersValue(parameters, "policyIdentifier", PolicyInformation.defaultValues("policyIdentifier"));
        if ("policyQualifiers" in parameters) this.policyQualifiers = getParametersValue(parameters, "policyQualifiers", PolicyInformation.defaultValues("policyQualifiers"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "policyIdentifier":
                return "";
            case "policyQualifiers":
                return [];
            default:
                throw new Error(`Invalid member name for PolicyInformation class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new ObjectIdentifier({
                    name: names.policyIdentifier || ""
                }),
                new Sequence({
                    optional: true,
                    value: [
                        new Repeated({
                            name: names.policyQualifiers || "",
                            value: PolicyQualifierInfo.schema()
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "policyIdentifier",
            "policyQualifiers"
        ]);
        const asn1 = compareSchema(schema, schema, PolicyInformation.schema({
            names: {
                policyIdentifier: "policyIdentifier",
                policyQualifiers: "policyQualifiers"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PolicyInformation");
        this.policyIdentifier = asn1.result.policyIdentifier.valueBlock.toString();
        if ("policyQualifiers" in asn1.result) this.policyQualifiers = Array.from(asn1.result.policyQualifiers, (element)=>new PolicyQualifierInfo({
                schema: element
            })
        );
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(new ObjectIdentifier({
            value: this.policyIdentifier
        }));
        if ("policyQualifiers" in this) {
            outputArray.push(new Sequence({
                value: Array.from(this.policyQualifiers, (element)=>element.toSchema()
                )
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const object = {
            policyIdentifier: this.policyIdentifier
        };
        if ("policyQualifiers" in this) object.policyQualifiers = Array.from(this.policyQualifiers, (element)=>element.toJSON()
        );
        return object;
    }
}
class CertificatePolicies {
    constructor(parameters = {}){
        this.certificatePolicies = getParametersValue(parameters, "certificatePolicies", CertificatePolicies.defaultValues("certificatePolicies"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "certificatePolicies":
                return [];
            default:
                throw new Error(`Invalid member name for CertificatePolicies class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Repeated({
                    name: names.certificatePolicies || "",
                    value: PolicyInformation.schema()
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "certificatePolicies"
        ]);
        const asn1 = compareSchema(schema, schema, CertificatePolicies.schema({
            names: {
                certificatePolicies: "certificatePolicies"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for CertificatePolicies");
        this.certificatePolicies = Array.from(asn1.result.certificatePolicies, (element)=>new PolicyInformation({
                schema: element
            })
        );
    }
    toSchema() {
        return new Sequence({
            value: Array.from(this.certificatePolicies, (element)=>element.toSchema()
            )
        });
    }
    toJSON() {
        return {
            certificatePolicies: Array.from(this.certificatePolicies, (element)=>element.toJSON()
            )
        };
    }
}
class PolicyMapping {
    constructor(parameters = {}){
        this.issuerDomainPolicy = getParametersValue(parameters, "issuerDomainPolicy", PolicyMapping.defaultValues("issuerDomainPolicy"));
        this.subjectDomainPolicy = getParametersValue(parameters, "subjectDomainPolicy", PolicyMapping.defaultValues("subjectDomainPolicy"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "issuerDomainPolicy":
                return "";
            case "subjectDomainPolicy":
                return "";
            default:
                throw new Error(`Invalid member name for PolicyMapping class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new ObjectIdentifier({
                    name: names.issuerDomainPolicy || ""
                }),
                new ObjectIdentifier({
                    name: names.subjectDomainPolicy || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "issuerDomainPolicy",
            "subjectDomainPolicy"
        ]);
        const asn1 = compareSchema(schema, schema, PolicyMapping.schema({
            names: {
                issuerDomainPolicy: "issuerDomainPolicy",
                subjectDomainPolicy: "subjectDomainPolicy"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PolicyMapping");
        this.issuerDomainPolicy = asn1.result.issuerDomainPolicy.valueBlock.toString();
        this.subjectDomainPolicy = asn1.result.subjectDomainPolicy.valueBlock.toString();
    }
    toSchema() {
        return new Sequence({
            value: [
                new ObjectIdentifier({
                    value: this.issuerDomainPolicy
                }),
                new ObjectIdentifier({
                    value: this.subjectDomainPolicy
                })
            ]
        });
    }
    toJSON() {
        return {
            issuerDomainPolicy: this.issuerDomainPolicy,
            subjectDomainPolicy: this.subjectDomainPolicy
        };
    }
}
class PolicyMappings {
    constructor(parameters = {}){
        this.mappings = getParametersValue(parameters, "mappings", PolicyMappings.defaultValues("mappings"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "mappings":
                return [];
            default:
                throw new Error(`Invalid member name for PolicyMappings class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Repeated({
                    name: names.mappings || "",
                    value: PolicyMapping.schema()
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "mappings"
        ]);
        const asn1 = compareSchema(schema, schema, PolicyMappings.schema({
            names: {
                mappings: "mappings"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PolicyMappings");
        this.mappings = Array.from(asn1.result.mappings, (element)=>new PolicyMapping({
                schema: element
            })
        );
    }
    toSchema() {
        return new Sequence({
            value: Array.from(this.mappings, (element)=>element.toSchema()
            )
        });
    }
    toJSON() {
        return {
            mappings: Array.from(this.mappings, (element)=>element.toJSON()
            )
        };
    }
}
class AuthorityKeyIdentifier {
    constructor(parameters = {}){
        if ("keyIdentifier" in parameters) this.keyIdentifier = getParametersValue(parameters, "keyIdentifier", AuthorityKeyIdentifier.defaultValues("keyIdentifier"));
        if ("authorityCertIssuer" in parameters) this.authorityCertIssuer = getParametersValue(parameters, "authorityCertIssuer", AuthorityKeyIdentifier.defaultValues("authorityCertIssuer"));
        if ("authorityCertSerialNumber" in parameters) this.authorityCertSerialNumber = getParametersValue(parameters, "authorityCertSerialNumber", AuthorityKeyIdentifier.defaultValues("authorityCertSerialNumber"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "keyIdentifier":
                return new OctetString();
            case "authorityCertIssuer":
                return [];
            case "authorityCertSerialNumber":
                return new Integer();
            default:
                throw new Error(`Invalid member name for AuthorityKeyIdentifier class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Primitive({
                    name: names.keyIdentifier || "",
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    }
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: [
                        new Repeated({
                            name: names.authorityCertIssuer || "",
                            value: GeneralName.schema()
                        })
                    ]
                }),
                new Primitive({
                    name: names.authorityCertSerialNumber || "",
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 2
                    }
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "keyIdentifier",
            "authorityCertIssuer",
            "authorityCertSerialNumber"
        ]);
        const asn1 = compareSchema(schema, schema, AuthorityKeyIdentifier.schema({
            names: {
                keyIdentifier: "keyIdentifier",
                authorityCertIssuer: "authorityCertIssuer",
                authorityCertSerialNumber: "authorityCertSerialNumber"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for AuthorityKeyIdentifier");
        if ("keyIdentifier" in asn1.result) this.keyIdentifier = new OctetString({
            valueHex: asn1.result.keyIdentifier.valueBlock.valueHex
        });
        if ("authorityCertIssuer" in asn1.result) this.authorityCertIssuer = Array.from(asn1.result.authorityCertIssuer, (element)=>new GeneralName({
                schema: element
            })
        );
        if ("authorityCertSerialNumber" in asn1.result) this.authorityCertSerialNumber = new Integer({
            valueHex: asn1.result.authorityCertSerialNumber.valueBlock.valueHex
        });
    }
    toSchema() {
        const outputArray = [];
        if ("keyIdentifier" in this) {
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: this.keyIdentifier.valueBlock.value
            }));
        }
        if ("authorityCertIssuer" in this) {
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                },
                value: Array.from(this.authorityCertIssuer, (element)=>element.toSchema()
                )
            }));
        }
        if ("authorityCertSerialNumber" in this) {
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 2
                },
                value: this.authorityCertSerialNumber.valueBlock.value
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const object = {};
        if ("keyIdentifier" in this) object.keyIdentifier = this.keyIdentifier.toJSON();
        if ("authorityCertIssuer" in this) object.authorityCertIssuer = Array.from(this.authorityCertIssuer, (element)=>element.toJSON()
        );
        if ("authorityCertSerialNumber" in this) object.authorityCertSerialNumber = this.authorityCertSerialNumber.toJSON();
        return object;
    }
}
class PolicyConstraints {
    constructor(parameters = {}){
        if ("requireExplicitPolicy" in parameters) this.requireExplicitPolicy = getParametersValue(parameters, "requireExplicitPolicy", PolicyConstraints.defaultValues("requireExplicitPolicy"));
        if ("inhibitPolicyMapping" in parameters) this.inhibitPolicyMapping = getParametersValue(parameters, "inhibitPolicyMapping", PolicyConstraints.defaultValues("inhibitPolicyMapping"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "requireExplicitPolicy":
                return 0;
            case "inhibitPolicyMapping":
                return 0;
            default:
                throw new Error(`Invalid member name for PolicyConstraints class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Primitive({
                    name: names.requireExplicitPolicy || "",
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    }
                }),
                new Primitive({
                    name: names.inhibitPolicyMapping || "",
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    }
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "requireExplicitPolicy",
            "inhibitPolicyMapping"
        ]);
        const asn1 = compareSchema(schema, schema, PolicyConstraints.schema({
            names: {
                requireExplicitPolicy: "requireExplicitPolicy",
                inhibitPolicyMapping: "inhibitPolicyMapping"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PolicyConstraints");
        if ("requireExplicitPolicy" in asn1.result) {
            const field1 = asn1.result.requireExplicitPolicy;
            field1.idBlock.tagClass = 1;
            field1.idBlock.tagNumber = 2;
            const ber1 = field1.toBER(false);
            const int1 = fromBER(ber1);
            this.requireExplicitPolicy = int1.result.valueBlock.valueDec;
        }
        if ("inhibitPolicyMapping" in asn1.result) {
            const field2 = asn1.result.inhibitPolicyMapping;
            field2.idBlock.tagClass = 1;
            field2.idBlock.tagNumber = 2;
            const ber2 = field2.toBER(false);
            const int2 = fromBER(ber2);
            this.inhibitPolicyMapping = int2.result.valueBlock.valueDec;
        }
    }
    toSchema() {
        const outputArray = [];
        if ("requireExplicitPolicy" in this) {
            const int1 = new Integer({
                value: this.requireExplicitPolicy
            });
            int1.idBlock.tagClass = 3;
            int1.idBlock.tagNumber = 0;
            outputArray.push(int1);
        }
        if ("inhibitPolicyMapping" in this) {
            const int2 = new Integer({
                value: this.inhibitPolicyMapping
            });
            int2.idBlock.tagClass = 3;
            int2.idBlock.tagNumber = 1;
            outputArray.push(int2);
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const object = {};
        if ("requireExplicitPolicy" in this) object.requireExplicitPolicy = this.requireExplicitPolicy;
        if ("inhibitPolicyMapping" in this) object.inhibitPolicyMapping = this.inhibitPolicyMapping;
        return object;
    }
}
class ExtKeyUsage {
    constructor(parameters = {}){
        this.keyPurposes = getParametersValue(parameters, "keyPurposes", ExtKeyUsage.defaultValues("keyPurposes"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "keyPurposes":
                return [];
            default:
                throw new Error(`Invalid member name for ExtKeyUsage class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Repeated({
                    name: names.keyPurposes || "",
                    value: new ObjectIdentifier()
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "keyPurposes"
        ]);
        const asn1 = compareSchema(schema, schema, ExtKeyUsage.schema({
            names: {
                keyPurposes: "keyPurposes"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for ExtKeyUsage");
        this.keyPurposes = Array.from(asn1.result.keyPurposes, (element)=>element.valueBlock.toString()
        );
    }
    toSchema() {
        return new Sequence({
            value: Array.from(this.keyPurposes, (element)=>new ObjectIdentifier({
                    value: element
                })
            )
        });
    }
    toJSON() {
        return {
            keyPurposes: Array.from(this.keyPurposes)
        };
    }
}
class InfoAccess {
    constructor(parameters = {}){
        this.accessDescriptions = getParametersValue(parameters, "accessDescriptions", InfoAccess.defaultValues("accessDescriptions"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "accessDescriptions":
                return [];
            default:
                throw new Error(`Invalid member name for InfoAccess class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Repeated({
                    name: names.accessDescriptions || "",
                    value: AccessDescription.schema()
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "accessDescriptions"
        ]);
        const asn1 = compareSchema(schema, schema, InfoAccess.schema({
            names: {
                accessDescriptions: "accessDescriptions"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for InfoAccess");
        this.accessDescriptions = Array.from(asn1.result.accessDescriptions, (element)=>new AccessDescription({
                schema: element
            })
        );
    }
    toSchema() {
        return new Sequence({
            value: Array.from(this.accessDescriptions, (element)=>element.toSchema()
            )
        });
    }
    toJSON() {
        return {
            accessDescriptions: Array.from(this.accessDescriptions, (element)=>element.toJSON()
            )
        };
    }
}
class ByteStream {
    constructor(parameters = {}){
        this.clear();
        for (const key of Object.keys(parameters)){
            switch(key){
                case "length":
                    this.length = parameters.length;
                    break;
                case "stub":
                    for(let i146 = 0; i146 < this._view.length; i146++)this._view[i146] = parameters.stub;
                    break;
                case "view":
                    this.fromUint8Array(parameters.view);
                    break;
                case "buffer":
                    this.fromArrayBuffer(parameters.buffer);
                    break;
                case "string":
                    this.fromString(parameters.string);
                    break;
                case "hexstring":
                    this.fromHexString(parameters.hexstring);
                    break;
                default:
            }
        }
    }
    set buffer(value) {
        this._buffer = value.slice(0);
        this._view = new Uint8Array(this._buffer);
    }
    get buffer() {
        return this._buffer;
    }
    set view(value) {
        this._buffer = new ArrayBuffer(value.length);
        this._view = new Uint8Array(this._buffer);
        this._view.set(value);
    }
    get view() {
        return this._view;
    }
    get length() {
        return this._buffer.byteLength;
    }
    set length(value) {
        this._buffer = new ArrayBuffer(value);
        this._view = new Uint8Array(this._buffer);
    }
    clear() {
        this._buffer = new ArrayBuffer(0);
        this._view = new Uint8Array(this._buffer);
    }
    fromArrayBuffer(array) {
        this.buffer = array;
    }
    fromUint8Array(array) {
        this._buffer = new ArrayBuffer(array.length);
        this._view = new Uint8Array(this._buffer);
        this._view.set(array);
    }
    fromString(string) {
        const stringLength = string.length;
        this.length = stringLength;
        for(let i147 = 0; i147 < stringLength; i147++)this.view[i147] = string.charCodeAt(i147);
    }
    toString(start = 0, length = this.view.length - start) {
        let result = "";
        if (start >= this.view.length || start < 0) {
            start = 0;
        }
        if (length >= this.view.length || length < 0) {
            length = this.view.length - start;
        }
        for(let i148 = start; i148 < start + length; i148++)result += String.fromCharCode(this.view[i148]);
        return result;
    }
    fromHexString(hexString) {
        const stringLength = hexString.length;
        this.buffer = new ArrayBuffer(stringLength >> 1);
        this.view = new Uint8Array(this.buffer);
        const hexMap = new Map();
        hexMap.set("0", 0x00);
        hexMap.set("1", 0x01);
        hexMap.set("2", 0x02);
        hexMap.set("3", 0x03);
        hexMap.set("4", 0x04);
        hexMap.set("5", 0x05);
        hexMap.set("6", 0x06);
        hexMap.set("7", 0x07);
        hexMap.set("8", 0x08);
        hexMap.set("9", 0x09);
        hexMap.set("A", 0x0A);
        hexMap.set("a", 0x0A);
        hexMap.set("B", 0x0B);
        hexMap.set("b", 0x0B);
        hexMap.set("C", 0x0C);
        hexMap.set("c", 0x0C);
        hexMap.set("D", 0x0D);
        hexMap.set("d", 0x0D);
        hexMap.set("E", 0x0E);
        hexMap.set("e", 0x0E);
        hexMap.set("F", 0x0F);
        hexMap.set("f", 0x0F);
        let j = 0;
        let temp = 0x00;
        for(let i149 = 0; i149 < stringLength; i149++){
            if (!(i149 % 2)) {
                temp = hexMap.get(hexString.charAt(i149)) << 4;
            } else {
                temp |= hexMap.get(hexString.charAt(i149));
                this.view[j] = temp;
                j++;
            }
        }
    }
    toHexString(start = 0, length = this.view.length - start) {
        let result = "";
        if (start >= this.view.length || start < 0) {
            start = 0;
        }
        if (length >= this.view.length || length < 0) {
            length = this.view.length - start;
        }
        for(let i150 = start; i150 < start + length; i150++){
            const str = this.view[i150].toString(16).toUpperCase();
            result = result + (str.length == 1 ? "0" : "") + str;
        }
        return result;
    }
    copy(start = 0, length = this._buffer.byteLength - start) {
        if (start === 0 && this._buffer.byteLength === 0) return new ByteStream();
        if (start < 0 || start > this._buffer.byteLength - 1) throw new Error(`Wrong start position: ${start}`);
        const stream = new ByteStream();
        stream._buffer = this._buffer.slice(start, start + length);
        stream._view = new Uint8Array(stream._buffer);
        return stream;
    }
    slice(start = 0, end = this._buffer.byteLength) {
        if (start === 0 && this._buffer.byteLength === 0) return new ByteStream();
        if (start < 0 || start > this._buffer.byteLength - 1) throw new Error(`Wrong start position: ${start}`);
        const stream = new ByteStream();
        stream._buffer = this._buffer.slice(start, end);
        stream._view = new Uint8Array(stream._buffer);
        return stream;
    }
    realloc(size) {
        const buffer = new ArrayBuffer(size);
        const view = new Uint8Array(buffer);
        if (size > this._view.length) view.set(this._view);
        else {
            view.set(new Uint8Array(this._buffer, 0, size));
        }
        this._buffer = buffer.slice(0);
        this._view = new Uint8Array(this._buffer);
    }
    append(stream) {
        const initialSize = this._buffer.byteLength;
        const streamViewLength = stream._buffer.byteLength;
        const copyView = stream._view.slice();
        this.realloc(initialSize + streamViewLength);
        this._view.set(copyView, initialSize);
    }
    insert(stream, start = 0, length = this._buffer.byteLength - start) {
        if (start > this._buffer.byteLength - 1) return false;
        if (length > this._buffer.byteLength - start) {
            length = this._buffer.byteLength - start;
        }
        if (length > stream._buffer.byteLength) {
            length = stream._buffer.byteLength;
        }
        if (length == stream._buffer.byteLength) this._view.set(stream._view, start);
        else {
            this._view.set(stream._view.slice(0, length), start);
        }
        return true;
    }
    isEqual(stream) {
        if (this._buffer.byteLength != stream._buffer.byteLength) return false;
        for(let i151 = 0; i151 < stream._buffer.byteLength; i151++){
            if (this.view[i151] != stream.view[i151]) return false;
        }
        return true;
    }
    isEqualView(view) {
        if (view.length != this.view.length) return false;
        for(let i152 = 0; i152 < view.length; i152++){
            if (this.view[i152] != view[i152]) return false;
        }
        return true;
    }
    findPattern(pattern, start = null, length = null, backward = false) {
        if (start == null) {
            start = backward ? this.buffer.byteLength : 0;
        }
        if (start > this.buffer.byteLength) {
            start = this.buffer.byteLength;
        }
        if (backward) {
            if (length == null) {
                length = start;
            }
            if (length > start) {
                length = start;
            }
        } else {
            if (length == null) {
                length = this.buffer.byteLength - start;
            }
            if (length > this.buffer.byteLength - start) {
                length = this.buffer.byteLength - start;
            }
        }
        const patternLength = pattern.buffer.byteLength;
        if (patternLength > length) return -1;
        const patternArray = [];
        for(let i153 = 0; i153 < patternLength; i153++)patternArray.push(pattern.view[i153]);
        for(let i1 = 0; i1 <= length - patternLength; i1++){
            let equal = true;
            const equalStart = backward ? start - patternLength - i1 : start + i1;
            for(let j = 0; j < patternLength; j++){
                if (this.view[j + equalStart] != patternArray[j]) {
                    equal = false;
                    break;
                }
            }
            if (equal) {
                return backward ? start - patternLength - i1 : start + patternLength + i1;
            }
        }
        return -1;
    }
    findFirstIn(patterns, start = null, length = null, backward = false) {
        if (start == null) {
            start = backward ? this.buffer.byteLength : 0;
        }
        if (start > this.buffer.byteLength) {
            start = this.buffer.byteLength;
        }
        if (backward) {
            if (length == null) {
                length = start;
            }
            if (length > start) {
                length = start;
            }
        } else {
            if (length == null) {
                length = this.buffer.byteLength - start;
            }
            if (length > this.buffer.byteLength - start) {
                length = this.buffer.byteLength - start;
            }
        }
        const result = {
            id: -1,
            position: backward ? 0 : start + length,
            length: 0
        };
        for(let i154 = 0; i154 < patterns.length; i154++){
            const position2 = this.findPattern(patterns[i154], start, length, backward);
            if (position2 != -1) {
                let valid = false;
                const patternLength = patterns[i154].length;
                if (backward) {
                    if (position2 - patternLength >= result.position - result.length) valid = true;
                } else {
                    if (position2 - patternLength <= result.position - result.length) valid = true;
                }
                if (valid) {
                    result.position = position2;
                    result.id = i154;
                    result.length = patternLength;
                }
            }
        }
        return result;
    }
    findAllIn(patterns, start = 0, length = this.buffer.byteLength - start) {
        const result = [];
        if (start == null) {
            start = 0;
        }
        if (start > this.buffer.byteLength - 1) return result;
        if (length == null) {
            length = this.buffer.byteLength - start;
        }
        if (length > this.buffer.byteLength - start) {
            length = this.buffer.byteLength - start;
        }
        let patternFound = {
            id: -1,
            position: start
        };
        do {
            const position3 = patternFound.position;
            patternFound = this.findFirstIn(patterns, patternFound.position, length);
            if (patternFound.id == -1) {
                break;
            }
            length -= patternFound.position - position3;
            result.push({
                id: patternFound.id,
                position: patternFound.position
            });
        }while (true)
        return result;
    }
    findAllPatternIn(pattern, start = 0, length = this.buffer.byteLength - start) {
        if (start == null) {
            start = 0;
        }
        if (start > this.buffer.byteLength) {
            start = this.buffer.byteLength;
        }
        if (length == null) {
            length = this.buffer.byteLength - start;
        }
        if (length > this.buffer.byteLength - start) {
            length = this.buffer.byteLength - start;
        }
        const result = [];
        const patternLength = pattern.buffer.byteLength;
        if (patternLength > length) return -1;
        const patternArray = Array.from(pattern.view);
        for(let i155 = 0; i155 <= length - patternLength; i155++){
            let equal = true;
            const equalStart = start + i155;
            for(let j = 0; j < patternLength; j++){
                if (this.view[j + equalStart] != patternArray[j]) {
                    equal = false;
                    break;
                }
            }
            if (equal) {
                result.push(start + patternLength + i155);
                i155 += patternLength - 1;
            }
        }
        return result;
    }
    findFirstNotIn(patterns, start = null, length = null, backward = false) {
        if (start == null) {
            start = backward ? this.buffer.byteLength : 0;
        }
        if (start > this.buffer.byteLength) {
            start = this.buffer.byteLength;
        }
        if (backward) {
            if (length == null) {
                length = start;
            }
            if (length > start) {
                length = start;
            }
        } else {
            if (length == null) {
                length = this.buffer.byteLength - start;
            }
            if (length > this.buffer.byteLength - start) {
                length = this.buffer.byteLength - start;
            }
        }
        const result = {
            left: {
                id: -1,
                position: start
            },
            right: {
                id: -1,
                position: 0
            },
            value: new ByteStream()
        };
        let currentLength = length;
        while(currentLength > 0){
            result.right = this.findFirstIn(patterns, backward ? start - length + currentLength : start + length - currentLength, currentLength, backward);
            if (result.right.id == -1) {
                length = currentLength;
                if (backward) {
                    start -= length;
                } else {
                    start = result.left.position;
                }
                result.value = new ByteStream();
                result.value._buffer = this._buffer.slice(start, start + length);
                result.value._view = new Uint8Array(result.value._buffer);
                break;
            }
            if (result.right.position != (backward ? result.left.position - patterns[result.right.id].buffer.byteLength : result.left.position + patterns[result.right.id].buffer.byteLength)) {
                if (backward) {
                    start = result.right.position + patterns[result.right.id].buffer.byteLength;
                    length = result.left.position - result.right.position - patterns[result.right.id].buffer.byteLength;
                } else {
                    start = result.left.position;
                    length = result.right.position - result.left.position - patterns[result.right.id].buffer.byteLength;
                }
                result.value = new ByteStream();
                result.value._buffer = this._buffer.slice(start, start + length);
                result.value._view = new Uint8Array(result.value._buffer);
                break;
            }
            result.left = result.right;
            currentLength -= patterns[result.right.id]._buffer.byteLength;
        }
        if (backward) {
            const temp = result.right;
            result.right = result.left;
            result.left = temp;
        }
        return result;
    }
    findAllNotIn(patterns, start = null, length = null) {
        const result = [];
        if (start == null) {
            start = 0;
        }
        if (start > this.buffer.byteLength - 1) return result;
        if (length == null) {
            length = this.buffer.byteLength - start;
        }
        if (length > this.buffer.byteLength - start) {
            length = this.buffer.byteLength - start;
        }
        let patternFound = {
            left: {
                id: -1,
                position: start
            },
            right: {
                id: -1,
                position: start
            },
            value: new ByteStream()
        };
        do {
            const position4 = patternFound.right.position;
            patternFound = this.findFirstNotIn(patterns, patternFound.right.position, length);
            length -= patternFound.right.position - position4;
            result.push({
                left: {
                    id: patternFound.left.id,
                    position: patternFound.left.position
                },
                right: {
                    id: patternFound.right.id,
                    position: patternFound.right.position
                },
                value: patternFound.value
            });
        }while (patternFound.right.id != -1)
        return result;
    }
    findFirstSequence(patterns, start = null, length = null, backward = false) {
        if (start == null) {
            start = backward ? this.buffer.byteLength : 0;
        }
        if (start > this.buffer.byteLength) {
            start = this.buffer.byteLength;
        }
        if (backward) {
            if (length == null) {
                length = start;
            }
            if (length > start) {
                length = start;
            }
        } else {
            if (length == null) {
                length = this.buffer.byteLength - start;
            }
            if (length > this.buffer.byteLength - start) {
                length = this.buffer.byteLength - start;
            }
        }
        const firstIn = this.skipNotPatterns(patterns, start, length, backward);
        if (firstIn == -1) {
            return {
                position: -1,
                value: new ByteStream()
            };
        }
        const firstNotIn = this.skipPatterns(patterns, firstIn, length - (backward ? start - firstIn : firstIn - start), backward);
        if (backward) {
            start = firstNotIn;
            length = firstIn - firstNotIn;
        } else {
            start = firstIn;
            length = firstNotIn - firstIn;
        }
        const value = new ByteStream();
        value._buffer = this._buffer.slice(start, start + length);
        value._view = new Uint8Array(value._buffer);
        return {
            position: firstNotIn,
            value
        };
    }
    findAllSequences(patterns, start = null, length = null) {
        const result = [];
        if (start == null) {
            start = 0;
        }
        if (start > this.buffer.byteLength - 1) return result;
        if (length == null) {
            length = this.buffer.byteLength - start;
        }
        if (length > this.buffer.byteLength - start) {
            length = this.buffer.byteLength - start;
        }
        let patternFound = {
            position: start,
            value: new ByteStream()
        };
        do {
            const position5 = patternFound.position;
            patternFound = this.findFirstSequence(patterns, patternFound.position, length);
            if (patternFound.position != -1) {
                length -= patternFound.position - position5;
                result.push({
                    position: patternFound.position,
                    value: patternFound.value
                });
            }
        }while (patternFound.position != -1)
        return result;
    }
    findPairedPatterns(leftPattern, rightPattern, start = null, length = null) {
        const result = [];
        if (leftPattern.isEqual(rightPattern)) return result;
        if (start == null) {
            start = 0;
        }
        if (start > this.buffer.byteLength - 1) return result;
        if (length == null) {
            length = this.buffer.byteLength - start;
        }
        if (length > this.buffer.byteLength - start) {
            length = this.buffer.byteLength - start;
        }
        let currentPositionLeft = 0;
        const leftPatterns = this.findAllPatternIn(leftPattern, start, length);
        if (leftPatterns.length == 0) return result;
        const rightPatterns = this.findAllPatternIn(rightPattern, start, length);
        if (rightPatterns.length == 0) return result;
        while(currentPositionLeft < leftPatterns.length){
            if (rightPatterns.length == 0) {
                break;
            }
            if (leftPatterns[0] == rightPatterns[0]) {
                result.push({
                    left: leftPatterns[0],
                    right: rightPatterns[0]
                });
                leftPatterns.splice(0, 1);
                rightPatterns.splice(0, 1);
                continue;
            }
            if (leftPatterns[currentPositionLeft] > rightPatterns[0]) {
                break;
            }
            while(leftPatterns[currentPositionLeft] < rightPatterns[0]){
                currentPositionLeft++;
                if (currentPositionLeft >= leftPatterns.length) {
                    break;
                }
            }
            result.push({
                left: leftPatterns[currentPositionLeft - 1],
                right: rightPatterns[0]
            });
            leftPatterns.splice(currentPositionLeft - 1, 1);
            rightPatterns.splice(0, 1);
            currentPositionLeft = 0;
        }
        result.sort((a20, b)=>a20.left - b.left
        );
        return result;
    }
    findPairedArrays(inputLeftPatterns, inputRightPatterns, start = null, length = null) {
        const result = [];
        if (start == null) {
            start = 0;
        }
        if (start > this.buffer.byteLength - 1) return result;
        if (length == null) {
            length = this.buffer.byteLength - start;
        }
        if (length > this.buffer.byteLength - start) {
            length = this.buffer.byteLength - start;
        }
        let currentPositionLeft = 0;
        const leftPatterns = this.findAllIn(inputLeftPatterns, start, length);
        if (leftPatterns.length == 0) return result;
        const rightPatterns = this.findAllIn(inputRightPatterns, start, length);
        if (rightPatterns.length == 0) return result;
        while(currentPositionLeft < leftPatterns.length){
            if (rightPatterns.length == 0) {
                break;
            }
            if (leftPatterns[0].position == rightPatterns[0].position) {
                result.push({
                    left: leftPatterns[0],
                    right: rightPatterns[0]
                });
                leftPatterns.splice(0, 1);
                rightPatterns.splice(0, 1);
                continue;
            }
            if (leftPatterns[currentPositionLeft].position > rightPatterns[0].position) {
                break;
            }
            while(leftPatterns[currentPositionLeft].position < rightPatterns[0].position){
                currentPositionLeft++;
                if (currentPositionLeft >= leftPatterns.length) {
                    break;
                }
            }
            result.push({
                left: leftPatterns[currentPositionLeft - 1],
                right: rightPatterns[0]
            });
            leftPatterns.splice(currentPositionLeft - 1, 1);
            rightPatterns.splice(0, 1);
            currentPositionLeft = 0;
        }
        result.sort((a21, b)=>a21.left.position - b.left.position
        );
        return result;
    }
    replacePattern(searchPattern, replacePattern, start = null, length = null, findAllResult = null) {
        let result;
        let i156;
        const output = {
            status: -1,
            searchPatternPositions: [],
            replacePatternPositions: []
        };
        if (start == null) {
            start = 0;
        }
        if (start > this.buffer.byteLength - 1) return false;
        if (length == null) {
            length = this.buffer.byteLength - start;
        }
        if (length > this.buffer.byteLength - start) {
            length = this.buffer.byteLength - start;
        }
        if (findAllResult == null) {
            result = this.findAllIn([
                searchPattern
            ], start, length);
            if (result.length == 0) return output;
        } else result = findAllResult;
        output.searchPatternPositions.push(...Array.from(result, (element)=>element.position
        ));
        const patternDifference = searchPattern.buffer.byteLength - replacePattern.buffer.byteLength;
        const changedBuffer = new ArrayBuffer(this.view.length - result.length * patternDifference);
        const changedView = new Uint8Array(changedBuffer);
        changedView.set(new Uint8Array(this.buffer, 0, start));
        for(i156 = 0; i156 < result.length; i156++){
            const currentPosition = i156 == 0 ? start : result[i156 - 1].position;
            changedView.set(new Uint8Array(this.buffer, currentPosition, result[i156].position - searchPattern.buffer.byteLength - currentPosition), currentPosition - i156 * patternDifference);
            changedView.set(replacePattern.view, result[i156].position - searchPattern.buffer.byteLength - i156 * patternDifference);
            output.replacePatternPositions.push(result[i156].position - searchPattern.buffer.byteLength - i156 * patternDifference);
        }
        i156--;
        changedView.set(new Uint8Array(this.buffer, result[i156].position, this.buffer.byteLength - result[i156].position), result[i156].position - searchPattern.buffer.byteLength + replacePattern.buffer.byteLength - i156 * patternDifference);
        this.buffer = changedBuffer;
        this.view = new Uint8Array(this.buffer);
        output.status = 1;
        return output;
    }
    skipPatterns(patterns, start = null, length = null, backward = false) {
        if (start == null) {
            start = backward ? this.buffer.byteLength : 0;
        }
        if (start > this.buffer.byteLength) {
            start = this.buffer.byteLength;
        }
        if (backward) {
            if (length == null) {
                length = start;
            }
            if (length > start) {
                length = start;
            }
        } else {
            if (length == null) {
                length = this.buffer.byteLength - start;
            }
            if (length > this.buffer.byteLength - start) {
                length = this.buffer.byteLength - start;
            }
        }
        let result = start;
        for(let k = 0; k < patterns.length; k++){
            const patternLength = patterns[k].buffer.byteLength;
            const equalStart = backward ? result - patternLength : result;
            let equal = true;
            for(let j = 0; j < patternLength; j++){
                if (this.view[j + equalStart] != patterns[k].view[j]) {
                    equal = false;
                    break;
                }
            }
            if (equal) {
                k = -1;
                if (backward) {
                    result -= patternLength;
                    if (result <= 0) return result;
                } else {
                    result += patternLength;
                    if (result >= start + length) return result;
                }
            }
        }
        return result;
    }
    skipNotPatterns(patterns, start = null, length = null, backward = false) {
        if (start == null) {
            start = backward ? this.buffer.byteLength : 0;
        }
        if (start > this.buffer.byteLength) {
            start = this.buffer.byteLength;
        }
        if (backward) {
            if (length == null) {
                length = start;
            }
            if (length > start) {
                length = start;
            }
        } else {
            if (length == null) {
                length = this.buffer.byteLength - start;
            }
            if (length > this.buffer.byteLength - start) {
                length = this.buffer.byteLength - start;
            }
        }
        let result = -1;
        for(let i157 = 0; i157 < length; i157++){
            for(let k = 0; k < patterns.length; k++){
                const patternLength = patterns[k].buffer.byteLength;
                const equalStart = backward ? start - i157 - patternLength : start + i157;
                let equal = true;
                for(let j = 0; j < patternLength; j++){
                    if (this.view[j + equalStart] != patterns[k].view[j]) {
                        equal = false;
                        break;
                    }
                }
                if (equal) {
                    result = backward ? start - i157 : start + i157;
                    break;
                }
            }
            if (result != -1) {
                break;
            }
        }
        return result;
    }
}
class SeqStream {
    constructor(parameters = {}){
        this.stream = new ByteStream();
        this._length = 0;
        this.backward = false;
        this._start = 0;
        this.appendBlock = 0;
        this.prevLength = 0;
        this.prevStart = 0;
        for (const key of Object.keys(parameters)){
            switch(key){
                case "stream":
                    this.stream = parameters.stream;
                    break;
                case "backward":
                    this.backward = parameters.backward;
                    this._start = this.stream.buffer.byteLength;
                    break;
                case "length":
                    this._length = parameters.length;
                    break;
                case "start":
                    this._start = parameters.start;
                    break;
                case "appendBlock":
                    this.appendBlock = parameters.appendBlock;
                    break;
                case "view":
                    this.stream = new ByteStream({
                        view: parameters.view
                    });
                    break;
                case "buffer":
                    this.stream = new ByteStream({
                        buffer: parameters.buffer
                    });
                    break;
                case "string":
                    this.stream = new ByteStream({
                        string: parameters.string
                    });
                    break;
                case "hexstring":
                    this.stream = new ByteStream({
                        hexstring: parameters.hexstring
                    });
                    break;
                default:
            }
        }
    }
    set stream(value) {
        this._stream = value;
        this.prevLength = this._length;
        this._length = value._buffer.byteLength;
        this.prevStart = this._start;
        this._start = 0;
    }
    get stream() {
        return this._stream;
    }
    set length(value) {
        this.prevLength = this._length;
        this._length = value;
    }
    get length() {
        if (this.appendBlock) return this.start;
        return this._length;
    }
    set start(value) {
        if (value > this.stream.buffer.byteLength) return;
        this.prevStart = this._start;
        this.prevLength = this._length;
        this._length -= this.backward ? this._start - value : value - this._start;
        this._start = value;
    }
    get start() {
        return this._start;
    }
    get buffer() {
        return this._stream._buffer.slice(0, this._length);
    }
    resetPosition() {
        this._start = this.prevStart;
        this._length = this.prevLength;
    }
    findPattern(pattern, gap = null) {
        if (gap == null || gap > this.length) {
            gap = this.length;
        }
        const result = this.stream.findPattern(pattern, this.start, this.length, this.backward);
        if (result == -1) return result;
        if (this.backward) {
            if (result < this.start - pattern.buffer.byteLength - gap) return -1;
        } else {
            if (result > this.start + pattern.buffer.byteLength + gap) return -1;
        }
        this.start = result;
        return result;
    }
    findFirstIn(patterns, gap = null) {
        if (gap == null || gap > this.length) {
            gap = this.length;
        }
        const result = this.stream.findFirstIn(patterns, this.start, this.length, this.backward);
        if (result.id == -1) return result;
        if (this.backward) {
            if (result.position < this.start - patterns[result.id].buffer.byteLength - gap) {
                return {
                    id: -1,
                    position: this.backward ? 0 : this.start + this.length
                };
            }
        } else {
            if (result.position > this.start + patterns[result.id].buffer.byteLength + gap) {
                return {
                    id: -1,
                    position: this.backward ? 0 : this.start + this.length
                };
            }
        }
        this.start = result.position;
        return result;
    }
    findAllIn(patterns) {
        const start = this.backward ? this.start - this.length : this.start;
        return this.stream.findAllIn(patterns, start, this.length);
    }
    findFirstNotIn(patterns, gap = null) {
        if (gap == null || gap > this._length) {
            gap = this._length;
        }
        const result = this._stream.findFirstNotIn(patterns, this._start, this._length, this.backward);
        if (result.left.id == -1 && result.right.id == -1) return result;
        if (this.backward) {
            if (result.right.id != -1) {
                if (result.right.position < this._start - patterns[result.right.id]._buffer.byteLength - gap) {
                    return {
                        left: {
                            id: -1,
                            position: this._start
                        },
                        right: {
                            id: -1,
                            position: 0
                        },
                        value: new ByteStream()
                    };
                }
            }
        } else {
            if (result.left.id != -1) {
                if (result.left.position > this._start + patterns[result.left.id]._buffer.byteLength + gap) {
                    return {
                        left: {
                            id: -1,
                            position: this._start
                        },
                        right: {
                            id: -1,
                            position: 0
                        },
                        value: new ByteStream()
                    };
                }
            }
        }
        if (this.backward) {
            if (result.left.id == -1) this.start = 0;
            else this.start = result.left.position;
        } else {
            if (result.right.id == -1) this.start = this._start + this._length;
            else this.start = result.right.position;
        }
        return result;
    }
    findAllNotIn(patterns) {
        const start = this.backward ? this._start - this._length : this._start;
        return this._stream.findAllNotIn(patterns, start, this._length);
    }
    findFirstSequence(patterns, length = null, gap = null) {
        if (length == null || length > this._length) {
            length = this._length;
        }
        if (gap == null || gap > length) {
            gap = length;
        }
        const result = this._stream.findFirstSequence(patterns, this._start, length, this.backward);
        if (result.value.buffer.byteLength == 0) return result;
        if (this.backward) {
            if (result.position < this._start - result.value._buffer.byteLength - gap) {
                return {
                    position: -1,
                    value: new ByteStream()
                };
            }
        } else {
            if (result.position > this._start + result.value._buffer.byteLength + gap) {
                return {
                    position: -1,
                    value: new ByteStream()
                };
            }
        }
        this.start = result.position;
        return result;
    }
    findAllSequences(patterns) {
        const start = this.backward ? this.start - this.length : this.start;
        return this.stream.findAllSequences(patterns, start, this.length);
    }
    findPairedPatterns(leftPattern, rightPattern, gap = null) {
        if (gap == null || gap > this.length) {
            gap = this.length;
        }
        const start = this.backward ? this.start - this.length : this.start;
        const result = this.stream.findPairedPatterns(leftPattern, rightPattern, start, this.length);
        if (result.length) {
            if (this.backward) {
                if (result[0].right < this.start - rightPattern.buffer.byteLength - gap) return [];
            } else {
                if (result[0].left > this.start + leftPattern.buffer.byteLength + gap) return [];
            }
        }
        return result;
    }
    findPairedArrays(leftPatterns, rightPatterns, gap = null) {
        if (gap == null || gap > this.length) {
            gap = this.length;
        }
        const start = this.backward ? this.start - this.length : this.start;
        const result = this.stream.findPairedArrays(leftPatterns, rightPatterns, start, this.length);
        if (result.length) {
            if (this.backward) {
                if (result[0].right.position < this.start - rightPatterns[result[0].right.id].buffer.byteLength - gap) return [];
            } else {
                if (result[0].left.position > this.start + leftPatterns[result[0].left.id].buffer.byteLength + gap) return [];
            }
        }
        return result;
    }
    replacePattern(searchPattern, replacePattern) {
        const start = this.backward ? this.start - this.length : this.start;
        return this.stream.replacePattern(searchPattern, replacePattern, start, this.length);
    }
    skipPatterns(patterns) {
        const result = this.stream.skipPatterns(patterns, this.start, this.length, this.backward);
        this.start = result;
        return result;
    }
    skipNotPatterns(patterns) {
        const result = this.stream.skipNotPatterns(patterns, this.start, this.length, this.backward);
        if (result == -1) return -1;
        this.start = result;
        return result;
    }
    append(stream) {
        if (this._start + stream._buffer.byteLength > this._stream._buffer.byteLength) {
            if (stream._buffer.byteLength > this.appendBlock) {
                this.appendBlock = stream._buffer.byteLength + 1000;
            }
            this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
        }
        this._stream._view.set(stream._view, this._start);
        this._length += stream._buffer.byteLength * 2;
        this.start = this._start + stream._buffer.byteLength;
        this.prevLength -= stream._buffer.byteLength * 2;
    }
    appendView(view) {
        if (this._start + view.length > this._stream._buffer.byteLength) {
            if (view.length > this.appendBlock) {
                this.appendBlock = view.length + 1000;
            }
            this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
        }
        this._stream._view.set(view, this._start);
        this._length += view.length * 2;
        this.start = this._start + view.length;
        this.prevLength -= view.length * 2;
    }
    appendChar(__char) {
        if (this._start + 1 > this._stream._buffer.byteLength) {
            if (1 > this.appendBlock) {
                this.appendBlock = 1000;
            }
            this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
        }
        this._stream._view[this._start] = __char;
        this._length += 2;
        this.start = this._start + 1;
        this.prevLength -= 2;
    }
    appendUint16(number) {
        if (this._start + 2 > this._stream._buffer.byteLength) {
            if (2 > this.appendBlock) {
                this.appendBlock = 1000;
            }
            this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
        }
        const value = new Uint16Array([
            number
        ]);
        const view = new Uint8Array(value.buffer);
        this._stream._view[this._start] = view[1];
        this._stream._view[this._start + 1] = view[0];
        this._length += 4;
        this.start = this._start + 2;
        this.prevLength -= 4;
    }
    appendUint24(number) {
        if (this._start + 3 > this._stream._buffer.byteLength) {
            if (3 > this.appendBlock) {
                this.appendBlock = 1000;
            }
            this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
        }
        const value = new Uint32Array([
            number
        ]);
        const view = new Uint8Array(value.buffer);
        this._stream._view[this._start] = view[2];
        this._stream._view[this._start + 1] = view[1];
        this._stream._view[this._start + 2] = view[0];
        this._length += 6;
        this.start = this._start + 3;
        this.prevLength -= 6;
    }
    appendUint32(number) {
        if (this._start + 4 > this._stream._buffer.byteLength) {
            if (4 > this.appendBlock) {
                this.appendBlock = 1000;
            }
            this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
        }
        const value = new Uint32Array([
            number
        ]);
        const view = new Uint8Array(value.buffer);
        this._stream._view[this._start] = view[3];
        this._stream._view[this._start + 1] = view[2];
        this._stream._view[this._start + 2] = view[1];
        this._stream._view[this._start + 3] = view[0];
        this._length += 8;
        this.start = this._start + 4;
        this.prevLength -= 8;
    }
    getBlock(size, changeLength = true) {
        if (this._length <= 0) return [];
        if (this._length < size) {
            size = this._length;
        }
        let result;
        if (this.backward) {
            const buffer = this._stream._buffer.slice(this._length - size, this._length);
            const view = new Uint8Array(buffer);
            result = new Array(size);
            for(let i158 = 0; i158 < size; i158++)result[size - 1 - i158] = view[i158];
        } else {
            const buffer = this._stream._buffer.slice(this._start, this._start + size);
            result = Array.from(new Uint8Array(buffer));
        }
        if (changeLength) {
            this.start += this.backward ? -1 * size : size;
        }
        return result;
    }
    getUint16(changeLength = true) {
        const block = this.getBlock(2, changeLength);
        if (block.length < 2) return 0;
        const value = new Uint16Array(1);
        const view = new Uint8Array(value.buffer);
        view[0] = block[1];
        view[1] = block[0];
        return value[0];
    }
    getInt16(changeLength = true) {
        const block = this.getBlock(2, changeLength);
        if (block.length < 2) return 0;
        const value = new Int16Array(1);
        const view = new Uint8Array(value.buffer);
        view[0] = block[1];
        view[1] = block[0];
        return value[0];
    }
    getUint24(changeLength = true) {
        const block = this.getBlock(3, changeLength);
        if (block.length < 3) return 0;
        const value = new Uint32Array(1);
        const view = new Uint8Array(value.buffer);
        for(let i159 = 3; i159 >= 1; i159--)view[3 - i159] = block[i159 - 1];
        return value[0];
    }
    getUint32(changeLength = true) {
        const block = this.getBlock(4, changeLength);
        if (block.length < 4) return 0;
        const value = new Uint32Array(1);
        const view = new Uint8Array(value.buffer);
        for(let i160 = 3; i160 >= 0; i160--)view[3 - i160] = block[i160];
        return value[0];
    }
    getInt32(changeLength = true) {
        const block = this.getBlock(4, changeLength);
        if (block.length < 4) return 0;
        const value = new Int32Array(1);
        const view = new Uint8Array(value.buffer);
        for(let i161 = 3; i161 >= 0; i161--)view[3 - i161] = block[i161];
        return value[0];
    }
}
const bitsToStringArray = [
    "00000000",
    "00000001",
    "00000010",
    "00000011",
    "00000100",
    "00000101",
    "00000110",
    "00000111",
    "00001000",
    "00001001",
    "00001010",
    "00001011",
    "00001100",
    "00001101",
    "00001110",
    "00001111",
    "00010000",
    "00010001",
    "00010010",
    "00010011",
    "00010100",
    "00010101",
    "00010110",
    "00010111",
    "00011000",
    "00011001",
    "00011010",
    "00011011",
    "00011100",
    "00011101",
    "00011110",
    "00011111",
    "00100000",
    "00100001",
    "00100010",
    "00100011",
    "00100100",
    "00100101",
    "00100110",
    "00100111",
    "00101000",
    "00101001",
    "00101010",
    "00101011",
    "00101100",
    "00101101",
    "00101110",
    "00101111",
    "00110000",
    "00110001",
    "00110010",
    "00110011",
    "00110100",
    "00110101",
    "00110110",
    "00110111",
    "00111000",
    "00111001",
    "00111010",
    "00111011",
    "00111100",
    "00111101",
    "00111110",
    "00111111",
    "01000000",
    "01000001",
    "01000010",
    "01000011",
    "01000100",
    "01000101",
    "01000110",
    "01000111",
    "01001000",
    "01001001",
    "01001010",
    "01001011",
    "01001100",
    "01001101",
    "01001110",
    "01001111",
    "01010000",
    "01010001",
    "01010010",
    "01010011",
    "01010100",
    "01010101",
    "01010110",
    "01010111",
    "01011000",
    "01011001",
    "01011010",
    "01011011",
    "01011100",
    "01011101",
    "01011110",
    "01011111",
    "01100000",
    "01100001",
    "01100010",
    "01100011",
    "01100100",
    "01100101",
    "01100110",
    "01100111",
    "01101000",
    "01101001",
    "01101010",
    "01101011",
    "01101100",
    "01101101",
    "01101110",
    "01101111",
    "01110000",
    "01110001",
    "01110010",
    "01110011",
    "01110100",
    "01110101",
    "01110110",
    "01110111",
    "01111000",
    "01111001",
    "01111010",
    "01111011",
    "01111100",
    "01111101",
    "01111110",
    "01111111",
    "10000000",
    "10000001",
    "10000010",
    "10000011",
    "10000100",
    "10000101",
    "10000110",
    "10000111",
    "10001000",
    "10001001",
    "10001010",
    "10001011",
    "10001100",
    "10001101",
    "10001110",
    "10001111",
    "10010000",
    "10010001",
    "10010010",
    "10010011",
    "10010100",
    "10010101",
    "10010110",
    "10010111",
    "10011000",
    "10011001",
    "10011010",
    "10011011",
    "10011100",
    "10011101",
    "10011110",
    "10011111",
    "10100000",
    "10100001",
    "10100010",
    "10100011",
    "10100100",
    "10100101",
    "10100110",
    "10100111",
    "10101000",
    "10101001",
    "10101010",
    "10101011",
    "10101100",
    "10101101",
    "10101110",
    "10101111",
    "10110000",
    "10110001",
    "10110010",
    "10110011",
    "10110100",
    "10110101",
    "10110110",
    "10110111",
    "10111000",
    "10111001",
    "10111010",
    "10111011",
    "10111100",
    "10111101",
    "10111110",
    "10111111",
    "11000000",
    "11000001",
    "11000010",
    "11000011",
    "11000100",
    "11000101",
    "11000110",
    "11000111",
    "11001000",
    "11001001",
    "11001010",
    "11001011",
    "11001100",
    "11001101",
    "11001110",
    "11001111",
    "11010000",
    "11010001",
    "11010010",
    "11010011",
    "11010100",
    "11010101",
    "11010110",
    "11010111",
    "11011000",
    "11011001",
    "11011010",
    "11011011",
    "11011100",
    "11011101",
    "11011110",
    "11011111",
    "11100000",
    "11100001",
    "11100010",
    "11100011",
    "11100100",
    "11100101",
    "11100110",
    "11100111",
    "11101000",
    "11101001",
    "11101010",
    "11101011",
    "11101100",
    "11101101",
    "11101110",
    "11101111",
    "11110000",
    "11110001",
    "11110010",
    "11110011",
    "11110100",
    "11110101",
    "11110110",
    "11110111",
    "11111000",
    "11111001",
    "11111010",
    "11111011",
    "11111100",
    "11111101",
    "11111110",
    "11111111"
];
class BitStream {
    constructor(parameters = {}){
        this.buffer = new ArrayBuffer(0);
        this.view = new Uint8Array(this.buffer);
        this.bitsCount = 0;
        for (const key of Object.keys(parameters)){
            switch(key){
                case "byteStream":
                    this.fromByteStream(parameters.byteStream);
                    break;
                case "view":
                    this.fromUint8Array(parameters.view);
                    break;
                case "buffer":
                    this.fromArrayBuffer(parameters.buffer);
                    break;
                case "string":
                    this.fromString(parameters.string);
                    break;
                case "uint32":
                    this.fromUint32(parameters.uint32);
                    break;
                case "bitsCount":
                    this.bitsCount = parameters.bitsCount;
                    break;
                default:
            }
        }
    }
    clear() {
        this.buffer = new ArrayBuffer(0);
        this.view = new Uint8Array(this.buffer);
        this.bitsCount = 0;
    }
    fromByteStream(stream) {
        this.buffer = stream.buffer.slice(0);
        this.view = new Uint8Array(this.buffer);
        this.bitsCount = this.view.length << 3;
    }
    fromArrayBuffer(array) {
        this.buffer = array.slice(0);
        this.view = new Uint8Array(this.buffer);
        this.bitsCount = this.view.length << 3;
    }
    fromUint8Array(array) {
        this.buffer = new ArrayBuffer(array.length);
        this.view = new Uint8Array(this.buffer);
        this.view.set(array);
        this.bitsCount = this.view.length << 3;
    }
    fromString(string) {
        const stringLength = string.length;
        this.buffer = new ArrayBuffer((stringLength >> 3) + (stringLength % 8 ? 1 : 0));
        this.view = new Uint8Array(this.buffer);
        this.bitsCount = (stringLength >> 3) + 1 << 3;
        let byteIndex = 0;
        for(let i162 = 0; i162 < stringLength; i162++){
            if (string[i162] == "1") this.view[byteIndex] |= 1 << 7 - i162 % 8;
            if (i162 && (i162 + 1) % 8 == 0) byteIndex++;
        }
        if (stringLength % 8) this.shiftRight(8 - stringLength % 8);
        this.bitsCount = stringLength;
    }
    fromUint32(uint32) {
        this.buffer = new ArrayBuffer(4);
        this.view = new Uint8Array(this.buffer);
        const value = new Uint32Array([
            uint32
        ]);
        const view = new Uint8Array(value.buffer);
        for(let i163 = 3; i163 >= 0; i163--)this.view[i163] = view[3 - i163];
        this.bitsCount = 32;
    }
    toString(start = null, length = null) {
        if (start == null) {
            start = 0;
        }
        if (start >= this.view.length || start < 0) {
            start = 0;
        }
        if (length == null) {
            length = this.view.length - start;
        }
        if (length >= this.view.length || length < 0) {
            length = this.view.length - start;
        }
        const result = [];
        for(let i164 = start; i164 < start + length; i164++)result.push(bitsToStringArray[this.view[i164]]);
        return result.join("").slice((this.view.length << 3) - this.bitsCount);
    }
    shiftRight(shift, needShrink = true) {
        if (this.view.length == 0) return;
        if (shift < 0 || shift > 8) throw new Error("The \"shift\" parameter must be in range 0-8");
        if (shift > this.bitsCount) throw new Error("The \"shift\" parameter can not be bigger than \"this.bitsCount\"");
        const shiftMask = 0xFF >> 8 - shift;
        this.view[this.view.length - 1] >>= shift;
        for(let i165 = this.view.length - 2; i165 >= 0; i165--){
            this.view[i165 + 1] |= (this.view[i165] & shiftMask) << 8 - shift;
            this.view[i165] >>= shift;
        }
        this.bitsCount -= shift;
        if (this.bitsCount == 0) this.clear();
        if (needShrink) this.shrink();
    }
    shiftLeft(shift) {
        if (this.view.length == 0) return;
        if (shift < 0 || shift > 8) throw new Error("The \"shift\" parameter must be in range 0-8");
        if (shift > this.bitsCount) throw new Error("The \"shift\" parameter can not be bigger than \"this.bitsCount\"");
        const bitsOffset = this.bitsCount & 0x07;
        if (bitsOffset > shift) {
            this.view[0] &= 0xFF >> bitsOffset + shift;
        } else {
            const buffer = new ArrayBuffer(this.buffer.byteLength - 1);
            const view = new Uint8Array(buffer);
            view.set(new Uint8Array(this.buffer, 1, this.buffer.byteLength - 1));
            view[0] &= 0xFF >> shift - bitsOffset;
            this.buffer = buffer.slice(0);
            this.view = new Uint8Array(this.buffer);
        }
        this.bitsCount -= shift;
        if (this.bitsCount == 0) this.clear();
    }
    slice(start = null, end = null) {
        let valueShift = 0;
        if (this.bitsCount % 8) valueShift = 8 - this.bitsCount % 8;
        start += valueShift;
        end += valueShift;
        if (start == null) {
            start = 0;
        }
        if (start < 0 || start > (this.view.length << 3) - 1) return new BitStream();
        if (end == null) {
            end = (this.view.length << 3) - 1;
        }
        if (end < 0 || end > (this.view.length << 3) - 1) return new BitStream();
        if (end - start + 1 > this.bitsCount) return new BitStream();
        const startIndex = start >> 3;
        const startOffset = start & 0x07;
        const endIndex = end >> 3;
        const endOffset = end & 0x07;
        const bitsLength = endIndex - startIndex == 0 ? 1 : endIndex - startIndex + 1;
        const result = new BitStream();
        result.buffer = new ArrayBuffer(bitsLength);
        result.view = new Uint8Array(result.buffer);
        result.bitsCount = bitsLength << 3;
        result.view.set(new Uint8Array(this.buffer, startIndex, bitsLength));
        result.view[0] &= 0xFF >> startOffset;
        result.view[bitsLength] &= 0xFF << 7 - endOffset;
        if (7 - endOffset) result.shiftRight(7 - endOffset, false);
        result.bitsCount = end - start + 1;
        result.shrink();
        return result;
    }
    copy(start = null, length = null) {
        if (start < 0 || start > (this.view.length << 3) - 1) return new BitStream();
        if (length === null) {
            length = (this.view.length << 3) - start - 1;
        }
        if (length > this.bitsCount) return new BitStream();
        return this.slice(start, start + length - 1);
    }
    shrink() {
        const currentLength = (this.bitsCount >> 3) + (this.bitsCount % 8 ? 1 : 0);
        if (currentLength < this.buffer.byteLength) {
            const buffer = new ArrayBuffer(currentLength);
            const view = new Uint8Array(buffer);
            view.set(new Uint8Array(this.buffer, this.buffer.byteLength - currentLength, currentLength));
            this.buffer = buffer.slice(0);
            this.view = new Uint8Array(this.buffer);
        }
    }
    reverseBytes() {
        for(let i166 = 0; i166 < this.view.length; i166++){
            this.view[i166] = (this.view[i166] * 0x0802 & 0x22110 | this.view[i166] * 0x8020 & 0x88440) * 0x10101 >> 16;
        }
        if (this.bitsCount % 8) {
            const currentLength = (this.bitsCount >> 3) + (this.bitsCount % 8 ? 1 : 0);
            this.view[this.view.length - currentLength] >>= 8 - (this.bitsCount & 0x07);
        }
    }
    reverseValue() {
        const initialValue = this.toString();
        const initialValueLength = initialValue.length;
        const reversedValue = new Array(initialValueLength);
        for(let i167 = 0; i167 < initialValueLength; i167++)reversedValue[initialValueLength - 1 - i167] = initialValue[i167];
        this.fromString(reversedValue.join(""));
    }
    getNumberValue() {
        const byteLength9 = this.buffer.byteLength - 1;
        if (byteLength9 > 3) return -1;
        if (byteLength9 == -1) return 0;
        const value = new Uint32Array(1);
        const view = new Uint8Array(value.buffer);
        for(let i168 = byteLength9; i168 >= 0; i168--)view[byteLength9 - i168] = this.view[i168];
        return value[0];
    }
    findPattern(pattern, start = null, length = null, backward = false) {
        const stringStream = new ByteStream({
            string: this.toString()
        });
        const stringPattern = new ByteStream({
            string: pattern.toString()
        });
        return stringStream.findPattern(stringPattern, start, length, backward);
    }
    findFirstIn(patterns, start = null, length = null, backward = false) {
        const stringStream = new ByteStream({
            string: this.toString()
        });
        const stringPatterns = new Array(patterns.length);
        for(let i169 = 0; i169 < patterns.length; i169++){
            stringPatterns[i169] = new ByteStream({
                string: patterns[i169].toString()
            });
        }
        return stringStream.findFirstIn(stringPatterns, start, length, backward);
    }
    findAllIn(patterns, start = null, length = null) {
        const stringStream = new ByteStream({
            string: this.toString()
        });
        const stringPatterns = new Array(patterns.length);
        for(let i170 = 0; i170 < patterns.length; i170++){
            stringPatterns[i170] = new ByteStream({
                string: patterns[i170].toString()
            });
        }
        return stringStream.findAllIn(stringPatterns, start, length);
    }
    findAllPatternIn(pattern, start = null, length = null) {
        const stringStream = new ByteStream({
            string: this.toString()
        });
        const stringPattern = new ByteStream({
            string: pattern.toString()
        });
        return stringStream.findAllPatternIn(stringPattern, start, length);
    }
    findFirstNotIn(patterns, start = null, length = null, backward = false) {
        const stringStream = new ByteStream({
            string: this.toString()
        });
        const stringPatterns = new Array(patterns.length);
        for(let i171 = 0; i171 < patterns.length; i171++){
            stringPatterns[i171] = new ByteStream({
                string: patterns[i171].toString()
            });
        }
        return stringStream.findFirstNotIn(stringPatterns, start, length, backward);
    }
    findAllNotIn(patterns, start = null, length = null) {
        const stringStream = new ByteStream({
            string: this.toString()
        });
        const stringPatterns = new Array(patterns.length);
        for(let i172 = 0; i172 < patterns.length; i172++){
            stringPatterns[i172] = new ByteStream({
                string: patterns[i172].toString()
            });
        }
        return stringStream.findAllNotIn(stringPatterns, start, length);
    }
    findFirstSequence(patterns, start = null, length = null, backward = false) {
        const stringStream = new ByteStream({
            string: this.toString()
        });
        const stringPatterns = new Array(patterns.length);
        for(let i173 = 0; i173 < patterns.length; i173++){
            stringPatterns[i173] = new ByteStream({
                string: patterns[i173].toString()
            });
        }
        return stringStream.findFirstSequence(stringPatterns, start, length, backward);
    }
    findAllSequences(patterns, start, length) {
        const stringStream = new ByteStream({
            string: this.toString()
        });
        const stringPatterns = new Array(patterns.length);
        for(let i174 = 0; i174 < patterns.length; i174++){
            stringPatterns[i174] = new ByteStream({
                string: patterns[i174].toString()
            });
        }
        return stringStream.findAllSequences(stringPatterns, start, length);
    }
    findPairedPatterns(leftPattern, rightPattern, start = null, length = null) {
        const stringStream = new ByteStream({
            string: this.toString()
        });
        const stringLeftPattern = new ByteStream({
            string: leftPattern.toString()
        });
        const stringRightPattern = new ByteStream({
            string: rightPattern.toString()
        });
        return stringStream.findPairedPatterns(stringLeftPattern, stringRightPattern, start, length);
    }
    findPairedArrays(inputLeftPatterns, inputRightPatterns, start = null, length = null) {
        const stringStream = new ByteStream({
            string: this.toString()
        });
        const stringLeftPatterns = new Array(inputLeftPatterns.length);
        for(let i175 = 0; i175 < inputLeftPatterns.length; i175++){
            stringLeftPatterns[i175] = new ByteStream({
                string: inputLeftPatterns[i175].toString()
            });
        }
        const stringRightPatterns = new Array(inputRightPatterns.length);
        for(let i212 = 0; i212 < inputRightPatterns.length; i212++){
            stringRightPatterns[i212] = new ByteStream({
                string: inputRightPatterns[i212].toString()
            });
        }
        return stringStream.findPairedArrays(stringLeftPatterns, stringRightPatterns, start, length);
    }
    replacePattern(searchPattern, replacePattern, start = null, length = null) {
        const stringStream = new ByteStream({
            string: this.toString()
        });
        const stringSearchPattern = new ByteStream({
            string: searchPattern.toString()
        });
        const stringReplacePattern = new ByteStream({
            string: replacePattern.toString()
        });
        if (stringStream.findPairedPatterns(stringSearchPattern, stringReplacePattern, start, length)) {
            this.fromString(stringStream.toString());
            return true;
        }
        return false;
    }
    skipPatterns(patterns, start, length, backward) {
        const stringStream = new ByteStream({
            string: this.toString()
        });
        const stringPatterns = new Array(patterns.length);
        for(let i176 = 0; i176 < patterns.length; i176++){
            stringPatterns[i176] = new ByteStream({
                string: patterns[i176].toString()
            });
        }
        return stringStream.skipPatterns(stringPatterns, start, length, backward);
    }
    skipNotPatterns(patterns, start, length, backward) {
        const stringStream = new ByteStream({
            string: this.toString()
        });
        const stringPatterns = new Array(patterns.length);
        for(let i177 = 0; i177 < patterns.length; i177++){
            stringPatterns[i177] = new ByteStream({
                string: patterns[i177].toString()
            });
        }
        return stringStream.skipNotPatterns(stringPatterns, start, length, backward);
    }
    append(stream) {
        this.fromString([
            this.toString(),
            stream.toString()
        ].join(""));
    }
}
class SignedCertificateTimestamp {
    constructor(parameters = {}){
        this.version = getParametersValue(parameters, "version", SignedCertificateTimestamp.defaultValues("version"));
        this.logID = getParametersValue(parameters, "logID", SignedCertificateTimestamp.defaultValues("logID"));
        this.timestamp = getParametersValue(parameters, "timestamp", SignedCertificateTimestamp.defaultValues("timestamp"));
        this.extensions = getParametersValue(parameters, "extensions", SignedCertificateTimestamp.defaultValues("extensions"));
        this.hashAlgorithm = getParametersValue(parameters, "hashAlgorithm", SignedCertificateTimestamp.defaultValues("hashAlgorithm"));
        this.signatureAlgorithm = getParametersValue(parameters, "signatureAlgorithm", SignedCertificateTimestamp.defaultValues("signatureAlgorithm"));
        this.signature = getParametersValue(parameters, "signature", SignedCertificateTimestamp.defaultValues("signature"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
        if ("stream" in parameters) this.fromStream(parameters.stream);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "version":
                return 0;
            case "logID":
            case "extensions":
                return new ArrayBuffer(0);
            case "timestamp":
                return new Date(0);
            case "hashAlgorithm":
            case "signatureAlgorithm":
                return "";
            case "signature":
                return new Any();
            default:
                throw new Error(`Invalid member name for SignedCertificateTimestamp class: ${memberName}`);
        }
    }
    fromSchema(schema) {
        if (schema instanceof RawData === false) throw new Error("Object's schema was not verified against input data for SignedCertificateTimestamp");
        const seqStream = new SeqStream({
            stream: new ByteStream({
                buffer: schema.data
            })
        });
        this.fromStream(seqStream);
    }
    fromStream(stream) {
        const blockLength = stream.getUint16();
        this.version = stream.getBlock(1)[0];
        if (this.version === 0) {
            this.logID = new Uint8Array(stream.getBlock(32)).buffer.slice(0);
            this.timestamp = new Date(utilFromBase(new Uint8Array(stream.getBlock(8)), 8));
            const extensionsLength = stream.getUint16();
            this.extensions = new Uint8Array(stream.getBlock(extensionsLength)).buffer.slice(0);
            switch(stream.getBlock(1)[0]){
                case 0:
                    this.hashAlgorithm = "none";
                    break;
                case 1:
                    this.hashAlgorithm = "md5";
                    break;
                case 2:
                    this.hashAlgorithm = "sha1";
                    break;
                case 3:
                    this.hashAlgorithm = "sha224";
                    break;
                case 4:
                    this.hashAlgorithm = "sha256";
                    break;
                case 5:
                    this.hashAlgorithm = "sha384";
                    break;
                case 6:
                    this.hashAlgorithm = "sha512";
                    break;
                default:
                    throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
            }
            switch(stream.getBlock(1)[0]){
                case 0:
                    this.signatureAlgorithm = "anonymous";
                    break;
                case 1:
                    this.signatureAlgorithm = "rsa";
                    break;
                case 2:
                    this.signatureAlgorithm = "dsa";
                    break;
                case 3:
                    this.signatureAlgorithm = "ecdsa";
                    break;
                default:
                    throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
            }
            const signatureLength = stream.getUint16();
            const signatureData = new Uint8Array(stream.getBlock(signatureLength)).buffer.slice(0);
            const asn1 = fromBER(signatureData);
            if (asn1.offset === -1) throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
            this.signature = asn1.result;
            if (blockLength !== 47 + extensionsLength + signatureLength) throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
        }
    }
    toSchema() {
        const stream = this.toStream();
        return new RawData({
            data: stream.stream.buffer
        });
    }
    toStream() {
        const stream = new SeqStream();
        stream.appendUint16(47 + this.extensions.byteLength + this.signature.valueBeforeDecode.byteLength);
        stream.appendChar(this.version);
        stream.appendView(new Uint8Array(this.logID));
        const timeBuffer = new ArrayBuffer(8);
        const timeView = new Uint8Array(timeBuffer);
        const baseArray = utilToBase(this.timestamp.valueOf(), 8);
        timeView.set(baseArray, 8 - baseArray.byteLength);
        stream.appendView(timeView);
        stream.appendUint16(this.extensions.byteLength);
        if (this.extensions.byteLength) stream.appendView(new Uint8Array(this.extensions));
        let _hashAlgorithm;
        switch(this.hashAlgorithm.toLowerCase()){
            case "none":
                _hashAlgorithm = 0;
                break;
            case "md5":
                _hashAlgorithm = 1;
                break;
            case "sha1":
                _hashAlgorithm = 2;
                break;
            case "sha224":
                _hashAlgorithm = 3;
                break;
            case "sha256":
                _hashAlgorithm = 4;
                break;
            case "sha384":
                _hashAlgorithm = 5;
                break;
            case "sha512":
                _hashAlgorithm = 6;
                break;
            default:
                throw new Error(`Incorrect data for hashAlgorithm: ${this.hashAlgorithm}`);
        }
        stream.appendChar(_hashAlgorithm);
        let _signatureAlgorithm;
        switch(this.signatureAlgorithm.toLowerCase()){
            case "anonymous":
                _signatureAlgorithm = 0;
                break;
            case "rsa":
                _signatureAlgorithm = 1;
                break;
            case "dsa":
                _signatureAlgorithm = 2;
                break;
            case "ecdsa":
                _signatureAlgorithm = 3;
                break;
            default:
                throw new Error(`Incorrect data for signatureAlgorithm: ${this.signatureAlgorithm}`);
        }
        stream.appendChar(_signatureAlgorithm);
        const _signature = this.signature.toBER(false);
        stream.appendUint16(_signature.byteLength);
        stream.appendView(new Uint8Array(_signature));
        return stream;
    }
    toJSON() {
        return {
            version: this.version,
            logID: bufferToHexCodes(this.logID),
            timestamp: this.timestamp,
            extensions: bufferToHexCodes(this.extensions),
            hashAlgorithm: this.hashAlgorithm,
            signatureAlgorithm: this.signatureAlgorithm,
            signature: this.signature.toJSON()
        };
    }
    async verify(logs, data, dataType = 0) {
        let logId = toBase64(arrayBufferToString(this.logID));
        let publicKeyBase64 = null;
        let publicKeyInfo;
        let stream = new SeqStream();
        for (const log of logs){
            if (log.log_id === logId) {
                publicKeyBase64 = log.key;
                break;
            }
        }
        if (publicKeyBase64 === null) throw new Error(`Public key not found for CT with logId: ${logId}`);
        const asn1 = fromBER(stringToArrayBuffer(fromBase64(publicKeyBase64)));
        if (asn1.offset === -1) throw new Error(`Incorrect key value for CT Log with logId: ${logId}`);
        publicKeyInfo = new PublicKeyInfo({
            schema: asn1.result
        });
        stream.appendChar(0x00);
        stream.appendChar(0x00);
        const timeBuffer = new ArrayBuffer(8);
        const timeView = new Uint8Array(timeBuffer);
        const baseArray = utilToBase(this.timestamp.valueOf(), 8);
        timeView.set(new Uint8Array(baseArray), 8 - baseArray.byteLength);
        stream.appendView(timeView);
        stream.appendUint16(dataType);
        if (dataType === 0) stream.appendUint24(data.byteLength);
        stream.appendView(new Uint8Array(data));
        stream.appendUint16(this.extensions.byteLength);
        if (this.extensions.byteLength !== 0) stream.appendView(new Uint8Array(this.extensions));
        return getEngine().subtle.verifyWithPublicKey(stream._stream._buffer.slice(0, stream._length), {
            valueBlock: {
                valueHex: this.signature.toBER(false)
            }
        }, publicKeyInfo, {
            algorithmId: ""
        }, "SHA-256");
    }
}
class SignedCertificateTimestampList {
    constructor(parameters = {}){
        this.timestamps = getParametersValue(parameters, "timestamps", SignedCertificateTimestampList.defaultValues("timestamps"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "timestamps":
                return [];
            default:
                throw new Error(`Invalid member name for SignedCertificateTimestampList class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "timestamps":
                return memberValue.length === 0;
            default:
                throw new Error(`Invalid member name for SignedCertificateTimestampList class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        if ("optional" in names === false) names.optional = false;
        return new OctetString({
            name: names.blockName || "SignedCertificateTimestampList",
            optional: names.optional
        });
    }
    fromSchema(schema) {
        if (schema instanceof OctetString === false) throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");
        const seqStream = new SeqStream({
            stream: new ByteStream({
                buffer: schema.valueBlock.valueHex
            })
        });
        let dataLength = seqStream.getUint16();
        if (dataLength !== seqStream.length) throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");
        while(seqStream.length)this.timestamps.push(new SignedCertificateTimestamp({
            stream: seqStream
        }));
    }
    toSchema() {
        const stream = new SeqStream();
        let overallLength = 0;
        const timestampsData = [];
        for (const timestamp of this.timestamps){
            const timestampStream = timestamp.toStream();
            timestampsData.push(timestampStream);
            overallLength += timestampStream.stream.buffer.byteLength;
        }
        stream.appendUint16(overallLength);
        for (const timestamp1 of timestampsData)stream.appendView(timestamp1.stream.view);
        return new OctetString({
            valueHex: stream.stream.buffer.slice(0)
        });
    }
    toJSON() {
        return {
            timestamps: Array.from(this.timestamps, (element)=>element.toJSON()
            )
        };
    }
}
class Extension {
    constructor(parameters = {}){
        this.extnID = getParametersValue(parameters, "extnID", Extension.defaultValues("extnID"));
        this.critical = getParametersValue(parameters, "critical", Extension.defaultValues("critical"));
        if ("extnValue" in parameters) this.extnValue = new OctetString({
            valueHex: parameters.extnValue
        });
        else this.extnValue = Extension.defaultValues("extnValue");
        if ("parsedValue" in parameters) this.parsedValue = getParametersValue(parameters, "parsedValue", Extension.defaultValues("parsedValue"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "extnID":
                return "";
            case "critical":
                return false;
            case "extnValue":
                return new OctetString();
            case "parsedValue":
                return {};
            default:
                throw new Error(`Invalid member name for Extension class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new ObjectIdentifier({
                    name: names.extnID || ""
                }),
                new Boolean1({
                    name: names.critical || "",
                    optional: true
                }),
                new OctetString({
                    name: names.extnValue || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "extnID",
            "critical",
            "extnValue"
        ]);
        let asn1 = compareSchema(schema, schema, Extension.schema({
            names: {
                extnID: "extnID",
                critical: "critical",
                extnValue: "extnValue"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for Extension");
        this.extnID = asn1.result.extnID.valueBlock.toString();
        if ("critical" in asn1.result) this.critical = asn1.result.critical.valueBlock.value;
        this.extnValue = asn1.result.extnValue;
        asn1 = fromBER(this.extnValue.valueBlock.valueHex);
        if (asn1.offset === -1) return;
        switch(this.extnID){
            case "2.5.29.9":
                this.parsedValue = new SubjectDirectoryAttributes({
                    schema: asn1.result
                });
                break;
            case "2.5.29.14":
                this.parsedValue = asn1.result;
                break;
            case "2.5.29.15":
                this.parsedValue = asn1.result;
                break;
            case "2.5.29.16":
                this.parsedValue = new PrivateKeyUsagePeriod({
                    schema: asn1.result
                });
                break;
            case "2.5.29.17":
            case "2.5.29.18":
                this.parsedValue = new AltName({
                    schema: asn1.result
                });
                break;
            case "2.5.29.19":
                this.parsedValue = new BasicConstraints({
                    schema: asn1.result
                });
                break;
            case "2.5.29.20":
            case "2.5.29.27":
                this.parsedValue = asn1.result;
                break;
            case "2.5.29.21":
                this.parsedValue = asn1.result;
                break;
            case "2.5.29.24":
                this.parsedValue = asn1.result;
                break;
            case "2.5.29.28":
                this.parsedValue = new IssuingDistributionPoint({
                    schema: asn1.result
                });
                break;
            case "2.5.29.29":
                this.parsedValue = new GeneralNames({
                    schema: asn1.result
                });
                break;
            case "2.5.29.30":
                this.parsedValue = new NameConstraints({
                    schema: asn1.result
                });
                break;
            case "2.5.29.31":
            case "2.5.29.46":
                this.parsedValue = new CRLDistributionPoints({
                    schema: asn1.result
                });
                break;
            case "2.5.29.32":
                this.parsedValue = new CertificatePolicies({
                    schema: asn1.result
                });
                break;
            case "2.5.29.33":
                this.parsedValue = new PolicyMappings({
                    schema: asn1.result
                });
                break;
            case "2.5.29.35":
                this.parsedValue = new AuthorityKeyIdentifier({
                    schema: asn1.result
                });
                break;
            case "2.5.29.36":
                this.parsedValue = new PolicyConstraints({
                    schema: asn1.result
                });
                break;
            case "2.5.29.37":
                this.parsedValue = new ExtKeyUsage({
                    schema: asn1.result
                });
                break;
            case "2.5.29.54":
                this.parsedValue = asn1.result;
                break;
            case "1.3.6.1.5.5.7.1.1":
            case "1.3.6.1.5.5.7.1.11":
                this.parsedValue = new InfoAccess({
                    schema: asn1.result
                });
                break;
            case "1.3.6.1.4.1.11129.2.4.2":
                this.parsedValue = new SignedCertificateTimestampList({
                    schema: asn1.result
                });
                break;
            default:
        }
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(new ObjectIdentifier({
            value: this.extnID
        }));
        if (this.critical !== Extension.defaultValues("critical")) outputArray.push(new Boolean1({
            value: this.critical
        }));
        outputArray.push(this.extnValue);
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const object = {
            extnID: this.extnID,
            extnValue: this.extnValue.toJSON()
        };
        if (this.critical !== Extension.defaultValues("critical")) object.critical = this.critical;
        if ("parsedValue" in this) {
            if ("toJSON" in this.parsedValue) object.parsedValue = this.parsedValue.toJSON();
        }
        return object;
    }
}
class Extensions {
    constructor(parameters = {}){
        this.extensions = getParametersValue(parameters, "extensions", Extensions.defaultValues("extensions"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "extensions":
                return [];
            default:
                throw new Error(`Invalid member name for Extensions class: ${memberName}`);
        }
    }
    static schema(parameters = {}, optional = false) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            optional,
            name: names.blockName || "",
            value: [
                new Repeated({
                    name: names.extensions || "",
                    value: Extension.schema(names.extension || {})
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "extensions"
        ]);
        const asn1 = compareSchema(schema, schema, Extensions.schema({
            names: {
                extensions: "extensions"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for Extensions");
        this.extensions = Array.from(asn1.result.extensions, (element)=>new Extension({
                schema: element
            })
        );
    }
    toSchema() {
        return new Sequence({
            value: Array.from(this.extensions, (element)=>element.toSchema()
            )
        });
    }
    toJSON() {
        return {
            extensions: Array.from(this.extensions, (element)=>element.toJSON()
            )
        };
    }
}
function tbsCertificate(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new Sequence({
        name: names.blockName || "tbsCertificate",
        value: [
            new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: [
                    new Integer({
                        name: names.tbsCertificateVersion || "tbsCertificate.version"
                    })
                ]
            }),
            new Integer({
                name: names.tbsCertificateSerialNumber || "tbsCertificate.serialNumber"
            }),
            AlgorithmIdentifier.schema(names.signature || {
                names: {
                    blockName: "tbsCertificate.signature"
                }
            }),
            RelativeDistinguishedNames.schema(names.issuer || {
                names: {
                    blockName: "tbsCertificate.issuer"
                }
            }),
            new Sequence({
                name: names.tbsCertificateValidity || "tbsCertificate.validity",
                value: [
                    Time.schema(names.notBefore || {
                        names: {
                            utcTimeName: "tbsCertificate.notBefore",
                            generalTimeName: "tbsCertificate.notBefore"
                        }
                    }),
                    Time.schema(names.notAfter || {
                        names: {
                            utcTimeName: "tbsCertificate.notAfter",
                            generalTimeName: "tbsCertificate.notAfter"
                        }
                    })
                ]
            }),
            RelativeDistinguishedNames.schema(names.subject || {
                names: {
                    blockName: "tbsCertificate.subject"
                }
            }),
            PublicKeyInfo.schema(names.subjectPublicKeyInfo || {
                names: {
                    blockName: "tbsCertificate.subjectPublicKeyInfo"
                }
            }),
            new Primitive({
                name: names.tbsCertificateIssuerUniqueID || "tbsCertificate.issuerUniqueID",
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                }
            }),
            new Primitive({
                name: names.tbsCertificateSubjectUniqueID || "tbsCertificate.subjectUniqueID",
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 2
                }
            }),
            new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 3
                },
                value: [
                    Extensions.schema(names.extensions || {
                        names: {
                            blockName: "tbsCertificate.extensions"
                        }
                    })
                ]
            })
        ]
    });
}
class Certificate {
    constructor(parameters = {}){
        this.tbs = getParametersValue(parameters, "tbs", Certificate.defaultValues("tbs"));
        this.version = getParametersValue(parameters, "version", Certificate.defaultValues("version"));
        this.serialNumber = getParametersValue(parameters, "serialNumber", Certificate.defaultValues("serialNumber"));
        this.signature = getParametersValue(parameters, "signature", Certificate.defaultValues("signature"));
        this.issuer = getParametersValue(parameters, "issuer", Certificate.defaultValues("issuer"));
        this.notBefore = getParametersValue(parameters, "notBefore", Certificate.defaultValues("notBefore"));
        this.notAfter = getParametersValue(parameters, "notAfter", Certificate.defaultValues("notAfter"));
        this.subject = getParametersValue(parameters, "subject", Certificate.defaultValues("subject"));
        this.subjectPublicKeyInfo = getParametersValue(parameters, "subjectPublicKeyInfo", Certificate.defaultValues("subjectPublicKeyInfo"));
        if ("issuerUniqueID" in parameters) this.issuerUniqueID = getParametersValue(parameters, "issuerUniqueID", Certificate.defaultValues("issuerUniqueID"));
        if ("subjectUniqueID" in parameters) this.subjectUniqueID = getParametersValue(parameters, "subjectUniqueID", Certificate.defaultValues("subjectUniqueID"));
        if ("extensions" in parameters) this.extensions = getParametersValue(parameters, "extensions", Certificate.defaultValues("extensions"));
        this.signatureAlgorithm = getParametersValue(parameters, "signatureAlgorithm", Certificate.defaultValues("signatureAlgorithm"));
        this.signatureValue = getParametersValue(parameters, "signatureValue", Certificate.defaultValues("signatureValue"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "tbs":
                return new ArrayBuffer(0);
            case "version":
                return 0;
            case "serialNumber":
                return new Integer();
            case "signature":
                return new AlgorithmIdentifier();
            case "issuer":
                return new RelativeDistinguishedNames();
            case "notBefore":
                return new Time();
            case "notAfter":
                return new Time();
            case "subject":
                return new RelativeDistinguishedNames();
            case "subjectPublicKeyInfo":
                return new PublicKeyInfo();
            case "issuerUniqueID":
                return new ArrayBuffer(0);
            case "subjectUniqueID":
                return new ArrayBuffer(0);
            case "extensions":
                return [];
            case "signatureAlgorithm":
                return new AlgorithmIdentifier();
            case "signatureValue":
                return new BitString();
            default:
                throw new Error(`Invalid member name for Certificate class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                tbsCertificate(names.tbsCertificate),
                AlgorithmIdentifier.schema(names.signatureAlgorithm || {
                    names: {
                        blockName: "signatureAlgorithm"
                    }
                }),
                new BitString({
                    name: names.signatureValue || "signatureValue"
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "tbsCertificate",
            "tbsCertificate.extensions",
            "tbsCertificate.version",
            "tbsCertificate.serialNumber",
            "tbsCertificate.signature",
            "tbsCertificate.issuer",
            "tbsCertificate.notBefore",
            "tbsCertificate.notAfter",
            "tbsCertificate.subject",
            "tbsCertificate.subjectPublicKeyInfo",
            "tbsCertificate.issuerUniqueID",
            "tbsCertificate.subjectUniqueID",
            "signatureAlgorithm",
            "signatureValue"
        ]);
        const asn1 = compareSchema(schema, schema, Certificate.schema({
            names: {
                tbsCertificate: {
                    names: {
                        extensions: {
                            names: {
                                extensions: "tbsCertificate.extensions"
                            }
                        }
                    }
                }
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for Certificate");
        this.tbs = asn1.result.tbsCertificate.valueBeforeDecode;
        if ("tbsCertificate.version" in asn1.result) this.version = asn1.result["tbsCertificate.version"].valueBlock.valueDec;
        this.serialNumber = asn1.result["tbsCertificate.serialNumber"];
        this.signature = new AlgorithmIdentifier({
            schema: asn1.result["tbsCertificate.signature"]
        });
        this.issuer = new RelativeDistinguishedNames({
            schema: asn1.result["tbsCertificate.issuer"]
        });
        this.notBefore = new Time({
            schema: asn1.result["tbsCertificate.notBefore"]
        });
        this.notAfter = new Time({
            schema: asn1.result["tbsCertificate.notAfter"]
        });
        this.subject = new RelativeDistinguishedNames({
            schema: asn1.result["tbsCertificate.subject"]
        });
        this.subjectPublicKeyInfo = new PublicKeyInfo({
            schema: asn1.result["tbsCertificate.subjectPublicKeyInfo"]
        });
        if ("tbsCertificate.issuerUniqueID" in asn1.result) this.issuerUniqueID = asn1.result["tbsCertificate.issuerUniqueID"].valueBlock.valueHex;
        if ("tbsCertificate.subjectUniqueID" in asn1.result) this.issuerUniqueID = asn1.result["tbsCertificate.subjectUniqueID"].valueBlock.valueHex;
        if ("tbsCertificate.extensions" in asn1.result) this.extensions = Array.from(asn1.result["tbsCertificate.extensions"], (element)=>new Extension({
                schema: element
            })
        );
        this.signatureAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result.signatureAlgorithm
        });
        this.signatureValue = asn1.result.signatureValue;
    }
    encodeTBS() {
        const outputArray = [];
        if ("version" in this && this.version !== Certificate.defaultValues("version")) {
            outputArray.push(new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: [
                    new Integer({
                        value: this.version
                    })
                ]
            }));
        }
        outputArray.push(this.serialNumber);
        outputArray.push(this.signature.toSchema());
        outputArray.push(this.issuer.toSchema());
        outputArray.push(new Sequence({
            value: [
                this.notBefore.toSchema(),
                this.notAfter.toSchema()
            ]
        }));
        outputArray.push(this.subject.toSchema());
        outputArray.push(this.subjectPublicKeyInfo.toSchema());
        if ("issuerUniqueID" in this) {
            outputArray.push(new Primitive({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                },
                valueHex: this.issuerUniqueID
            }));
        }
        if ("subjectUniqueID" in this) {
            outputArray.push(new Primitive({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 2
                },
                valueHex: this.subjectUniqueID
            }));
        }
        if ("subjectUniqueID" in this) {
            outputArray.push(new Primitive({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 3
                },
                value: [
                    this.extensions.toSchema()
                ]
            }));
        }
        if ("extensions" in this) {
            outputArray.push(new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 3
                },
                value: [
                    new Sequence({
                        value: Array.from(this.extensions, (element)=>element.toSchema()
                        )
                    })
                ]
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toSchema(encodeFlag = false) {
        let tbsSchema = {};
        if (encodeFlag === false) {
            if (this.tbs.length === 0) return Certificate.schema().value[0];
            tbsSchema = fromBER(this.tbs).result;
        } else tbsSchema = this.encodeTBS();
        return new Sequence({
            value: [
                tbsSchema,
                this.signatureAlgorithm.toSchema(),
                this.signatureValue
            ]
        });
    }
    toJSON() {
        const object = {
            tbs: bufferToHexCodes(this.tbs, 0, this.tbs.byteLength),
            serialNumber: this.serialNumber.toJSON(),
            signature: this.signature.toJSON(),
            issuer: this.issuer.toJSON(),
            notBefore: this.notBefore.toJSON(),
            notAfter: this.notAfter.toJSON(),
            subject: this.subject.toJSON(),
            subjectPublicKeyInfo: this.subjectPublicKeyInfo.toJSON(),
            signatureAlgorithm: this.signatureAlgorithm.toJSON(),
            signatureValue: this.signatureValue.toJSON()
        };
        if ("version" in this && this.version !== Certificate.defaultValues("version")) object.version = this.version;
        if ("issuerUniqueID" in this) object.issuerUniqueID = bufferToHexCodes(this.issuerUniqueID, 0, this.issuerUniqueID.byteLength);
        if ("subjectUniqueID" in this) object.subjectUniqueID = bufferToHexCodes(this.subjectUniqueID, 0, this.subjectUniqueID.byteLength);
        if ("extensions" in this) object.extensions = Array.from(this.extensions, (element)=>element.toJSON()
        );
        return object;
    }
    getPublicKey(parameters = null) {
        return getEngine().subtle.getPublicKey(this.subjectPublicKeyInfo, this.signatureAlgorithm, parameters);
    }
    getKeyHash() {
        const crypto = getCrypto();
        if (typeof crypto === "undefined") return Promise.reject("Unable to create WebCrypto object");
        return crypto.digest({
            name: "sha-1"
        }, new Uint8Array(this.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex));
    }
    sign(privateKey, hashAlgorithm = "SHA-1") {
        if (typeof privateKey === "undefined") return Promise.reject("Need to provide a private key for signing");
        let sequence = Promise.resolve();
        let parameters;
        const engine3 = getEngine();
        sequence = sequence.then(()=>engine3.subtle.getSignatureParameters(privateKey, hashAlgorithm)
        );
        sequence = sequence.then((result)=>{
            parameters = result.parameters;
            this.signature = result.signatureAlgorithm;
            this.signatureAlgorithm = result.signatureAlgorithm;
        });
        sequence = sequence.then(()=>{
            this.tbs = this.encodeTBS().toBER(false);
        });
        sequence = sequence.then(()=>engine3.subtle.signWithPrivateKey(this.tbs, privateKey, parameters)
        );
        sequence = sequence.then((result)=>{
            this.signatureValue = new BitString({
                valueHex: result
            });
        });
        return sequence;
    }
    verify(issuerCertificate = null) {
        let subjectPublicKeyInfo = {};
        if (issuerCertificate !== null) subjectPublicKeyInfo = issuerCertificate.subjectPublicKeyInfo;
        else {
            if (this.issuer.isEqual(this.subject)) subjectPublicKeyInfo = this.subjectPublicKeyInfo;
        }
        if (subjectPublicKeyInfo instanceof PublicKeyInfo === false) return Promise.reject("Please provide issuer certificate as a parameter");
        return getEngine().subtle.verifyWithPublicKey(this.tbs, this.signatureValue, subjectPublicKeyInfo, this.signatureAlgorithm);
    }
}
class AttCertValidityPeriod {
    constructor(parameters = {}){
        this.notBeforeTime = getParametersValue(parameters, "notBeforeTime", AttCertValidityPeriod.defaultValues("notBeforeTime"));
        this.notAfterTime = getParametersValue(parameters, "notAfterTime", AttCertValidityPeriod.defaultValues("notAfterTime"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "notBeforeTime":
            case "notAfterTime":
                return new Date(0, 0, 0);
            default:
                throw new Error(`Invalid member name for AttCertValidityPeriod class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new GeneralizedTime({
                    name: names.notBeforeTime || ""
                }),
                new GeneralizedTime({
                    name: names.notAfterTime || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "notBeforeTime",
            "notAfterTime"
        ]);
        const asn1 = compareSchema(schema, schema, AttCertValidityPeriod.schema({
            names: {
                notBeforeTime: "notBeforeTime",
                notAfterTime: "notAfterTime"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for AttCertValidityPeriod");
        this.notBeforeTime = asn1.result.notBeforeTime.toDate();
        this.notAfterTime = asn1.result.notAfterTime.toDate();
    }
    toSchema() {
        return new Sequence({
            value: [
                new GeneralizedTime({
                    valueDate: this.notBeforeTime
                }),
                new GeneralizedTime({
                    valueDate: this.notAfterTime
                })
            ]
        });
    }
    toJSON() {
        return {
            notBeforeTime: this.notBeforeTime,
            notAfterTime: this.notAfterTime
        };
    }
}
class IssuerSerial {
    constructor(parameters = {}){
        this.issuer = getParametersValue(parameters, "issuer", IssuerSerial.defaultValues("issuer"));
        this.serialNumber = getParametersValue(parameters, "serialNumber", IssuerSerial.defaultValues("serialNumber"));
        if ("issuerUID" in parameters) this.issuerUID = getParametersValue(parameters, "issuerUID", IssuerSerial.defaultValues("issuerUID"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "issuer":
                return new GeneralNames();
            case "serialNumber":
                return new Integer();
            case "issuerUID":
                return new BitString();
            default:
                throw new Error(`Invalid member name for IssuerSerial class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                GeneralNames.schema(names.issuer || {}),
                new Integer({
                    name: names.serialNumber || ""
                }),
                new BitString({
                    optional: true,
                    name: names.issuerUID || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "issuer",
            "serialNumber",
            "issuerUID"
        ]);
        const asn1 = compareSchema(schema, schema, IssuerSerial.schema({
            names: {
                issuer: {
                    names: {
                        blockName: "issuer"
                    }
                },
                serialNumber: "serialNumber",
                issuerUID: "issuerUID"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for IssuerSerial");
        this.issuer = new GeneralNames({
            schema: asn1.result.issuer
        });
        this.serialNumber = asn1.result.serialNumber;
        if ("issuerUID" in asn1.result) this.issuerUID = asn1.result.issuerUID;
    }
    toSchema() {
        const result = new Sequence({
            value: [
                this.issuer.toSchema(),
                this.serialNumber
            ]
        });
        if ("issuerUID" in this) result.valueBlock.value.push(this.issuerUID);
        return result;
    }
    toJSON() {
        const result = {
            issuer: this.issuer.toJSON(),
            serialNumber: this.serialNumber.toJSON()
        };
        if ("issuerUID" in this) result.issuerUID = this.issuerUID.toJSON();
        return result;
    }
}
class AttributeCertificateInfoV1 {
    constructor(parameters = {}){
        this.version = getParametersValue(parameters, "version", AttributeCertificateInfoV1.defaultValues("version"));
        if ("baseCertificateID" in parameters) this.baseCertificateID = getParametersValue(parameters, "baseCertificateID", AttributeCertificateInfoV1.defaultValues("baseCertificateID"));
        if ("subjectName" in parameters) this.subjectName = getParametersValue(parameters, "subjectName", AttributeCertificateInfoV1.defaultValues("subjectName"));
        this.issuer = getParametersValue(parameters, "issuer", AttributeCertificateInfoV1.defaultValues("issuer"));
        this.signature = getParametersValue(parameters, "signature", AttributeCertificateInfoV1.defaultValues("signature"));
        this.serialNumber = getParametersValue(parameters, "serialNumber", AttributeCertificateInfoV1.defaultValues("serialNumber"));
        this.attrCertValidityPeriod = getParametersValue(parameters, "attrCertValidityPeriod", AttributeCertificateInfoV1.defaultValues("attrCertValidityPeriod"));
        this.attributes = getParametersValue(parameters, "attributes", AttributeCertificateInfoV1.defaultValues("attributes"));
        if ("issuerUniqueID" in parameters) this.issuerUniqueID = getParametersValue(parameters, "issuerUniqueID", AttributeCertificateInfoV1.defaultValues("issuerUniqueID"));
        if ("extensions" in parameters) this.extensions = getParametersValue(parameters, "extensions", AttributeCertificateInfoV1.defaultValues("extensions"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "version":
                return 0;
            case "baseCertificateID":
                return new IssuerSerial();
            case "subjectName":
                return new GeneralNames();
            case "issuer":
                return {};
            case "signature":
                return new AlgorithmIdentifier();
            case "serialNumber":
                return new Integer();
            case "attrCertValidityPeriod":
                return new AttCertValidityPeriod();
            case "attributes":
                return [];
            case "issuerUniqueID":
                return new BitString();
            case "extensions":
                return new Extensions();
            default:
                throw new Error(`Invalid member name for AttributeCertificateInfoV1 class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Integer({
                    name: names.version || ""
                }),
                new Choice({
                    value: [
                        new Constructed({
                            name: names.baseCertificateID || "",
                            idBlock: {
                                tagClass: 3,
                                tagNumber: 0
                            },
                            value: IssuerSerial.schema().valueBlock.value
                        }),
                        new Constructed({
                            name: names.subjectName || "",
                            idBlock: {
                                tagClass: 3,
                                tagNumber: 1
                            },
                            value: GeneralNames.schema().valueBlock.value
                        })
                    ]
                }),
                GeneralNames.schema({
                    names: {
                        blockName: names.issuer || ""
                    }
                }),
                AlgorithmIdentifier.schema(names.signature || {}),
                new Integer({
                    name: names.serialNumber || ""
                }),
                AttCertValidityPeriod.schema(names.attrCertValidityPeriod || {}),
                new Sequence({
                    name: names.attributes || "",
                    value: [
                        new Repeated({
                            value: Attribute.schema()
                        })
                    ]
                }),
                new BitString({
                    optional: true,
                    name: names.issuerUniqueID || ""
                }),
                Extensions.schema(names.extensions || {}, true)
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "version",
            "baseCertificateID",
            "subjectName",
            "issuer",
            "signature",
            "serialNumber",
            "attrCertValidityPeriod",
            "attributes",
            "issuerUniqueID",
            "extensions"
        ]);
        const asn1 = compareSchema(schema, schema, AttributeCertificateInfoV1.schema({
            names: {
                version: "version",
                baseCertificateID: "baseCertificateID",
                subjectName: "subjectName",
                issuer: "issuer",
                signature: {
                    names: {
                        blockName: "signature"
                    }
                },
                serialNumber: "serialNumber",
                attrCertValidityPeriod: {
                    names: {
                        blockName: "attrCertValidityPeriod"
                    }
                },
                attributes: "attributes",
                issuerUniqueID: "issuerUniqueID",
                extensions: {
                    names: {
                        blockName: "extensions"
                    }
                }
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for AttributeCertificateInfoV1");
        this.version = asn1.result.version.valueBlock.valueDec;
        if ("baseCertificateID" in asn1.result) {
            this.baseCertificateID = new IssuerSerial({
                schema: new Sequence({
                    value: asn1.result.baseCertificateID.valueBlock.value
                })
            });
        }
        if ("subjectName" in asn1.result) {
            this.subjectName = new GeneralNames({
                schema: new Sequence({
                    value: asn1.result.subjectName.valueBlock.value
                })
            });
        }
        this.issuer = asn1.result.issuer;
        this.signature = new AlgorithmIdentifier({
            schema: asn1.result.signature
        });
        this.serialNumber = asn1.result.serialNumber;
        this.attrCertValidityPeriod = new AttCertValidityPeriod({
            schema: asn1.result.attrCertValidityPeriod
        });
        this.attributes = Array.from(asn1.result.attributes.valueBlock.value, (element)=>new Attribute({
                schema: element
            })
        );
        if ("issuerUniqueID" in asn1.result) this.issuerUniqueID = asn1.result.issuerUniqueID;
        if ("extensions" in asn1.result) this.extensions = new Extensions({
            schema: asn1.result.extensions
        });
    }
    toSchema() {
        const result = new Sequence({
            value: [
                new Integer({
                    value: this.version
                })
            ]
        });
        if ("baseCertificateID" in this) {
            result.valueBlock.value.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: this.baseCertificateID.toSchema().valueBlock.value
            }));
        }
        if ("subjectName" in this) {
            result.valueBlock.value.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                },
                value: this.subjectName.toSchema().valueBlock.value
            }));
        }
        result.valueBlock.value.push(this.issuer.toSchema());
        result.valueBlock.value.push(this.signature.toSchema());
        result.valueBlock.value.push(this.serialNumber);
        result.valueBlock.value.push(this.attrCertValidityPeriod.toSchema());
        result.valueBlock.value.push(new Sequence({
            value: Array.from(this.attributes, (element)=>element.toSchema()
            )
        }));
        if ("issuerUniqueID" in this) result.valueBlock.value.push(this.issuerUniqueID);
        if ("extensions" in this) result.valueBlock.value.push(this.extensions.toSchema());
        return result;
    }
    toJSON() {
        const result = {
            version: this.version
        };
        if ("baseCertificateID" in this) result.baseCertificateID = this.baseCertificateID.toJSON();
        if ("subjectName" in this) result.subjectName = this.subjectName.toJSON();
        result.issuer = this.issuer.toJSON();
        result.signature = this.signature.toJSON();
        result.serialNumber = this.serialNumber.toJSON();
        result.attrCertValidityPeriod = this.attrCertValidityPeriod.toJSON();
        result.attributes = Array.from(this.attributes, (element)=>element.toJSON()
        );
        if ("issuerUniqueID" in this) result.issuerUniqueID = this.issuerUniqueID.toJSON();
        if ("extensions" in this) result.extensions = this.extensions.toJSON();
        return result;
    }
}
class AttributeCertificateV1 {
    constructor(parameters = {}){
        this.acinfo = getParametersValue(parameters, "acinfo", AttributeCertificateV1.defaultValues("acinfo"));
        this.signatureAlgorithm = getParametersValue(parameters, "signatureAlgorithm", AttributeCertificateV1.defaultValues("signatureAlgorithm"));
        this.signatureValue = getParametersValue(parameters, "signatureValue", AttributeCertificateV1.defaultValues("signatureValue"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "acinfo":
                return new AttributeCertificateInfoV1();
            case "signatureAlgorithm":
                return new AlgorithmIdentifier();
            case "signatureValue":
                return new BitString();
            default:
                throw new Error(`Invalid member name for AttributeCertificateV1 class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                AttributeCertificateInfoV1.schema(names.acinfo || {}),
                AlgorithmIdentifier.schema(names.signatureAlgorithm || {}),
                new BitString({
                    name: names.signatureValue || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "acinfo",
            "signatureValue",
            "signatureAlgorithm"
        ]);
        const asn1 = compareSchema(schema, schema, AttributeCertificateV1.schema({
            names: {
                acinfo: {
                    names: {
                        blockName: "acinfo"
                    }
                },
                signatureAlgorithm: {
                    names: {
                        blockName: "signatureAlgorithm"
                    }
                },
                signatureValue: "signatureValue"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for AttributeCertificateV1");
        this.acinfo = new AttributeCertificateInfoV1({
            schema: asn1.result.acinfo
        });
        this.signatureAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result.signatureAlgorithm
        });
        this.signatureValue = asn1.result.signatureValue;
    }
    toSchema() {
        return new Sequence({
            value: [
                this.acinfo.toSchema(),
                this.signatureAlgorithm.toSchema(),
                this.signatureValue
            ]
        });
    }
    toJSON() {
        return {
            acinfo: this.acinfo.toJSON(),
            signatureAlgorithm: this.signatureAlgorithm.toJSON(),
            signatureValue: this.signatureValue.toJSON()
        };
    }
}
class ObjectDigestInfo {
    constructor(parameters = {}){
        this.digestedObjectType = getParametersValue(parameters, "digestedObjectType", ObjectDigestInfo.defaultValues("digestedObjectType"));
        if ("otherObjectTypeID" in parameters) this.otherObjectTypeID = getParametersValue(parameters, "otherObjectTypeID", ObjectDigestInfo.defaultValues("otherObjectTypeID"));
        this.digestAlgorithm = getParametersValue(parameters, "digestAlgorithm", ObjectDigestInfo.defaultValues("digestAlgorithm"));
        this.objectDigest = getParametersValue(parameters, "objectDigest", ObjectDigestInfo.defaultValues("objectDigest"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "digestedObjectType":
                return new Enumerated();
            case "otherObjectTypeID":
                return new ObjectIdentifier();
            case "digestAlgorithm":
                return new AlgorithmIdentifier();
            case "objectDigest":
                return new BitString();
            default:
                throw new Error(`Invalid member name for ObjectDigestInfo class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Enumerated({
                    name: names.digestedObjectType || ""
                }),
                new ObjectIdentifier({
                    optional: true,
                    name: names.otherObjectTypeID || ""
                }),
                AlgorithmIdentifier.schema(names.digestAlgorithm || {}),
                new BitString({
                    name: names.objectDigest || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "digestedObjectType",
            "otherObjectTypeID",
            "digestAlgorithm",
            "objectDigest"
        ]);
        const asn1 = compareSchema(schema, schema, ObjectDigestInfo.schema({
            names: {
                digestedObjectType: "digestedObjectType",
                otherObjectTypeID: "otherObjectTypeID",
                digestAlgorithm: {
                    names: {
                        blockName: "digestAlgorithm"
                    }
                },
                objectDigest: "objectDigest"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for ObjectDigestInfo");
        this.digestedObjectType = asn1.result.digestedObjectType;
        if ("otherObjectTypeID" in asn1.result) this.otherObjectTypeID = asn1.result.otherObjectTypeID;
        this.digestAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result.digestAlgorithm
        });
        this.objectDigest = asn1.result.objectDigest;
    }
    toSchema() {
        const result = new Sequence({
            value: [
                this.digestedObjectType
            ]
        });
        if ("otherObjectTypeID" in this) result.value.push(this.otherObjectTypeID);
        result.value.push(this.digestAlgorithm.toSchema());
        result.value.push(this.objectDigest);
        return result;
    }
    toJSON() {
        const result = {
            digestedObjectType: this.digestedObjectType.toJSON()
        };
        if ("otherObjectTypeID" in this) result.otherObjectTypeID = this.otherObjectTypeID.toJSON();
        result.digestAlgorithm = this.digestAlgorithm.toJSON();
        result.objectDigest = this.objectDigest.toJSON();
        return result;
    }
}
class V2Form {
    constructor(parameters = {}){
        if ("issuerName" in parameters) this.issuerName = getParametersValue(parameters, "issuerName", V2Form.defaultValues("issuerName"));
        if ("baseCertificateID" in parameters) this.baseCertificateID = getParametersValue(parameters, "baseCertificateID", V2Form.defaultValues("baseCertificateID"));
        if ("objectDigestInfo" in parameters) this.objectDigestInfo = getParametersValue(parameters, "objectDigestInfo", V2Form.defaultValues("objectDigestInfo"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "issuerName":
                return new GeneralNames();
            case "baseCertificateID":
                return new IssuerSerial();
            case "objectDigestInfo":
                return new ObjectDigestInfo();
            default:
                throw new Error(`Invalid member name for V2Form class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                GeneralNames.schema({
                    names: {
                        blockName: names.issuerName
                    }
                }, true),
                new Constructed({
                    optional: true,
                    name: names.baseCertificateID || "",
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: IssuerSerial.schema().valueBlock.value
                }),
                new Constructed({
                    optional: true,
                    name: names.objectDigestInfo || "",
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: ObjectDigestInfo.schema().valueBlock.value
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "issuerName",
            "baseCertificateID",
            "objectDigestInfo"
        ]);
        const asn1 = compareSchema(schema, schema, V2Form.schema({
            names: {
                issuerName: "issuerName",
                baseCertificateID: "baseCertificateID",
                objectDigestInfo: "objectDigestInfo"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for V2Form");
        if ("issuerName" in asn1.result) this.issuerName = new GeneralNames({
            schema: asn1.result.issuerName
        });
        if ("baseCertificateID" in asn1.result) {
            this.baseCertificateID = new IssuerSerial({
                schema: new Sequence({
                    value: asn1.result.baseCertificateID.valueBlock.value
                })
            });
        }
        if ("objectDigestInfo" in asn1.result) {
            this.objectDigestInfo = new ObjectDigestInfo({
                schema: new Sequence({
                    value: asn1.result.objectDigestInfo.valueBlock.value
                })
            });
        }
    }
    toSchema() {
        const result = new Sequence();
        if ("issuerName" in this) result.valueBlock.value.push(this.issuerName.toSchema());
        if ("baseCertificateID" in this) {
            result.valueBlock.value.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: this.baseCertificateID.toSchema().valueBlock.value
            }));
        }
        if ("objectDigestInfo" in this) {
            result.valueBlock.value.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                },
                value: this.objectDigestInfo.toSchema().valueBlock.value
            }));
        }
        return result;
    }
    toJSON() {
        const result = {};
        if ("issuerName" in this) result.issuerName = this.issuerName.toJSON();
        if ("baseCertificateID" in this) result.baseCertificateID = this.baseCertificateID.toJSON();
        if ("objectDigestInfo" in this) result.objectDigestInfo = this.objectDigestInfo.toJSON();
        return result;
    }
}
class Holder {
    constructor(parameters = {}){
        if ("baseCertificateID" in parameters) this.baseCertificateID = getParametersValue(parameters, "baseCertificateID", Holder.defaultValues("baseCertificateID"));
        if ("entityName" in parameters) this.entityName = getParametersValue(parameters, "entityName", Holder.defaultValues("entityName"));
        if ("objectDigestInfo" in parameters) this.objectDigestInfo = getParametersValue(parameters, "objectDigestInfo", Holder.defaultValues("objectDigestInfo"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "baseCertificateID":
                return new IssuerSerial();
            case "entityName":
                return new GeneralNames();
            case "objectDigestInfo":
                return new ObjectDigestInfo();
            default:
                throw new Error(`Invalid member name for Holder class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Constructed({
                    optional: true,
                    name: names.baseCertificateID || "",
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: IssuerSerial.schema().valueBlock.value
                }),
                new Constructed({
                    optional: true,
                    name: names.entityName || "",
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: GeneralNames.schema().valueBlock.value
                }),
                new Constructed({
                    optional: true,
                    name: names.objectDigestInfo || "",
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 2
                    },
                    value: ObjectDigestInfo.schema().valueBlock.value
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "baseCertificateID",
            "entityName",
            "objectDigestInfo"
        ]);
        const asn1 = compareSchema(schema, schema, Holder.schema({
            names: {
                baseCertificateID: "baseCertificateID",
                entityName: "entityName",
                objectDigestInfo: "objectDigestInfo"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for Holder");
        if ("baseCertificateID" in asn1.result) {
            this.baseCertificateID = new IssuerSerial({
                schema: new Sequence({
                    value: asn1.result.baseCertificateID.valueBlock.value
                })
            });
        }
        if ("entityName" in asn1.result) {
            this.entityName = new GeneralNames({
                schema: new Sequence({
                    value: asn1.result.entityName.valueBlock.value
                })
            });
        }
        if ("objectDigestInfo" in asn1.result) {
            this.objectDigestInfo = new ObjectDigestInfo({
                schema: new Sequence({
                    value: asn1.result.objectDigestInfo.valueBlock.value
                })
            });
        }
    }
    toSchema() {
        const result = new Sequence();
        if ("baseCertificateID" in this) {
            result.valueBlock.value.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: this.baseCertificateID.toSchema().valueBlock.value
            }));
        }
        if ("entityName" in this) {
            result.valueBlock.value.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                },
                value: this.entityName.toSchema().valueBlock.value
            }));
        }
        if ("objectDigestInfo" in this) {
            result.valueBlock.value.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 2
                },
                value: this.objectDigestInfo.toSchema().valueBlock.value
            }));
        }
        return result;
    }
    toJSON() {
        const result = {};
        if ("baseCertificateID" in this) result.baseCertificateID = this.baseCertificateID.toJSON();
        if ("entityName" in this) result.entityName = this.entityName.toJSON();
        if ("objectDigestInfo" in this) result.objectDigestInfo = this.objectDigestInfo.toJSON();
        return result;
    }
}
class AttributeCertificateInfoV2 {
    constructor(parameters = {}){
        this.version = getParametersValue(parameters, "version", AttributeCertificateInfoV2.defaultValues("version"));
        this.holder = getParametersValue(parameters, "holder", AttributeCertificateInfoV2.defaultValues("holder"));
        this.issuer = getParametersValue(parameters, "issuer", AttributeCertificateInfoV2.defaultValues("issuer"));
        this.signature = getParametersValue(parameters, "signature", AttributeCertificateInfoV2.defaultValues("signature"));
        this.serialNumber = getParametersValue(parameters, "serialNumber", AttributeCertificateInfoV2.defaultValues("serialNumber"));
        this.attrCertValidityPeriod = getParametersValue(parameters, "attrCertValidityPeriod", AttributeCertificateInfoV2.defaultValues("attrCertValidityPeriod"));
        this.attributes = getParametersValue(parameters, "attributes", AttributeCertificateInfoV2.defaultValues("attributes"));
        if ("issuerUniqueID" in parameters) this.issuerUniqueID = getParametersValue(parameters, "issuerUniqueID", AttributeCertificateInfoV2.defaultValues("issuerUniqueID"));
        if ("extensions" in parameters) this.extensions = getParametersValue(parameters, "extensions", AttributeCertificateInfoV2.defaultValues("extensions"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "version":
                return 1;
            case "holder":
                return new Holder();
            case "issuer":
                return {};
            case "signature":
                return new AlgorithmIdentifier();
            case "serialNumber":
                return new Integer();
            case "attrCertValidityPeriod":
                return new AttCertValidityPeriod();
            case "attributes":
                return [];
            case "issuerUniqueID":
                return new BitString();
            case "extensions":
                return new Extensions();
            default:
                throw new Error(`Invalid member name for AttributeCertificateInfoV2 class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Integer({
                    name: names.version || ""
                }),
                Holder.schema(names.holder || {}),
                new Choice({
                    value: [
                        GeneralNames.schema({
                            names: {
                                blockName: names.issuer || ""
                            }
                        }),
                        new Constructed({
                            name: names.issuer || "",
                            idBlock: {
                                tagClass: 3,
                                tagNumber: 0
                            },
                            value: V2Form.schema().valueBlock.value
                        })
                    ]
                }),
                AlgorithmIdentifier.schema(names.signature || {}),
                new Integer({
                    name: names.serialNumber || ""
                }),
                AttCertValidityPeriod.schema(names.attrCertValidityPeriod || {}),
                new Sequence({
                    name: names.attributes || "",
                    value: [
                        new Repeated({
                            value: Attribute.schema()
                        })
                    ]
                }),
                new BitString({
                    optional: true,
                    name: names.issuerUniqueID || ""
                }),
                Extensions.schema(names.extensions || {}, true)
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "version",
            "holder",
            "issuer",
            "signature",
            "serialNumber",
            "attrCertValidityPeriod",
            "attributes",
            "issuerUniqueID",
            "extensions"
        ]);
        const asn1 = compareSchema(schema, schema, AttributeCertificateInfoV2.schema({
            names: {
                version: "version",
                holder: {
                    names: {
                        blockName: "holder"
                    }
                },
                issuer: "issuer",
                signature: {
                    names: {
                        blockName: "signature"
                    }
                },
                serialNumber: "serialNumber",
                attrCertValidityPeriod: {
                    names: {
                        blockName: "attrCertValidityPeriod"
                    }
                },
                attributes: "attributes",
                issuerUniqueID: "issuerUniqueID",
                extensions: {
                    names: {
                        blockName: "extensions"
                    }
                }
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for AttributeCertificateInfoV2");
        this.version = asn1.result.version.valueBlock.valueDec;
        this.holder = new Holder({
            schema: asn1.result.holder
        });
        switch(asn1.result.issuer.idBlock.tagClass){
            case 3:
                this.issuer = new V2Form({
                    schema: new Sequence({
                        value: asn1.result.issuer.valueBlock.value
                    })
                });
                break;
            case 1:
            default:
                throw new Error("Incorect value for 'issuer' in AttributeCertificateInfoV2");
        }
        this.signature = new AlgorithmIdentifier({
            schema: asn1.result.signature
        });
        this.serialNumber = asn1.result.serialNumber;
        this.attrCertValidityPeriod = new AttCertValidityPeriod({
            schema: asn1.result.attrCertValidityPeriod
        });
        this.attributes = Array.from(asn1.result.attributes.valueBlock.value, (element)=>new Attribute({
                schema: element
            })
        );
        if ("issuerUniqueID" in asn1.result) this.issuerUniqueID = asn1.result.issuerUniqueID;
        if ("extensions" in asn1.result) this.extensions = new Extensions({
            schema: asn1.result.extensions
        });
    }
    toSchema() {
        const result = new Sequence({
            value: [
                new Integer({
                    value: this.version
                }),
                this.holder.toSchema(),
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: this.issuer.toSchema().valueBlock.value
                }),
                this.signature.toSchema(),
                this.serialNumber,
                this.attrCertValidityPeriod.toSchema(),
                new Sequence({
                    value: Array.from(this.attributes, (element)=>element.toSchema()
                    )
                })
            ]
        });
        if ("issuerUniqueID" in this) result.valueBlock.value.push(this.issuerUniqueID);
        if ("extensions" in this) result.valueBlock.value.push(this.extensions.toSchema());
        return result;
    }
    toJSON() {
        const result = {
            version: this.version,
            holder: this.holder.toJSON(),
            issuer: this.issuer.toJSON(),
            signature: this.signature.toJSON(),
            serialNumber: this.serialNumber.toJSON(),
            attrCertValidityPeriod: this.attrCertValidityPeriod.toJSON(),
            attributes: Array.from(this.attributes, (element)=>element.toJSON()
            )
        };
        if ("issuerUniqueID" in this) result.issuerUniqueID = this.issuerUniqueID.toJSON();
        if ("extensions" in this) result.extensions = this.extensions.toJSON();
        return result;
    }
}
class AttributeCertificateV2 {
    constructor(parameters = {}){
        this.acinfo = getParametersValue(parameters, "acinfo", AttributeCertificateV2.defaultValues("acinfo"));
        this.signatureAlgorithm = getParametersValue(parameters, "signatureAlgorithm", AttributeCertificateV2.defaultValues("signatureAlgorithm"));
        this.signatureValue = getParametersValue(parameters, "signatureValue", AttributeCertificateV2.defaultValues("signatureValue"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "acinfo":
                return new AttributeCertificateInfoV2();
            case "signatureAlgorithm":
                return new AlgorithmIdentifier();
            case "signatureValue":
                return new BitString();
            default:
                throw new Error(`Invalid member name for AttributeCertificateV2 class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                AttributeCertificateInfoV2.schema(names.acinfo || {}),
                AlgorithmIdentifier.schema(names.signatureAlgorithm || {}),
                new BitString({
                    name: names.signatureValue || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "acinfo",
            "signatureAlgorithm",
            "signatureValue"
        ]);
        const asn1 = compareSchema(schema, schema, AttributeCertificateV2.schema({
            names: {
                acinfo: {
                    names: {
                        blockName: "acinfo"
                    }
                },
                signatureAlgorithm: {
                    names: {
                        blockName: "signatureAlgorithm"
                    }
                },
                signatureValue: "signatureValue"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for AttributeCertificateV2");
        this.acinfo = new AttributeCertificateInfoV2({
            schema: asn1.result.acinfo
        });
        this.signatureAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result.signatureAlgorithm
        });
        this.signatureValue = asn1.result.signatureValue;
    }
    toSchema() {
        return new Sequence({
            value: [
                this.acinfo.toSchema(),
                this.signatureAlgorithm.toSchema(),
                this.signatureValue
            ]
        });
    }
    toJSON() {
        return {
            acinfo: this.acinfo.toJSON(),
            signatureAlgorithm: this.signatureAlgorithm.toJSON(),
            signatureValue: this.signatureValue.toJSON()
        };
    }
}
class CertBag {
    constructor(parameters = {}){
        this.certId = getParametersValue(parameters, "certId", CertBag.defaultValues("certId"));
        this.certValue = getParametersValue(parameters, "certValue", CertBag.defaultValues("certValue"));
        if ("parsedValue" in parameters) this.parsedValue = getParametersValue(parameters, "parsedValue", CertBag.defaultValues("parsedValue"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "certId":
                return "";
            case "certValue":
                return new Any();
            case "parsedValue":
                return {};
            default:
                throw new Error(`Invalid member name for CertBag class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "certId":
                return memberValue === "";
            case "certValue":
                return memberValue instanceof Any;
            case "parsedValue":
                return memberValue instanceof Object && Object.keys(memberValue).length === 0;
            default:
                throw new Error(`Invalid member name for CertBag class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new ObjectIdentifier({
                    name: names.id || "id"
                }),
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Any({
                            name: names.value || "value"
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "certId",
            "certValue"
        ]);
        const asn1 = compareSchema(schema, schema, CertBag.schema({
            names: {
                id: "certId",
                value: "certValue"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for CertBag");
        this.certId = asn1.result.certId.valueBlock.toString();
        this.certValue = asn1.result.certValue;
        switch(this.certId){
            case "1.2.840.113549.1.9.22.1":
                {
                    const asn1Inner = fromBER(this.certValue.valueBlock.valueHex);
                    try {
                        this.parsedValue = new Certificate({
                            schema: asn1Inner.result
                        });
                    } catch (ex) {
                        this.parsedValue = new AttributeCertificateV2({
                            schema: asn1Inner.result
                        });
                    }
                }
                break;
            case "1.2.840.113549.1.9.22.3":
                {
                    const asn1Inner = fromBER(this.certValue.valueBlock.valueHex);
                    this.parsedValue = new AttributeCertificateV2({
                        schema: asn1Inner.result
                    });
                }
                break;
            case "1.2.840.113549.1.9.22.2":
            default:
                throw new Error(`Incorrect "certId" value in CertBag: ${this.certId}`);
        }
    }
    toSchema() {
        if ("parsedValue" in this) {
            if ("acinfo" in this.parsedValue) this.certId = "1.2.840.113549.1.9.22.3";
            else this.certId = "1.2.840.113549.1.9.22.1";
            this.certValue = new OctetString({
                valueHex: this.parsedValue.toSchema().toBER(false)
            });
        }
        return new Sequence({
            value: [
                new ObjectIdentifier({
                    value: this.certId
                }),
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        "toSchema" in this.certValue ? this.certValue.toSchema() : this.certValue
                    ]
                })
            ]
        });
    }
    toJSON() {
        return {
            certId: this.certId,
            certValue: this.certValue.toJSON()
        };
    }
}
class RevokedCertificate {
    constructor(parameters = {}){
        this.userCertificate = getParametersValue(parameters, "userCertificate", RevokedCertificate.defaultValues("userCertificate"));
        this.revocationDate = getParametersValue(parameters, "revocationDate", RevokedCertificate.defaultValues("revocationDate"));
        if ("crlEntryExtensions" in parameters) this.crlEntryExtensions = getParametersValue(parameters, "crlEntryExtensions", RevokedCertificate.defaultValues("crlEntryExtensions"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "userCertificate":
                return new Integer();
            case "revocationDate":
                return new Time();
            case "crlEntryExtensions":
                return new Extensions();
            default:
                throw new Error(`Invalid member name for RevokedCertificate class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Integer({
                    name: names.userCertificate || "userCertificate"
                }),
                Time.schema({
                    names: {
                        utcTimeName: names.revocationDate || "revocationDate",
                        generalTimeName: names.revocationDate || "revocationDate"
                    }
                }),
                Extensions.schema({
                    names: {
                        blockName: names.crlEntryExtensions || "crlEntryExtensions"
                    }
                }, true)
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "userCertificate",
            "revocationDate",
            "crlEntryExtensions"
        ]);
        const asn1 = compareSchema(schema, schema, RevokedCertificate.schema());
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for RevokedCertificate");
        this.userCertificate = asn1.result.userCertificate;
        this.revocationDate = new Time({
            schema: asn1.result.revocationDate
        });
        if ("crlEntryExtensions" in asn1.result) this.crlEntryExtensions = new Extensions({
            schema: asn1.result.crlEntryExtensions
        });
    }
    toSchema() {
        const outputArray = [
            this.userCertificate,
            this.revocationDate.toSchema()
        ];
        if ("crlEntryExtensions" in this) outputArray.push(this.crlEntryExtensions.toSchema());
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const object = {
            userCertificate: this.userCertificate.toJSON(),
            revocationDate: this.revocationDate.toJSON
        };
        if ("crlEntryExtensions" in this) object.crlEntryExtensions = this.crlEntryExtensions.toJSON();
        return object;
    }
}
function tbsCertList(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new Sequence({
        name: names.blockName || "tbsCertList",
        value: [
            new Integer({
                optional: true,
                name: names.tbsCertListVersion || "tbsCertList.version",
                value: 2
            }),
            AlgorithmIdentifier.schema(names.signature || {
                names: {
                    blockName: "tbsCertList.signature"
                }
            }),
            RelativeDistinguishedNames.schema(names.issuer || {
                names: {
                    blockName: "tbsCertList.issuer"
                }
            }),
            Time.schema(names.tbsCertListThisUpdate || {
                names: {
                    utcTimeName: "tbsCertList.thisUpdate",
                    generalTimeName: "tbsCertList.thisUpdate"
                }
            }),
            Time.schema(names.tbsCertListNextUpdate || {
                names: {
                    utcTimeName: "tbsCertList.nextUpdate",
                    generalTimeName: "tbsCertList.nextUpdate"
                }
            }, true),
            new Sequence({
                optional: true,
                value: [
                    new Repeated({
                        name: names.tbsCertListRevokedCertificates || "tbsCertList.revokedCertificates",
                        value: new Sequence({
                            value: [
                                new Integer(),
                                Time.schema(),
                                Extensions.schema({}, true)
                            ]
                        })
                    })
                ]
            }),
            new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: [
                    Extensions.schema(names.crlExtensions || {
                        names: {
                            blockName: "tbsCertList.extensions"
                        }
                    })
                ]
            })
        ]
    });
}
class CertificateRevocationList {
    constructor(parameters = {}){
        this.tbs = getParametersValue(parameters, "tbs", CertificateRevocationList.defaultValues("tbs"));
        this.version = getParametersValue(parameters, "version", CertificateRevocationList.defaultValues("version"));
        this.signature = getParametersValue(parameters, "signature", CertificateRevocationList.defaultValues("signature"));
        this.issuer = getParametersValue(parameters, "issuer", CertificateRevocationList.defaultValues("issuer"));
        this.thisUpdate = getParametersValue(parameters, "thisUpdate", CertificateRevocationList.defaultValues("thisUpdate"));
        if ("nextUpdate" in parameters) this.nextUpdate = getParametersValue(parameters, "nextUpdate", CertificateRevocationList.defaultValues("nextUpdate"));
        if ("revokedCertificates" in parameters) this.revokedCertificates = getParametersValue(parameters, "revokedCertificates", CertificateRevocationList.defaultValues("revokedCertificates"));
        if ("crlExtensions" in parameters) this.crlExtensions = getParametersValue(parameters, "crlExtensions", CertificateRevocationList.defaultValues("crlExtensions"));
        this.signatureAlgorithm = getParametersValue(parameters, "signatureAlgorithm", CertificateRevocationList.defaultValues("signatureAlgorithm"));
        this.signatureValue = getParametersValue(parameters, "signatureValue", CertificateRevocationList.defaultValues("signatureValue"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "tbs":
                return new ArrayBuffer(0);
            case "version":
                return 1;
            case "signature":
                return new AlgorithmIdentifier();
            case "issuer":
                return new RelativeDistinguishedNames();
            case "thisUpdate":
                return new Time();
            case "nextUpdate":
                return new Time();
            case "revokedCertificates":
                return [];
            case "crlExtensions":
                return new Extensions();
            case "signatureAlgorithm":
                return new AlgorithmIdentifier();
            case "signatureValue":
                return new BitString();
            default:
                throw new Error(`Invalid member name for CertificateRevocationList class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "CertificateList",
            value: [
                tbsCertList(parameters),
                AlgorithmIdentifier.schema(names.signatureAlgorithm || {
                    names: {
                        blockName: "signatureAlgorithm"
                    }
                }),
                new BitString({
                    name: names.signatureValue || "signatureValue"
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "tbsCertList",
            "tbsCertList.version",
            "tbsCertList.signature",
            "tbsCertList.issuer",
            "tbsCertList.thisUpdate",
            "tbsCertList.nextUpdate",
            "tbsCertList.revokedCertificates",
            "tbsCertList.extensions",
            "signatureAlgorithm",
            "signatureValue"
        ]);
        const asn1 = compareSchema(schema, schema, CertificateRevocationList.schema());
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for CertificateRevocationList");
        this.tbs = asn1.result.tbsCertList.valueBeforeDecode;
        if ("tbsCertList.version" in asn1.result) this.version = asn1.result["tbsCertList.version"].valueBlock.valueDec;
        this.signature = new AlgorithmIdentifier({
            schema: asn1.result["tbsCertList.signature"]
        });
        this.issuer = new RelativeDistinguishedNames({
            schema: asn1.result["tbsCertList.issuer"]
        });
        this.thisUpdate = new Time({
            schema: asn1.result["tbsCertList.thisUpdate"]
        });
        if ("tbsCertList.nextUpdate" in asn1.result) this.nextUpdate = new Time({
            schema: asn1.result["tbsCertList.nextUpdate"]
        });
        if ("tbsCertList.revokedCertificates" in asn1.result) this.revokedCertificates = Array.from(asn1.result["tbsCertList.revokedCertificates"], (element)=>new RevokedCertificate({
                schema: element
            })
        );
        if ("tbsCertList.extensions" in asn1.result) this.crlExtensions = new Extensions({
            schema: asn1.result["tbsCertList.extensions"]
        });
        this.signatureAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result.signatureAlgorithm
        });
        this.signatureValue = asn1.result.signatureValue;
    }
    encodeTBS() {
        const outputArray = [];
        if (this.version !== CertificateRevocationList.defaultValues("version")) outputArray.push(new Integer({
            value: this.version
        }));
        outputArray.push(this.signature.toSchema());
        outputArray.push(this.issuer.toSchema());
        outputArray.push(this.thisUpdate.toSchema());
        if ("nextUpdate" in this) outputArray.push(this.nextUpdate.toSchema());
        if ("revokedCertificates" in this) {
            outputArray.push(new Sequence({
                value: Array.from(this.revokedCertificates, (element)=>element.toSchema()
                )
            }));
        }
        if ("crlExtensions" in this) {
            outputArray.push(new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: [
                    this.crlExtensions.toSchema()
                ]
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toSchema(encodeFlag = false) {
        let tbsSchema;
        if (encodeFlag === false) {
            if (this.tbs.length === 0) return CertificateRevocationList.schema();
            tbsSchema = fromBER(this.tbs).result;
        } else tbsSchema = this.encodeTBS();
        return new Sequence({
            value: [
                tbsSchema,
                this.signatureAlgorithm.toSchema(),
                this.signatureValue
            ]
        });
    }
    toJSON() {
        const object = {
            tbs: bufferToHexCodes(this.tbs, 0, this.tbs.byteLength),
            signature: this.signature.toJSON(),
            issuer: this.issuer.toJSON(),
            thisUpdate: this.thisUpdate.toJSON(),
            signatureAlgorithm: this.signatureAlgorithm.toJSON(),
            signatureValue: this.signatureValue.toJSON()
        };
        if (this.version !== CertificateRevocationList.defaultValues("version")) object.version = this.version;
        if ("nextUpdate" in this) object.nextUpdate = this.nextUpdate.toJSON();
        if ("revokedCertificates" in this) object.revokedCertificates = Array.from(this.revokedCertificates, (element)=>element.toJSON()
        );
        if ("crlExtensions" in this) object.crlExtensions = this.crlExtensions.toJSON();
        return object;
    }
    isCertificateRevoked(certificate) {
        if (this.issuer.isEqual(certificate.issuer) === false) return false;
        if ("revokedCertificates" in this === false) return false;
        for (const revokedCertificate of this.revokedCertificates){
            if (revokedCertificate.userCertificate.isEqual(certificate.serialNumber)) return true;
        }
        return false;
    }
    sign(privateKey, hashAlgorithm = "SHA-1") {
        if (typeof privateKey === "undefined") return Promise.reject("Need to provide a private key for signing");
        let sequence = Promise.resolve();
        let parameters;
        const engine4 = getEngine();
        sequence = sequence.then(()=>engine4.subtle.getSignatureParameters(privateKey, hashAlgorithm)
        );
        sequence = sequence.then((result)=>{
            parameters = result.parameters;
            this.signature = result.signatureAlgorithm;
            this.signatureAlgorithm = result.signatureAlgorithm;
        });
        sequence = sequence.then(()=>{
            this.tbs = this.encodeTBS().toBER(false);
        });
        sequence = sequence.then(()=>engine4.subtle.signWithPrivateKey(this.tbs, privateKey, parameters)
        );
        sequence = sequence.then((result)=>{
            this.signatureValue = new BitString({
                valueHex: result
            });
        });
        return sequence;
    }
    verify(parameters = {}) {
        let sequence = Promise.resolve();
        let subjectPublicKeyInfo = -1;
        const engine5 = getEngine();
        if ("issuerCertificate" in parameters) {
            subjectPublicKeyInfo = parameters.issuerCertificate.subjectPublicKeyInfo;
            if (this.issuer.isEqual(parameters.issuerCertificate.subject) === false) return Promise.resolve(false);
        }
        if ("publicKeyInfo" in parameters) subjectPublicKeyInfo = parameters.publicKeyInfo;
        if ("subjectPublicKey" in subjectPublicKeyInfo === false) return Promise.reject("Issuer's certificate must be provided as an input parameter");
        if ("crlExtensions" in this) {
            for (const extension of this.crlExtensions.extensions){
                if (extension.critical) {
                    if ("parsedValue" in extension === false) return Promise.resolve(false);
                }
            }
        }
        sequence = sequence.then(()=>engine5.subtle.verifyWithPublicKey(this.tbs, this.signatureValue, subjectPublicKeyInfo, this.signatureAlgorithm)
        );
        return sequence;
    }
}
class CRLBag {
    constructor(parameters = {}){
        this.crlId = getParametersValue(parameters, "crlId", CRLBag.defaultValues("crlId"));
        this.crlValue = getParametersValue(parameters, "crlValue", CRLBag.defaultValues("crlValue"));
        if ("parsedValue" in parameters) this.parsedValue = getParametersValue(parameters, "parsedValue", CRLBag.defaultValues("parsedValue"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "crlId":
                return "";
            case "crlValue":
                return new Any();
            case "parsedValue":
                return {};
            default:
                throw new Error(`Invalid member name for CRLBag class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "crlId":
                return memberValue === "";
            case "crlValue":
                return memberValue instanceof Any;
            case "parsedValue":
                return memberValue instanceof Object && Object.keys(memberValue).length === 0;
            default:
                throw new Error(`Invalid member name for CRLBag class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new ObjectIdentifier({
                    name: names.id || "id"
                }),
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Any({
                            name: names.value || "value"
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "crlId",
            "crlValue"
        ]);
        const asn1 = compareSchema(schema, schema, CRLBag.schema({
            names: {
                id: "crlId",
                value: "crlValue"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for CRLBag");
        this.crlId = asn1.result.crlId.valueBlock.toString();
        this.crlValue = asn1.result.crlValue;
        switch(this.crlId){
            case "1.2.840.113549.1.9.23.1":
                {
                    const asn1Inner = fromBER(this.certValue.valueBlock.valueHex);
                    this.parsedValue = new CertificateRevocationList({
                        schema: asn1Inner.result
                    });
                }
                break;
            default:
                throw new Error(`Incorrect "crlId" value in CRLBag: ${this.crlId}`);
        }
    }
    toSchema() {
        if ("parsedValue" in this) {
            this.certId = "1.2.840.113549.1.9.23.1";
            this.certValue = new OctetString({
                valueHex: this.parsedValue.toSchema().toBER(false)
            });
        }
        return new Sequence({
            value: [
                new ObjectIdentifier({
                    value: this.crlId
                }),
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        this.crlValue.toSchema()
                    ]
                })
            ]
        });
    }
    toJSON() {
        return {
            crlId: this.crlId,
            crlValue: this.crlValue.toJSON()
        };
    }
}
class SecretBag {
    constructor(parameters = {}){
        this.secretTypeId = getParametersValue(parameters, "secretTypeId", SecretBag.defaultValues("secretTypeId"));
        this.secretValue = getParametersValue(parameters, "secretValue", SecretBag.defaultValues("secretValue"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "secretTypeId":
                return "";
            case "secretValue":
                return new Any();
            default:
                throw new Error(`Invalid member name for SecretBag class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "secretTypeId":
                return memberValue === "";
            case "secretValue":
                return memberValue instanceof Any;
            default:
                throw new Error(`Invalid member name for SecretBag class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new ObjectIdentifier({
                    name: names.id || "id"
                }),
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Any({
                            name: names.value || "value"
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "secretTypeId",
            "secretValue"
        ]);
        const asn1 = compareSchema(schema, schema, SecretBag.schema({
            names: {
                id: "secretTypeId",
                value: "secretValue"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for SecretBag");
        this.secretTypeId = asn1.result.secretTypeId.valueBlock.toString();
        this.secretValue = asn1.result.secretValue;
    }
    toSchema() {
        return new Sequence({
            value: [
                new ObjectIdentifier({
                    value: this.secretTypeId
                }),
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        this.secretValue.toSchema()
                    ]
                })
            ]
        });
    }
    toJSON() {
        return {
            secretTypeId: this.secretTypeId,
            secretValue: this.secretValue.toJSON()
        };
    }
}
class SafeContents {
    constructor(parameters = {}){
        this.safeBags = getParametersValue(parameters, "safeBags", SafeContents.defaultValues("safeBags"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "safeBags":
                return [];
            default:
                throw new Error(`Invalid member name for SafeContents class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "safeBags":
                return memberValue.length === 0;
            default:
                throw new Error(`Invalid member name for SafeContents class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Repeated({
                    name: names.safeBags || "",
                    value: SafeBag.schema()
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "safeBags"
        ]);
        const asn1 = compareSchema(schema, schema, SafeContents.schema({
            names: {
                safeBags: "safeBags"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for SafeContents");
        this.safeBags = Array.from(asn1.result.safeBags, (element)=>new SafeBag({
                schema: element
            })
        );
    }
    toSchema() {
        return new Sequence({
            value: Array.from(this.safeBags, (element)=>element.toSchema()
            )
        });
    }
    toJSON() {
        return {
            safeBags: Array.from(this.safeBags, (element)=>element.toJSON()
            )
        };
    }
}
class SafeBag {
    constructor(parameters = {}){
        this.bagId = getParametersValue(parameters, "bagId", SafeBag.defaultValues("bagId"));
        this.bagValue = getParametersValue(parameters, "bagValue", SafeBag.defaultValues("bagValue"));
        if ("bagAttributes" in parameters) this.bagAttributes = getParametersValue(parameters, "bagAttributes", SafeBag.defaultValues("bagAttributes"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "bagId":
                return "";
            case "bagValue":
                return new Any();
            case "bagAttributes":
                return [];
            default:
                throw new Error(`Invalid member name for SafeBag class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "bagId":
                return memberValue === "";
            case "bagValue":
                return memberValue instanceof Any;
            case "bagAttributes":
                return memberValue.length === 0;
            default:
                throw new Error(`Invalid member name for SafeBag class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new ObjectIdentifier({
                    name: names.bagId || "bagId"
                }),
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Any({
                            name: names.bagValue || "bagValue"
                        })
                    ]
                }),
                new Set1({
                    optional: true,
                    value: [
                        new Repeated({
                            name: names.bagAttributes || "bagAttributes",
                            value: Attribute.schema()
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "bagId",
            "bagValue",
            "bagAttributes"
        ]);
        const asn1 = compareSchema(schema, schema, SafeBag.schema({
            names: {
                bagId: "bagId",
                bagValue: "bagValue",
                bagAttributes: "bagAttributes"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for SafeBag");
        this.bagId = asn1.result.bagId.valueBlock.toString();
        switch(this.bagId){
            case "1.2.840.113549.1.12.10.1.1":
                this.bagValue = new PrivateKeyInfo({
                    schema: asn1.result.bagValue
                });
                break;
            case "1.2.840.113549.1.12.10.1.2":
                this.bagValue = new PKCS8ShroudedKeyBag({
                    schema: asn1.result.bagValue
                });
                break;
            case "1.2.840.113549.1.12.10.1.3":
                this.bagValue = new CertBag({
                    schema: asn1.result.bagValue
                });
                break;
            case "1.2.840.113549.1.12.10.1.4":
                this.bagValue = new CRLBag({
                    schema: asn1.result.bagValue
                });
                break;
            case "1.2.840.113549.1.12.10.1.5":
                this.bagValue = new SecretBag({
                    schema: asn1.result.bagValue
                });
                break;
            case "1.2.840.113549.1.12.10.1.6":
                this.bagValue = new SafeContents({
                    schema: asn1.result.bagValue
                });
                break;
            default:
                throw new Error(`Invalid "bagId" for SafeBag: ${this.bagId}`);
        }
        if ("bagAttributes" in asn1.result) this.bagAttributes = Array.from(asn1.result.bagAttributes, (element)=>new Attribute({
                schema: element
            })
        );
    }
    toSchema() {
        const outputArray = [
            new ObjectIdentifier({
                value: this.bagId
            }),
            new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: [
                    this.bagValue.toSchema()
                ]
            })
        ];
        if ("bagAttributes" in this) {
            outputArray.push(new Set1({
                value: Array.from(this.bagAttributes, (element)=>element.toSchema()
                )
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const output = {
            bagId: this.bagId,
            bagValue: this.bagValue.toJSON()
        };
        if ("bagAttributes" in this) output.bagAttributes = Array.from(this.bagAttributes, (element)=>element.toJSON()
        );
        return output;
    }
}
class OtherCertificateFormat {
    constructor(parameters = {}){
        this.otherCertFormat = getParametersValue(parameters, "otherCertFormat", OtherCertificateFormat.defaultValues("otherCertFormat"));
        this.otherCert = getParametersValue(parameters, "otherCert", OtherCertificateFormat.defaultValues("otherCert"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "otherCertFormat":
                return "";
            case "otherCert":
                return new Any();
            default:
                throw new Error(`Invalid member name for OtherCertificateFormat class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new ObjectIdentifier({
                    name: names.otherCertFormat || "otherCertFormat"
                }),
                new Any({
                    name: names.otherCert || "otherCert"
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "otherCertFormat",
            "otherCert"
        ]);
        const asn1 = compareSchema(schema, schema, OtherCertificateFormat.schema());
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for OtherCertificateFormat");
        this.otherCertFormat = asn1.result.otherCertFormat.valueBlock.toString();
        this.otherCert = asn1.result.otherCert;
    }
    toSchema() {
        return new Sequence({
            value: [
                new ObjectIdentifier({
                    value: this.otherCertFormat
                }),
                this.otherCert
            ]
        });
    }
    toJSON() {
        const object = {
            otherCertFormat: this.otherCertFormat
        };
        if (!(this.otherCert instanceof Any)) object.otherCert = this.otherCert.toJSON();
        return object;
    }
}
class CertificateSet {
    constructor(parameters = {}){
        this.certificates = getParametersValue(parameters, "certificates", CertificateSet.defaultValues("certificates"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "certificates":
                return [];
            default:
                throw new Error(`Invalid member name for Attribute class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Set1({
            name: names.blockName || "",
            value: [
                new Repeated({
                    name: names.certificates || "certificates",
                    value: new Choice({
                        value: [
                            Certificate.schema(),
                            new Constructed({
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: 0
                                },
                                value: [
                                    new Any()
                                ]
                            }),
                            new Constructed({
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: 1
                                },
                                value: AttributeCertificateV1.schema().valueBlock.value
                            }),
                            new Constructed({
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: 2
                                },
                                value: AttributeCertificateV2.schema().valueBlock.value
                            }),
                            new Constructed({
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: 3
                                },
                                value: OtherCertificateFormat.schema().valueBlock.value
                            })
                        ]
                    })
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "certificates"
        ]);
        const asn1 = compareSchema(schema, schema, CertificateSet.schema());
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for CertificateSet");
        this.certificates = Array.from(asn1.result.certificates, (element)=>{
            const initialTagNumber = element.idBlock.tagNumber;
            if (element.idBlock.tagClass === 1) return new Certificate({
                schema: element
            });
            const elementSequence = new Sequence({
                value: element.valueBlock.value
            });
            switch(initialTagNumber){
                case 1:
                    return new AttributeCertificateV1({
                        schema: elementSequence
                    });
                case 2:
                    return new AttributeCertificateV2({
                        schema: elementSequence
                    });
                case 3:
                    return new OtherCertificateFormat({
                        schema: elementSequence
                    });
                case 0:
                default:
            }
            return element;
        });
    }
    toSchema() {
        return new Set1({
            value: Array.from(this.certificates, (element)=>{
                switch(true){
                    case element instanceof Certificate:
                        return element.toSchema();
                    case element instanceof AttributeCertificateV1:
                        return new Constructed({
                            idBlock: {
                                tagClass: 3,
                                tagNumber: 1
                            },
                            value: element.toSchema().valueBlock.value
                        });
                    case element instanceof AttributeCertificateV2:
                        return new Constructed({
                            idBlock: {
                                tagClass: 3,
                                tagNumber: 2
                            },
                            value: element.toSchema().valueBlock.value
                        });
                    case element instanceof OtherCertificateFormat:
                        return new Constructed({
                            idBlock: {
                                tagClass: 3,
                                tagNumber: 3
                            },
                            value: element.toSchema().valueBlock.value
                        });
                    default:
                }
                return element;
            })
        });
    }
    toJSON() {
        return {
            certificates: Array.from(this.certificates, (element)=>element.toJSON()
            )
        };
    }
}
class OtherRevocationInfoFormat {
    constructor(parameters = {}){
        this.otherRevInfoFormat = getParametersValue(parameters, "otherRevInfoFormat", OtherRevocationInfoFormat.defaultValues("otherRevInfoFormat"));
        this.otherRevInfo = getParametersValue(parameters, "otherRevInfo", OtherRevocationInfoFormat.defaultValues("otherRevInfo"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "otherRevInfoFormat":
                return "";
            case "otherRevInfo":
                return new Any();
            default:
                throw new Error(`Invalid member name for OtherRevocationInfoFormat class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new ObjectIdentifier({
                    name: names.otherRevInfoFormat || "otherRevInfoFormat"
                }),
                new Any({
                    name: names.otherRevInfo || "otherRevInfo"
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "otherRevInfoFormat",
            "otherRevInfo"
        ]);
        const asn1 = compareSchema(schema, schema, OtherRevocationInfoFormat.schema());
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for OtherRevocationInfoFormat");
        this.otherRevInfoFormat = asn1.result.otherRevInfoFormat.valueBlock.toString();
        this.otherRevInfo = asn1.result.otherRevInfo;
    }
    toSchema() {
        return new Sequence({
            value: [
                new ObjectIdentifier({
                    value: this.otherRevInfoFormat
                }),
                this.otherRevInfo
            ]
        });
    }
    toJSON() {
        const object = {
            otherRevInfoFormat: this.otherRevInfoFormat
        };
        if (!(this.otherRevInfo instanceof Any)) object.otherRevInfo = this.otherRevInfo.toJSON();
        return object;
    }
}
class RevocationInfoChoices {
    constructor(parameters = {}){
        this.crls = getParametersValue(parameters, "crls", RevocationInfoChoices.defaultValues("crls"));
        this.otherRevocationInfos = getParametersValue(parameters, "otherRevocationInfos", RevocationInfoChoices.defaultValues("otherRevocationInfos"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "crls":
                return [];
            case "otherRevocationInfos":
                return [];
            default:
                throw new Error(`Invalid member name for RevocationInfoChoices class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Set1({
            name: names.blockName || "",
            value: [
                new Repeated({
                    name: names.crls || "",
                    value: new Choice({
                        value: [
                            CertificateRevocationList.schema(),
                            new Constructed({
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: 1
                                },
                                value: [
                                    new ObjectIdentifier(),
                                    new Any()
                                ]
                            })
                        ]
                    })
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "crls"
        ]);
        const asn1 = compareSchema(schema, schema, RevocationInfoChoices.schema({
            names: {
                crls: "crls"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for RevocationInfoChoices");
        for (const element of asn1.result.crls){
            if (element.idBlock.tagClass === 1) this.crls.push(new CertificateRevocationList({
                schema: element
            }));
            else this.otherRevocationInfos.push(new OtherRevocationInfoFormat({
                schema: element
            }));
        }
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(...Array.from(this.crls, (element)=>element.toSchema()
        ));
        outputArray.push(...Array.from(this.otherRevocationInfos, (element)=>{
            const schema = element.toSchema();
            schema.idBlock.tagClass = 3;
            schema.idBlock.tagNumber = 1;
            return schema;
        }));
        return new Set1({
            value: outputArray
        });
    }
    toJSON() {
        return {
            crls: Array.from(this.crls, (element)=>element.toJSON()
            ),
            otherRevocationInfos: Array.from(this.otherRevocationInfos, (element)=>element.toJSON()
            )
        };
    }
}
class OriginatorInfo {
    constructor(parameters = {}){
        this.certs = getParametersValue(parameters, "certs", OriginatorInfo.defaultValues("certs"));
        this.crls = getParametersValue(parameters, "crls", OriginatorInfo.defaultValues("crls"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "certs":
                return new CertificateSet();
            case "crls":
                return new RevocationInfoChoices();
            default:
                throw new Error(`Invalid member name for OriginatorInfo class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "certs":
                return memberValue.certificates.length === 0;
            case "crls":
                return memberValue.crls.length === 0 && memberValue.otherRevocationInfos.length === 0;
            default:
                throw new Error(`Invalid member name for OriginatorInfo class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Constructed({
                    name: names.certs || "",
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: CertificateSet.schema().valueBlock.value
                }),
                new Constructed({
                    name: names.crls || "",
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: RevocationInfoChoices.schema().valueBlock.value
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "certs",
            "crls"
        ]);
        const asn1 = compareSchema(schema, schema, OriginatorInfo.schema({
            names: {
                certs: "certs",
                crls: "crls"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for OriginatorInfo");
        this.certs = new CertificateSet({
            schema: new Set1({
                value: asn1.result.certs.valueBlock.value
            })
        });
        this.crls = new RevocationInfoChoices({
            schema: new Set1({
                value: asn1.result.crls.valueBlock.value
            })
        });
    }
    toSchema() {
        return new Sequence({
            value: [
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: this.certs.toSchema().valueBlock.value
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: this.crls.toSchema().valueBlock.value
                })
            ]
        });
    }
    toJSON() {
        return {
            certs: this.certs.toJSON(),
            crls: this.crls.toJSON()
        };
    }
}
class IssuerAndSerialNumber {
    constructor(parameters = {}){
        this.issuer = getParametersValue(parameters, "issuer", IssuerAndSerialNumber.defaultValues("issuer"));
        this.serialNumber = getParametersValue(parameters, "serialNumber", IssuerAndSerialNumber.defaultValues("serialNumber"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "issuer":
                return new RelativeDistinguishedNames();
            case "serialNumber":
                return new Integer();
            default:
                throw new Error(`Invalid member name for IssuerAndSerialNumber class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                RelativeDistinguishedNames.schema(names.issuer || {}),
                new Integer({
                    name: names.serialNumber || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "issuer",
            "serialNumber"
        ]);
        const asn1 = compareSchema(schema, schema, IssuerAndSerialNumber.schema({
            names: {
                issuer: {
                    names: {
                        blockName: "issuer"
                    }
                },
                serialNumber: "serialNumber"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for IssuerAndSerialNumber");
        this.issuer = new RelativeDistinguishedNames({
            schema: asn1.result.issuer
        });
        this.serialNumber = asn1.result.serialNumber;
    }
    toSchema() {
        return new Sequence({
            value: [
                this.issuer.toSchema(),
                this.serialNumber
            ]
        });
    }
    toJSON() {
        return {
            issuer: this.issuer.toJSON(),
            serialNumber: this.serialNumber.toJSON()
        };
    }
}
class RecipientIdentifier {
    constructor(parameters = {}){
        this.variant = getParametersValue(parameters, "variant", RecipientIdentifier.defaultValues("variant"));
        if ("value" in parameters) this.value = getParametersValue(parameters, "value", RecipientIdentifier.defaultValues("value"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "variant":
                return -1;
            case "value":
                return {};
            default:
                throw new Error(`Invalid member name for RecipientIdentifier class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "variant":
                return memberValue === -1;
            case "values":
                return Object.keys(memberValue).length === 0;
            default:
                throw new Error(`Invalid member name for RecipientIdentifier class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Choice({
            value: [
                IssuerAndSerialNumber.schema({
                    names: {
                        blockName: names.blockName || ""
                    }
                }),
                new Constructed({
                    name: names.blockName || "",
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new OctetString()
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "blockName"
        ]);
        const asn1 = compareSchema(schema, schema, RecipientIdentifier.schema({
            names: {
                blockName: "blockName"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for RecipientIdentifier");
        if (asn1.result.blockName.idBlock.tagClass === 1) {
            this.variant = 1;
            this.value = new IssuerAndSerialNumber({
                schema: asn1.result.blockName
            });
        } else {
            this.variant = 2;
            this.value = asn1.result.blockName.valueBlock.value[0];
        }
    }
    toSchema() {
        switch(this.variant){
            case 1:
                return this.value.toSchema();
            case 2:
                return new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        this.value
                    ]
                });
            default:
                return new Any();
        }
    }
    toJSON() {
        const _object = {
            variant: this.variant
        };
        if (this.variant === 1 || this.variant === 2) _object.value = this.value.toJSON();
        return _object;
    }
}
class KeyTransRecipientInfo {
    constructor(parameters = {}){
        this.version = getParametersValue(parameters, "version", KeyTransRecipientInfo.defaultValues("version"));
        this.rid = getParametersValue(parameters, "rid", KeyTransRecipientInfo.defaultValues("rid"));
        this.keyEncryptionAlgorithm = getParametersValue(parameters, "keyEncryptionAlgorithm", KeyTransRecipientInfo.defaultValues("keyEncryptionAlgorithm"));
        this.encryptedKey = getParametersValue(parameters, "encryptedKey", KeyTransRecipientInfo.defaultValues("encryptedKey"));
        this.recipientCertificate = getParametersValue(parameters, "recipientCertificate", KeyTransRecipientInfo.defaultValues("recipientCertificate"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "version":
                return -1;
            case "rid":
                return {};
            case "keyEncryptionAlgorithm":
                return new AlgorithmIdentifier();
            case "encryptedKey":
                return new OctetString();
            case "recipientCertificate":
                return new Certificate();
            default:
                throw new Error(`Invalid member name for KeyTransRecipientInfo class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "version":
                return memberValue === KeyTransRecipientInfo.defaultValues("version");
            case "rid":
                return Object.keys(memberValue).length === 0;
            case "keyEncryptionAlgorithm":
            case "encryptedKey":
                return memberValue.isEqual(KeyTransRecipientInfo.defaultValues(memberName));
            case "recipientCertificate":
                return false;
            default:
                throw new Error(`Invalid member name for KeyTransRecipientInfo class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Integer({
                    name: names.version || ""
                }),
                RecipientIdentifier.schema(names.rid || {}),
                AlgorithmIdentifier.schema(names.keyEncryptionAlgorithm || {}),
                new OctetString({
                    name: names.encryptedKey || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "version",
            "rid",
            "keyEncryptionAlgorithm",
            "encryptedKey"
        ]);
        const asn1 = compareSchema(schema, schema, KeyTransRecipientInfo.schema({
            names: {
                version: "version",
                rid: {
                    names: {
                        blockName: "rid"
                    }
                },
                keyEncryptionAlgorithm: {
                    names: {
                        blockName: "keyEncryptionAlgorithm"
                    }
                },
                encryptedKey: "encryptedKey"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for KeyTransRecipientInfo");
        this.version = asn1.result.version.valueBlock.valueDec;
        if (asn1.result.rid.idBlock.tagClass === 3) this.rid = asn1.result.rid.valueBlock.value[0];
        else this.rid = new IssuerAndSerialNumber({
            schema: asn1.result.rid
        });
        this.keyEncryptionAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result.keyEncryptionAlgorithm
        });
        this.encryptedKey = asn1.result.encryptedKey;
    }
    toSchema() {
        const outputArray = [];
        if (this.rid instanceof IssuerAndSerialNumber) {
            this.version = 0;
            outputArray.push(new Integer({
                value: this.version
            }));
            outputArray.push(this.rid.toSchema());
        } else {
            this.version = 2;
            outputArray.push(new Integer({
                value: this.version
            }));
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: [
                    this.rid
                ]
            }));
        }
        outputArray.push(this.keyEncryptionAlgorithm.toSchema());
        outputArray.push(this.encryptedKey);
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        return {
            version: this.version,
            rid: this.rid.toJSON(),
            keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),
            encryptedKey: this.encryptedKey.toJSON()
        };
    }
}
class OriginatorPublicKey {
    constructor(parameters = {}){
        this.algorithm = getParametersValue(parameters, "algorithm", OriginatorPublicKey.defaultValues("algorithm"));
        this.publicKey = getParametersValue(parameters, "publicKey", OriginatorPublicKey.defaultValues("publicKey"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "algorithm":
                return new AlgorithmIdentifier();
            case "publicKey":
                return new BitString();
            default:
                throw new Error(`Invalid member name for OriginatorPublicKey class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "algorithm":
            case "publicKey":
                return memberValue.isEqual(OriginatorPublicKey.defaultValues(memberName));
            default:
                throw new Error(`Invalid member name for OriginatorPublicKey class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                AlgorithmIdentifier.schema(names.algorithm || {}),
                new BitString({
                    name: names.publicKey || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "algorithm",
            "publicKey"
        ]);
        const asn1 = compareSchema(schema, schema, OriginatorPublicKey.schema({
            names: {
                algorithm: {
                    names: {
                        blockName: "algorithm"
                    }
                },
                publicKey: "publicKey"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for OriginatorPublicKey");
        this.algorithm = new AlgorithmIdentifier({
            schema: asn1.result.algorithm
        });
        this.publicKey = asn1.result.publicKey;
    }
    toSchema() {
        return new Sequence({
            value: [
                this.algorithm.toSchema(),
                this.publicKey
            ]
        });
    }
    toJSON() {
        return {
            algorithm: this.algorithm.toJSON(),
            publicKey: this.publicKey.toJSON()
        };
    }
}
class OriginatorIdentifierOrKey {
    constructor(parameters = {}){
        this.variant = getParametersValue(parameters, "variant", OriginatorIdentifierOrKey.defaultValues("variant"));
        if ("value" in parameters) this.value = getParametersValue(parameters, "value", OriginatorIdentifierOrKey.defaultValues("value"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "variant":
                return -1;
            case "value":
                return {};
            default:
                throw new Error(`Invalid member name for OriginatorIdentifierOrKey class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "variant":
                return memberValue === -1;
            case "value":
                return Object.keys(memberValue).length === 0;
            default:
                throw new Error(`Invalid member name for OriginatorIdentifierOrKey class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Choice({
            value: [
                IssuerAndSerialNumber.schema({
                    names: {
                        blockName: names.blockName || ""
                    }
                }),
                new Primitive({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    name: names.blockName || ""
                }),
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    name: names.blockName || "",
                    value: OriginatorPublicKey.schema().valueBlock.value
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "blockName"
        ]);
        const asn1 = compareSchema(schema, schema, OriginatorIdentifierOrKey.schema({
            names: {
                blockName: "blockName"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for OriginatorIdentifierOrKey");
        if (asn1.result.blockName.idBlock.tagClass === 1) {
            this.variant = 1;
            this.value = new IssuerAndSerialNumber({
                schema: asn1.result.blockName
            });
        } else {
            if (asn1.result.blockName.idBlock.tagNumber === 0) {
                asn1.result.blockName.idBlock.tagClass = 1;
                asn1.result.blockName.idBlock.tagNumber = 4;
                this.variant = 2;
                this.value = asn1.result.blockName;
            } else {
                this.variant = 3;
                this.value = new OriginatorPublicKey({
                    schema: new Sequence({
                        value: asn1.result.blockName.valueBlock.value
                    })
                });
            }
        }
    }
    toSchema() {
        switch(this.variant){
            case 1:
                return this.value.toSchema();
            case 2:
                this.value.idBlock.tagClass = 3;
                this.value.idBlock.tagNumber = 0;
                return this.value;
            case 3:
                {
                    const _schema = this.value.toSchema();
                    _schema.idBlock.tagClass = 3;
                    _schema.idBlock.tagNumber = 1;
                    return _schema;
                }
            default:
                return new Any();
        }
    }
    toJSON() {
        const _object = {
            variant: this.variant
        };
        if (this.variant === 1 || this.variant === 2 || this.variant === 3) _object.value = this.value.toJSON();
        return _object;
    }
}
class OtherKeyAttribute {
    constructor(parameters = {}){
        this.keyAttrId = getParametersValue(parameters, "keyAttrId", OtherKeyAttribute.defaultValues("keyAttrId"));
        if ("keyAttr" in parameters) this.keyAttr = getParametersValue(parameters, "keyAttr", OtherKeyAttribute.defaultValues("keyAttr"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "keyAttrId":
                return "";
            case "keyAttr":
                return {};
            default:
                throw new Error(`Invalid member name for OtherKeyAttribute class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "keyAttrId":
                return memberValue === "";
            case "keyAttr":
                return Object.keys(memberValue).length === 0;
            default:
                throw new Error(`Invalid member name for OtherKeyAttribute class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            optional: names.optional || true,
            name: names.blockName || "",
            value: [
                new ObjectIdentifier({
                    name: names.keyAttrId || ""
                }),
                new Any({
                    optional: true,
                    name: names.keyAttr || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "keyAttrId",
            "keyAttr"
        ]);
        const asn1 = compareSchema(schema, schema, OtherKeyAttribute.schema({
            names: {
                keyAttrId: "keyAttrId",
                keyAttr: "keyAttr"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for OtherKeyAttribute");
        this.keyAttrId = asn1.result.keyAttrId.valueBlock.toString();
        if ("keyAttr" in asn1.result) this.keyAttr = asn1.result.keyAttr;
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(new ObjectIdentifier({
            value: this.keyAttrId
        }));
        if ("keyAttr" in this) outputArray.push(this.keyAttr.toSchema());
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const _object = {
            keyAttrId: this.keyAttrId
        };
        if ("keyAttr" in this) _object.keyAttr = this.keyAttr.toJSON();
        return _object;
    }
}
class RecipientKeyIdentifier {
    constructor(parameters = {}){
        this.subjectKeyIdentifier = getParametersValue(parameters, "subjectKeyIdentifier", RecipientKeyIdentifier.defaultValues("subjectKeyIdentifier"));
        if ("date" in parameters) this.date = getParametersValue(parameters, "date", RecipientKeyIdentifier.defaultValues("date"));
        if ("other" in parameters) this.other = getParametersValue(parameters, "other", RecipientKeyIdentifier.defaultValues("other"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "subjectKeyIdentifier":
                return new OctetString();
            case "date":
                return new GeneralizedTime();
            case "other":
                return new OtherKeyAttribute();
            default:
                throw new Error(`Invalid member name for RecipientKeyIdentifier class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "subjectKeyIdentifier":
                return memberValue.isEqual(RecipientKeyIdentifier.defaultValues("subjectKeyIdentifier"));
            case "date":
                return memberValue.year === 0 && memberValue.month === 0 && memberValue.day === 0 && memberValue.hour === 0 && memberValue.minute === 0 && memberValue.second === 0 && memberValue.millisecond === 0;
            case "other":
                return memberValue.keyAttrId === "" && "keyAttr" in memberValue === false;
            default:
                throw new Error(`Invalid member name for RecipientKeyIdentifier class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new OctetString({
                    name: names.subjectKeyIdentifier || ""
                }),
                new GeneralizedTime({
                    optional: true,
                    name: names.date || ""
                }),
                OtherKeyAttribute.schema(names.other || {})
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "subjectKeyIdentifier",
            "date",
            "other"
        ]);
        const asn1 = compareSchema(schema, schema, RecipientKeyIdentifier.schema({
            names: {
                subjectKeyIdentifier: "subjectKeyIdentifier",
                date: "date",
                other: {
                    names: {
                        blockName: "other"
                    }
                }
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for RecipientKeyIdentifier");
        this.subjectKeyIdentifier = asn1.result.subjectKeyIdentifier;
        if ("date" in asn1.result) this.date = asn1.result.date;
        if ("other" in asn1.result) this.other = new OtherKeyAttribute({
            schema: asn1.result.other
        });
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(this.subjectKeyIdentifier);
        if ("date" in this) outputArray.push(this.date);
        if ("other" in this) outputArray.push(this.other.toSchema());
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const _object = {
            subjectKeyIdentifier: this.subjectKeyIdentifier.toJSON()
        };
        if ("date" in this) _object.date = this.date;
        if ("other" in this) _object.other = this.other.toJSON();
        return _object;
    }
}
class KeyAgreeRecipientIdentifier {
    constructor(parameters = {}){
        this.variant = getParametersValue(parameters, "variant", KeyAgreeRecipientIdentifier.defaultValues("variant"));
        this.value = getParametersValue(parameters, "value", KeyAgreeRecipientIdentifier.defaultValues("value"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "variant":
                return -1;
            case "value":
                return {};
            default:
                throw new Error(`Invalid member name for KeyAgreeRecipientIdentifier class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "variant":
                return memberValue === -1;
            case "value":
                return Object.keys(memberValue).length === 0;
            default:
                throw new Error(`Invalid member name for KeyAgreeRecipientIdentifier class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Choice({
            value: [
                IssuerAndSerialNumber.schema(names.issuerAndSerialNumber || {
                    names: {
                        blockName: names.blockName || ""
                    }
                }),
                new Constructed({
                    name: names.blockName || "",
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: RecipientKeyIdentifier.schema(names.rKeyId || {
                        names: {
                            blockName: names.blockName || ""
                        }
                    }).valueBlock.value
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "blockName"
        ]);
        const asn1 = compareSchema(schema, schema, KeyAgreeRecipientIdentifier.schema({
            names: {
                blockName: "blockName"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for KeyAgreeRecipientIdentifier");
        if (asn1.result.blockName.idBlock.tagClass === 1) {
            this.variant = 1;
            this.value = new IssuerAndSerialNumber({
                schema: asn1.result.blockName
            });
        } else {
            this.variant = 2;
            this.value = new RecipientKeyIdentifier({
                schema: new Sequence({
                    value: asn1.result.blockName.valueBlock.value
                })
            });
        }
    }
    toSchema() {
        switch(this.variant){
            case 1:
                return this.value.toSchema();
            case 2:
                return new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: this.value.toSchema().valueBlock.value
                });
            default:
                return new Any();
        }
    }
    toJSON() {
        const _object = {
            variant: this.variant
        };
        if (this.variant === 1 || this.variant === 2) _object.value = this.value.toJSON();
        return _object;
    }
}
class RecipientEncryptedKey {
    constructor(parameters = {}){
        this.rid = getParametersValue(parameters, "rid", RecipientEncryptedKey.defaultValues("rid"));
        this.encryptedKey = getParametersValue(parameters, "encryptedKey", RecipientEncryptedKey.defaultValues("encryptedKey"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "rid":
                return new KeyAgreeRecipientIdentifier();
            case "encryptedKey":
                return new OctetString();
            default:
                throw new Error(`Invalid member name for RecipientEncryptedKey class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "rid":
                return memberValue.variant === -1 && "value" in memberValue === false;
            case "encryptedKey":
                return memberValue.isEqual(RecipientEncryptedKey.defaultValues("encryptedKey"));
            default:
                throw new Error(`Invalid member name for RecipientEncryptedKey class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                KeyAgreeRecipientIdentifier.schema(names.rid || {}),
                new OctetString({
                    name: names.encryptedKey || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "rid",
            "encryptedKey"
        ]);
        const asn1 = compareSchema(schema, schema, RecipientEncryptedKey.schema({
            names: {
                rid: {
                    names: {
                        blockName: "rid"
                    }
                },
                encryptedKey: "encryptedKey"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for RecipientEncryptedKey");
        this.rid = new KeyAgreeRecipientIdentifier({
            schema: asn1.result.rid
        });
        this.encryptedKey = asn1.result.encryptedKey;
    }
    toSchema() {
        return new Sequence({
            value: [
                this.rid.toSchema(),
                this.encryptedKey
            ]
        });
    }
    toJSON() {
        return {
            rid: this.rid.toJSON(),
            encryptedKey: this.encryptedKey.toJSON()
        };
    }
}
class RecipientEncryptedKeys {
    constructor(parameters = {}){
        this.encryptedKeys = getParametersValue(parameters, "encryptedKeys", RecipientEncryptedKeys.defaultValues("encryptedKeys"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "encryptedKeys":
                return [];
            default:
                throw new Error(`Invalid member name for RecipientEncryptedKeys class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "encryptedKeys":
                return memberValue.length === 0;
            default:
                throw new Error(`Invalid member name for RecipientEncryptedKeys class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Repeated({
                    name: names.RecipientEncryptedKeys || "",
                    value: RecipientEncryptedKey.schema()
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "RecipientEncryptedKeys"
        ]);
        const asn1 = compareSchema(schema, schema, RecipientEncryptedKeys.schema({
            names: {
                RecipientEncryptedKeys: "RecipientEncryptedKeys"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for RecipientEncryptedKeys");
        this.encryptedKeys = Array.from(asn1.result.RecipientEncryptedKeys, (element)=>new RecipientEncryptedKey({
                schema: element
            })
        );
    }
    toSchema() {
        return new Sequence({
            value: Array.from(this.encryptedKeys, (element)=>element.toSchema()
            )
        });
    }
    toJSON() {
        return {
            encryptedKeys: Array.from(this.encryptedKeys, (element)=>element.toJSON()
            )
        };
    }
}
class KeyAgreeRecipientInfo {
    constructor(parameters = {}){
        this.version = getParametersValue(parameters, "version", KeyAgreeRecipientInfo.defaultValues("version"));
        this.originator = getParametersValue(parameters, "originator", KeyAgreeRecipientInfo.defaultValues("originator"));
        if ("ukm" in parameters) this.ukm = getParametersValue(parameters, "ukm", KeyAgreeRecipientInfo.defaultValues("ukm"));
        this.keyEncryptionAlgorithm = getParametersValue(parameters, "keyEncryptionAlgorithm", KeyAgreeRecipientInfo.defaultValues("keyEncryptionAlgorithm"));
        this.recipientEncryptedKeys = getParametersValue(parameters, "recipientEncryptedKeys", KeyAgreeRecipientInfo.defaultValues("recipientEncryptedKeys"));
        this.recipientCertificate = getParametersValue(parameters, "recipientCertificate", KeyAgreeRecipientInfo.defaultValues("recipientCertificate"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "version":
                return 0;
            case "originator":
                return new OriginatorIdentifierOrKey();
            case "ukm":
                return new OctetString();
            case "keyEncryptionAlgorithm":
                return new AlgorithmIdentifier();
            case "recipientEncryptedKeys":
                return new RecipientEncryptedKeys();
            case "recipientCertificate":
                return new Certificate();
            default:
                throw new Error(`Invalid member name for KeyAgreeRecipientInfo class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "version":
                return memberValue === 0;
            case "originator":
                return memberValue.variant === -1 && "value" in memberValue === false;
            case "ukm":
                return memberValue.isEqual(KeyAgreeRecipientInfo.defaultValues("ukm"));
            case "keyEncryptionAlgorithm":
                return memberValue.algorithmId === "" && "algorithmParams" in memberValue === false;
            case "recipientEncryptedKeys":
                return memberValue.encryptedKeys.length === 0;
            case "recipientCertificate":
                return false;
            default:
                throw new Error(`Invalid member name for KeyAgreeRecipientInfo class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Integer({
                    name: names.version || ""
                }),
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        OriginatorIdentifierOrKey.schema(names.originator || {})
                    ]
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: [
                        new OctetString({
                            name: names.ukm || ""
                        })
                    ]
                }),
                AlgorithmIdentifier.schema(names.keyEncryptionAlgorithm || {}),
                RecipientEncryptedKeys.schema(names.recipientEncryptedKeys || {})
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "version",
            "originator",
            "ukm",
            "keyEncryptionAlgorithm",
            "recipientEncryptedKeys"
        ]);
        const asn1 = compareSchema(schema, schema, KeyAgreeRecipientInfo.schema({
            names: {
                version: "version",
                originator: {
                    names: {
                        blockName: "originator"
                    }
                },
                ukm: "ukm",
                keyEncryptionAlgorithm: {
                    names: {
                        blockName: "keyEncryptionAlgorithm"
                    }
                },
                recipientEncryptedKeys: {
                    names: {
                        blockName: "recipientEncryptedKeys"
                    }
                }
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for KeyAgreeRecipientInfo");
        this.version = asn1.result.version.valueBlock.valueDec;
        this.originator = new OriginatorIdentifierOrKey({
            schema: asn1.result.originator
        });
        if ("ukm" in asn1.result) this.ukm = asn1.result.ukm;
        this.keyEncryptionAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result.keyEncryptionAlgorithm
        });
        this.recipientEncryptedKeys = new RecipientEncryptedKeys({
            schema: asn1.result.recipientEncryptedKeys
        });
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(new Integer({
            value: this.version
        }));
        outputArray.push(new Constructed({
            idBlock: {
                tagClass: 3,
                tagNumber: 0
            },
            value: [
                this.originator.toSchema()
            ]
        }));
        if ("ukm" in this) {
            outputArray.push(new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                },
                value: [
                    this.ukm
                ]
            }));
        }
        outputArray.push(this.keyEncryptionAlgorithm.toSchema());
        outputArray.push(this.recipientEncryptedKeys.toSchema());
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const _object = {
            version: this.version,
            originator: this.originator.toJSON()
        };
        if ("ukm" in this) _object.ukm = this.ukm.toJSON();
        _object.keyEncryptionAlgorithm = this.keyEncryptionAlgorithm.toJSON();
        _object.recipientEncryptedKeys = this.recipientEncryptedKeys.toJSON();
        return _object;
    }
}
class KEKIdentifier {
    constructor(parameters = {}){
        this.keyIdentifier = getParametersValue(parameters, "keyIdentifier", KEKIdentifier.defaultValues("keyIdentifier"));
        if ("date" in parameters) this.date = getParametersValue(parameters, "date", KEKIdentifier.defaultValues("date"));
        if ("other" in parameters) this.other = getParametersValue(parameters, "other", KEKIdentifier.defaultValues("other"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "keyIdentifier":
                return new OctetString();
            case "date":
                return new GeneralizedTime();
            case "other":
                return new OtherKeyAttribute();
            default:
                throw new Error(`Invalid member name for KEKIdentifier class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "keyIdentifier":
                return memberValue.isEqual(KEKIdentifier.defaultValues("keyIdentifier"));
            case "date":
                return memberValue.year === 0 && memberValue.month === 0 && memberValue.day === 0 && memberValue.hour === 0 && memberValue.minute === 0 && memberValue.second === 0 && memberValue.millisecond === 0;
            case "other":
                return memberValue.compareWithDefault("keyAttrId", memberValue.keyAttrId) && "keyAttr" in memberValue === false;
            default:
                throw new Error(`Invalid member name for KEKIdentifier class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new OctetString({
                    name: names.keyIdentifier || ""
                }),
                new GeneralizedTime({
                    optional: true,
                    name: names.date || ""
                }),
                OtherKeyAttribute.schema(names.other || {})
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "keyIdentifier",
            "date",
            "other"
        ]);
        const asn1 = compareSchema(schema, schema, KEKIdentifier.schema({
            names: {
                keyIdentifier: "keyIdentifier",
                date: "date",
                other: {
                    names: {
                        blockName: "other"
                    }
                }
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for KEKIdentifier");
        this.keyIdentifier = asn1.result.keyIdentifier;
        if ("date" in asn1.result) this.date = asn1.result.date;
        if ("other" in asn1.result) this.other = new OtherKeyAttribute({
            schema: asn1.result.other
        });
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(this.keyIdentifier);
        if ("date" in this) outputArray.push(this.date);
        if ("other" in this) outputArray.push(this.other.toSchema());
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const _object = {
            keyIdentifier: this.keyIdentifier.toJSON()
        };
        if ("date" in this) _object.date = this.date;
        if ("other" in this) _object.other = this.other.toJSON();
        return _object;
    }
}
class KEKRecipientInfo {
    constructor(parameters = {}){
        this.version = getParametersValue(parameters, "version", KEKRecipientInfo.defaultValues("version"));
        this.kekid = getParametersValue(parameters, "kekid", KEKRecipientInfo.defaultValues("kekid"));
        this.keyEncryptionAlgorithm = getParametersValue(parameters, "keyEncryptionAlgorithm", KEKRecipientInfo.defaultValues("keyEncryptionAlgorithm"));
        this.encryptedKey = getParametersValue(parameters, "encryptedKey", KEKRecipientInfo.defaultValues("encryptedKey"));
        this.preDefinedKEK = getParametersValue(parameters, "preDefinedKEK", KEKRecipientInfo.defaultValues("preDefinedKEK"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "version":
                return 0;
            case "kekid":
                return new KEKIdentifier();
            case "keyEncryptionAlgorithm":
                return new AlgorithmIdentifier();
            case "encryptedKey":
                return new OctetString();
            case "preDefinedKEK":
                return new ArrayBuffer(0);
            default:
                throw new Error(`Invalid member name for KEKRecipientInfo class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "KEKRecipientInfo":
                return memberValue === KEKRecipientInfo.defaultValues("version");
            case "kekid":
                return memberValue.compareWithDefault("keyIdentifier", memberValue.keyIdentifier) && "date" in memberValue === false && "other" in memberValue === false;
            case "keyEncryptionAlgorithm":
                return memberValue.algorithmId === "" && "algorithmParams" in memberValue === false;
            case "encryptedKey":
                return memberValue.isEqual(KEKRecipientInfo.defaultValues("encryptedKey"));
            case "preDefinedKEK":
                return memberValue.byteLength === 0;
            default:
                throw new Error(`Invalid member name for KEKRecipientInfo class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Integer({
                    name: names.version || ""
                }),
                KEKIdentifier.schema(names.kekid || {}),
                AlgorithmIdentifier.schema(names.keyEncryptionAlgorithm || {}),
                new OctetString({
                    name: names.encryptedKey || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "version",
            "kekid",
            "keyEncryptionAlgorithm",
            "encryptedKey"
        ]);
        const asn1 = compareSchema(schema, schema, KEKRecipientInfo.schema({
            names: {
                version: "version",
                kekid: {
                    names: {
                        blockName: "kekid"
                    }
                },
                keyEncryptionAlgorithm: {
                    names: {
                        blockName: "keyEncryptionAlgorithm"
                    }
                },
                encryptedKey: "encryptedKey"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for KEKRecipientInfo");
        this.version = asn1.result.version.valueBlock.valueDec;
        this.kekid = new KEKIdentifier({
            schema: asn1.result.kekid
        });
        this.keyEncryptionAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result.keyEncryptionAlgorithm
        });
        this.encryptedKey = asn1.result.encryptedKey;
    }
    toSchema() {
        return new Sequence({
            value: [
                new Integer({
                    value: this.version
                }),
                this.kekid.toSchema(),
                this.keyEncryptionAlgorithm.toSchema(),
                this.encryptedKey
            ]
        });
    }
    toJSON() {
        return {
            version: this.version,
            kekid: this.kekid.toJSON(),
            keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),
            encryptedKey: this.encryptedKey.toJSON()
        };
    }
}
class PasswordRecipientinfo {
    constructor(parameters = {}){
        this.version = getParametersValue(parameters, "version", PasswordRecipientinfo.defaultValues("version"));
        if ("keyDerivationAlgorithm" in parameters) this.keyDerivationAlgorithm = getParametersValue(parameters, "keyDerivationAlgorithm", PasswordRecipientinfo.defaultValues("keyDerivationAlgorithm"));
        this.keyEncryptionAlgorithm = getParametersValue(parameters, "keyEncryptionAlgorithm", PasswordRecipientinfo.defaultValues("keyEncryptionAlgorithm"));
        this.encryptedKey = getParametersValue(parameters, "encryptedKey", PasswordRecipientinfo.defaultValues("encryptedKey"));
        this.password = getParametersValue(parameters, "password", PasswordRecipientinfo.defaultValues("password"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "version":
                return -1;
            case "keyDerivationAlgorithm":
                return new AlgorithmIdentifier();
            case "keyEncryptionAlgorithm":
                return new AlgorithmIdentifier();
            case "encryptedKey":
                return new OctetString();
            case "password":
                return new ArrayBuffer(0);
            default:
                throw new Error(`Invalid member name for PasswordRecipientinfo class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "version":
                return memberValue === -1;
            case "keyDerivationAlgorithm":
            case "keyEncryptionAlgorithm":
                return memberValue.algorithmId === "" && "algorithmParams" in memberValue === false;
            case "encryptedKey":
                return memberValue.isEqual(PasswordRecipientinfo.defaultValues("encryptedKey"));
            case "password":
                return memberValue.byteLength === 0;
            default:
                throw new Error(`Invalid member name for PasswordRecipientinfo class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Integer({
                    name: names.version || ""
                }),
                new Constructed({
                    name: names.keyDerivationAlgorithm || "",
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: AlgorithmIdentifier.schema().valueBlock.value
                }),
                AlgorithmIdentifier.schema(names.keyEncryptionAlgorithm || {}),
                new OctetString({
                    name: names.encryptedKey || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "version",
            "keyDerivationAlgorithm",
            "keyEncryptionAlgorithm",
            "encryptedKey"
        ]);
        const asn1 = compareSchema(schema, schema, PasswordRecipientinfo.schema({
            names: {
                version: "version",
                keyDerivationAlgorithm: "keyDerivationAlgorithm",
                keyEncryptionAlgorithm: {
                    names: {
                        blockName: "keyEncryptionAlgorithm"
                    }
                },
                encryptedKey: "encryptedKey"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PasswordRecipientinfo");
        this.version = asn1.result.version.valueBlock.valueDec;
        if ("keyDerivationAlgorithm" in asn1.result) {
            this.keyDerivationAlgorithm = new AlgorithmIdentifier({
                schema: new Sequence({
                    value: asn1.result.keyDerivationAlgorithm.valueBlock.value
                })
            });
        }
        this.keyEncryptionAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result.keyEncryptionAlgorithm
        });
        this.encryptedKey = asn1.result.encryptedKey;
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(new Integer({
            value: this.version
        }));
        if ("keyDerivationAlgorithm" in this) {
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: this.keyDerivationAlgorithm.toSchema().valueBlock.value
            }));
        }
        outputArray.push(this.keyEncryptionAlgorithm.toSchema());
        outputArray.push(this.encryptedKey);
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        return {
            version: this.version,
            keyDerivationAlgorithm: this.keyDerivationAlgorithm.toJSON(),
            keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),
            encryptedKey: this.encryptedKey.toJSON()
        };
    }
}
class OtherRecipientInfo {
    constructor(parameters = {}){
        this.oriType = getParametersValue(parameters, "oriType", OtherRecipientInfo.defaultValues("oriType"));
        this.oriValue = getParametersValue(parameters, "oriValue", OtherRecipientInfo.defaultValues("oriValue"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "oriType":
                return "";
            case "oriValue":
                return {};
            default:
                throw new Error(`Invalid member name for OtherRecipientInfo class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "oriType":
                return memberValue === "";
            case "oriValue":
                return Object.keys(memberValue).length === 0;
            default:
                throw new Error(`Invalid member name for OtherRecipientInfo class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new ObjectIdentifier({
                    name: names.oriType || ""
                }),
                new Any({
                    name: names.oriValue || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "oriType",
            "oriValue"
        ]);
        const asn1 = compareSchema(schema, schema, OtherRecipientInfo.schema({
            names: {
                oriType: "oriType",
                oriValue: "oriValue"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for OtherRecipientInfo");
        this.oriType = asn1.result.oriType.valueBlock.toString();
        this.oriValue = asn1.result.oriValue;
    }
    toSchema() {
        return new Sequence({
            value: [
                new ObjectIdentifier({
                    value: this.oriType
                }),
                this.oriValue
            ]
        });
    }
    toJSON() {
        const _object = {
            oriType: this.oriType
        };
        if (OtherRecipientInfo.compareWithDefault("oriValue", this.oriValue) === false) _object.oriValue = this.oriValue.toJSON();
        return _object;
    }
}
class RecipientInfo {
    constructor(parameters = {}){
        this.variant = getParametersValue(parameters, "variant", RecipientInfo.defaultValues("variant"));
        if ("value" in parameters) this.value = getParametersValue(parameters, "value", RecipientInfo.defaultValues("value"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "variant":
                return -1;
            case "value":
                return {};
            default:
                throw new Error(`Invalid member name for RecipientInfo class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "variant":
                return memberValue === RecipientInfo.defaultValues(memberName);
            case "value":
                return Object.keys(memberValue).length === 0;
            default:
                throw new Error(`Invalid member name for RecipientInfo class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Choice({
            value: [
                KeyTransRecipientInfo.schema({
                    names: {
                        blockName: names.blockName || ""
                    }
                }),
                new Constructed({
                    name: names.blockName || "",
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: KeyAgreeRecipientInfo.schema().valueBlock.value
                }),
                new Constructed({
                    name: names.blockName || "",
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 2
                    },
                    value: KEKRecipientInfo.schema().valueBlock.value
                }),
                new Constructed({
                    name: names.blockName || "",
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 3
                    },
                    value: PasswordRecipientinfo.schema().valueBlock.value
                }),
                new Constructed({
                    name: names.blockName || "",
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 4
                    },
                    value: OtherRecipientInfo.schema().valueBlock.value
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "blockName"
        ]);
        const asn1 = compareSchema(schema, schema, RecipientInfo.schema({
            names: {
                blockName: "blockName"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for RecipientInfo");
        if (asn1.result.blockName.idBlock.tagClass === 1) {
            this.variant = 1;
            this.value = new KeyTransRecipientInfo({
                schema: asn1.result.blockName
            });
        } else {
            const blockSequence = new Sequence({
                value: asn1.result.blockName.valueBlock.value
            });
            switch(asn1.result.blockName.idBlock.tagNumber){
                case 1:
                    this.variant = 2;
                    this.value = new KeyAgreeRecipientInfo({
                        schema: blockSequence
                    });
                    break;
                case 2:
                    this.variant = 3;
                    this.value = new KEKRecipientInfo({
                        schema: blockSequence
                    });
                    break;
                case 3:
                    this.variant = 4;
                    this.value = new PasswordRecipientinfo({
                        schema: blockSequence
                    });
                    break;
                case 4:
                    this.variant = 5;
                    this.value = new OtherRecipientInfo({
                        schema: blockSequence
                    });
                    break;
                default:
                    throw new Error("Incorrect structure of RecipientInfo block");
            }
        }
    }
    toSchema() {
        const _schema = this.value.toSchema();
        switch(this.variant){
            case 1:
                return _schema;
            case 2:
            case 3:
            case 4:
                _schema.idBlock.tagClass = 3;
                _schema.idBlock.tagNumber = this.variant - 1;
                return _schema;
            default:
                return new Any();
        }
    }
    toJSON() {
        const _object = {
            variant: this.variant
        };
        if (this.variant >= 1 && this.variant <= 4) _object.value = this.value.toJSON();
        return _object;
    }
}
class RSAESOAEPParams {
    constructor(parameters = {}){
        this.hashAlgorithm = getParametersValue(parameters, "hashAlgorithm", RSAESOAEPParams.defaultValues("hashAlgorithm"));
        this.maskGenAlgorithm = getParametersValue(parameters, "maskGenAlgorithm", RSAESOAEPParams.defaultValues("maskGenAlgorithm"));
        this.pSourceAlgorithm = getParametersValue(parameters, "pSourceAlgorithm", RSAESOAEPParams.defaultValues("pSourceAlgorithm"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "hashAlgorithm":
                return new AlgorithmIdentifier({
                    algorithmId: "1.3.14.3.2.26",
                    algorithmParams: new Null()
                });
            case "maskGenAlgorithm":
                return new AlgorithmIdentifier({
                    algorithmId: "1.2.840.113549.1.1.8",
                    algorithmParams: new AlgorithmIdentifier({
                        algorithmId: "1.3.14.3.2.26",
                        algorithmParams: new Null()
                    }).toSchema()
                });
            case "pSourceAlgorithm":
                return new AlgorithmIdentifier({
                    algorithmId: "1.2.840.113549.1.1.9",
                    algorithmParams: new OctetString({
                        valueHex: new Uint8Array([
                            0xda,
                            0x39,
                            0xa3,
                            0xee,
                            0x5e,
                            0x6b,
                            0x4b,
                            0x0d,
                            0x32,
                            0x55,
                            0xbf,
                            0xef,
                            0x95,
                            0x60,
                            0x18,
                            0x90,
                            0xaf,
                            0xd8,
                            0x07,
                            0x09
                        ]).buffer
                    })
                });
            default:
                throw new Error(`Invalid member name for RSAESOAEPParams class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    optional: true,
                    value: [
                        AlgorithmIdentifier.schema(names.hashAlgorithm || {})
                    ]
                }),
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    optional: true,
                    value: [
                        AlgorithmIdentifier.schema(names.maskGenAlgorithm || {})
                    ]
                }),
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 2
                    },
                    optional: true,
                    value: [
                        AlgorithmIdentifier.schema(names.pSourceAlgorithm || {})
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "hashAlgorithm",
            "maskGenAlgorithm",
            "pSourceAlgorithm"
        ]);
        const asn1 = compareSchema(schema, schema, RSAESOAEPParams.schema({
            names: {
                hashAlgorithm: {
                    names: {
                        blockName: "hashAlgorithm"
                    }
                },
                maskGenAlgorithm: {
                    names: {
                        blockName: "maskGenAlgorithm"
                    }
                },
                pSourceAlgorithm: {
                    names: {
                        blockName: "pSourceAlgorithm"
                    }
                }
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for RSAESOAEPParams");
        if ("hashAlgorithm" in asn1.result) this.hashAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result.hashAlgorithm
        });
        if ("maskGenAlgorithm" in asn1.result) this.maskGenAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result.maskGenAlgorithm
        });
        if ("pSourceAlgorithm" in asn1.result) this.pSourceAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result.pSourceAlgorithm
        });
    }
    toSchema() {
        const outputArray = [];
        if (!this.hashAlgorithm.isEqual(RSAESOAEPParams.defaultValues("hashAlgorithm"))) {
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: [
                    this.hashAlgorithm.toSchema()
                ]
            }));
        }
        if (!this.maskGenAlgorithm.isEqual(RSAESOAEPParams.defaultValues("maskGenAlgorithm"))) {
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                },
                value: [
                    this.maskGenAlgorithm.toSchema()
                ]
            }));
        }
        if (!this.pSourceAlgorithm.isEqual(RSAESOAEPParams.defaultValues("pSourceAlgorithm"))) {
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 2
                },
                value: [
                    this.pSourceAlgorithm.toSchema()
                ]
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const object = {};
        if (!this.hashAlgorithm.isEqual(RSAESOAEPParams.defaultValues("hashAlgorithm"))) object.hashAlgorithm = this.hashAlgorithm.toJSON();
        if (!this.maskGenAlgorithm.isEqual(RSAESOAEPParams.defaultValues("maskGenAlgorithm"))) object.maskGenAlgorithm = this.maskGenAlgorithm.toJSON();
        if (!this.pSourceAlgorithm.isEqual(RSAESOAEPParams.defaultValues("pSourceAlgorithm"))) object.pSourceAlgorithm = this.pSourceAlgorithm.toJSON();
        return object;
    }
}
class ECCCMSSharedInfo {
    constructor(parameters = {}){
        this.keyInfo = getParametersValue(parameters, "keyInfo", ECCCMSSharedInfo.defaultValues("keyInfo"));
        if ("entityUInfo" in parameters) this.entityUInfo = getParametersValue(parameters, "entityUInfo", ECCCMSSharedInfo.defaultValues("entityUInfo"));
        this.suppPubInfo = getParametersValue(parameters, "suppPubInfo", ECCCMSSharedInfo.defaultValues("suppPubInfo"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "keyInfo":
                return new AlgorithmIdentifier();
            case "entityUInfo":
                return new OctetString();
            case "suppPubInfo":
                return new OctetString();
            default:
                throw new Error(`Invalid member name for ECCCMSSharedInfo class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "keyInfo":
            case "entityUInfo":
            case "suppPubInfo":
                return memberValue.isEqual(ECCCMSSharedInfo.defaultValues(memberName));
            default:
                throw new Error(`Invalid member name for ECCCMSSharedInfo class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                AlgorithmIdentifier.schema(names.keyInfo || {}),
                new Constructed({
                    name: names.entityUInfo || "",
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    optional: true,
                    value: [
                        new OctetString()
                    ]
                }),
                new Constructed({
                    name: names.suppPubInfo || "",
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 2
                    },
                    value: [
                        new OctetString()
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "keyInfo",
            "entityUInfo",
            "suppPubInfo"
        ]);
        const asn1 = compareSchema(schema, schema, ECCCMSSharedInfo.schema({
            names: {
                keyInfo: {
                    names: {
                        blockName: "keyInfo"
                    }
                },
                entityUInfo: "entityUInfo",
                suppPubInfo: "suppPubInfo"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for ECCCMSSharedInfo");
        this.keyInfo = new AlgorithmIdentifier({
            schema: asn1.result.keyInfo
        });
        if ("entityUInfo" in asn1.result) this.entityUInfo = asn1.result.entityUInfo.valueBlock.value[0];
        this.suppPubInfo = asn1.result.suppPubInfo.valueBlock.value[0];
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(this.keyInfo.toSchema());
        if ("entityUInfo" in this) {
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: [
                    this.entityUInfo
                ]
            }));
        }
        outputArray.push(new Constructed({
            idBlock: {
                tagClass: 3,
                tagNumber: 2
            },
            value: [
                this.suppPubInfo
            ]
        }));
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const _object = {
            keyInfo: this.keyInfo.toJSON()
        };
        if ("entityUInfo" in this) _object.entityUInfo = this.entityUInfo.toJSON();
        _object.suppPubInfo = this.suppPubInfo.toJSON();
        return _object;
    }
}
class EnvelopedData {
    constructor(parameters = {}){
        this.version = getParametersValue(parameters, "version", EnvelopedData.defaultValues("version"));
        if ("originatorInfo" in parameters) this.originatorInfo = getParametersValue(parameters, "originatorInfo", EnvelopedData.defaultValues("originatorInfo"));
        this.recipientInfos = getParametersValue(parameters, "recipientInfos", EnvelopedData.defaultValues("recipientInfos"));
        this.encryptedContentInfo = getParametersValue(parameters, "encryptedContentInfo", EnvelopedData.defaultValues("encryptedContentInfo"));
        if ("unprotectedAttrs" in parameters) this.unprotectedAttrs = getParametersValue(parameters, "unprotectedAttrs", EnvelopedData.defaultValues("unprotectedAttrs"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "version":
                return 0;
            case "originatorInfo":
                return new OriginatorInfo();
            case "recipientInfos":
                return [];
            case "encryptedContentInfo":
                return new EncryptedContentInfo();
            case "unprotectedAttrs":
                return [];
            default:
                throw new Error(`Invalid member name for EnvelopedData class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "version":
                return memberValue === EnvelopedData.defaultValues(memberName);
            case "originatorInfo":
                return memberValue.certs.certificates.length === 0 && memberValue.crls.crls.length === 0;
            case "recipientInfos":
            case "unprotectedAttrs":
                return memberValue.length === 0;
            case "encryptedContentInfo":
                return EncryptedContentInfo.compareWithDefault("contentType", memberValue.contentType) && EncryptedContentInfo.compareWithDefault("contentEncryptionAlgorithm", memberValue.contentEncryptionAlgorithm) && EncryptedContentInfo.compareWithDefault("encryptedContent", memberValue.encryptedContent);
            default:
                throw new Error(`Invalid member name for EnvelopedData class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Integer({
                    name: names.version || ""
                }),
                new Constructed({
                    name: names.originatorInfo || "",
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: OriginatorInfo.schema().valueBlock.value
                }),
                new Set1({
                    value: [
                        new Repeated({
                            name: names.recipientInfos || "",
                            value: RecipientInfo.schema()
                        })
                    ]
                }),
                EncryptedContentInfo.schema(names.encryptedContentInfo || {}),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: [
                        new Repeated({
                            name: names.unprotectedAttrs || "",
                            value: Attribute.schema()
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "version",
            "originatorInfo",
            "recipientInfos",
            "encryptedContentInfo",
            "unprotectedAttrs"
        ]);
        const asn1 = compareSchema(schema, schema, EnvelopedData.schema({
            names: {
                version: "version",
                originatorInfo: "originatorInfo",
                recipientInfos: "recipientInfos",
                encryptedContentInfo: {
                    names: {
                        blockName: "encryptedContentInfo"
                    }
                },
                unprotectedAttrs: "unprotectedAttrs"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for EnvelopedData");
        this.version = asn1.result.version.valueBlock.valueDec;
        if ("originatorInfo" in asn1.result) {
            this.originatorInfo = new OriginatorInfo({
                schema: new Sequence({
                    value: asn1.result.originatorInfo.valueBlock.value
                })
            });
        }
        this.recipientInfos = Array.from(asn1.result.recipientInfos, (element)=>new RecipientInfo({
                schema: element
            })
        );
        this.encryptedContentInfo = new EncryptedContentInfo({
            schema: asn1.result.encryptedContentInfo
        });
        if ("unprotectedAttrs" in asn1.result) this.unprotectedAttrs = Array.from(asn1.result.unprotectedAttrs, (element)=>new Attribute({
                schema: element
            })
        );
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(new Integer({
            value: this.version
        }));
        if ("originatorInfo" in this) {
            outputArray.push(new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: this.originatorInfo.toSchema().valueBlock.value
            }));
        }
        outputArray.push(new Set1({
            value: Array.from(this.recipientInfos, (element)=>element.toSchema()
            )
        }));
        outputArray.push(this.encryptedContentInfo.toSchema());
        if ("unprotectedAttrs" in this) {
            outputArray.push(new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                },
                value: Array.from(this.unprotectedAttrs, (element)=>element.toSchema()
                )
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const _object = {
            version: this.version
        };
        if ("originatorInfo" in this) _object.originatorInfo = this.originatorInfo.toJSON();
        _object.recipientInfos = Array.from(this.recipientInfos, (element)=>element.toJSON()
        );
        _object.encryptedContentInfo = this.encryptedContentInfo.toJSON();
        if ("unprotectedAttrs" in this) _object.unprotectedAttrs = Array.from(this.unprotectedAttrs, (element)=>element.toJSON()
        );
        return _object;
    }
    addRecipientByCertificate(certificate, parameters, variant) {
        const encryptionParameters = parameters || {};
        if (certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.113549") !== -1) variant = 1;
        else {
            if (certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.10045") !== -1) variant = 2;
            else throw new Error(`Unknown type of certificate's public key: ${certificate.subjectPublicKeyInfo.algorithm.algorithmId}`);
        }
        if ("oaepHashAlgorithm" in encryptionParameters === false) encryptionParameters.oaepHashAlgorithm = "SHA-512";
        if ("kdfAlgorithm" in encryptionParameters === false) encryptionParameters.kdfAlgorithm = "SHA-512";
        if ("kekEncryptionLength" in encryptionParameters === false) encryptionParameters.kekEncryptionLength = 256;
        switch(variant){
            case 1:
                {
                    const oaepOID = getOIDByAlgorithm({
                        name: "RSA-OAEP"
                    });
                    if (oaepOID === "") throw new Error("Can not find OID for OAEP");
                    const hashOID = getOIDByAlgorithm({
                        name: encryptionParameters.oaepHashAlgorithm
                    });
                    if (hashOID === "") throw new Error(`Unknown OAEP hash algorithm: ${encryptionParameters.oaepHashAlgorithm}`);
                    const hashAlgorithm = new AlgorithmIdentifier({
                        algorithmId: hashOID,
                        algorithmParams: new Null()
                    });
                    const rsaOAEPParams = new RSAESOAEPParams({
                        hashAlgorithm,
                        maskGenAlgorithm: new AlgorithmIdentifier({
                            algorithmId: "1.2.840.113549.1.1.8",
                            algorithmParams: hashAlgorithm.toSchema()
                        })
                    });
                    const keyInfo = new KeyTransRecipientInfo({
                        version: 0,
                        rid: new IssuerAndSerialNumber({
                            issuer: certificate.issuer,
                            serialNumber: certificate.serialNumber
                        }),
                        keyEncryptionAlgorithm: new AlgorithmIdentifier({
                            algorithmId: oaepOID,
                            algorithmParams: rsaOAEPParams.toSchema()
                        }),
                        recipientCertificate: certificate
                    });
                    this.recipientInfos.push(new RecipientInfo({
                        variant: 1,
                        value: keyInfo
                    }));
                }
                break;
            case 2:
                {
                    const encryptedKey = new RecipientEncryptedKey({
                        rid: new KeyAgreeRecipientIdentifier({
                            variant: 1,
                            value: new IssuerAndSerialNumber({
                                issuer: certificate.issuer,
                                serialNumber: certificate.serialNumber
                            })
                        })
                    });
                    const aesKWoid = getOIDByAlgorithm({
                        name: "AES-KW",
                        length: encryptionParameters.kekEncryptionLength
                    });
                    if (aesKWoid === "") throw new Error(`Unknown length for key encryption algorithm: ${encryptionParameters.kekEncryptionLength}`);
                    const aesKW = new AlgorithmIdentifier({
                        algorithmId: aesKWoid,
                        algorithmParams: new Null()
                    });
                    const ecdhOID = getOIDByAlgorithm({
                        name: "ECDH",
                        kdf: encryptionParameters.kdfAlgorithm
                    });
                    if (ecdhOID === "") throw new Error(`Unknown KDF algorithm: ${encryptionParameters.kdfAlgorithm}`);
                    const ukmBuffer = new ArrayBuffer(64);
                    const ukmView = new Uint8Array(ukmBuffer);
                    getRandomValues(ukmView);
                    const keyInfo = new KeyAgreeRecipientInfo({
                        version: 3,
                        ukm: new OctetString({
                            valueHex: ukmBuffer
                        }),
                        keyEncryptionAlgorithm: new AlgorithmIdentifier({
                            algorithmId: ecdhOID,
                            algorithmParams: aesKW.toSchema()
                        }),
                        recipientEncryptedKeys: new RecipientEncryptedKeys({
                            encryptedKeys: [
                                encryptedKey
                            ]
                        }),
                        recipientCertificate: certificate
                    });
                    this.recipientInfos.push(new RecipientInfo({
                        variant: 2,
                        value: keyInfo
                    }));
                }
                break;
            default:
                throw new Error(`Unknown "variant" value: ${variant}`);
        }
        return true;
    }
    addRecipientByPreDefinedData(preDefinedData, parameters, variant) {
        const encryptionParameters = parameters || {};
        if (preDefinedData instanceof ArrayBuffer === false) throw new Error("Please pass \"preDefinedData\" in ArrayBuffer type");
        if (preDefinedData.byteLength === 0) throw new Error("Pre-defined data could have zero length");
        if ("keyIdentifier" in encryptionParameters === false) {
            const keyIdentifierBuffer = new ArrayBuffer(16);
            const keyIdentifierView = new Uint8Array(keyIdentifierBuffer);
            getRandomValues(keyIdentifierView);
            encryptionParameters.keyIdentifier = keyIdentifierBuffer;
        }
        if ("hmacHashAlgorithm" in encryptionParameters === false) encryptionParameters.hmacHashAlgorithm = "SHA-512";
        if ("iterationCount" in encryptionParameters === false) encryptionParameters.iterationCount = 2048;
        if ("keyEncryptionAlgorithm" in encryptionParameters === false) {
            encryptionParameters.keyEncryptionAlgorithm = {
                name: "AES-KW",
                length: 256
            };
        }
        if ("keyEncryptionAlgorithmParams" in encryptionParameters === false) encryptionParameters.keyEncryptionAlgorithmParams = new Null();
        switch(variant){
            case 1:
                {
                    const kekOID = getOIDByAlgorithm(encryptionParameters.keyEncryptionAlgorithm);
                    if (kekOID === "") throw new Error("Incorrect value for \"keyEncryptionAlgorithm\"");
                    const keyInfo = new KEKRecipientInfo({
                        version: 4,
                        kekid: new KEKIdentifier({
                            keyIdentifier: new OctetString({
                                valueHex: encryptionParameters.keyIdentifier
                            })
                        }),
                        keyEncryptionAlgorithm: new AlgorithmIdentifier({
                            algorithmId: kekOID,
                            algorithmParams: encryptionParameters.keyEncryptionAlgorithmParams
                        }),
                        preDefinedKEK: preDefinedData
                    });
                    this.recipientInfos.push(new RecipientInfo({
                        variant: 3,
                        value: keyInfo
                    }));
                }
                break;
            case 2:
                {
                    const pbkdf2OID = getOIDByAlgorithm({
                        name: "PBKDF2"
                    });
                    if (pbkdf2OID === "") throw new Error("Can not find OID for PBKDF2");
                    const saltBuffer = new ArrayBuffer(64);
                    const saltView = new Uint8Array(saltBuffer);
                    getRandomValues(saltView);
                    const hmacOID = getOIDByAlgorithm({
                        name: "HMAC",
                        hash: {
                            name: encryptionParameters.hmacHashAlgorithm
                        }
                    });
                    if (hmacOID === "") throw new Error(`Incorrect value for "hmacHashAlgorithm": ${encryptionParameters.hmacHashAlgorithm}`);
                    const pbkdf2Params = new PBKDF2Params({
                        salt: new OctetString({
                            valueHex: saltBuffer
                        }),
                        iterationCount: encryptionParameters.iterationCount,
                        prf: new AlgorithmIdentifier({
                            algorithmId: hmacOID,
                            algorithmParams: new Null()
                        })
                    });
                    const kekOID = getOIDByAlgorithm(encryptionParameters.keyEncryptionAlgorithm);
                    if (kekOID === "") throw new Error("Incorrect value for \"keyEncryptionAlgorithm\"");
                    const keyInfo = new PasswordRecipientinfo({
                        version: 0,
                        keyDerivationAlgorithm: new AlgorithmIdentifier({
                            algorithmId: pbkdf2OID,
                            algorithmParams: pbkdf2Params.toSchema()
                        }),
                        keyEncryptionAlgorithm: new AlgorithmIdentifier({
                            algorithmId: kekOID,
                            algorithmParams: encryptionParameters.keyEncryptionAlgorithmParams
                        }),
                        password: preDefinedData
                    });
                    this.recipientInfos.push(new RecipientInfo({
                        variant: 4,
                        value: keyInfo
                    }));
                }
                break;
            default:
                throw new Error(`Unknown value for "variant": ${variant}`);
        }
    }
    encrypt(contentEncryptionAlgorithm, contentToEncrypt) {
        let sequence = Promise.resolve();
        const ivBuffer = new ArrayBuffer(16);
        const ivView = new Uint8Array(ivBuffer);
        getRandomValues(ivView);
        const contentView = new Uint8Array(contentToEncrypt);
        let sessionKey;
        let encryptedContent;
        let exportedSessionKey;
        const recipientsPromises = [];
        const _this = this;
        const contentEncryptionOID = getOIDByAlgorithm(contentEncryptionAlgorithm);
        if (contentEncryptionOID === "") return Promise.reject("Wrong \"contentEncryptionAlgorithm\" value");
        const crypto = getCrypto();
        if (typeof crypto === "undefined") return Promise.reject("Unable to create WebCrypto object");
        sequence = sequence.then(()=>crypto.generateKey(contentEncryptionAlgorithm, true, [
                "encrypt"
            ])
        );
        sequence = sequence.then((result)=>{
            sessionKey = result;
            return crypto.encrypt({
                name: contentEncryptionAlgorithm.name,
                iv: ivView
            }, sessionKey, contentView);
        }, (error17)=>Promise.reject(error17)
        );
        sequence = sequence.then((result)=>{
            encryptedContent = result;
            return crypto.exportKey("raw", sessionKey);
        }, (error18)=>Promise.reject(error18)
        ).then((result)=>{
            exportedSessionKey = result;
            return true;
        }, (error19)=>Promise.reject(error19)
        );
        sequence = sequence.then(()=>{
            this.version = 2;
            this.encryptedContentInfo = new EncryptedContentInfo({
                contentType: "1.2.840.113549.1.7.1",
                contentEncryptionAlgorithm: new AlgorithmIdentifier({
                    algorithmId: contentEncryptionOID,
                    algorithmParams: new OctetString({
                        valueHex: ivBuffer
                    })
                }),
                encryptedContent: new OctetString({
                    valueHex: encryptedContent
                })
            });
        }, (error20)=>Promise.reject(error20)
        );
        function SubKeyAgreeRecipientInfo(index) {
            let currentSequence = Promise.resolve();
            let ecdhPublicKey;
            let ecdhPrivateKey;
            let recipientCurve;
            let recipientCurveLength;
            let exportedECDHPublicKey;
            currentSequence = currentSequence.then(()=>{
                const curveObject = _this.recipientInfos[index].value.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;
                if (curveObject instanceof ObjectIdentifier === false) return Promise.reject(`Incorrect "recipientCertificate" for index ${index}`);
                const curveOID = curveObject.valueBlock.toString();
                switch(curveOID){
                    case "1.2.840.10045.3.1.7":
                        recipientCurve = "P-256";
                        recipientCurveLength = 256;
                        break;
                    case "1.3.132.0.34":
                        recipientCurve = "P-384";
                        recipientCurveLength = 384;
                        break;
                    case "1.3.132.0.35":
                        recipientCurve = "P-521";
                        recipientCurveLength = 528;
                        break;
                    default:
                        return Promise.reject(`Incorrect curve OID for index ${index}`);
                }
                return recipientCurve;
            }, (error21)=>Promise.reject(error21)
            );
            currentSequence = currentSequence.then((result)=>crypto.generateKey({
                    name: "ECDH",
                    namedCurve: result
                }, true, [
                    "deriveBits"
                ])
            , (error22)=>Promise.reject(error22)
            );
            currentSequence = currentSequence.then((result)=>{
                ecdhPublicKey = result.publicKey;
                ecdhPrivateKey = result.privateKey;
                return crypto.exportKey("spki", ecdhPublicKey);
            }, (error23)=>Promise.reject(error23)
            );
            currentSequence = currentSequence.then((result)=>{
                exportedECDHPublicKey = result;
                return _this.recipientInfos[index].value.recipientCertificate.getPublicKey({
                    algorithm: {
                        algorithm: {
                            name: "ECDH",
                            namedCurve: recipientCurve
                        },
                        usages: []
                    }
                });
            }, (error24)=>Promise.reject(error24)
            );
            currentSequence = currentSequence.then((result)=>crypto.deriveBits({
                    name: "ECDH",
                    public: result
                }, ecdhPrivateKey, recipientCurveLength)
            , (error25)=>Promise.reject(error25)
            );
            currentSequence = currentSequence.then((result)=>{
                const aesKWAlgorithm = new AlgorithmIdentifier({
                    schema: _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams
                });
                const KWalgorithm = getAlgorithmByOID(aesKWAlgorithm.algorithmId);
                if ("name" in KWalgorithm === false) return Promise.reject(`Incorrect OID for key encryption algorithm: ${aesKWAlgorithm.algorithmId}`);
                let kwLength = KWalgorithm.length;
                const kwLengthBuffer = new ArrayBuffer(4);
                const kwLengthView = new Uint8Array(kwLengthBuffer);
                for(let j = 3; j >= 0; j--){
                    kwLengthView[j] = kwLength;
                    kwLength >>= 8;
                }
                const eccInfo = new ECCCMSSharedInfo({
                    keyInfo: new AlgorithmIdentifier({
                        algorithmId: aesKWAlgorithm.algorithmId,
                        algorithmParams: new Null()
                    }),
                    entityUInfo: _this.recipientInfos[index].value.ukm,
                    suppPubInfo: new OctetString({
                        valueHex: kwLengthBuffer
                    })
                });
                const encodedInfo = eccInfo.toSchema().toBER(false);
                const ecdhAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
                if ("name" in ecdhAlgorithm === false) return Promise.reject(`Incorrect OID for key encryption algorithm: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);
                return kdf(ecdhAlgorithm.kdf, result, KWalgorithm.length, encodedInfo);
            }, (error26)=>Promise.reject(error26)
            );
            currentSequence = currentSequence.then((result)=>crypto.importKey("raw", result, {
                    name: "AES-KW"
                }, true, [
                    "wrapKey"
                ])
            , (error27)=>Promise.reject(error27)
            );
            currentSequence = currentSequence.then((result)=>crypto.wrapKey("raw", sessionKey, result, {
                    name: "AES-KW"
                })
            , (error28)=>Promise.reject(error28)
            );
            currentSequence = currentSequence.then((result)=>{
                const asn1 = fromBER(exportedECDHPublicKey);
                const originator = new OriginatorIdentifierOrKey();
                originator.variant = 3;
                originator.value = new OriginatorPublicKey({
                    schema: asn1.result
                });
                if ("algorithmParams" in originator.value.algorithm) delete originator.value.algorithm.algorithmParams;
                _this.recipientInfos[index].value.originator = originator;
                _this.recipientInfos[index].value.recipientEncryptedKeys.encryptedKeys[0].encryptedKey = new OctetString({
                    valueHex: result
                });
            }, (error29)=>Promise.reject(error29)
            );
            return currentSequence;
        }
        function SubKeyTransRecipientInfo(index) {
            let currentSequence = Promise.resolve();
            currentSequence = currentSequence.then(()=>{
                const schema = _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams;
                const rsaOAEPParams = new RSAESOAEPParams({
                    schema
                });
                const hashAlgorithm = getAlgorithmByOID(rsaOAEPParams.hashAlgorithm.algorithmId);
                if ("name" in hashAlgorithm === false) return Promise.reject(`Incorrect OID for hash algorithm: ${rsaOAEPParams.hashAlgorithm.algorithmId}`);
                return _this.recipientInfos[index].value.recipientCertificate.getPublicKey({
                    algorithm: {
                        algorithm: {
                            name: "RSA-OAEP",
                            hash: {
                                name: hashAlgorithm.name
                            }
                        },
                        usages: [
                            "encrypt",
                            "wrapKey"
                        ]
                    }
                });
            }, (error30)=>Promise.reject(error30)
            );
            currentSequence = currentSequence.then((result)=>crypto.encrypt(result.algorithm, result, exportedSessionKey)
            , (error31)=>Promise.reject(error31)
            );
            currentSequence = currentSequence.then((result)=>{
                _this.recipientInfos[index].value.encryptedKey = new OctetString({
                    valueHex: result
                });
            }, (error32)=>Promise.reject(error32)
            );
            return currentSequence;
        }
        function SubKEKRecipientInfo(index) {
            let currentSequence = Promise.resolve();
            let kekAlgorithm;
            currentSequence = currentSequence.then(()=>{
                kekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
                if ("name" in kekAlgorithm === false) return Promise.reject(`Incorrect OID for "keyEncryptionAlgorithm": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);
                return crypto.importKey("raw", new Uint8Array(_this.recipientInfos[index].value.preDefinedKEK), kekAlgorithm, true, [
                    "wrapKey"
                ]);
            }, (error33)=>Promise.reject(error33)
            );
            currentSequence = currentSequence.then((result)=>crypto.wrapKey("raw", sessionKey, result, kekAlgorithm)
            , (error34)=>Promise.reject(error34)
            );
            currentSequence = currentSequence.then((result)=>{
                _this.recipientInfos[index].value.encryptedKey = new OctetString({
                    valueHex: result
                });
            }, (error35)=>Promise.reject(error35)
            );
            return currentSequence;
        }
        function SubPasswordRecipientinfo(index) {
            let currentSequence = Promise.resolve();
            let pbkdf2Params;
            let kekAlgorithm;
            currentSequence = currentSequence.then(()=>{
                if ("keyDerivationAlgorithm" in _this.recipientInfos[index].value === false) return Promise.reject("Please append encoded \"keyDerivationAlgorithm\"");
                if ("algorithmParams" in _this.recipientInfos[index].value.keyDerivationAlgorithm === false) return Promise.reject("Incorrectly encoded \"keyDerivationAlgorithm\"");
                try {
                    pbkdf2Params = new PBKDF2Params({
                        schema: _this.recipientInfos[index].value.keyDerivationAlgorithm.algorithmParams
                    });
                } catch (ex) {
                    return Promise.reject("Incorrectly encoded \"keyDerivationAlgorithm\"");
                }
                return Promise.resolve();
            }, (error36)=>Promise.reject(error36)
            );
            currentSequence = currentSequence.then(()=>{
                const passwordView = new Uint8Array(_this.recipientInfos[index].value.password);
                return crypto.importKey("raw", passwordView, "PBKDF2", false, [
                    "deriveKey"
                ]);
            }, (error37)=>Promise.reject(error37)
            );
            currentSequence = currentSequence.then((result)=>{
                kekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
                if ("name" in kekAlgorithm === false) return Promise.reject(`Incorrect OID for "keyEncryptionAlgorithm": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);
                let hmacHashAlgorithm = "SHA-1";
                if ("prf" in pbkdf2Params) {
                    const algorithm = getAlgorithmByOID(pbkdf2Params.prf.algorithmId);
                    if ("name" in algorithm === false) return Promise.reject("Incorrect OID for HMAC hash algorithm");
                    hmacHashAlgorithm = algorithm.hash.name;
                }
                const saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex);
                const iterations = pbkdf2Params.iterationCount;
                return crypto.deriveKey({
                    name: "PBKDF2",
                    hash: {
                        name: hmacHashAlgorithm
                    },
                    salt: saltView,
                    iterations
                }, result, kekAlgorithm, true, [
                    "wrapKey"
                ]);
            }, (error38)=>Promise.reject(error38)
            );
            currentSequence = currentSequence.then((result)=>crypto.wrapKey("raw", sessionKey, result, kekAlgorithm)
            , (error39)=>Promise.reject(error39)
            );
            currentSequence = currentSequence.then((result)=>{
                _this.recipientInfos[index].value.encryptedKey = new OctetString({
                    valueHex: result
                });
            }, (error40)=>Promise.reject(error40)
            );
            return currentSequence;
        }
        sequence = sequence.then(()=>{
            for(let i178 = 0; i178 < this.recipientInfos.length; i178++){
                let currentSequence = Promise.resolve();
                switch(this.recipientInfos[i178].variant){
                    case 1:
                        currentSequence = SubKeyTransRecipientInfo(i178);
                        break;
                    case 2:
                        currentSequence = SubKeyAgreeRecipientInfo(i178);
                        break;
                    case 3:
                        currentSequence = SubKEKRecipientInfo(i178);
                        break;
                    case 4:
                        currentSequence = SubPasswordRecipientinfo(i178);
                        break;
                    default:
                        return Promise.reject(`Uknown recipient type in array with index ${i178}`);
                }
                recipientsPromises.push(currentSequence);
            }
            return Promise.all(recipientsPromises);
        }, (error41)=>Promise.reject(error41)
        );
        return sequence;
    }
    decrypt(recipientIndex, parameters) {
        let sequence = Promise.resolve();
        const decryptionParameters = parameters || {};
        const _this = this;
        if (recipientIndex + 1 > this.recipientInfos.length) return Promise.reject(`Maximum value for "index" is: ${this.recipientInfos.length - 1}`);
        const crypto = getCrypto();
        if (typeof crypto === "undefined") return Promise.reject("Unable to create WebCrypto object");
        function SubKeyAgreeRecipientInfo(index) {
            let currentSequence = Promise.resolve();
            let recipientCurve;
            let recipientCurveLength;
            let curveOID;
            let ecdhPrivateKey;
            currentSequence = currentSequence.then(()=>{
                if ("recipientCertificate" in decryptionParameters === false) return Promise.reject("Parameter \"recipientCertificate\" is mandatory for \"KeyAgreeRecipientInfo\"");
                if ("recipientPrivateKey" in decryptionParameters === false) return Promise.reject("Parameter \"recipientPrivateKey\" is mandatory for \"KeyAgreeRecipientInfo\"");
                const curveObject = decryptionParameters.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;
                if (curveObject instanceof ObjectIdentifier === false) return Promise.reject(`Incorrect "recipientCertificate" for index ${index}`);
                curveOID = curveObject.valueBlock.toString();
                switch(curveOID){
                    case "1.2.840.10045.3.1.7":
                        recipientCurve = "P-256";
                        recipientCurveLength = 256;
                        break;
                    case "1.3.132.0.34":
                        recipientCurve = "P-384";
                        recipientCurveLength = 384;
                        break;
                    case "1.3.132.0.35":
                        recipientCurve = "P-521";
                        recipientCurveLength = 528;
                        break;
                    default:
                        return Promise.reject(`Incorrect curve OID for index ${index}`);
                }
                return crypto.importKey("pkcs8", decryptionParameters.recipientPrivateKey, {
                    name: "ECDH",
                    namedCurve: recipientCurve
                }, true, [
                    "deriveBits"
                ]);
            }, (error42)=>Promise.reject(error42)
            );
            currentSequence = currentSequence.then((result)=>{
                ecdhPrivateKey = result;
                if ("algorithmParams" in _this.recipientInfos[index].value.originator.value.algorithm === false) _this.recipientInfos[index].value.originator.value.algorithm.algorithmParams = new ObjectIdentifier({
                    value: curveOID
                });
                const buffer = _this.recipientInfos[index].value.originator.value.toSchema().toBER(false);
                return crypto.importKey("spki", buffer, {
                    name: "ECDH",
                    namedCurve: recipientCurve
                }, true, []);
            }, (error43)=>Promise.reject(error43)
            );
            currentSequence = currentSequence.then((result)=>crypto.deriveBits({
                    name: "ECDH",
                    public: result
                }, ecdhPrivateKey, recipientCurveLength)
            , (error44)=>Promise.reject(error44)
            );
            currentSequence = currentSequence.then((result)=>{
                const aesKWAlgorithm = new AlgorithmIdentifier({
                    schema: _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams
                });
                const KWalgorithm = getAlgorithmByOID(aesKWAlgorithm.algorithmId);
                if ("name" in KWalgorithm === false) return Promise.reject(`Incorrect OID for key encryption algorithm: ${aesKWAlgorithm.algorithmId}`);
                let kwLength = KWalgorithm.length;
                const kwLengthBuffer = new ArrayBuffer(4);
                const kwLengthView = new Uint8Array(kwLengthBuffer);
                for(let j = 3; j >= 0; j--){
                    kwLengthView[j] = kwLength;
                    kwLength >>= 8;
                }
                const eccInfo = new ECCCMSSharedInfo({
                    keyInfo: new AlgorithmIdentifier({
                        algorithmId: aesKWAlgorithm.algorithmId,
                        algorithmParams: new Null()
                    }),
                    entityUInfo: _this.recipientInfos[index].value.ukm,
                    suppPubInfo: new OctetString({
                        valueHex: kwLengthBuffer
                    })
                });
                const encodedInfo = eccInfo.toSchema().toBER(false);
                const ecdhAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
                if ("name" in ecdhAlgorithm === false) return Promise.reject(`Incorrect OID for key encryption algorithm: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);
                return kdf(ecdhAlgorithm.kdf, result, KWalgorithm.length, encodedInfo);
            }, (error45)=>Promise.reject(error45)
            );
            currentSequence = currentSequence.then((result)=>crypto.importKey("raw", result, {
                    name: "AES-KW"
                }, true, [
                    "unwrapKey"
                ])
            , (error46)=>Promise.reject(error46)
            );
            currentSequence = currentSequence.then((result)=>{
                const contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);
                if ("name" in contentEncryptionAlgorithm === false) return Promise.reject(`Incorrect "contentEncryptionAlgorithm": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
                return crypto.unwrapKey("raw", _this.recipientInfos[index].value.recipientEncryptedKeys.encryptedKeys[0].encryptedKey.valueBlock.valueHex, result, {
                    name: "AES-KW"
                }, contentEncryptionAlgorithm, true, [
                    "decrypt"
                ]);
            }, (error47)=>Promise.reject(error47)
            );
            return currentSequence;
        }
        function SubKeyTransRecipientInfo(index) {
            let currentSequence = Promise.resolve();
            currentSequence = currentSequence.then(()=>{
                if ("recipientPrivateKey" in decryptionParameters === false) return Promise.reject("Parameter \"recipientPrivateKey\" is mandatory for \"KeyTransRecipientInfo\"");
                const schema = _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams;
                const rsaOAEPParams = new RSAESOAEPParams({
                    schema
                });
                const hashAlgorithm = getAlgorithmByOID(rsaOAEPParams.hashAlgorithm.algorithmId);
                if ("name" in hashAlgorithm === false) return Promise.reject(`Incorrect OID for hash algorithm: ${rsaOAEPParams.hashAlgorithm.algorithmId}`);
                return crypto.importKey("pkcs8", decryptionParameters.recipientPrivateKey, {
                    name: "RSA-OAEP",
                    hash: {
                        name: hashAlgorithm.name
                    }
                }, true, [
                    "decrypt"
                ]);
            }, (error48)=>Promise.reject(error48)
            );
            currentSequence = currentSequence.then((result)=>crypto.decrypt(result.algorithm, result, _this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex)
            , (error49)=>Promise.reject(error49)
            );
            currentSequence = currentSequence.then((result)=>{
                const contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);
                if ("name" in contentEncryptionAlgorithm === false) return Promise.reject(`Incorrect "contentEncryptionAlgorithm": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
                return crypto.importKey("raw", result, contentEncryptionAlgorithm, true, [
                    "decrypt"
                ]);
            }, (error50)=>Promise.reject(error50)
            );
            return currentSequence;
        }
        function SubKEKRecipientInfo(index) {
            let currentSequence = Promise.resolve();
            let kekAlgorithm;
            currentSequence = currentSequence.then(()=>{
                if ("preDefinedData" in decryptionParameters === false) return Promise.reject("Parameter \"preDefinedData\" is mandatory for \"KEKRecipientInfo\"");
                kekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
                if ("name" in kekAlgorithm === false) return Promise.reject(`Incorrect OID for "keyEncryptionAlgorithm": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);
                return crypto.importKey("raw", decryptionParameters.preDefinedData, kekAlgorithm, true, [
                    "unwrapKey"
                ]);
            }, (error51)=>Promise.reject(error51)
            );
            currentSequence = currentSequence.then((result)=>{
                const contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);
                if ("name" in contentEncryptionAlgorithm === false) return Promise.reject(`Incorrect "contentEncryptionAlgorithm": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
                return crypto.unwrapKey("raw", _this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex, result, kekAlgorithm, contentEncryptionAlgorithm, true, [
                    "decrypt"
                ]);
            }, (error52)=>Promise.reject(error52)
            );
            return currentSequence;
        }
        function SubPasswordRecipientinfo(index) {
            let currentSequence = Promise.resolve();
            let pbkdf2Params;
            let kekAlgorithm;
            currentSequence = currentSequence.then(()=>{
                if ("preDefinedData" in decryptionParameters === false) return Promise.reject("Parameter \"preDefinedData\" is mandatory for \"KEKRecipientInfo\"");
                if ("keyDerivationAlgorithm" in _this.recipientInfos[index].value === false) return Promise.reject("Please append encoded \"keyDerivationAlgorithm\"");
                if ("algorithmParams" in _this.recipientInfos[index].value.keyDerivationAlgorithm === false) return Promise.reject("Incorrectly encoded \"keyDerivationAlgorithm\"");
                try {
                    pbkdf2Params = new PBKDF2Params({
                        schema: _this.recipientInfos[index].value.keyDerivationAlgorithm.algorithmParams
                    });
                } catch (ex) {
                    return Promise.reject("Incorrectly encoded \"keyDerivationAlgorithm\"");
                }
                return crypto.importKey("raw", decryptionParameters.preDefinedData, "PBKDF2", false, [
                    "deriveKey"
                ]);
            }, (error53)=>Promise.reject(error53)
            );
            currentSequence = currentSequence.then((result)=>{
                kekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
                if ("name" in kekAlgorithm === false) return Promise.reject(`Incorrect OID for "keyEncryptionAlgorithm": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);
                let hmacHashAlgorithm = "SHA-1";
                if ("prf" in pbkdf2Params) {
                    const algorithm = getAlgorithmByOID(pbkdf2Params.prf.algorithmId);
                    if ("name" in algorithm === false) return Promise.reject("Incorrect OID for HMAC hash algorithm");
                    hmacHashAlgorithm = algorithm.hash.name;
                }
                const saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex);
                const iterations = pbkdf2Params.iterationCount;
                return crypto.deriveKey({
                    name: "PBKDF2",
                    hash: {
                        name: hmacHashAlgorithm
                    },
                    salt: saltView,
                    iterations
                }, result, kekAlgorithm, true, [
                    "unwrapKey"
                ]);
            }, (error54)=>Promise.reject(error54)
            );
            currentSequence = currentSequence.then((result)=>{
                const contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);
                if ("name" in contentEncryptionAlgorithm === false) return Promise.reject(`Incorrect "contentEncryptionAlgorithm": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
                return crypto.unwrapKey("raw", _this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex, result, kekAlgorithm, contentEncryptionAlgorithm, true, [
                    "decrypt"
                ]);
            }, (error55)=>Promise.reject(error55)
            );
            return currentSequence;
        }
        sequence = sequence.then(()=>{
            let currentSequence = Promise.resolve();
            switch(this.recipientInfos[recipientIndex].variant){
                case 1:
                    currentSequence = SubKeyTransRecipientInfo(recipientIndex);
                    break;
                case 2:
                    currentSequence = SubKeyAgreeRecipientInfo(recipientIndex);
                    break;
                case 3:
                    currentSequence = SubKEKRecipientInfo(recipientIndex);
                    break;
                case 4:
                    currentSequence = SubPasswordRecipientinfo(recipientIndex);
                    break;
                default:
                    return Promise.reject(`Uknown recipient type in array with index ${recipientIndex}`);
            }
            return currentSequence;
        }, (error56)=>Promise.reject(error56)
        );
        sequence = sequence.then((result)=>{
            const contentEncryptionAlgorithm = getAlgorithmByOID(this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);
            if ("name" in contentEncryptionAlgorithm === false) return Promise.reject(`Incorrect "contentEncryptionAlgorithm": ${this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
            const ivBuffer = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams.valueBlock.valueHex;
            const ivView = new Uint8Array(ivBuffer);
            let dataBuffer = new ArrayBuffer(0);
            if (this.encryptedContentInfo.encryptedContent.idBlock.isConstructed === false) dataBuffer = this.encryptedContentInfo.encryptedContent.valueBlock.valueHex;
            else {
                for (const content of this.encryptedContentInfo.encryptedContent.valueBlock.value)dataBuffer = utilConcatBuf(dataBuffer, content.valueBlock.valueHex);
            }
            return crypto.decrypt({
                name: contentEncryptionAlgorithm.name,
                iv: ivView
            }, result, dataBuffer);
        }, (error57)=>Promise.reject(error57)
        );
        return sequence;
    }
}
class AuthenticatedSafe {
    constructor(parameters = {}){
        this.safeContents = getParametersValue(parameters, "safeContents", AuthenticatedSafe.defaultValues("safeContents"));
        if ("parsedValue" in parameters) this.parsedValue = getParametersValue(parameters, "parsedValue", AuthenticatedSafe.defaultValues("parsedValue"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "safeContents":
                return [];
            case "parsedValue":
                return {};
            default:
                throw new Error(`Invalid member name for AuthenticatedSafe class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "safeContents":
                return memberValue.length === 0;
            case "parsedValue":
                return memberValue instanceof Object && Object.keys(memberValue).length === 0;
            default:
                throw new Error(`Invalid member name for AuthenticatedSafe class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Repeated({
                    name: names.contentInfos || "",
                    value: ContentInfo.schema()
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "contentInfos"
        ]);
        const asn1 = compareSchema(schema, schema, AuthenticatedSafe.schema({
            names: {
                contentInfos: "contentInfos"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for AuthenticatedSafe");
        this.safeContents = Array.from(asn1.result.contentInfos, (element)=>new ContentInfo({
                schema: element
            })
        );
    }
    toSchema() {
        return new Sequence({
            value: Array.from(this.safeContents, (element)=>element.toSchema()
            )
        });
    }
    toJSON() {
        return {
            safeContents: Array.from(this.safeContents, (element)=>element.toJSON()
            )
        };
    }
    parseInternalValues(parameters) {
        if (parameters instanceof Object === false) return Promise.reject("The \"parameters\" must has \"Object\" type");
        if ("safeContents" in parameters === false) return Promise.reject("Absent mandatory parameter \"safeContents\"");
        if (parameters.safeContents instanceof Array === false) return Promise.reject("The \"parameters.safeContents\" must has \"Array\" type");
        if (parameters.safeContents.length !== this.safeContents.length) return Promise.reject("Length of \"parameters.safeContents\" must be equal to \"this.safeContents.length\"");
        let sequence = Promise.resolve();
        this.parsedValue = {
            safeContents: []
        };
        for (const [index, content] of this.safeContents.entries()){
            switch(content.contentType){
                case "1.2.840.113549.1.7.1":
                    {
                        if (content.content instanceof OctetString === false) return Promise.reject("Wrong type of \"this.safeContents[j].content\"");
                        let authSafeContent = new ArrayBuffer(0);
                        if (content.content.valueBlock.isConstructed) {
                            for (const contentValue of content.content.valueBlock.value)authSafeContent = utilConcatBuf(authSafeContent, contentValue.valueBlock.valueHex);
                        } else authSafeContent = content.content.valueBlock.valueHex;
                        const asn1 = fromBER(authSafeContent);
                        if (asn1.offset === -1) return Promise.reject("Error during parsing of ASN.1 data inside \"content.content\"");
                        this.parsedValue.safeContents.push({
                            privacyMode: 0,
                            value: new SafeContents({
                                schema: asn1.result
                            })
                        });
                    }
                    break;
                case "1.2.840.113549.1.7.3":
                    {
                        const cmsEnveloped = new EnvelopedData({
                            schema: content.content
                        });
                        if ("recipientCertificate" in parameters.safeContents[index] === false) return Promise.reject("Absent mandatory parameter \"recipientCertificate\" in \"parameters.safeContents[j]\"");
                        const recipientCertificate = parameters.safeContents[index].recipientCertificate;
                        if ("recipientKey" in parameters.safeContents[index] === false) return Promise.reject("Absent mandatory parameter \"recipientKey\" in \"parameters.safeContents[j]\"");
                        const recipientKey = parameters.safeContents[index].recipientKey;
                        sequence = sequence.then(()=>cmsEnveloped.decrypt(0, {
                                recipientCertificate,
                                recipientPrivateKey: recipientKey
                            })
                        );
                        sequence = sequence.then((result)=>{
                            const asn1 = fromBER(result);
                            if (asn1.offset === -1) return Promise.reject("Error during parsing of decrypted data");
                            this.parsedValue.safeContents.push({
                                privacyMode: 2,
                                value: new SafeContents({
                                    schema: asn1.result
                                })
                            });
                            return Promise.resolve();
                        });
                    }
                    break;
                case "1.2.840.113549.1.7.6":
                    {
                        const cmsEncrypted = new EncryptedData({
                            schema: content.content
                        });
                        if ("password" in parameters.safeContents[index] === false) return Promise.reject("Absent mandatory parameter \"password\" in \"parameters.safeContents[j]\"");
                        const password = parameters.safeContents[index].password;
                        sequence = sequence.then(()=>cmsEncrypted.decrypt({
                                password
                            })
                        , (error58)=>Promise.reject(error58)
                        );
                        sequence = sequence.then((result)=>{
                            const asn1 = fromBER(result);
                            if (asn1.offset === -1) return Promise.reject("Error during parsing of decrypted data");
                            this.parsedValue.safeContents.push({
                                privacyMode: 1,
                                value: new SafeContents({
                                    schema: asn1.result
                                })
                            });
                            return Promise.resolve();
                        }, (error59)=>Promise.reject(error59)
                        );
                    }
                    break;
                default:
                    throw new Error(`Unknown "contentType" for AuthenticatedSafe: " ${content.contentType}`);
            }
        }
        return sequence;
    }
    makeInternalValues(parameters) {
        if ("parsedValue" in this === false) return Promise.reject("Please run \"parseValues\" first or add \"parsedValue\" manually");
        if (this.parsedValue instanceof Object === false) return Promise.reject("The \"this.parsedValue\" must has \"Object\" type");
        if (this.parsedValue.safeContents instanceof Array === false) return Promise.reject("The \"this.parsedValue.safeContents\" must has \"Array\" type");
        if (parameters instanceof Object === false) return Promise.reject("The \"parameters\" must has \"Object\" type");
        if ("safeContents" in parameters === false) return Promise.reject("Absent mandatory parameter \"safeContents\"");
        if (parameters.safeContents instanceof Array === false) return Promise.reject("The \"parameters.safeContents\" must has \"Array\" type");
        if (parameters.safeContents.length !== this.parsedValue.safeContents.length) return Promise.reject("Length of \"parameters.safeContents\" must be equal to \"this.parsedValue.safeContents\"");
        let sequence = Promise.resolve();
        this.safeContents = [];
        for (const [index, content] of this.parsedValue.safeContents.entries()){
            if ("privacyMode" in content === false) return Promise.reject("The \"privacyMode\" is a mandatory parameter for \"content\"");
            if ("value" in content === false) return Promise.reject("The \"value\" is a mandatory parameter for \"content\"");
            if (content.value instanceof SafeContents === false) return Promise.reject("The \"content.value\" must has \"SafeContents\" type");
            switch(content.privacyMode){
                case 0:
                    {
                        const contentBuffer = content.value.toSchema().toBER(false);
                        sequence = sequence.then(()=>{
                            this.safeContents.push(new ContentInfo({
                                contentType: "1.2.840.113549.1.7.1",
                                content: new OctetString({
                                    valueHex: contentBuffer
                                })
                            }));
                        });
                    }
                    break;
                case 1:
                    {
                        const cmsEncrypted = new EncryptedData();
                        const currentParameters = parameters.safeContents[index];
                        currentParameters.contentToEncrypt = content.value.toSchema().toBER(false);
                        sequence = sequence.then(()=>cmsEncrypted.encrypt(currentParameters)
                        , (error60)=>Promise.reject(error60)
                        );
                        sequence = sequence.then(()=>{
                            this.safeContents.push(new ContentInfo({
                                contentType: "1.2.840.113549.1.7.6",
                                content: cmsEncrypted.toSchema()
                            }));
                        }, (error61)=>Promise.reject(error61)
                        );
                    }
                    break;
                case 2:
                    {
                        const cmsEnveloped = new EnvelopedData();
                        const contentToEncrypt = content.value.toSchema().toBER(false);
                        if ("encryptingCertificate" in parameters.safeContents[index] === false) return Promise.reject("Absent mandatory parameter \"encryptingCertificate\" in \"parameters.safeContents[i]\"");
                        if ("encryptionAlgorithm" in parameters.safeContents[index] === false) return Promise.reject("Absent mandatory parameter \"encryptionAlgorithm\" in \"parameters.safeContents[i]\"");
                        switch(true){
                            case parameters.safeContents[index].encryptionAlgorithm.name.toLowerCase() === "aes-cbc":
                            case parameters.safeContents[index].encryptionAlgorithm.name.toLowerCase() === "aes-gcm":
                                break;
                            default:
                                return Promise.reject(`Incorrect parameter "encryptionAlgorithm" in "parameters.safeContents[i]": ${parameters.safeContents[index].encryptionAlgorithm}`);
                        }
                        switch(true){
                            case parameters.safeContents[index].encryptionAlgorithm.length === 128:
                            case parameters.safeContents[index].encryptionAlgorithm.length === 192:
                            case parameters.safeContents[index].encryptionAlgorithm.length === 256:
                                break;
                            default:
                                return Promise.reject(`Incorrect parameter "encryptionAlgorithm.length" in "parameters.safeContents[i]": ${parameters.safeContents[index].encryptionAlgorithm.length}`);
                        }
                        const encryptionAlgorithm = parameters.safeContents[index].encryptionAlgorithm;
                        cmsEnveloped.addRecipientByCertificate(parameters.safeContents[index].encryptingCertificate);
                        sequence = sequence.then(()=>cmsEnveloped.encrypt(encryptionAlgorithm, contentToEncrypt)
                        );
                        sequence = sequence.then(()=>{
                            this.safeContents.push(new ContentInfo({
                                contentType: "1.2.840.113549.1.7.3",
                                content: cmsEnveloped.toSchema()
                            }));
                        });
                    }
                    break;
                default:
                    return Promise.reject(`Incorrect value for "content.privacyMode": ${content.privacyMode}`);
            }
        }
        return sequence.then(()=>this
        , (error62)=>Promise.reject(`Error during parsing: ${error62}`)
        );
    }
}
class CertID {
    constructor(parameters = {}){
        this.hashAlgorithm = getParametersValue(parameters, "hashAlgorithm", CertID.defaultValues("hashAlgorithm"));
        this.issuerNameHash = getParametersValue(parameters, "issuerNameHash", CertID.defaultValues("issuerNameHash"));
        this.issuerKeyHash = getParametersValue(parameters, "issuerKeyHash", CertID.defaultValues("issuerKeyHash"));
        this.serialNumber = getParametersValue(parameters, "serialNumber", CertID.defaultValues("serialNumber"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "hashAlgorithm":
                return new AlgorithmIdentifier();
            case "issuerNameHash":
            case "issuerKeyHash":
                return new OctetString();
            case "serialNumber":
                return new Integer();
            default:
                throw new Error(`Invalid member name for CertID class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "hashAlgorithm":
                return memberValue.algorithmId === "" && "algorithmParams" in memberValue === false;
            case "issuerNameHash":
            case "issuerKeyHash":
            case "serialNumber":
                return memberValue.isEqual(CertID.defaultValues(memberName));
            default:
                throw new Error(`Invalid member name for CertID class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                AlgorithmIdentifier.schema(names.hashAlgorithmObject || {
                    names: {
                        blockName: names.hashAlgorithm || ""
                    }
                }),
                new OctetString({
                    name: names.issuerNameHash || ""
                }),
                new OctetString({
                    name: names.issuerKeyHash || ""
                }),
                new Integer({
                    name: names.serialNumber || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "hashAlgorithm",
            "issuerNameHash",
            "issuerKeyHash",
            "serialNumber"
        ]);
        const asn1 = compareSchema(schema, schema, CertID.schema({
            names: {
                hashAlgorithm: "hashAlgorithm",
                issuerNameHash: "issuerNameHash",
                issuerKeyHash: "issuerKeyHash",
                serialNumber: "serialNumber"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for CertID");
        this.hashAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result.hashAlgorithm
        });
        this.issuerNameHash = asn1.result.issuerNameHash;
        this.issuerKeyHash = asn1.result.issuerKeyHash;
        this.serialNumber = asn1.result.serialNumber;
    }
    toSchema() {
        return new Sequence({
            value: [
                this.hashAlgorithm.toSchema(),
                this.issuerNameHash,
                this.issuerKeyHash,
                this.serialNumber
            ]
        });
    }
    toJSON() {
        return {
            hashAlgorithm: this.hashAlgorithm.toJSON(),
            issuerNameHash: this.issuerNameHash.toJSON(),
            issuerKeyHash: this.issuerKeyHash.toJSON(),
            serialNumber: this.serialNumber.toJSON()
        };
    }
    isEqual(certificateID) {
        if (!this.hashAlgorithm.algorithmId === certificateID.hashAlgorithm.algorithmId) return false;
        if (isEqualBuffer(this.issuerNameHash.valueBlock.valueHex, certificateID.issuerNameHash.valueBlock.valueHex) === false) return false;
        if (isEqualBuffer(this.issuerKeyHash.valueBlock.valueHex, certificateID.issuerKeyHash.valueBlock.valueHex) === false) return false;
        if (!this.serialNumber.isEqual(certificateID.serialNumber)) return false;
        return true;
    }
    createForCertificate(certificate, parameters) {
        let sequence = Promise.resolve();
        let issuerCertificate;
        const crypto = getCrypto();
        if (typeof crypto === "undefined") return Promise.reject("Unable to create WebCrypto object");
        if ("hashAlgorithm" in parameters === false) return Promise.reject("Parameter \"hashAlgorithm\" is mandatory for \"OCSP_REQUEST.createForCertificate\"");
        const hashOID = getOIDByAlgorithm({
            name: parameters.hashAlgorithm
        });
        if (hashOID === "") return Promise.reject(`Incorrect "hashAlgorithm": ${this.hashAlgorithm}`);
        this.hashAlgorithm = new AlgorithmIdentifier({
            algorithmId: hashOID,
            algorithmParams: new Null()
        });
        if ("issuerCertificate" in parameters) issuerCertificate = parameters.issuerCertificate;
        else return Promise.reject("Parameter \"issuerCertificate\" is mandatory for \"OCSP_REQUEST.createForCertificate\"");
        this.serialNumber = certificate.serialNumber;
        sequence = sequence.then(()=>crypto.digest({
                name: parameters.hashAlgorithm
            }, issuerCertificate.subject.toSchema().toBER(false))
        , (error63)=>Promise.reject(error63)
        );
        sequence = sequence.then((result)=>{
            this.issuerNameHash = new OctetString({
                valueHex: result
            });
            const issuerKeyBuffer = issuerCertificate.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex;
            return crypto.digest({
                name: parameters.hashAlgorithm
            }, issuerKeyBuffer);
        }, (error64)=>Promise.reject(error64)
        ).then((result)=>{
            this.issuerKeyHash = new OctetString({
                valueHex: result
            });
        }, (error65)=>Promise.reject(error65)
        );
        return sequence;
    }
}
class SingleResponse {
    constructor(parameters = {}){
        this.certID = getParametersValue(parameters, "certID", SingleResponse.defaultValues("certID"));
        this.certStatus = getParametersValue(parameters, "certStatus", SingleResponse.defaultValues("certStatus"));
        this.thisUpdate = getParametersValue(parameters, "thisUpdate", SingleResponse.defaultValues("thisUpdate"));
        if ("nextUpdate" in parameters) this.nextUpdate = getParametersValue(parameters, "nextUpdate", SingleResponse.defaultValues("nextUpdate"));
        if ("singleExtensions" in parameters) this.singleExtensions = getParametersValue(parameters, "singleExtensions", SingleResponse.defaultValues("singleExtensions"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "certID":
                return new CertID();
            case "certStatus":
                return {};
            case "thisUpdate":
            case "nextUpdate":
                return new Date(0, 0, 0);
            case "singleExtensions":
                return [];
            default:
                throw new Error(`Invalid member name for SingleResponse class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "certID":
                return CertID.compareWithDefault("hashAlgorithm", memberValue.hashAlgorithm) && CertID.compareWithDefault("issuerNameHash", memberValue.issuerNameHash) && CertID.compareWithDefault("issuerKeyHash", memberValue.issuerKeyHash) && CertID.compareWithDefault("serialNumber", memberValue.serialNumber);
            case "certStatus":
                return Object.keys(memberValue).length === 0;
            case "thisUpdate":
            case "nextUpdate":
                return memberValue === SingleResponse.defaultValues(memberName);
            default:
                throw new Error(`Invalid member name for SingleResponse class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                CertID.schema(names.certID || {}),
                new Choice({
                    value: [
                        new Primitive({
                            name: names.certStatus || "",
                            idBlock: {
                                tagClass: 3,
                                tagNumber: 0
                            },
                            lenBlockLength: 1
                        }),
                        new Constructed({
                            name: names.certStatus || "",
                            idBlock: {
                                tagClass: 3,
                                tagNumber: 1
                            },
                            value: [
                                new GeneralizedTime(),
                                new Constructed({
                                    optional: true,
                                    idBlock: {
                                        tagClass: 3,
                                        tagNumber: 0
                                    },
                                    value: [
                                        new Enumerated()
                                    ]
                                })
                            ]
                        }),
                        new Primitive({
                            name: names.certStatus || "",
                            idBlock: {
                                tagClass: 3,
                                tagNumber: 2
                            },
                            lenBlock: {
                                length: 1
                            }
                        })
                    ]
                }),
                new GeneralizedTime({
                    name: names.thisUpdate || ""
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new GeneralizedTime({
                            name: names.nextUpdate || ""
                        })
                    ]
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: [
                        Extensions.schema(names.singleExtensions || {})
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "certID",
            "certStatus",
            "thisUpdate",
            "nextUpdate",
            "singleExtensions"
        ]);
        const asn1 = compareSchema(schema, schema, SingleResponse.schema({
            names: {
                certID: {
                    names: {
                        blockName: "certID"
                    }
                },
                certStatus: "certStatus",
                thisUpdate: "thisUpdate",
                nextUpdate: "nextUpdate",
                singleExtensions: {
                    names: {
                        blockName: "singleExtensions"
                    }
                }
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for SingleResponse");
        this.certID = new CertID({
            schema: asn1.result.certID
        });
        this.certStatus = asn1.result.certStatus;
        this.thisUpdate = asn1.result.thisUpdate.toDate();
        if ("nextUpdate" in asn1.result) this.nextUpdate = asn1.result.nextUpdate.toDate();
        if ("singleExtensions" in asn1.result) this.singleExtensions = Array.from(asn1.result.singleExtensions.valueBlock.value, (element)=>new Extension({
                schema: element
            })
        );
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(this.certID.toSchema());
        outputArray.push(this.certStatus);
        outputArray.push(new GeneralizedTime({
            valueDate: this.thisUpdate
        }));
        if ("nextUpdate" in this) outputArray.push(new GeneralizedTime({
            valueDate: this.nextUpdate
        }));
        if ("singleExtensions" in this) {
            outputArray.push(new Sequence({
                value: Array.from(this.singleExtensions, (element)=>element.toSchema()
                )
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const _object = {
            certID: this.certID.toJSON(),
            certStatus: this.certStatus.toJSON(),
            thisUpdate: this.thisUpdate
        };
        if ("nextUpdate" in this) _object.nextUpdate = this.nextUpdate;
        if ("singleExtensions" in this) _object.singleExtensions = Array.from(this.singleExtensions, (element)=>element.toJSON()
        );
        return _object;
    }
}
class ResponseData {
    constructor(parameters = {}){
        this.tbs = getParametersValue(parameters, "tbs", ResponseData.defaultValues("tbs"));
        this.responderID = getParametersValue(parameters, "responderID", ResponseData.defaultValues("responderID"));
        this.producedAt = getParametersValue(parameters, "producedAt", ResponseData.defaultValues("producedAt"));
        this.responses = getParametersValue(parameters, "responses", ResponseData.defaultValues("responses"));
        if ("responseExtensions" in parameters) this.responseExtensions = getParametersValue(parameters, "responseExtensions", ResponseData.defaultValues("responseExtensions"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "tbs":
                return new ArrayBuffer(0);
            case "responderID":
                return {};
            case "producedAt":
                return new Date(0, 0, 0);
            case "responses":
            case "responseExtensions":
                return [];
            default:
                throw new Error(`Invalid member name for ResponseData class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "tbs":
                return memberValue.byteLength === 0;
            case "responderID":
                return Object.keys(memberValue).length === 0;
            case "producedAt":
                return memberValue === ResponseData.defaultValues(memberName);
            case "responses":
            case "responseExtensions":
                return memberValue.length === 0;
            default:
                throw new Error(`Invalid member name for ResponseData class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "ResponseData",
            value: [
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Integer({
                            name: names.version || "ResponseData.version"
                        })
                    ]
                }),
                new Choice({
                    value: [
                        new Constructed({
                            name: names.responderID || "ResponseData.responderID",
                            idBlock: {
                                tagClass: 3,
                                tagNumber: 1
                            },
                            value: [
                                RelativeDistinguishedNames.schema(names.ResponseDataByName || {
                                    names: {
                                        blockName: "ResponseData.byName"
                                    }
                                })
                            ]
                        }),
                        new Constructed({
                            name: names.responderID || "ResponseData.responderID",
                            idBlock: {
                                tagClass: 3,
                                tagNumber: 2
                            },
                            value: [
                                new OctetString({
                                    name: names.ResponseDataByKey || "ResponseData.byKey"
                                })
                            ]
                        })
                    ]
                }),
                new GeneralizedTime({
                    name: names.producedAt || "ResponseData.producedAt"
                }),
                new Sequence({
                    value: [
                        new Repeated({
                            name: "ResponseData.responses",
                            value: SingleResponse.schema(names.response || {})
                        })
                    ]
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: [
                        Extensions.schema(names.extensions || {
                            names: {
                                blockName: "ResponseData.responseExtensions"
                            }
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "ResponseData",
            "ResponseData.version",
            "ResponseData.responderID",
            "ResponseData.producedAt",
            "ResponseData.responses",
            "ResponseData.responseExtensions"
        ]);
        const asn1 = compareSchema(schema, schema, ResponseData.schema());
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for ResponseData");
        this.tbs = asn1.result.ResponseData.valueBeforeDecode;
        if ("ResponseData.version" in asn1.result) this.version = asn1.result["ResponseData.version"].valueBlock.valueDec;
        if (asn1.result["ResponseData.responderID"].idBlock.tagNumber === 1) this.responderID = new RelativeDistinguishedNames({
            schema: asn1.result["ResponseData.responderID"].valueBlock.value[0]
        });
        else this.responderID = asn1.result["ResponseData.responderID"].valueBlock.value[0];
        this.producedAt = asn1.result["ResponseData.producedAt"].toDate();
        this.responses = Array.from(asn1.result["ResponseData.responses"], (element)=>new SingleResponse({
                schema: element
            })
        );
        if ("ResponseData.responseExtensions" in asn1.result) this.responseExtensions = Array.from(asn1.result["ResponseData.responseExtensions"].valueBlock.value, (element)=>new Extension({
                schema: element
            })
        );
    }
    toSchema(encodeFlag = false) {
        let tbsSchema;
        if (encodeFlag === false) {
            if (this.tbs.length === 0) return ResponseData.schema();
            tbsSchema = fromBER(this.tbs).result;
        } else {
            const outputArray = [];
            if ("version" in this) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Integer({
                            value: this.version
                        })
                    ]
                }));
            }
            if (this.responderID instanceof RelativeDistinguishedNames) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: [
                        this.responderID.toSchema()
                    ]
                }));
            } else {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 2
                    },
                    value: [
                        this.responderID
                    ]
                }));
            }
            outputArray.push(new GeneralizedTime({
                valueDate: this.producedAt
            }));
            outputArray.push(new Sequence({
                value: Array.from(this.responses, (element)=>element.toSchema()
                )
            }));
            if ("responseExtensions" in this) {
                outputArray.push(new Sequence({
                    value: Array.from(this.responseExtensions, (element)=>element.toSchema()
                    )
                }));
            }
            tbsSchema = new Sequence({
                value: outputArray
            });
        }
        return tbsSchema;
    }
    toJSON() {
        const _object = {};
        if ("version" in this) _object.version = this.version;
        if ("responderID" in this) _object.responderID = this.responderID;
        if ("producedAt" in this) _object.producedAt = this.producedAt;
        if ("responses" in this) _object.responses = Array.from(this.responses, (element)=>element.toJSON()
        );
        if ("responseExtensions" in this) _object.responseExtensions = Array.from(this.responseExtensions, (element)=>element.toJSON()
        );
        return _object;
    }
}
class CertificateChainValidationEngine {
    constructor(parameters = {}){
        this.trustedCerts = getParametersValue(parameters, "trustedCerts", this.defaultValues("trustedCerts"));
        this.certs = getParametersValue(parameters, "certs", this.defaultValues("certs"));
        this.crls = getParametersValue(parameters, "crls", this.defaultValues("crls"));
        this.ocsps = getParametersValue(parameters, "ocsps", this.defaultValues("ocsps"));
        this.checkDate = getParametersValue(parameters, "checkDate", this.defaultValues("checkDate"));
        this.findOrigin = getParametersValue(parameters, "findOrigin", this.defaultValues("findOrigin"));
        this.findIssuer = getParametersValue(parameters, "findIssuer", this.defaultValues("findIssuer"));
    }
    static defaultFindOrigin(certificate, validationEngine) {
        if (certificate.tbs.byteLength === 0) certificate.tbs = certificate.encodeTBS();
        for (const localCert of validationEngine.certs){
            if (localCert.tbs.byteLength === 0) localCert.tbs = localCert.encodeTBS();
            if (isEqualBuffer(certificate.tbs, localCert.tbs)) return "Intermediate Certificates";
        }
        for (const trustedCert of validationEngine.trustedCerts){
            if (trustedCert.tbs.byteLength === 0) trustedCert.tbs = trustedCert.encodeTBS();
            if (isEqualBuffer(certificate.tbs, trustedCert.tbs)) return "Trusted Certificates";
        }
        return "Unknown";
    }
    async defaultFindIssuer(certificate, validationEngine) {
        let result = [];
        let keyIdentifier = null;
        let authorityCertIssuer = null;
        let authorityCertSerialNumber = null;
        if (certificate.subject.isEqual(certificate.issuer)) {
            try {
                const verificationResult = await certificate.verify();
                if (verificationResult === true) return [
                    certificate
                ];
            } catch (ex) {}
        }
        if ("extensions" in certificate) {
            for (const extension of certificate.extensions){
                if (extension.extnID === "2.5.29.35") {
                    if ("keyIdentifier" in extension.parsedValue) keyIdentifier = extension.parsedValue.keyIdentifier;
                    else {
                        if ("authorityCertIssuer" in extension.parsedValue) authorityCertIssuer = extension.parsedValue.authorityCertIssuer;
                        if ("authorityCertSerialNumber" in extension.parsedValue) authorityCertSerialNumber = extension.parsedValue.authorityCertSerialNumber;
                    }
                    break;
                }
            }
        }
        function checkCertificate(possibleIssuer) {
            if (keyIdentifier !== null) {
                if ("extensions" in possibleIssuer) {
                    let extensionFound = false;
                    for (const extension of possibleIssuer.extensions){
                        if (extension.extnID === "2.5.29.14") {
                            extensionFound = true;
                            if (isEqualBuffer(extension.parsedValue.valueBlock.valueHex, keyIdentifier.valueBlock.valueHex)) result.push(possibleIssuer);
                            break;
                        }
                    }
                    if (extensionFound) return;
                }
            }
            let authorityCertSerialNumberEqual = false;
            if (authorityCertSerialNumber !== null) authorityCertSerialNumberEqual = possibleIssuer.serialNumber.isEqual(authorityCertSerialNumber);
            if (authorityCertIssuer !== null) {
                if (possibleIssuer.subject.isEqual(authorityCertIssuer)) {
                    if (authorityCertSerialNumberEqual) result.push(possibleIssuer);
                }
            } else {
                if (certificate.issuer.isEqual(possibleIssuer.subject)) result.push(possibleIssuer);
            }
        }
        for (const trustedCert of validationEngine.trustedCerts)checkCertificate(trustedCert);
        for (const intermediateCert of validationEngine.certs)checkCertificate(intermediateCert);
        for(let i179 = 0; i179 < result.length; i179++){
            try {
                const verificationResult = await certificate.verify(result[i179]);
                if (verificationResult === false) result.splice(i179, 1);
            } catch (ex) {
                result.splice(i179, 1);
            }
        }
        return result;
    }
    defaultValues(memberName) {
        switch(memberName){
            case "trustedCerts":
                return [];
            case "certs":
                return [];
            case "crls":
                return [];
            case "ocsps":
                return [];
            case "checkDate":
                return new Date();
            case "findOrigin":
                return CertificateChainValidationEngine.defaultFindOrigin;
            case "findIssuer":
                return this.defaultFindIssuer;
            default:
                throw new Error(`Invalid member name for CertificateChainValidationEngine class: ${memberName}`);
        }
    }
    async sort() {
        const localCerts = [];
        const _this = this;
        async function buildPath(certificate) {
            const result = [];
            function checkUnique(array) {
                let unique = true;
                for(let i180 = 0; i180 < array.length; i180++){
                    for(let j = 0; j < array.length; j++){
                        if (j === i180) continue;
                        if (array[i180] === array[j]) {
                            unique = false;
                            break;
                        }
                    }
                    if (!unique) break;
                }
                return unique;
            }
            const findIssuerResult = await _this.findIssuer(certificate, _this);
            if (findIssuerResult.length === 0) throw new Error("No valid certificate paths found");
            for(let i5 = 0; i5 < findIssuerResult.length; i5++){
                if (isEqualBuffer(findIssuerResult[i5].tbs, certificate.tbs)) {
                    result.push([
                        findIssuerResult[i5]
                    ]);
                    continue;
                }
                const buildPathResult = await buildPath(findIssuerResult[i5]);
                for(let j = 0; j < buildPathResult.length; j++){
                    const copy1 = buildPathResult[j].slice();
                    copy1.splice(0, 0, findIssuerResult[i5]);
                    if (checkUnique(copy1)) result.push(copy1);
                    else result.push(buildPathResult[j]);
                }
            }
            return result;
        }
        async function findCRL(certificate) {
            const issuerCertificates = [];
            const crls = [];
            const crlsAndCertificates = [];
            issuerCertificates.push(...localCerts.filter((element)=>certificate.issuer.isEqual(element.subject)
            ));
            if (issuerCertificates.length === 0) {
                return {
                    status: 1,
                    statusMessage: "No certificate's issuers"
                };
            }
            crls.push(..._this.crls.filter((element)=>element.issuer.isEqual(certificate.issuer)
            ));
            if (crls.length === 0) {
                return {
                    status: 1,
                    statusMessage: "No CRLs for specific certificate issuer"
                };
            }
            for(let i181 = 0; i181 < crls.length; i181++){
                if (crls[i181].nextUpdate.value < _this.checkDate) continue;
                for(let j = 0; j < issuerCertificates.length; j++){
                    try {
                        const result = await crls[i181].verify({
                            issuerCertificate: issuerCertificates[j]
                        });
                        if (result) {
                            crlsAndCertificates.push({
                                crl: crls[i181],
                                certificate: issuerCertificates[j]
                            });
                            break;
                        }
                    } catch (ex) {}
                }
            }
            if (crlsAndCertificates.length) {
                return {
                    status: 0,
                    statusMessage: "",
                    result: crlsAndCertificates
                };
            }
            return {
                status: 1,
                statusMessage: "No valid CRLs found"
            };
        }
        async function findOCSP(certificate, issuerCertificate) {
            const hashAlgorithm = getAlgorithmByOID(certificate.signatureAlgorithm.algorithmId);
            if ("name" in hashAlgorithm === false) return 1;
            if ("hash" in hashAlgorithm === false) return 1;
            for(let i182 = 0; i182 < _this.ocsps.length; i182++){
                const result = await _this.ocsps[i182].getCertificateStatus(certificate, issuerCertificate);
                if (result.isForCertificate) {
                    if (result.status === 0) return 0;
                    return 1;
                }
            }
            return 2;
        }
        async function checkForCA(certificate, needToCheckCRL = false) {
            let isCA = false;
            let mustBeCA = false;
            let keyUsagePresent = false;
            let cRLSign = false;
            if ("extensions" in certificate) {
                for(let j = 0; j < certificate.extensions.length; j++){
                    if (certificate.extensions[j].critical === true && "parsedValue" in certificate.extensions[j] === false) {
                        return {
                            result: false,
                            resultCode: 6,
                            resultMessage: `Unable to parse critical certificate extension: ${certificate.extensions[j].extnID}`
                        };
                    }
                    if (certificate.extensions[j].extnID === "2.5.29.15") {
                        keyUsagePresent = true;
                        const view = new Uint8Array(certificate.extensions[j].parsedValue.valueBlock.valueHex);
                        if ((view[0] & 0x04) === 0x04) mustBeCA = true;
                        if ((view[0] & 0x02) === 0x02) cRLSign = true;
                    }
                    if (certificate.extensions[j].extnID === "2.5.29.19") {
                        if ("cA" in certificate.extensions[j].parsedValue) {
                            if (certificate.extensions[j].parsedValue.cA === true) isCA = true;
                        }
                    }
                }
                if (mustBeCA === true && isCA === false) {
                    return {
                        result: false,
                        resultCode: 3,
                        resultMessage: "Unable to build certificate chain - using \"keyCertSign\" flag set without BasicConstaints"
                    };
                }
                if (keyUsagePresent === true && isCA === true && mustBeCA === false) {
                    return {
                        result: false,
                        resultCode: 4,
                        resultMessage: "Unable to build certificate chain - \"keyCertSign\" flag was not set"
                    };
                }
                if (isCA === true && keyUsagePresent === true && needToCheckCRL && cRLSign === false) {
                    return {
                        result: false,
                        resultCode: 5,
                        resultMessage: "Unable to build certificate chain - intermediate certificate must have \"cRLSign\" key usage flag"
                    };
                }
            }
            if (isCA === false) {
                return {
                    result: false,
                    resultCode: 7,
                    resultMessage: "Unable to build certificate chain - more than one possible end-user certificate"
                };
            }
            return {
                result: true,
                resultCode: 0,
                resultMessage: ""
            };
        }
        async function basicCheck(path26, checkDate) {
            for(let i183 = 0; i183 < path26.length; i183++){
                if (path26[i183].notBefore.value > checkDate || path26[i183].notAfter.value < checkDate) {
                    return {
                        result: false,
                        resultCode: 8,
                        resultMessage: "The certificate is either not yet valid or expired"
                    };
                }
            }
            if (path26.length < 2) {
                return {
                    result: false,
                    resultCode: 9,
                    resultMessage: "Too short certificate path"
                };
            }
            for(let i6 = path26.length - 2; i6 >= 0; i6--){
                if (path26[i6].issuer.isEqual(path26[i6].subject) === false) {
                    if (path26[i6].issuer.isEqual(path26[i6 + 1].subject) === false) {
                        return {
                            result: false,
                            resultCode: 10,
                            resultMessage: "Incorrect name chaining"
                        };
                    }
                }
            }
            if (_this.crls.length !== 0 || _this.ocsps.length !== 0) {
                for(let i184 = 0; i184 < path26.length - 2; i184++){
                    let ocspResult;
                    let crlResult;
                    if (_this.ocsps.length !== 0) {
                        ocspResult = await findOCSP(path26[i184], path26[i184 + 1]);
                        switch(ocspResult){
                            case 0:
                                continue;
                            case 1:
                                return {
                                    result: false,
                                    resultCode: 12,
                                    resultMessage: "One of certificates was revoked via OCSP response"
                                };
                            case 2:
                                break;
                            default:
                        }
                    }
                    if (_this.crls.length !== 0) {
                        crlResult = await findCRL(path26[i184]);
                        if (crlResult.status) {
                            throw {
                                result: false,
                                resultCode: 11,
                                resultMessage: `No revocation values found for one of certificates: ${crlResult.statusMessage}`
                            };
                        }
                        for(let j = 0; j < crlResult.result.length; j++){
                            const isCertificateRevoked = crlResult.result[j].crl.isCertificateRevoked(path26[i184]);
                            if (isCertificateRevoked) {
                                return {
                                    result: false,
                                    resultCode: 12,
                                    resultMessage: "One of certificates had been revoked"
                                };
                            }
                            const isCertificateCA = await checkForCA(crlResult.result[j].certificate, true);
                            if (isCertificateCA.result === false) {
                                return {
                                    result: false,
                                    resultCode: 13,
                                    resultMessage: "CRL issuer certificate is not a CA certificate or does not have crlSign flag"
                                };
                            }
                        }
                    } else {
                        if (ocspResult === 2) {
                            return {
                                result: false,
                                resultCode: 11,
                                resultMessage: "No revocation values found for one of certificates"
                            };
                        }
                    }
                }
            }
            for(let i7 = 1; i7 < path26.length; i7++){
                const result = await checkForCA(path26[i7]);
                if (result.result === false) {
                    return {
                        result: false,
                        resultCode: 14,
                        resultMessage: "One of intermediate certificates is not a CA certificate"
                    };
                }
            }
            return {
                result: true
            };
        }
        localCerts.push(..._this.trustedCerts);
        localCerts.push(..._this.certs);
        for(let i4 = 0; i4 < localCerts.length; i4++){
            for(let j = 0; j < localCerts.length; j++){
                if (i4 === j) continue;
                if (isEqualBuffer(localCerts[i4].tbs, localCerts[j].tbs)) {
                    localCerts.splice(j, 1);
                    i4 = 0;
                    break;
                }
            }
        }
        let result1;
        const certificatePath = [
            localCerts[localCerts.length - 1]
        ];
        result1 = await buildPath(localCerts[localCerts.length - 1]);
        if (result1.length === 0) {
            return {
                result: false,
                resultCode: 60,
                resultMessage: "Unable to find certificate path"
            };
        }
        for(let i1 = 0; i1 < result1.length; i1++){
            let found = false;
            for(let j = 0; j < result1[i1].length; j++){
                const certificate = result1[i1][j];
                for(let k = 0; k < _this.trustedCerts.length; k++){
                    if (isEqualBuffer(certificate.tbs, _this.trustedCerts[k].tbs)) {
                        found = true;
                        break;
                    }
                }
                if (found) break;
            }
            if (!found) {
                result1.splice(i1, 1);
                i1 = 0;
            }
        }
        if (result1.length === 0) {
            throw {
                result: false,
                resultCode: 97,
                resultMessage: "No valid certificate paths found"
            };
        }
        let shortestLength = result1[0].length;
        let shortestIndex = 0;
        for(let i213 = 0; i213 < result1.length; i213++){
            if (result1[i213].length < shortestLength) {
                shortestLength = result1[i213].length;
                shortestIndex = i213;
            }
        }
        for(let i3 = 0; i3 < result1[shortestIndex].length; i3++)certificatePath.push(result1[shortestIndex][i3]);
        result1 = await basicCheck(certificatePath, _this.checkDate);
        if (result1.result === false) throw result1;
        return certificatePath;
    }
    async verify(parameters = {}) {
        function compareDNSName(name, constraint) {
            const namePrepared = stringPrep(name);
            const constraintPrepared = stringPrep(constraint);
            const nameSplitted = namePrepared.split(".");
            const constraintSplitted = constraintPrepared.split(".");
            const nameLen = nameSplitted.length;
            const constrLen = constraintSplitted.length;
            if (nameLen === 0 || constrLen === 0 || nameLen < constrLen) return false;
            for(let i185 = 0; i185 < nameLen; i185++){
                if (nameSplitted[i185].length === 0) return false;
            }
            for(let i8 = 0; i8 < constrLen; i8++){
                if (constraintSplitted[i8].length === 0) {
                    if (i8 === 0) {
                        if (constrLen === 1) return false;
                        continue;
                    }
                    return false;
                }
            }
            for(let i9 = 0; i9 < constrLen; i9++){
                if (constraintSplitted[constrLen - 1 - i9].length === 0) continue;
                if (nameSplitted[nameLen - 1 - i9].localeCompare(constraintSplitted[constrLen - 1 - i9]) !== 0) return false;
            }
            return true;
        }
        function compareRFC822Name(name, constraint) {
            const namePrepared = stringPrep(name);
            const constraintPrepared = stringPrep(constraint);
            const nameSplitted = namePrepared.split("@");
            const constraintSplitted = constraintPrepared.split("@");
            if (nameSplitted.length === 0 || constraintSplitted.length === 0 || nameSplitted.length < constraintSplitted.length) return false;
            if (constraintSplitted.length === 1) {
                const result = compareDNSName(nameSplitted[1], constraintSplitted[0]);
                if (result) {
                    const ns = nameSplitted[1].split(".");
                    const cs = constraintSplitted[0].split(".");
                    if (cs[0].length === 0) return true;
                    return ns.length === cs.length;
                }
                return false;
            }
            return namePrepared.localeCompare(constraintPrepared) === 0;
        }
        function compareUniformResourceIdentifier(name, constraint) {
            let namePrepared = stringPrep(name);
            const constraintPrepared = stringPrep(constraint);
            const ns = namePrepared.split("/");
            const cs = constraintPrepared.split("/");
            if (cs.length > 1) return false;
            if (ns.length > 1) {
                for(let i186 = 0; i186 < ns.length; i186++){
                    if (ns[i186].length > 0 && ns[i186].charAt(ns[i186].length - 1) !== ":") {
                        const nsPort = ns[i186].split(":");
                        namePrepared = nsPort[0];
                        break;
                    }
                }
            }
            const result = compareDNSName(namePrepared, constraintPrepared);
            if (result) {
                const nameSplitted = namePrepared.split(".");
                const constraintSplitted = constraintPrepared.split(".");
                if (constraintSplitted[0].length === 0) return true;
                return nameSplitted.length === constraintSplitted.length;
            }
            return false;
        }
        function compareIPAddress(name, constraint) {
            const nameView = new Uint8Array(name.valueBlock.valueHex);
            const constraintView = new Uint8Array(constraint.valueBlock.valueHex);
            if (nameView.length === 4 && constraintView.length === 8) {
                for(let i187 = 0; i187 < 4; i187++){
                    if ((nameView[i187] ^ constraintView[i187]) & constraintView[i187 + 4]) return false;
                }
                return true;
            }
            if (nameView.length === 16 && constraintView.length === 32) {
                for(let i188 = 0; i188 < 16; i188++){
                    if ((nameView[i188] ^ constraintView[i188]) & constraintView[i188 + 16]) return false;
                }
                return true;
            }
            return false;
        }
        function compareDirectoryName(name, constraint) {
            if (name.typesAndValues.length === 0 || constraint.typesAndValues.length === 0) return true;
            if (name.typesAndValues.length < constraint.typesAndValues.length) return false;
            let result = true;
            let nameStart = 0;
            for(let i189 = 0; i189 < constraint.typesAndValues.length; i189++){
                let localResult = false;
                for(let j = nameStart; j < name.typesAndValues.length; j++){
                    localResult = name.typesAndValues[j].isEqual(constraint.typesAndValues[i189]);
                    if (name.typesAndValues[j].type === constraint.typesAndValues[i189].type) result = result && localResult;
                    if (localResult === true) {
                        if (nameStart === 0 || nameStart === j) {
                            nameStart = j + 1;
                            break;
                        } else return false;
                    }
                }
                if (localResult === false) return false;
            }
            return nameStart === 0 ? false : result;
        }
        try {
            if (this.certs.length === 0) throw "Empty certificate array";
            let initialPolicySet = [];
            initialPolicySet.push("2.5.29.32.0");
            let initialExplicitPolicy = false;
            let initialPolicyMappingInhibit = false;
            let initialInhibitPolicy = false;
            let initialPermittedSubtreesSet = [];
            let initialExcludedSubtreesSet = [];
            let initialRequiredNameForms = [];
            if ("initialPolicySet" in parameters) initialPolicySet = parameters.initialPolicySet;
            if ("initialExplicitPolicy" in parameters) initialExplicitPolicy = parameters.initialExplicitPolicy;
            if ("initialPolicyMappingInhibit" in parameters) initialPolicyMappingInhibit = parameters.initialPolicyMappingInhibit;
            if ("initialInhibitPolicy" in parameters) initialInhibitPolicy = parameters.initialInhibitPolicy;
            if ("initialPermittedSubtreesSet" in parameters) initialPermittedSubtreesSet = parameters.initialPermittedSubtreesSet;
            if ("initialExcludedSubtreesSet" in parameters) initialExcludedSubtreesSet = parameters.initialExcludedSubtreesSet;
            if ("initialRequiredNameForms" in parameters) initialRequiredNameForms = parameters.initialRequiredNameForms;
            let explicitPolicyIndicator = initialExplicitPolicy;
            let policyMappingInhibitIndicator = initialPolicyMappingInhibit;
            let inhibitAnyPolicyIndicator = initialInhibitPolicy;
            const pendingConstraints = new Array(3);
            pendingConstraints[0] = false;
            pendingConstraints[1] = false;
            pendingConstraints[2] = false;
            let explicitPolicyPending = 0;
            let policyMappingInhibitPending = 0;
            let inhibitAnyPolicyPending = 0;
            let permittedSubtrees = initialPermittedSubtreesSet;
            let excludedSubtrees = initialExcludedSubtreesSet;
            const requiredNameForms = initialRequiredNameForms;
            let pathDepth = 1;
            this.certs = await this.sort();
            const allPolicies = [];
            allPolicies.push("2.5.29.32.0");
            const policiesAndCerts = [];
            const anyPolicyArray = new Array(this.certs.length - 1);
            for(let ii = 0; ii < this.certs.length - 1; ii++)anyPolicyArray[ii] = true;
            policiesAndCerts.push(anyPolicyArray);
            const policyMappings = new Array(this.certs.length - 1);
            const certPolicies = new Array(this.certs.length - 1);
            let explicitPolicyStart = explicitPolicyIndicator ? this.certs.length - 1 : -1;
            for(let i190 = this.certs.length - 2; i190 >= 0; i190--, pathDepth++){
                if ("extensions" in this.certs[i190]) {
                    for(let j = 0; j < this.certs[i190].extensions.length; j++){
                        if (this.certs[i190].extensions[j].extnID === "2.5.29.32") {
                            certPolicies[i190] = this.certs[i190].extensions[j].parsedValue;
                            for(let s12 = 0; s12 < allPolicies.length; s12++){
                                if (allPolicies[s12] === "2.5.29.32.0") {
                                    delete policiesAndCerts[s12][i190];
                                    break;
                                }
                            }
                            for(let k = 0; k < this.certs[i190].extensions[j].parsedValue.certificatePolicies.length; k++){
                                let policyIndex = -1;
                                for(let s13 = 0; s13 < allPolicies.length; s13++){
                                    if (this.certs[i190].extensions[j].parsedValue.certificatePolicies[k].policyIdentifier === allPolicies[s13]) {
                                        policyIndex = s13;
                                        break;
                                    }
                                }
                                if (policyIndex === -1) {
                                    allPolicies.push(this.certs[i190].extensions[j].parsedValue.certificatePolicies[k].policyIdentifier);
                                    const certArray = new Array(this.certs.length - 1);
                                    certArray[i190] = true;
                                    policiesAndCerts.push(certArray);
                                } else policiesAndCerts[policyIndex][i190] = true;
                            }
                        }
                        if (this.certs[i190].extensions[j].extnID === "2.5.29.33") {
                            if (policyMappingInhibitIndicator) {
                                return {
                                    result: false,
                                    resultCode: 98,
                                    resultMessage: "Policy mapping prohibited"
                                };
                            }
                            policyMappings[i190] = this.certs[i190].extensions[j].parsedValue;
                        }
                        if (this.certs[i190].extensions[j].extnID === "2.5.29.36") {
                            if (explicitPolicyIndicator === false) {
                                if (this.certs[i190].extensions[j].parsedValue.requireExplicitPolicy === 0) {
                                    explicitPolicyIndicator = true;
                                    explicitPolicyStart = i190;
                                } else {
                                    if (pendingConstraints[0] === false) {
                                        pendingConstraints[0] = true;
                                        explicitPolicyPending = this.certs[i190].extensions[j].parsedValue.requireExplicitPolicy;
                                    } else explicitPolicyPending = explicitPolicyPending > this.certs[i190].extensions[j].parsedValue.requireExplicitPolicy ? this.certs[i190].extensions[j].parsedValue.requireExplicitPolicy : explicitPolicyPending;
                                }
                                if (this.certs[i190].extensions[j].parsedValue.inhibitPolicyMapping === 0) policyMappingInhibitIndicator = true;
                                else {
                                    if (pendingConstraints[1] === false) {
                                        pendingConstraints[1] = true;
                                        policyMappingInhibitPending = this.certs[i190].extensions[j].parsedValue.inhibitPolicyMapping + 1;
                                    } else policyMappingInhibitPending = policyMappingInhibitPending > this.certs[i190].extensions[j].parsedValue.inhibitPolicyMapping + 1 ? this.certs[i190].extensions[j].parsedValue.inhibitPolicyMapping + 1 : policyMappingInhibitPending;
                                }
                            }
                        }
                        if (this.certs[i190].extensions[j].extnID === "2.5.29.54") {
                            if (inhibitAnyPolicyIndicator === false) {
                                if (this.certs[i190].extensions[j].parsedValue.valueBlock.valueDec === 0) inhibitAnyPolicyIndicator = true;
                                else {
                                    if (pendingConstraints[2] === false) {
                                        pendingConstraints[2] = true;
                                        inhibitAnyPolicyPending = this.certs[i190].extensions[j].parsedValue.valueBlock.valueDec;
                                    } else inhibitAnyPolicyPending = inhibitAnyPolicyPending > this.certs[i190].extensions[j].parsedValue.valueBlock.valueDec ? this.certs[i190].extensions[j].parsedValue.valueBlock.valueDec : inhibitAnyPolicyPending;
                                }
                            }
                        }
                    }
                    if (inhibitAnyPolicyIndicator === true) {
                        let policyIndex = -1;
                        for(let searchAnyPolicy = 0; searchAnyPolicy < allPolicies.length; searchAnyPolicy++){
                            if (allPolicies[searchAnyPolicy] === "2.5.29.32.0") {
                                policyIndex = searchAnyPolicy;
                                break;
                            }
                        }
                        if (policyIndex !== -1) delete policiesAndCerts[0][i190];
                    }
                    if (explicitPolicyIndicator === false) {
                        if (pendingConstraints[0] === true) {
                            explicitPolicyPending--;
                            if (explicitPolicyPending === 0) {
                                explicitPolicyIndicator = true;
                                explicitPolicyStart = i190;
                                pendingConstraints[0] = false;
                            }
                        }
                    }
                    if (policyMappingInhibitIndicator === false) {
                        if (pendingConstraints[1] === true) {
                            policyMappingInhibitPending--;
                            if (policyMappingInhibitPending === 0) {
                                policyMappingInhibitIndicator = true;
                                pendingConstraints[1] = false;
                            }
                        }
                    }
                    if (inhibitAnyPolicyIndicator === false) {
                        if (pendingConstraints[2] === true) {
                            inhibitAnyPolicyPending--;
                            if (inhibitAnyPolicyPending === 0) {
                                inhibitAnyPolicyIndicator = true;
                                pendingConstraints[2] = false;
                            }
                        }
                    }
                }
            }
            for(let i10 = 0; i10 < this.certs.length - 1; i10++){
                if (i10 < this.certs.length - 2 && typeof policyMappings[i10 + 1] !== "undefined") {
                    for(let k = 0; k < policyMappings[i10 + 1].mappings.length; k++){
                        if (policyMappings[i10 + 1].mappings[k].issuerDomainPolicy === "2.5.29.32.0" || policyMappings[i10 + 1].mappings[k].subjectDomainPolicy === "2.5.29.32.0") {
                            return {
                                result: false,
                                resultCode: 99,
                                resultMessage: "The \"anyPolicy\" should not be a part of policy mapping scheme"
                            };
                        }
                        let issuerDomainPolicyIndex = -1;
                        let subjectDomainPolicyIndex = -1;
                        for(let n11 = 0; n11 < allPolicies.length; n11++){
                            if (allPolicies[n11] === policyMappings[i10 + 1].mappings[k].issuerDomainPolicy) issuerDomainPolicyIndex = n11;
                            if (allPolicies[n11] === policyMappings[i10 + 1].mappings[k].subjectDomainPolicy) subjectDomainPolicyIndex = n11;
                        }
                        if (typeof policiesAndCerts[issuerDomainPolicyIndex][i10] !== "undefined") delete policiesAndCerts[issuerDomainPolicyIndex][i10];
                        for(let j = 0; j < certPolicies[i10].certificatePolicies.length; j++){
                            if (policyMappings[i10 + 1].mappings[k].subjectDomainPolicy === certPolicies[i10].certificatePolicies[j].policyIdentifier) {
                                if (issuerDomainPolicyIndex !== -1 && subjectDomainPolicyIndex !== -1) {
                                    for(let m = 0; m <= i10; m++){
                                        if (typeof policiesAndCerts[subjectDomainPolicyIndex][m] !== "undefined") {
                                            policiesAndCerts[issuerDomainPolicyIndex][m] = true;
                                            delete policiesAndCerts[subjectDomainPolicyIndex][m];
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            for(let i11 = 0; i11 < allPolicies.length; i11++){
                if (allPolicies[i11] === "2.5.29.32.0") {
                    for(let j = 0; j < explicitPolicyStart; j++)delete policiesAndCerts[i11][j];
                }
            }
            const authConstrPolicies = [];
            for(let i12 = 0; i12 < policiesAndCerts.length; i12++){
                let found = true;
                for(let j = 0; j < this.certs.length - 1; j++){
                    let anyPolicyFound = false;
                    if (j < explicitPolicyStart && allPolicies[i12] === "2.5.29.32.0" && allPolicies.length > 1) {
                        found = false;
                        break;
                    }
                    if (typeof policiesAndCerts[i12][j] === "undefined") {
                        if (j >= explicitPolicyStart) {
                            for(let k = 0; k < allPolicies.length; k++){
                                if (allPolicies[k] === "2.5.29.32.0") {
                                    if (policiesAndCerts[k][j] === true) anyPolicyFound = true;
                                    break;
                                }
                            }
                        }
                        if (!anyPolicyFound) {
                            found = false;
                            break;
                        }
                    }
                }
                if (found === true) authConstrPolicies.push(allPolicies[i12]);
            }
            let userConstrPolicies = [];
            if (initialPolicySet.length === 1 && initialPolicySet[0] === "2.5.29.32.0" && explicitPolicyIndicator === false) userConstrPolicies = initialPolicySet;
            else {
                if (authConstrPolicies.length === 1 && authConstrPolicies[0] === "2.5.29.32.0") userConstrPolicies = initialPolicySet;
                else {
                    for(let i191 = 0; i191 < authConstrPolicies.length; i191++){
                        for(let j = 0; j < initialPolicySet.length; j++){
                            if (initialPolicySet[j] === authConstrPolicies[i191] || initialPolicySet[j] === "2.5.29.32.0") {
                                userConstrPolicies.push(authConstrPolicies[i191]);
                                break;
                            }
                        }
                    }
                }
            }
            const policyResult = {
                result: userConstrPolicies.length > 0,
                resultCode: 0,
                resultMessage: userConstrPolicies.length > 0 ? "" : "Zero \"userConstrPolicies\" array, no intersections with \"authConstrPolicies\"",
                authConstrPolicies,
                userConstrPolicies,
                explicitPolicyIndicator,
                policyMappings,
                certificatePath: this.certs
            };
            if (userConstrPolicies.length === 0) return policyResult;
            if (policyResult.result === false) return policyResult;
            pathDepth = 1;
            for(let i13 = this.certs.length - 2; i13 >= 0; i13--, pathDepth++){
                let subjectAltNames = [];
                let certPermittedSubtrees = [];
                let certExcludedSubtrees = [];
                if ("extensions" in this.certs[i13]) {
                    for(let j = 0; j < this.certs[i13].extensions.length; j++){
                        if (this.certs[i13].extensions[j].extnID === "2.5.29.30") {
                            if ("permittedSubtrees" in this.certs[i13].extensions[j].parsedValue) certPermittedSubtrees = certPermittedSubtrees.concat(this.certs[i13].extensions[j].parsedValue.permittedSubtrees);
                            if ("excludedSubtrees" in this.certs[i13].extensions[j].parsedValue) certExcludedSubtrees = certExcludedSubtrees.concat(this.certs[i13].extensions[j].parsedValue.excludedSubtrees);
                        }
                        if (this.certs[i13].extensions[j].extnID === "2.5.29.17") subjectAltNames = subjectAltNames.concat(this.certs[i13].extensions[j].parsedValue.altNames);
                    }
                }
                let formFound = requiredNameForms.length <= 0;
                for(let j = 0; j < requiredNameForms.length; j++){
                    switch(requiredNameForms[j].base.type){
                        case 4:
                            {
                                if (requiredNameForms[j].base.value.typesAndValues.length !== this.certs[i13].subject.typesAndValues.length) continue;
                                formFound = true;
                                for(let k = 0; k < this.certs[i13].subject.typesAndValues.length; k++){
                                    if (this.certs[i13].subject.typesAndValues[k].type !== requiredNameForms[j].base.value.typesAndValues[k].type) {
                                        formFound = false;
                                        break;
                                    }
                                }
                                if (formFound === true) break;
                            }
                            break;
                        default:
                    }
                }
                if (formFound === false) {
                    policyResult.result = false;
                    policyResult.resultCode = 21;
                    policyResult.resultMessage = "No neccessary name form found";
                    throw policyResult;
                }
                const constrGroups = [];
                constrGroups[0] = [];
                constrGroups[1] = [];
                constrGroups[2] = [];
                constrGroups[3] = [];
                constrGroups[4] = [];
                for(let j1 = 0; j1 < permittedSubtrees.length; j1++){
                    switch(permittedSubtrees[j1].base.type){
                        case 1:
                            constrGroups[0].push(permittedSubtrees[j1]);
                            break;
                        case 2:
                            constrGroups[1].push(permittedSubtrees[j1]);
                            break;
                        case 4:
                            constrGroups[2].push(permittedSubtrees[j1]);
                            break;
                        case 6:
                            constrGroups[3].push(permittedSubtrees[j1]);
                            break;
                        case 7:
                            constrGroups[4].push(permittedSubtrees[j1]);
                            break;
                        default:
                    }
                }
                for(let p = 0; p < 5; p++){
                    let groupPermitted = false;
                    let valueExists = false;
                    const group = constrGroups[p];
                    for(let j = 0; j < group.length; j++){
                        switch(p){
                            case 0:
                                if (subjectAltNames.length > 0) {
                                    for(let k = 0; k < subjectAltNames.length; k++){
                                        if (subjectAltNames[k].type === 1) {
                                            valueExists = true;
                                            groupPermitted = groupPermitted || compareRFC822Name(subjectAltNames[k].value, group[j].base.value);
                                        }
                                    }
                                } else {
                                    for(let k = 0; k < this.certs[i13].subject.typesAndValues.length; k++){
                                        if (this.certs[i13].subject.typesAndValues[k].type === "1.2.840.113549.1.9.1" || this.certs[i13].subject.typesAndValues[k].type === "0.9.2342.19200300.100.1.3") {
                                            valueExists = true;
                                            groupPermitted = groupPermitted || compareRFC822Name(this.certs[i13].subject.typesAndValues[k].value.valueBlock.value, group[j].base.value);
                                        }
                                    }
                                }
                                break;
                            case 1:
                                if (subjectAltNames.length > 0) {
                                    for(let k = 0; k < subjectAltNames.length; k++){
                                        if (subjectAltNames[k].type === 2) {
                                            valueExists = true;
                                            groupPermitted = groupPermitted || compareDNSName(subjectAltNames[k].value, group[j].base.value);
                                        }
                                    }
                                }
                                break;
                            case 2:
                                valueExists = true;
                                groupPermitted = compareDirectoryName(this.certs[i13].subject, group[j].base.value);
                                break;
                            case 3:
                                if (subjectAltNames.length > 0) {
                                    for(let k = 0; k < subjectAltNames.length; k++){
                                        if (subjectAltNames[k].type === 6) {
                                            valueExists = true;
                                            groupPermitted = groupPermitted || compareUniformResourceIdentifier(subjectAltNames[k].value, group[j].base.value);
                                        }
                                    }
                                }
                                break;
                            case 4:
                                if (subjectAltNames.length > 0) {
                                    for(let k = 0; k < subjectAltNames.length; k++){
                                        if (subjectAltNames[k].type === 7) {
                                            valueExists = true;
                                            groupPermitted = groupPermitted || compareIPAddress(subjectAltNames[k].value, group[j].base.value);
                                        }
                                    }
                                }
                                break;
                            default:
                        }
                        if (groupPermitted) break;
                    }
                    if (groupPermitted === false && group.length > 0 && valueExists) {
                        policyResult.result = false;
                        policyResult.resultCode = 41;
                        policyResult.resultMessage = "Failed to meet \"permitted sub-trees\" name constraint";
                        throw policyResult;
                    }
                }
                let excluded = false;
                for(let j2 = 0; j2 < excludedSubtrees.length; j2++){
                    switch(excludedSubtrees[j2].base.type){
                        case 1:
                            if (subjectAltNames.length >= 0) {
                                for(let k = 0; k < subjectAltNames.length; k++){
                                    if (subjectAltNames[k].type === 1) excluded = excluded || compareRFC822Name(subjectAltNames[k].value, excludedSubtrees[j2].base.value);
                                }
                            } else {
                                for(let k = 0; k < this.certs[i13].subject.typesAndValues.length; k++){
                                    if (this.certs[i13].subject.typesAndValues[k].type === "1.2.840.113549.1.9.1" || this.certs[i13].subject.typesAndValues[k].type === "0.9.2342.19200300.100.1.3") excluded = excluded || compareRFC822Name(this.certs[i13].subject.typesAndValues[k].value.valueBlock.value, excludedSubtrees[j2].base.value);
                                }
                            }
                            break;
                        case 2:
                            if (subjectAltNames.length > 0) {
                                for(let k = 0; k < subjectAltNames.length; k++){
                                    if (subjectAltNames[k].type === 2) excluded = excluded || compareDNSName(subjectAltNames[k].value, excludedSubtrees[j2].base.value);
                                }
                            }
                            break;
                        case 4:
                            excluded = excluded || compareDirectoryName(this.certs[i13].subject, excludedSubtrees[j2].base.value);
                            break;
                        case 6:
                            if (subjectAltNames.length > 0) {
                                for(let k = 0; k < subjectAltNames.length; k++){
                                    if (subjectAltNames[k].type === 6) excluded = excluded || compareUniformResourceIdentifier(subjectAltNames[k].value, excludedSubtrees[j2].base.value);
                                }
                            }
                            break;
                        case 7:
                            if (subjectAltNames.length > 0) {
                                for(let k = 0; k < subjectAltNames.length; k++){
                                    if (subjectAltNames[k].type === 7) excluded = excluded || compareIPAddress(subjectAltNames[k].value, excludedSubtrees[j2].base.value);
                                }
                            }
                            break;
                        default:
                    }
                    if (excluded) break;
                }
                if (excluded === true) {
                    policyResult.result = false;
                    policyResult.resultCode = 42;
                    policyResult.resultMessage = "Failed to meet \"excluded sub-trees\" name constraint";
                    throw policyResult;
                }
                permittedSubtrees = permittedSubtrees.concat(certPermittedSubtrees);
                excludedSubtrees = excludedSubtrees.concat(certExcludedSubtrees);
            }
            return policyResult;
        } catch (error66) {
            if (error66 instanceof Object) {
                if ("resultMessage" in error66) return error66;
                if ("message" in error66) {
                    return {
                        result: false,
                        resultCode: -1,
                        resultMessage: error66.message
                    };
                }
            }
            return {
                result: false,
                resultCode: -1,
                resultMessage: error66
            };
        }
    }
}
class BasicOCSPResponse {
    constructor(parameters = {}){
        this.tbsResponseData = getParametersValue(parameters, "tbsResponseData", BasicOCSPResponse.defaultValues("tbsResponseData"));
        this.signatureAlgorithm = getParametersValue(parameters, "signatureAlgorithm", BasicOCSPResponse.defaultValues("signatureAlgorithm"));
        this.signature = getParametersValue(parameters, "signature", BasicOCSPResponse.defaultValues("signature"));
        if ("certs" in parameters) this.certs = getParametersValue(parameters, "certs", BasicOCSPResponse.defaultValues("certs"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "tbsResponseData":
                return new ResponseData();
            case "signatureAlgorithm":
                return new AlgorithmIdentifier();
            case "signature":
                return new BitString();
            case "certs":
                return [];
            default:
                throw new Error(`Invalid member name for BasicOCSPResponse class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "type":
                {
                    let comparisonResult = ResponseData.compareWithDefault("tbs", memberValue.tbs) && ResponseData.compareWithDefault("responderID", memberValue.responderID) && ResponseData.compareWithDefault("producedAt", memberValue.producedAt) && ResponseData.compareWithDefault("responses", memberValue.responses);
                    if ("responseExtensions" in memberValue) comparisonResult = comparisonResult && ResponseData.compareWithDefault("responseExtensions", memberValue.responseExtensions);
                    return comparisonResult;
                }
            case "signatureAlgorithm":
                return memberValue.algorithmId === "" && "algorithmParams" in memberValue === false;
            case "signature":
                return memberValue.isEqual(BasicOCSPResponse.defaultValues(memberName));
            case "certs":
                return memberValue.length === 0;
            default:
                throw new Error(`Invalid member name for BasicOCSPResponse class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "BasicOCSPResponse",
            value: [
                ResponseData.schema(names.tbsResponseData || {
                    names: {
                        blockName: "BasicOCSPResponse.tbsResponseData"
                    }
                }),
                AlgorithmIdentifier.schema(names.signatureAlgorithm || {
                    names: {
                        blockName: "BasicOCSPResponse.signatureAlgorithm"
                    }
                }),
                new BitString({
                    name: names.signature || "BasicOCSPResponse.signature"
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Sequence({
                            value: [
                                new Repeated({
                                    name: "BasicOCSPResponse.certs",
                                    value: Certificate.schema(names.certs || {})
                                })
                            ]
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "BasicOCSPResponse.tbsResponseData",
            "BasicOCSPResponse.signatureAlgorithm",
            "BasicOCSPResponse.signature",
            "BasicOCSPResponse.certs"
        ]);
        const asn1 = compareSchema(schema, schema, BasicOCSPResponse.schema());
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for BasicOCSPResponse");
        this.tbsResponseData = new ResponseData({
            schema: asn1.result["BasicOCSPResponse.tbsResponseData"]
        });
        this.signatureAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result["BasicOCSPResponse.signatureAlgorithm"]
        });
        this.signature = asn1.result["BasicOCSPResponse.signature"];
        if ("BasicOCSPResponse.certs" in asn1.result) this.certs = Array.from(asn1.result["BasicOCSPResponse.certs"], (element)=>new Certificate({
                schema: element
            })
        );
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(this.tbsResponseData.toSchema());
        outputArray.push(this.signatureAlgorithm.toSchema());
        outputArray.push(this.signature);
        if ("certs" in this) {
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: [
                    new Sequence({
                        value: Array.from(this.certs, (element)=>element.toSchema()
                        )
                    })
                ]
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const _object = {
            tbsResponseData: this.tbsResponseData.toJSON(),
            signatureAlgorithm: this.signatureAlgorithm.toJSON(),
            signature: this.signature.toJSON()
        };
        if ("certs" in this) _object.certs = Array.from(this.certs, (element)=>element.toJSON()
        );
        return _object;
    }
    getCertificateStatus(certificate, issuerCertificate) {
        let sequence = Promise.resolve();
        const result = {
            isForCertificate: false,
            status: 2
        };
        const hashesObject = {};
        const certIDs = [];
        const certIDPromises = [];
        for (const response1 of this.tbsResponseData.responses){
            const hashAlgorithm = getAlgorithmByOID(response1.certID.hashAlgorithm.algorithmId);
            if ("name" in hashAlgorithm === false) return Promise.reject(`Wrong CertID hashing algorithm: ${response1.certID.hashAlgorithm.algorithmId}`);
            if (hashAlgorithm.name in hashesObject === false) {
                hashesObject[hashAlgorithm.name] = 1;
                const certID = new CertID();
                certIDs.push(certID);
                certIDPromises.push(certID.createForCertificate(certificate, {
                    hashAlgorithm: hashAlgorithm.name,
                    issuerCertificate
                }));
            }
        }
        sequence = sequence.then(()=>Promise.all(certIDPromises)
        );
        sequence = sequence.then(()=>{
            for (const response of this.tbsResponseData.responses){
                for (const id of certIDs){
                    if (response.certID.isEqual(id)) {
                        result.isForCertificate = true;
                        try {
                            switch(response.certStatus.idBlock.isConstructed){
                                case true:
                                    if (response.certStatus.idBlock.tagNumber === 1) result.status = 1;
                                    break;
                                case false:
                                    switch(response.certStatus.idBlock.tagNumber){
                                        case 0:
                                            result.status = 0;
                                            break;
                                        case 2:
                                            result.status = 2;
                                            break;
                                        default:
                                    }
                                    break;
                                default:
                            }
                        } catch (ex) {}
                        return result;
                    }
                }
            }
            return result;
        });
        return sequence;
    }
    sign(privateKey, hashAlgorithm = "SHA-1") {
        if (typeof privateKey === "undefined") return Promise.reject("Need to provide a private key for signing");
        let sequence = Promise.resolve();
        let parameters;
        const engine6 = getEngine();
        sequence = sequence.then(()=>engine6.subtle.getSignatureParameters(privateKey, hashAlgorithm)
        );
        sequence = sequence.then((result)=>{
            parameters = result.parameters;
            this.signatureAlgorithm = result.signatureAlgorithm;
        });
        sequence = sequence.then(()=>{
            this.tbsResponseData.tbs = this.tbsResponseData.toSchema(true).toBER(false);
        });
        sequence = sequence.then(()=>engine6.subtle.signWithPrivateKey(this.tbsResponseData.tbs, privateKey, parameters)
        );
        sequence = sequence.then((result)=>{
            this.signature = new BitString({
                valueHex: result
            });
        });
        return sequence;
    }
    verify(parameters = {}) {
        let signerCert = null;
        let certIndex = -1;
        let sequence = Promise.resolve();
        let trustedCerts = [];
        const _this = this;
        const engine7 = getEngine();
        if ("certs" in this === false) return Promise.reject("No certificates attached to the BasicOCSPResponce");
        if ("trustedCerts" in parameters) trustedCerts = parameters.trustedCerts;
        function checkCA(cert) {
            if (cert.issuer.isEqual(signerCert.issuer) === true && cert.serialNumber.isEqual(signerCert.serialNumber) === true) return null;
            let isCA = false;
            for (const extension of cert.extensions){
                if (extension.extnID === "2.5.29.19") {
                    if ("cA" in extension.parsedValue) {
                        if (extension.parsedValue.cA === true) isCA = true;
                    }
                }
            }
            if (isCA) return cert;
            return null;
        }
        const crypto = getCrypto();
        if (typeof crypto === "undefined") return Promise.reject("Unable to create WebCrypto object");
        switch(true){
            case this.tbsResponseData.responderID instanceof RelativeDistinguishedNames:
                sequence = sequence.then(()=>{
                    for (const [index, certificate] of _this.certs.entries()){
                        if (certificate.subject.isEqual(_this.tbsResponseData.responderID)) {
                            certIndex = index;
                            break;
                        }
                    }
                });
                break;
            case this.tbsResponseData.responderID instanceof OctetString:
                sequence = sequence.then(()=>Promise.all(Array.from(_this.certs, (element)=>crypto.digest({
                            name: "sha-1"
                        }, new Uint8Array(element.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex))
                    )).then((results)=>{
                        for (const [index] of _this.certs.entries()){
                            if (isEqualBuffer(results[index], _this.tbsResponseData.responderID.valueBlock.valueHex)) {
                                certIndex = index;
                                break;
                            }
                        }
                    })
                );
                break;
            default:
                return Promise.reject("Wrong value for responderID");
        }
        sequence = sequence.then(()=>{
            if (certIndex === -1) return Promise.reject("Correct certificate was not found in OCSP response");
            signerCert = this.certs[certIndex];
            return Promise.all(Array.from(_this.certs, (element)=>checkCA(element)
            )).then((promiseResults)=>{
                const additionalCerts = [];
                additionalCerts.push(signerCert);
                for (const promiseResult of promiseResults){
                    if (promiseResult !== null) additionalCerts.push(promiseResult);
                }
                const certChain = new CertificateChainValidationEngine({
                    certs: additionalCerts,
                    trustedCerts
                });
                return certChain.verify().then((verificationResult)=>{
                    if (verificationResult.result === true) return Promise.resolve();
                    return Promise.reject("Validation of signer's certificate failed");
                }, (error67)=>Promise.reject(`Validation of signer's certificate failed with error: ${error67 instanceof Object ? error67.resultMessage : error67}`)
                );
            }, (promiseError)=>Promise.reject(`Error during checking certificates for CA flag: ${promiseError}`)
            );
        });
        sequence = sequence.then(()=>engine7.subtle.verifyWithPublicKey(this.tbsResponseData.tbs, this.signature, this.certs[certIndex].subjectPublicKeyInfo, this.signatureAlgorithm)
        );
        return sequence;
    }
}
function CertificationRequestInfo(parameters = {}) {
    const names = getParametersValue(parameters, "names", {});
    return new Sequence({
        name: names.CertificationRequestInfo || "CertificationRequestInfo",
        value: [
            new Integer({
                name: names.CertificationRequestInfoVersion || "CertificationRequestInfo.version"
            }),
            RelativeDistinguishedNames.schema(names.subject || {
                names: {
                    blockName: "CertificationRequestInfo.subject"
                }
            }),
            PublicKeyInfo.schema({
                names: {
                    blockName: "CertificationRequestInfo.subjectPublicKeyInfo"
                }
            }),
            new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: [
                    new Repeated({
                        optional: true,
                        name: names.CertificationRequestInfoAttributes || "CertificationRequestInfo.attributes",
                        value: Attribute.schema(names.attributes || {})
                    })
                ]
            })
        ]
    });
}
class CertificationRequest {
    constructor(parameters = {}){
        this.tbs = getParametersValue(parameters, "tbs", CertificationRequest.defaultValues("tbs"));
        this.version = getParametersValue(parameters, "version", CertificationRequest.defaultValues("version"));
        this.subject = getParametersValue(parameters, "subject", CertificationRequest.defaultValues("subject"));
        this.subjectPublicKeyInfo = getParametersValue(parameters, "subjectPublicKeyInfo", CertificationRequest.defaultValues("subjectPublicKeyInfo"));
        if ("attributes" in parameters) this.attributes = getParametersValue(parameters, "attributes", CertificationRequest.defaultValues("attributes"));
        this.signatureAlgorithm = getParametersValue(parameters, "signatureAlgorithm", CertificationRequest.defaultValues("signatureAlgorithm"));
        this.signatureValue = getParametersValue(parameters, "signatureValue", CertificationRequest.defaultValues("signatureValue"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "tbs":
                return new ArrayBuffer(0);
            case "version":
                return 0;
            case "subject":
                return new RelativeDistinguishedNames();
            case "subjectPublicKeyInfo":
                return new PublicKeyInfo();
            case "attributes":
                return [];
            case "signatureAlgorithm":
                return new AlgorithmIdentifier();
            case "signatureValue":
                return new BitString();
            default:
                throw new Error(`Invalid member name for CertificationRequest class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            value: [
                CertificationRequestInfo(names.certificationRequestInfo || {}),
                new Sequence({
                    name: names.signatureAlgorithm || "signatureAlgorithm",
                    value: [
                        new ObjectIdentifier(),
                        new Any({
                            optional: true
                        })
                    ]
                }),
                new BitString({
                    name: names.signatureValue || "signatureValue"
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "CertificationRequestInfo",
            "CertificationRequestInfo.version",
            "CertificationRequestInfo.subject",
            "CertificationRequestInfo.subjectPublicKeyInfo",
            "CertificationRequestInfo.attributes",
            "signatureAlgorithm",
            "signatureValue"
        ]);
        const asn1 = compareSchema(schema, schema, CertificationRequest.schema());
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for CertificationRequest");
        this.tbs = asn1.result.CertificationRequestInfo.valueBeforeDecode;
        this.version = asn1.result["CertificationRequestInfo.version"].valueBlock.valueDec;
        this.subject = new RelativeDistinguishedNames({
            schema: asn1.result["CertificationRequestInfo.subject"]
        });
        this.subjectPublicKeyInfo = new PublicKeyInfo({
            schema: asn1.result["CertificationRequestInfo.subjectPublicKeyInfo"]
        });
        if ("CertificationRequestInfo.attributes" in asn1.result) this.attributes = Array.from(asn1.result["CertificationRequestInfo.attributes"], (element)=>new Attribute({
                schema: element
            })
        );
        this.signatureAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result.signatureAlgorithm
        });
        this.signatureValue = asn1.result.signatureValue;
    }
    encodeTBS() {
        const outputArray = [
            new Integer({
                value: this.version
            }),
            this.subject.toSchema(),
            this.subjectPublicKeyInfo.toSchema()
        ];
        if ("attributes" in this) {
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: Array.from(this.attributes, (element)=>element.toSchema()
                )
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toSchema(encodeFlag = false) {
        let tbsSchema;
        if (encodeFlag === false) {
            if (this.tbs.byteLength === 0) return CertificationRequest.schema();
            tbsSchema = fromBER(this.tbs).result;
        } else tbsSchema = this.encodeTBS();
        return new Sequence({
            value: [
                tbsSchema,
                this.signatureAlgorithm.toSchema(),
                this.signatureValue
            ]
        });
    }
    toJSON() {
        const object = {
            tbs: bufferToHexCodes(this.tbs, 0, this.tbs.byteLength),
            version: this.version,
            subject: this.subject.toJSON(),
            subjectPublicKeyInfo: this.subjectPublicKeyInfo.toJSON(),
            signatureAlgorithm: this.signatureAlgorithm.toJSON(),
            signatureValue: this.signatureValue.toJSON()
        };
        if ("attributes" in this) object.attributes = Array.from(this.attributes, (element)=>element.toJSON()
        );
        return object;
    }
    sign(privateKey, hashAlgorithm = "SHA-1") {
        if (typeof privateKey === "undefined") return Promise.reject("Need to provide a private key for signing");
        let sequence = Promise.resolve();
        let parameters;
        const engine8 = getEngine();
        sequence = sequence.then(()=>engine8.subtle.getSignatureParameters(privateKey, hashAlgorithm)
        );
        sequence = sequence.then((result)=>{
            parameters = result.parameters;
            this.signatureAlgorithm = result.signatureAlgorithm;
        });
        sequence = sequence.then(()=>{
            this.tbs = this.encodeTBS().toBER(false);
        });
        sequence = sequence.then(()=>engine8.subtle.signWithPrivateKey(this.tbs, privateKey, parameters)
        );
        sequence = sequence.then((result)=>{
            this.signatureValue = new BitString({
                valueHex: result
            });
        });
        return sequence;
    }
    verify() {
        return getEngine().subtle.verifyWithPublicKey(this.tbs, this.signatureValue, this.subjectPublicKeyInfo, this.signatureAlgorithm);
    }
    getPublicKey(parameters = null) {
        return getEngine().getPublicKey(this.subjectPublicKeyInfo, this.signatureAlgorithm, parameters);
    }
}
class DigestInfo {
    constructor(parameters = {}){
        this.digestAlgorithm = getParametersValue(parameters, "digestAlgorithm", DigestInfo.defaultValues("digestAlgorithm"));
        this.digest = getParametersValue(parameters, "digest", DigestInfo.defaultValues("digest"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "digestAlgorithm":
                return new AlgorithmIdentifier();
            case "digest":
                return new OctetString();
            default:
                throw new Error(`Invalid member name for DigestInfo class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "digestAlgorithm":
                return AlgorithmIdentifier.compareWithDefault("algorithmId", memberValue.algorithmId) && "algorithmParams" in memberValue === false;
            case "digest":
                return memberValue.isEqual(DigestInfo.defaultValues(memberName));
            default:
                throw new Error(`Invalid member name for DigestInfo class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                AlgorithmIdentifier.schema(names.digestAlgorithm || {
                    names: {
                        blockName: "digestAlgorithm"
                    }
                }),
                new OctetString({
                    name: names.digest || "digest"
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "digestAlgorithm",
            "digest"
        ]);
        const asn1 = compareSchema(schema, schema, DigestInfo.schema({
            names: {
                digestAlgorithm: {
                    names: {
                        blockName: "digestAlgorithm"
                    }
                },
                digest: "digest"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for DigestInfo");
        this.digestAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result.digestAlgorithm
        });
        this.digest = asn1.result.digest;
    }
    toSchema() {
        return new Sequence({
            value: [
                this.digestAlgorithm.toSchema(),
                this.digest
            ]
        });
    }
    toJSON() {
        return {
            digestAlgorithm: this.digestAlgorithm.toJSON(),
            digest: this.digest.toJSON()
        };
    }
}
class EncapsulatedContentInfo {
    constructor(parameters = {}){
        this.eContentType = getParametersValue(parameters, "eContentType", EncapsulatedContentInfo.defaultValues("eContentType"));
        if ("eContent" in parameters) {
            this.eContent = getParametersValue(parameters, "eContent", EncapsulatedContentInfo.defaultValues("eContent"));
            if (this.eContent.idBlock.tagClass === 1 && this.eContent.idBlock.tagNumber === 4) {
                if (this.eContent.idBlock.isConstructed === false) {
                    const constrString = new OctetString({
                        idBlock: {
                            isConstructed: true
                        },
                        isConstructed: true
                    });
                    let offset = 0;
                    let length = this.eContent.valueBlock.valueHex.byteLength;
                    while(length > 0){
                        const pieceView = new Uint8Array(this.eContent.valueBlock.valueHex, offset, offset + 65536 > this.eContent.valueBlock.valueHex.byteLength ? this.eContent.valueBlock.valueHex.byteLength - offset : 65536);
                        const _array = new ArrayBuffer(pieceView.length);
                        const _view = new Uint8Array(_array);
                        for(let i192 = 0; i192 < _view.length; i192++)_view[i192] = pieceView[i192];
                        constrString.valueBlock.value.push(new OctetString({
                            valueHex: _array
                        }));
                        length -= pieceView.length;
                        offset += pieceView.length;
                    }
                    this.eContent = constrString;
                }
            }
        }
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "eContentType":
                return "";
            case "eContent":
                return new OctetString();
            default:
                throw new Error(`Invalid member name for EncapsulatedContentInfo class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "eContentType":
                return memberValue === "";
            case "eContent":
                {
                    if (memberValue.idBlock.tagClass === 1 && memberValue.idBlock.tagNumber === 4) return memberValue.isEqual(EncapsulatedContentInfo.defaultValues("eContent"));
                    return false;
                }
            default:
                throw new Error(`Invalid member name for EncapsulatedContentInfo class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new ObjectIdentifier({
                    name: names.eContentType || ""
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Any({
                            name: names.eContent || ""
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "eContentType",
            "eContent"
        ]);
        const asn1 = compareSchema(schema, schema, EncapsulatedContentInfo.schema({
            names: {
                eContentType: "eContentType",
                eContent: "eContent"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for EncapsulatedContentInfo");
        this.eContentType = asn1.result.eContentType.valueBlock.toString();
        if ("eContent" in asn1.result) this.eContent = asn1.result.eContent;
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(new ObjectIdentifier({
            value: this.eContentType
        }));
        if ("eContent" in this) {
            if (EncapsulatedContentInfo.compareWithDefault("eContent", this.eContent) === false) {
                outputArray.push(new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        this.eContent
                    ]
                }));
            }
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const _object = {
            eContentType: this.eContentType
        };
        if ("eContent" in this) {
            if (EncapsulatedContentInfo.compareWithDefault("eContent", this.eContent) === false) _object.eContent = this.eContent.toJSON();
        }
        return _object;
    }
}
class MacData {
    constructor(parameters = {}){
        this.mac = getParametersValue(parameters, "mac", MacData.defaultValues("mac"));
        this.macSalt = getParametersValue(parameters, "macSalt", MacData.defaultValues("macSalt"));
        if ("iterations" in parameters) this.iterations = getParametersValue(parameters, "iterations", MacData.defaultValues("iterations"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "mac":
                return new DigestInfo();
            case "macSalt":
                return new OctetString();
            case "iterations":
                return 1;
            default:
                throw new Error(`Invalid member name for MacData class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "mac":
                return DigestInfo.compareWithDefault("digestAlgorithm", memberValue.digestAlgorithm) && DigestInfo.compareWithDefault("digest", memberValue.digest);
            case "macSalt":
                return memberValue.isEqual(MacData.defaultValues(memberName));
            case "iterations":
                return memberValue === MacData.defaultValues(memberName);
            default:
                throw new Error(`Invalid member name for MacData class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            optional: names.optional || true,
            value: [
                DigestInfo.schema(names.mac || {
                    names: {
                        blockName: "mac"
                    }
                }),
                new OctetString({
                    name: names.macSalt || "macSalt"
                }),
                new Integer({
                    optional: true,
                    name: names.iterations || "iterations"
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "mac",
            "macSalt",
            "iterations"
        ]);
        const asn1 = compareSchema(schema, schema, MacData.schema({
            names: {
                mac: {
                    names: {
                        blockName: "mac"
                    }
                },
                macSalt: "macSalt",
                iterations: "iterations"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for MacData");
        this.mac = new DigestInfo({
            schema: asn1.result.mac
        });
        this.macSalt = asn1.result.macSalt;
        if ("iterations" in asn1.result) this.iterations = asn1.result.iterations.valueBlock.valueDec;
    }
    toSchema() {
        const outputArray = [
            this.mac.toSchema(),
            this.macSalt
        ];
        if ("iterations" in this) outputArray.push(new Integer({
            value: this.iterations
        }));
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const output = {
            mac: this.mac.toJSON(),
            macSalt: this.macSalt.toJSON()
        };
        if ("iterations" in this) output.iterations = this.iterations.toJSON();
        return output;
    }
}
class MessageImprint {
    constructor(parameters = {}){
        this.hashAlgorithm = getParametersValue(parameters, "hashAlgorithm", MessageImprint.defaultValues("hashAlgorithm"));
        this.hashedMessage = getParametersValue(parameters, "hashedMessage", MessageImprint.defaultValues("hashedMessage"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "hashAlgorithm":
                return new AlgorithmIdentifier();
            case "hashedMessage":
                return new OctetString();
            default:
                throw new Error(`Invalid member name for MessageImprint class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "hashAlgorithm":
                return memberValue.algorithmId === "" && "algorithmParams" in memberValue === false;
            case "hashedMessage":
                return memberValue.isEqual(MessageImprint.defaultValues(memberName)) === 0;
            default:
                throw new Error(`Invalid member name for MessageImprint class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                AlgorithmIdentifier.schema(names.hashAlgorithm || {}),
                new OctetString({
                    name: names.hashedMessage || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "hashAlgorithm",
            "hashedMessage"
        ]);
        const asn1 = compareSchema(schema, schema, MessageImprint.schema({
            names: {
                hashAlgorithm: {
                    names: {
                        blockName: "hashAlgorithm"
                    }
                },
                hashedMessage: "hashedMessage"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for MessageImprint");
        this.hashAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result.hashAlgorithm
        });
        this.hashedMessage = asn1.result.hashedMessage;
    }
    toSchema() {
        return new Sequence({
            value: [
                this.hashAlgorithm.toSchema(),
                this.hashedMessage
            ]
        });
    }
    toJSON() {
        return {
            hashAlgorithm: this.hashAlgorithm.toJSON(),
            hashedMessage: this.hashedMessage.toJSON()
        };
    }
}
class Request {
    constructor(parameters = {}){
        this.reqCert = getParametersValue(parameters, "reqCert", Request.defaultValues("reqCert"));
        if ("singleRequestExtensions" in parameters) this.singleRequestExtensions = getParametersValue(parameters, "singleRequestExtensions", Request.defaultValues("singleRequestExtensions"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "reqCert":
                return new CertID();
            case "singleRequestExtensions":
                return [];
            default:
                throw new Error(`Invalid member name for Request class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "reqCert":
                return memberValue.isEqual(Request.defaultValues(memberName));
            case "singleRequestExtensions":
                return memberValue.length === 0;
            default:
                throw new Error(`Invalid member name for Request class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                CertID.schema(names.reqCert || {}),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        Extension.schema(names.extensions || {
                            names: {
                                blockName: names.singleRequestExtensions || ""
                            }
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "reqCert",
            "singleRequestExtensions"
        ]);
        const asn1 = compareSchema(schema, schema, Request.schema({
            names: {
                reqCert: {
                    names: {
                        blockName: "reqCert"
                    }
                },
                singleRequestExtensions: {
                    names: {
                        blockName: "singleRequestExtensions"
                    }
                }
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for Request");
        this.reqCert = new CertID({
            schema: asn1.result.reqCert
        });
        if ("singleRequestExtensions" in asn1.result) this.singleRequestExtensions = Array.from(asn1.result.singleRequestExtensions.valueBlock.value, (element)=>new Extension({
                schema: element
            })
        );
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(this.reqCert.toSchema());
        if ("singleRequestExtensions" in this) {
            outputArray.push(new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: [
                    new Sequence({
                        value: Array.from(this.singleRequestExtensions, (element)=>element.toSchema()
                        )
                    })
                ]
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const _object = {
            reqCert: this.reqCert.toJSON()
        };
        if ("singleRequestExtensions" in this) _object.singleRequestExtensions = Array.from(this.singleRequestExtensions, (element)=>element.toJSON()
        );
        return _object;
    }
}
class TBSRequest {
    constructor(parameters = {}){
        this.tbs = getParametersValue(parameters, "tbs", TBSRequest.defaultValues("tbs"));
        if ("version" in parameters) this.version = getParametersValue(parameters, "version", TBSRequest.defaultValues("version"));
        if ("requestorName" in parameters) this.requestorName = getParametersValue(parameters, "requestorName", TBSRequest.defaultValues("requestorName"));
        this.requestList = getParametersValue(parameters, "requestList", TBSRequest.defaultValues("requestList"));
        if ("requestExtensions" in parameters) this.requestExtensions = getParametersValue(parameters, "requestExtensions", TBSRequest.defaultValues("requestExtensions"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "tbs":
                return new ArrayBuffer(0);
            case "version":
                return 0;
            case "requestorName":
                return new GeneralName();
            case "requestList":
            case "requestExtensions":
                return [];
            default:
                throw new Error(`Invalid member name for TBSRequest class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "tbs":
                return memberValue.byteLength === 0;
            case "version":
                return memberValue === TBSRequest.defaultValues(memberName);
            case "requestorName":
                return memberValue.type === GeneralName.defaultValues("type") && Object.keys(memberValue.value).length === 0;
            case "requestList":
            case "requestExtensions":
                return memberValue.length === 0;
            default:
                throw new Error(`Invalid member name for TBSRequest class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "TBSRequest",
            value: [
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Integer({
                            name: names.TBSRequestVersion || "TBSRequest.version"
                        })
                    ]
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: [
                        GeneralName.schema(names.requestorName || {
                            names: {
                                blockName: "TBSRequest.requestorName"
                            }
                        })
                    ]
                }),
                new Sequence({
                    name: names.requestList || "TBSRequest.requestList",
                    value: [
                        new Repeated({
                            name: names.requests || "TBSRequest.requests",
                            value: Request.schema(names.requestNames || {})
                        })
                    ]
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 2
                    },
                    value: [
                        Extensions.schema(names.extensions || {
                            names: {
                                blockName: names.requestExtensions || "TBSRequest.requestExtensions"
                            }
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "TBSRequest",
            "TBSRequest.version",
            "TBSRequest.requestorName",
            "TBSRequest.requests",
            "TBSRequest.requestExtensions"
        ]);
        const asn1 = compareSchema(schema, schema, TBSRequest.schema());
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for TBSRequest");
        this.tbs = asn1.result.TBSRequest.valueBeforeDecode;
        if ("TBSRequest.version" in asn1.result) this.version = asn1.result["TBSRequest.version"].valueBlock.valueDec;
        if ("TBSRequest.requestorName" in asn1.result) this.requestorName = new GeneralName({
            schema: asn1.result["TBSRequest.requestorName"]
        });
        this.requestList = Array.from(asn1.result["TBSRequest.requests"], (element)=>new Request({
                schema: element
            })
        );
        if ("TBSRequest.requestExtensions" in asn1.result) this.requestExtensions = Array.from(asn1.result["TBSRequest.requestExtensions"].valueBlock.value, (element)=>new Extension({
                schema: element
            })
        );
    }
    toSchema(encodeFlag = false) {
        let tbsSchema;
        if (encodeFlag === false) {
            if (this.tbs.byteLength === 0) return TBSRequest.schema();
            tbsSchema = fromBER(this.tbs).result;
        } else {
            const outputArray = [];
            if ("version" in this) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Integer({
                            value: this.version
                        })
                    ]
                }));
            }
            if ("requestorName" in this) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: [
                        this.requestorName.toSchema()
                    ]
                }));
            }
            outputArray.push(new Sequence({
                value: Array.from(this.requestList, (element)=>element.toSchema()
                )
            }));
            if ("requestExtensions" in this) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 2
                    },
                    value: [
                        new Sequence({
                            value: Array.from(this.requestExtensions, (element)=>element.toSchema()
                            )
                        })
                    ]
                }));
            }
            tbsSchema = new Sequence({
                value: outputArray
            });
        }
        return tbsSchema;
    }
    toJSON() {
        const _object = {};
        if ("version" in this) _object.version = this.version;
        if ("requestorName" in this) _object.requestorName = this.requestorName.toJSON();
        _object.requestList = Array.from(this.requestList, (element)=>element.toJSON()
        );
        if ("requestExtensions" in this) _object.requestExtensions = Array.from(this.requestExtensions, (element)=>element.toJSON()
        );
        return _object;
    }
}
class Signature {
    constructor(parameters = {}){
        this.signatureAlgorithm = getParametersValue(parameters, "signatureAlgorithm", Signature.defaultValues("signatureAlgorithm"));
        this.signature = getParametersValue(parameters, "signature", Signature.defaultValues("signature"));
        if ("certs" in parameters) this.certs = getParametersValue(parameters, "certs", Signature.defaultValues("certs"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "signatureAlgorithm":
                return new AlgorithmIdentifier();
            case "signature":
                return new BitString();
            case "certs":
                return [];
            default:
                throw new Error(`Invalid member name for Signature class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "signatureAlgorithm":
                return memberValue.algorithmId === "" && "algorithmParams" in memberValue === false;
            case "signature":
                return memberValue.isEqual(Signature.defaultValues(memberName));
            case "certs":
                return memberValue.length === 0;
            default:
                throw new Error(`Invalid member name for Signature class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                AlgorithmIdentifier.schema(names.signatureAlgorithm || {}),
                new BitString({
                    name: names.signature || ""
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Sequence({
                            value: [
                                new Repeated({
                                    name: names.certs || "",
                                    value: Certificate.schema(names.certs || {})
                                })
                            ]
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "signatureAlgorithm",
            "signature",
            "certs"
        ]);
        const asn1 = compareSchema(schema, schema, Signature.schema({
            names: {
                signatureAlgorithm: {
                    names: {
                        blockName: "signatureAlgorithm"
                    }
                },
                signature: "signature",
                certs: "certs"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for Signature");
        this.signatureAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result.signatureAlgorithm
        });
        this.signature = asn1.result.signature;
        if ("certs" in asn1.result) this.certs = Array.from(asn1.result.certs, (element)=>new Certificate({
                schema: element
            })
        );
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(this.signatureAlgorithm.toSchema());
        outputArray.push(this.signature);
        if ("certs" in this) {
            outputArray.push(new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: [
                    new Sequence({
                        value: Array.from(this.certs, (element)=>element.toSchema()
                        )
                    })
                ]
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const _object = {
            signatureAlgorithm: this.signatureAlgorithm.toJSON(),
            signature: this.signature.toJSON()
        };
        if ("certs" in this) _object.certs = Array.from(this.certs, (element)=>element.toJSON()
        );
        return _object;
    }
}
class OCSPRequest {
    constructor(parameters = {}){
        this.tbsRequest = getParametersValue(parameters, "tbsRequest", OCSPRequest.defaultValues("tbsRequest"));
        if ("optionalSignature" in parameters) this.optionalSignature = getParametersValue(parameters, "optionalSignature", OCSPRequest.defaultValues("optionalSignature"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "tbsRequest":
                return new TBSRequest();
            case "optionalSignature":
                return new Signature();
            default:
                throw new Error(`Invalid member name for OCSPRequest class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "tbsRequest":
                return TBSRequest.compareWithDefault("tbs", memberValue.tbs) && TBSRequest.compareWithDefault("version", memberValue.version) && TBSRequest.compareWithDefault("requestorName", memberValue.requestorName) && TBSRequest.compareWithDefault("requestList", memberValue.requestList) && TBSRequest.compareWithDefault("requestExtensions", memberValue.requestExtensions);
            case "optionalSignature":
                return Signature.compareWithDefault("signatureAlgorithm", memberValue.signatureAlgorithm) && Signature.compareWithDefault("signature", memberValue.signature) && Signature.compareWithDefault("certs", memberValue.certs);
            default:
                throw new Error(`Invalid member name for OCSPRequest class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "OCSPRequest",
            value: [
                TBSRequest.schema(names.tbsRequest || {
                    names: {
                        blockName: "tbsRequest"
                    }
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        Signature.schema(names.optionalSignature || {
                            names: {
                                blockName: "optionalSignature"
                            }
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "tbsRequest",
            "optionalSignature"
        ]);
        const asn1 = compareSchema(schema, schema, OCSPRequest.schema());
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for OCSPRequest");
        this.tbsRequest = new TBSRequest({
            schema: asn1.result.tbsRequest
        });
        if ("optionalSignature" in asn1.result) this.optionalSignature = new Signature({
            schema: asn1.result.optionalSignature
        });
    }
    toSchema(encodeFlag = false) {
        const outputArray = [];
        outputArray.push(this.tbsRequest.toSchema(encodeFlag));
        if ("optionalSignature" in this) outputArray.push(this.optionalSignature.toSchema());
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const _object = {
            tbsRequest: this.tbsRequest.toJSON()
        };
        if ("optionalSignature" in this) _object.optionalSignature = this.optionalSignature.toJSON();
        return _object;
    }
    createForCertificate(certificate, parameters) {
        let sequence = Promise.resolve();
        const certID = new CertID();
        sequence = sequence.then(()=>certID.createForCertificate(certificate, parameters)
        );
        sequence = sequence.then(()=>{
            this.tbsRequest = new TBSRequest({
                requestList: [
                    new Request({
                        reqCert: certID
                    })
                ]
            });
        }, (error68)=>Promise.reject(error68)
        );
        return sequence;
    }
    sign(privateKey, hashAlgorithm = "SHA-1") {
        if (typeof privateKey === "undefined") return Promise.reject("Need to provide a private key for signing");
        if ("optionalSignature" in this === false) return Promise.reject("Need to create \"optionalSignature\" field before signing");
        let sequence = Promise.resolve();
        let parameters;
        let tbs;
        const engine9 = getEngine();
        sequence = sequence.then(()=>engine9.subtle.getSignatureParameters(privateKey, hashAlgorithm)
        );
        sequence = sequence.then((result)=>{
            parameters = result.parameters;
            this.optionalSignature.signatureAlgorithm = result.signatureAlgorithm;
        });
        sequence = sequence.then(()=>{
            tbs = this.tbsRequest.toSchema(true).toBER(false);
        });
        sequence = sequence.then(()=>engine9.subtle.signWithPrivateKey(tbs, privateKey, parameters)
        );
        sequence = sequence.then((result)=>{
            this.optionalSignature.signature = new BitString({
                valueHex: result
            });
        });
        return sequence;
    }
    verify() {}
}
class ResponseBytes {
    constructor(parameters = {}){
        this.responseType = getParametersValue(parameters, "responseType", ResponseBytes.defaultValues("responseType"));
        this.response = getParametersValue(parameters, "response", ResponseBytes.defaultValues("response"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "responseType":
                return "";
            case "response":
                return new OctetString();
            default:
                throw new Error(`Invalid member name for ResponseBytes class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "responseType":
                return memberValue === "";
            case "response":
                return memberValue.isEqual(ResponseBytes.defaultValues(memberName));
            default:
                throw new Error(`Invalid member name for ResponseBytes class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new ObjectIdentifier({
                    name: names.responseType || ""
                }),
                new OctetString({
                    name: names.response || ""
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "responseType",
            "response"
        ]);
        const asn1 = compareSchema(schema, schema, ResponseBytes.schema({
            names: {
                responseType: "responseType",
                response: "response"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for ResponseBytes");
        this.responseType = asn1.result.responseType.valueBlock.toString();
        this.response = asn1.result.response;
    }
    toSchema() {
        return new Sequence({
            value: [
                new ObjectIdentifier({
                    value: this.responseType
                }),
                this.response
            ]
        });
    }
    toJSON() {
        return {
            responseType: this.responseType,
            response: this.response.toJSON()
        };
    }
}
class OCSPResponse {
    constructor(parameters = {}){
        this.responseStatus = getParametersValue(parameters, "responseStatus", OCSPResponse.defaultValues("responseStatus"));
        if ("responseBytes" in parameters) this.responseBytes = getParametersValue(parameters, "responseBytes", OCSPResponse.defaultValues("responseBytes"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "responseStatus":
                return new Enumerated();
            case "responseBytes":
                return new ResponseBytes();
            default:
                throw new Error(`Invalid member name for OCSPResponse class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "responseStatus":
                return memberValue.isEqual(OCSPResponse.defaultValues(memberName));
            case "responseBytes":
                return ResponseBytes.compareWithDefault("responseType", memberValue.responseType) && ResponseBytes.compareWithDefault("response", memberValue.response);
            default:
                throw new Error(`Invalid member name for OCSPResponse class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "OCSPResponse",
            value: [
                new Enumerated({
                    name: names.responseStatus || "responseStatus"
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        ResponseBytes.schema(names.responseBytes || {
                            names: {
                                blockName: "responseBytes"
                            }
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "responseStatus",
            "responseBytes"
        ]);
        const asn1 = compareSchema(schema, schema, OCSPResponse.schema());
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for OCSPResponse");
        this.responseStatus = asn1.result.responseStatus;
        if ("responseBytes" in asn1.result) this.responseBytes = new ResponseBytes({
            schema: asn1.result.responseBytes
        });
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(this.responseStatus);
        if ("responseBytes" in this) {
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: [
                    this.responseBytes.toSchema()
                ]
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const _object = {
            responseStatus: this.responseStatus.toJSON()
        };
        if ("responseBytes" in this) _object.responseBytes = this.responseBytes.toJSON();
        return _object;
    }
    getCertificateStatus(certificate, issuerCertificate) {
        let basicResponse;
        const result = {
            isForCertificate: false,
            status: 2
        };
        if ("responseBytes" in this === false) return result;
        if (this.responseBytes.responseType !== "1.3.6.1.5.5.7.48.1.1") return result;
        try {
            const asn1Basic = fromBER(this.responseBytes.response.valueBlock.valueHex);
            basicResponse = new BasicOCSPResponse({
                schema: asn1Basic.result
            });
        } catch (ex) {
            return result;
        }
        return basicResponse.getCertificateStatus(certificate, issuerCertificate);
    }
    sign(privateKey, hashAlgorithm) {
        if (this.responseBytes.responseType === "1.3.6.1.5.5.7.48.1.1") {
            const asn1 = fromBER(this.responseBytes.response.valueBlock.valueHex);
            const basicResponse = new BasicOCSPResponse({
                schema: asn1.result
            });
            return basicResponse.sign(privateKey, hashAlgorithm);
        }
        return Promise.reject(`Unknown ResponseBytes type: ${this.responseBytes.responseType}`);
    }
    verify(issuerCertificate = null) {
        if ("responseBytes" in this === false) return Promise.reject("Empty ResponseBytes field");
        if (this.responseBytes.responseType === "1.3.6.1.5.5.7.48.1.1") {
            const asn1 = fromBER(this.responseBytes.response.valueBlock.valueHex);
            const basicResponse = new BasicOCSPResponse({
                schema: asn1.result
            });
            if (issuerCertificate !== null) {
                if ("certs" in basicResponse === false) basicResponse.certs = [];
                basicResponse.certs.push(issuerCertificate);
            }
            return basicResponse.verify();
        }
        return Promise.reject(`Unknown ResponseBytes type: ${this.responseBytes.responseType}`);
    }
}
class SignedAndUnsignedAttributes {
    constructor(parameters = {}){
        this.type = getParametersValue(parameters, "type", SignedAndUnsignedAttributes.defaultValues("type"));
        this.attributes = getParametersValue(parameters, "attributes", SignedAndUnsignedAttributes.defaultValues("attributes"));
        this.encodedValue = getParametersValue(parameters, "encodedValue", SignedAndUnsignedAttributes.defaultValues("encodedValue"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "type":
                return -1;
            case "attributes":
                return [];
            case "encodedValue":
                return new ArrayBuffer(0);
            default:
                throw new Error(`Invalid member name for SignedAndUnsignedAttributes class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "type":
                return memberValue === SignedAndUnsignedAttributes.defaultValues("type");
            case "attributes":
                return memberValue.length === 0;
            case "encodedValue":
                return memberValue.byteLength === 0;
            default:
                throw new Error(`Invalid member name for SignedAndUnsignedAttributes class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Constructed({
            name: names.blockName || "",
            optional: true,
            idBlock: {
                tagClass: 3,
                tagNumber: names.tagNumber
            },
            value: [
                new Repeated({
                    name: names.attributes || "",
                    value: Attribute.schema()
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "attributes"
        ]);
        const asn1 = compareSchema(schema, schema, SignedAndUnsignedAttributes.schema({
            names: {
                tagNumber: this.type,
                attributes: "attributes"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for SignedAndUnsignedAttributes");
        this.type = asn1.result.idBlock.tagNumber;
        this.encodedValue = asn1.result.valueBeforeDecode;
        const encodedView = new Uint8Array(this.encodedValue);
        encodedView[0] = 0x31;
        if ("attributes" in asn1.result === false) {
            if (this.type === 0) throw new Error("Wrong structure of SignedUnsignedAttributes");
            else return;
        }
        this.attributes = Array.from(asn1.result.attributes, (element)=>new Attribute({
                schema: element
            })
        );
    }
    toSchema() {
        if (SignedAndUnsignedAttributes.compareWithDefault("type", this.type) || SignedAndUnsignedAttributes.compareWithDefault("attributes", this.attributes)) throw new Error("Incorrectly initialized \"SignedAndUnsignedAttributes\" class");
        return new Constructed({
            optional: true,
            idBlock: {
                tagClass: 3,
                tagNumber: this.type
            },
            value: Array.from(this.attributes, (element)=>element.toSchema()
            )
        });
    }
    toJSON() {
        if (SignedAndUnsignedAttributes.compareWithDefault("type", this.type) || SignedAndUnsignedAttributes.compareWithDefault("attributes", this.attributes)) throw new Error("Incorrectly initialized \"SignedAndUnsignedAttributes\" class");
        return {
            type: this.type,
            attributes: Array.from(this.attributes, (element)=>element.toJSON()
            )
        };
    }
}
class SignerInfo {
    constructor(parameters = {}){
        this.version = getParametersValue(parameters, "version", SignerInfo.defaultValues("version"));
        this.sid = getParametersValue(parameters, "sid", SignerInfo.defaultValues("sid"));
        this.digestAlgorithm = getParametersValue(parameters, "digestAlgorithm", SignerInfo.defaultValues("digestAlgorithm"));
        if ("signedAttrs" in parameters) this.signedAttrs = getParametersValue(parameters, "signedAttrs", SignerInfo.defaultValues("signedAttrs"));
        this.signatureAlgorithm = getParametersValue(parameters, "signatureAlgorithm", SignerInfo.defaultValues("signatureAlgorithm"));
        this.signature = getParametersValue(parameters, "signature", SignerInfo.defaultValues("signature"));
        if ("unsignedAttrs" in parameters) this.unsignedAttrs = getParametersValue(parameters, "unsignedAttrs", SignerInfo.defaultValues("unsignedAttrs"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "version":
                return 0;
            case "sid":
                return new Any();
            case "digestAlgorithm":
                return new AlgorithmIdentifier();
            case "signedAttrs":
                return new SignedAndUnsignedAttributes({
                    type: 0
                });
            case "signatureAlgorithm":
                return new AlgorithmIdentifier();
            case "signature":
                return new OctetString();
            case "unsignedAttrs":
                return new SignedAndUnsignedAttributes({
                    type: 1
                });
            default:
                throw new Error(`Invalid member name for SignerInfo class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "version":
                return SignerInfo.defaultValues("version") === memberValue;
            case "sid":
                return memberValue instanceof Any;
            case "digestAlgorithm":
                if (memberValue instanceof AlgorithmIdentifier === false) return false;
                return memberValue.isEqual(SignerInfo.defaultValues("digestAlgorithm"));
            case "signedAttrs":
                return SignedAndUnsignedAttributes.compareWithDefault("type", memberValue.type) && SignedAndUnsignedAttributes.compareWithDefault("attributes", memberValue.attributes) && SignedAndUnsignedAttributes.compareWithDefault("encodedValue", memberValue.encodedValue);
            case "signatureAlgorithm":
                if (memberValue instanceof AlgorithmIdentifier === false) return false;
                return memberValue.isEqual(SignerInfo.defaultValues("signatureAlgorithm"));
            case "signature":
            case "unsignedAttrs":
                return SignedAndUnsignedAttributes.compareWithDefault("type", memberValue.type) && SignedAndUnsignedAttributes.compareWithDefault("attributes", memberValue.attributes) && SignedAndUnsignedAttributes.compareWithDefault("encodedValue", memberValue.encodedValue);
            default:
                throw new Error(`Invalid member name for SignerInfo class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: "SignerInfo",
            value: [
                new Integer({
                    name: names.version || "SignerInfo.version"
                }),
                new Choice({
                    value: [
                        IssuerAndSerialNumber.schema(names.sid || {
                            names: {
                                blockName: "SignerInfo.sid"
                            }
                        }),
                        new Constructed({
                            optional: true,
                            name: names.sid || "SignerInfo.sid",
                            idBlock: {
                                tagClass: 3,
                                tagNumber: 0
                            },
                            value: [
                                new OctetString()
                            ]
                        })
                    ]
                }),
                AlgorithmIdentifier.schema(names.digestAlgorithm || {
                    names: {
                        blockName: "SignerInfo.digestAlgorithm"
                    }
                }),
                SignedAndUnsignedAttributes.schema(names.signedAttrs || {
                    names: {
                        blockName: "SignerInfo.signedAttrs",
                        tagNumber: 0
                    }
                }),
                AlgorithmIdentifier.schema(names.signatureAlgorithm || {
                    names: {
                        blockName: "SignerInfo.signatureAlgorithm"
                    }
                }),
                new OctetString({
                    name: names.signature || "SignerInfo.signature"
                }),
                SignedAndUnsignedAttributes.schema(names.unsignedAttrs || {
                    names: {
                        blockName: "SignerInfo.unsignedAttrs",
                        tagNumber: 1
                    }
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "SignerInfo.version",
            "SignerInfo.sid",
            "SignerInfo.digestAlgorithm",
            "SignerInfo.signedAttrs",
            "SignerInfo.signatureAlgorithm",
            "SignerInfo.signature",
            "SignerInfo.unsignedAttrs"
        ]);
        const asn1 = compareSchema(schema, schema, SignerInfo.schema());
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for SignerInfo");
        this.version = asn1.result["SignerInfo.version"].valueBlock.valueDec;
        const currentSid = asn1.result["SignerInfo.sid"];
        if (currentSid.idBlock.tagClass === 1) this.sid = new IssuerAndSerialNumber({
            schema: currentSid
        });
        else this.sid = currentSid;
        this.digestAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result["SignerInfo.digestAlgorithm"]
        });
        if ("SignerInfo.signedAttrs" in asn1.result) this.signedAttrs = new SignedAndUnsignedAttributes({
            type: 0,
            schema: asn1.result["SignerInfo.signedAttrs"]
        });
        this.signatureAlgorithm = new AlgorithmIdentifier({
            schema: asn1.result["SignerInfo.signatureAlgorithm"]
        });
        this.signature = asn1.result["SignerInfo.signature"];
        if ("SignerInfo.unsignedAttrs" in asn1.result) this.unsignedAttrs = new SignedAndUnsignedAttributes({
            type: 1,
            schema: asn1.result["SignerInfo.unsignedAttrs"]
        });
    }
    toSchema() {
        if (SignerInfo.compareWithDefault("sid", this.sid)) throw new Error("Incorrectly initialized \"SignerInfo\" class");
        const outputArray = [];
        outputArray.push(new Integer({
            value: this.version
        }));
        if (this.sid instanceof IssuerAndSerialNumber) outputArray.push(this.sid.toSchema());
        else outputArray.push(this.sid);
        outputArray.push(this.digestAlgorithm.toSchema());
        if ("signedAttrs" in this) {
            if (SignerInfo.compareWithDefault("signedAttrs", this.signedAttrs) === false) outputArray.push(this.signedAttrs.toSchema());
        }
        outputArray.push(this.signatureAlgorithm.toSchema());
        outputArray.push(this.signature);
        if ("unsignedAttrs" in this) {
            if (SignerInfo.compareWithDefault("unsignedAttrs", this.unsignedAttrs) === false) outputArray.push(this.unsignedAttrs.toSchema());
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        if (SignerInfo.compareWithDefault("sid", this.sid)) throw new Error("Incorrectly initialized \"SignerInfo\" class");
        const _object = {
            version: this.version
        };
        if (!(this.sid instanceof Any)) _object.sid = this.sid.toJSON();
        _object.digestAlgorithm = this.digestAlgorithm.toJSON();
        if (SignerInfo.compareWithDefault("signedAttrs", this.signedAttrs) === false) _object.signedAttrs = this.signedAttrs.toJSON();
        _object.signatureAlgorithm = this.signatureAlgorithm.toJSON();
        _object.signature = this.signature.toJSON();
        if (SignerInfo.compareWithDefault("unsignedAttrs", this.unsignedAttrs) === false) _object.unsignedAttrs = this.unsignedAttrs.toJSON();
        return _object;
    }
}
class TSTInfo {
    constructor(parameters = {}){
        this.version = getParametersValue(parameters, "version", TSTInfo.defaultValues("version"));
        this.policy = getParametersValue(parameters, "policy", TSTInfo.defaultValues("policy"));
        this.messageImprint = getParametersValue(parameters, "messageImprint", TSTInfo.defaultValues("messageImprint"));
        this.serialNumber = getParametersValue(parameters, "serialNumber", TSTInfo.defaultValues("serialNumber"));
        this.genTime = getParametersValue(parameters, "genTime", TSTInfo.defaultValues("genTime"));
        if ("accuracy" in parameters) this.accuracy = getParametersValue(parameters, "accuracy", TSTInfo.defaultValues("accuracy"));
        if ("ordering" in parameters) this.ordering = getParametersValue(parameters, "ordering", TSTInfo.defaultValues("ordering"));
        if ("nonce" in parameters) this.nonce = getParametersValue(parameters, "nonce", TSTInfo.defaultValues("nonce"));
        if ("tsa" in parameters) this.tsa = getParametersValue(parameters, "tsa", TSTInfo.defaultValues("tsa"));
        if ("extensions" in parameters) this.extensions = getParametersValue(parameters, "extensions", TSTInfo.defaultValues("extensions"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "version":
                return 0;
            case "policy":
                return "";
            case "messageImprint":
                return new MessageImprint();
            case "serialNumber":
                return new Integer();
            case "genTime":
                return new Date(0, 0, 0);
            case "accuracy":
                return new Accuracy();
            case "ordering":
                return false;
            case "nonce":
                return new Integer();
            case "tsa":
                return new GeneralName();
            case "extensions":
                return [];
            default:
                throw new Error(`Invalid member name for TSTInfo class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "version":
            case "policy":
            case "genTime":
            case "ordering":
                return memberValue === TSTInfo.defaultValues(memberName);
            case "messageImprint":
                return MessageImprint.compareWithDefault("hashAlgorithm", memberValue.hashAlgorithm) && MessageImprint.compareWithDefault("hashedMessage", memberValue.hashedMessage);
            case "serialNumber":
            case "nonce":
                return memberValue.isEqual(TSTInfo.defaultValues(memberName));
            case "accuracy":
                return Accuracy.compareWithDefault("seconds", memberValue.seconds) && Accuracy.compareWithDefault("millis", memberValue.millis) && Accuracy.compareWithDefault("micros", memberValue.micros);
            case "tsa":
                return GeneralName.compareWithDefault("type", memberValue.type) && GeneralName.compareWithDefault("value", memberValue.value);
            case "extensions":
                return memberValue.length === 0;
            default:
                throw new Error(`Invalid member name for TSTInfo class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "TSTInfo",
            value: [
                new Integer({
                    name: names.version || "TSTInfo.version"
                }),
                new ObjectIdentifier({
                    name: names.policy || "TSTInfo.policy"
                }),
                MessageImprint.schema(names.messageImprint || {
                    names: {
                        blockName: "TSTInfo.messageImprint"
                    }
                }),
                new Integer({
                    name: names.serialNumber || "TSTInfo.serialNumber"
                }),
                new GeneralizedTime({
                    name: names.genTime || "TSTInfo.genTime"
                }),
                Accuracy.schema(names.accuracy || {
                    names: {
                        blockName: "TSTInfo.accuracy"
                    }
                }),
                new Boolean1({
                    name: names.ordering || "TSTInfo.ordering",
                    optional: true
                }),
                new Integer({
                    name: names.nonce || "TSTInfo.nonce",
                    optional: true
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        GeneralName.schema(names.tsa || {
                            names: {
                                blockName: "TSTInfo.tsa"
                            }
                        })
                    ]
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: [
                        new Repeated({
                            name: names.extensions || "TSTInfo.extensions",
                            value: Extension.schema(names.extension || {})
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "TSTInfo.version",
            "TSTInfo.policy",
            "TSTInfo.messageImprint",
            "TSTInfo.serialNumber",
            "TSTInfo.genTime",
            "TSTInfo.accuracy",
            "TSTInfo.ordering",
            "TSTInfo.nonce",
            "TSTInfo.tsa",
            "TSTInfo.extensions"
        ]);
        const asn1 = compareSchema(schema, schema, TSTInfo.schema());
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for TSTInfo");
        this.version = asn1.result["TSTInfo.version"].valueBlock.valueDec;
        this.policy = asn1.result["TSTInfo.policy"].valueBlock.toString();
        this.messageImprint = new MessageImprint({
            schema: asn1.result["TSTInfo.messageImprint"]
        });
        this.serialNumber = asn1.result["TSTInfo.serialNumber"];
        this.genTime = asn1.result["TSTInfo.genTime"].toDate();
        if ("TSTInfo.accuracy" in asn1.result) this.accuracy = new Accuracy({
            schema: asn1.result["TSTInfo.accuracy"]
        });
        if ("TSTInfo.ordering" in asn1.result) this.ordering = asn1.result["TSTInfo.ordering"].valueBlock.value;
        if ("TSTInfo.nonce" in asn1.result) this.nonce = asn1.result["TSTInfo.nonce"];
        if ("TSTInfo.tsa" in asn1.result) this.tsa = new GeneralName({
            schema: asn1.result["TSTInfo.tsa"]
        });
        if ("TSTInfo.extensions" in asn1.result) this.extensions = Array.from(asn1.result["TSTInfo.extensions"], (element)=>new Extension({
                schema: element
            })
        );
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(new Integer({
            value: this.version
        }));
        outputArray.push(new ObjectIdentifier({
            value: this.policy
        }));
        outputArray.push(this.messageImprint.toSchema());
        outputArray.push(this.serialNumber);
        outputArray.push(new GeneralizedTime({
            valueDate: this.genTime
        }));
        if ("accuracy" in this) outputArray.push(this.accuracy.toSchema());
        if ("ordering" in this) outputArray.push(new Boolean1({
            value: this.ordering
        }));
        if ("nonce" in this) outputArray.push(this.nonce);
        if ("tsa" in this) {
            outputArray.push(new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: [
                    this.tsa.toSchema()
                ]
            }));
        }
        if ("extensions" in this) {
            outputArray.push(new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                },
                value: Array.from(this.extensions, (element)=>element.toSchema()
                )
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const _object = {
            version: this.version,
            policy: this.policy,
            messageImprint: this.messageImprint.toJSON(),
            serialNumber: this.serialNumber.toJSON(),
            genTime: this.genTime
        };
        if ("accuracy" in this) _object.accuracy = this.accuracy.toJSON();
        if ("ordering" in this) _object.ordering = this.ordering;
        if ("nonce" in this) _object.nonce = this.nonce.toJSON();
        if ("tsa" in this) _object.tsa = this.tsa.toJSON();
        if ("extensions" in this) _object.extensions = Array.from(this.extensions, (element)=>element.toJSON()
        );
        return _object;
    }
    verify(parameters = {}) {
        let sequence = Promise.resolve();
        let data;
        let notBefore = null;
        let notAfter = null;
        const crypto = getCrypto();
        if (typeof crypto === "undefined") return Promise.reject("Unable to create WebCrypto object");
        if ("data" in parameters) data = parameters.data;
        else return Promise.reject("\"data\" is a mandatory attribute for TST_INFO verification");
        if ("notBefore" in parameters) notBefore = parameters.notBefore;
        if ("notAfter" in parameters) notAfter = parameters.notAfter;
        if (notBefore !== null) {
            if (this.genTime < notBefore) return Promise.reject("Generation time for TSTInfo object is less than notBefore value");
        }
        if (notAfter !== null) {
            if (this.genTime > notAfter) return Promise.reject("Generation time for TSTInfo object is more than notAfter value");
        }
        const shaAlgorithm = getAlgorithmByOID(this.messageImprint.hashAlgorithm.algorithmId);
        if ("name" in shaAlgorithm === false) return Promise.reject(`Unsupported signature algorithm: ${this.messageImprint.hashAlgorithm.algorithmId}`);
        sequence = sequence.then(()=>crypto.digest(shaAlgorithm.name, new Uint8Array(data))
        ).then((result)=>isEqualBuffer(result, this.messageImprint.hashedMessage.valueBlock.valueHex)
        );
        return sequence;
    }
}
class SignedData {
    constructor(parameters = {}){
        this.version = getParametersValue(parameters, "version", SignedData.defaultValues("version"));
        this.digestAlgorithms = getParametersValue(parameters, "digestAlgorithms", SignedData.defaultValues("digestAlgorithms"));
        this.encapContentInfo = getParametersValue(parameters, "encapContentInfo", SignedData.defaultValues("encapContentInfo"));
        if ("certificates" in parameters) this.certificates = getParametersValue(parameters, "certificates", SignedData.defaultValues("certificates"));
        if ("crls" in parameters) this.crls = getParametersValue(parameters, "crls", SignedData.defaultValues("crls"));
        if ("ocsps" in parameters) this.ocsps = getParametersValue(parameters, "ocsps", SignedData.defaultValues("ocsps"));
        this.signerInfos = getParametersValue(parameters, "signerInfos", SignedData.defaultValues("signerInfos"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "version":
                return 0;
            case "digestAlgorithms":
                return [];
            case "encapContentInfo":
                return new EncapsulatedContentInfo();
            case "certificates":
                return [];
            case "crls":
                return [];
            case "ocsps":
                return [];
            case "signerInfos":
                return [];
            default:
                throw new Error(`Invalid member name for SignedData class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "version":
                return memberValue === SignedData.defaultValues("version");
            case "encapContentInfo":
                return new EncapsulatedContentInfo();
            case "digestAlgorithms":
            case "certificates":
            case "crls":
            case "ocsps":
            case "signerInfos":
                return memberValue.length === 0;
            default:
                throw new Error(`Invalid member name for SignedData class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        if ("optional" in names === false) names.optional = false;
        return new Sequence({
            name: names.blockName || "SignedData",
            optional: names.optional,
            value: [
                new Integer({
                    name: names.version || "SignedData.version"
                }),
                new Set1({
                    value: [
                        new Repeated({
                            name: names.digestAlgorithms || "SignedData.digestAlgorithms",
                            value: AlgorithmIdentifier.schema()
                        })
                    ]
                }),
                EncapsulatedContentInfo.schema(names.encapContentInfo || {
                    names: {
                        blockName: "SignedData.encapContentInfo"
                    }
                }),
                new Constructed({
                    name: names.certificates || "SignedData.certificates",
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: CertificateSet.schema().valueBlock.value
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: RevocationInfoChoices.schema(names.crls || {
                        names: {
                            crls: "SignedData.crls"
                        }
                    }).valueBlock.value
                }),
                new Set1({
                    value: [
                        new Repeated({
                            name: names.signerInfos || "SignedData.signerInfos",
                            value: SignerInfo.schema()
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "SignedData.version",
            "SignedData.digestAlgorithms",
            "SignedData.encapContentInfo",
            "SignedData.certificates",
            "SignedData.crls",
            "SignedData.signerInfos"
        ]);
        const asn1 = compareSchema(schema, schema, SignedData.schema());
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for SignedData");
        this.version = asn1.result["SignedData.version"].valueBlock.valueDec;
        if ("SignedData.digestAlgorithms" in asn1.result) this.digestAlgorithms = Array.from(asn1.result["SignedData.digestAlgorithms"], (algorithm)=>new AlgorithmIdentifier({
                schema: algorithm
            })
        );
        this.encapContentInfo = new EncapsulatedContentInfo({
            schema: asn1.result["SignedData.encapContentInfo"]
        });
        if ("SignedData.certificates" in asn1.result) {
            const certificateSet = new CertificateSet({
                schema: new Set1({
                    value: asn1.result["SignedData.certificates"].valueBlock.value
                })
            });
            this.certificates = certificateSet.certificates.slice(0);
        }
        if ("SignedData.crls" in asn1.result) {
            this.crls = Array.from(asn1.result["SignedData.crls"], (crl)=>{
                if (crl.idBlock.tagClass === 1) return new CertificateRevocationList({
                    schema: crl
                });
                crl.idBlock.tagClass = 1;
                crl.idBlock.tagNumber = 16;
                return new OtherRevocationInfoFormat({
                    schema: crl
                });
            });
        }
        if ("SignedData.signerInfos" in asn1.result) this.signerInfos = Array.from(asn1.result["SignedData.signerInfos"], (signerInfoSchema)=>new SignerInfo({
                schema: signerInfoSchema
            })
        );
    }
    toSchema(encodeFlag = false) {
        const outputArray = [];
        outputArray.push(new Integer({
            value: this.version
        }));
        outputArray.push(new Set1({
            value: Array.from(this.digestAlgorithms, (algorithm)=>algorithm.toSchema(encodeFlag)
            )
        }));
        outputArray.push(this.encapContentInfo.toSchema());
        if ("certificates" in this) {
            const certificateSet = new CertificateSet({
                certificates: this.certificates
            });
            const certificateSetSchema = certificateSet.toSchema();
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: certificateSetSchema.valueBlock.value
            }));
        }
        if ("crls" in this) {
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                },
                value: Array.from(this.crls, (crl)=>{
                    if (crl instanceof OtherRevocationInfoFormat) {
                        const crlSchema = crl.toSchema(encodeFlag);
                        crlSchema.idBlock.tagClass = 3;
                        crlSchema.idBlock.tagNumber = 1;
                        return crlSchema;
                    }
                    return crl.toSchema(encodeFlag);
                })
            }));
        }
        outputArray.push(new Set1({
            value: Array.from(this.signerInfos, (signerInfo)=>signerInfo.toSchema(encodeFlag)
            )
        }));
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const _object = {
            version: this.version,
            digestAlgorithms: Array.from(this.digestAlgorithms, (algorithm)=>algorithm.toJSON()
            ),
            encapContentInfo: this.encapContentInfo.toJSON()
        };
        if ("certificates" in this) _object.certificates = Array.from(this.certificates, (certificate)=>certificate.toJSON()
        );
        if ("crls" in this) _object.crls = Array.from(this.crls, (crl)=>crl.toJSON()
        );
        _object.signerInfos = Array.from(this.signerInfos, (signerInfo)=>signerInfo.toJSON()
        );
        return _object;
    }
    verify({ signer =-1 , data =new ArrayBuffer(0) , trustedCerts =[] , checkDate =new Date() , checkChain =false , extendedMode =false , findOrigin =null , findIssuer =null  } = {}) {
        let sequence = Promise.resolve();
        let messageDigestValue = new ArrayBuffer(0);
        let shaAlgorithm = "";
        let signerCertificate = {};
        let timestampSerial = null;
        let certificatePath = [];
        const engine10 = getEngine();
        const crypto = getCrypto();
        if (typeof crypto === "undefined") return Promise.reject("Unable to create WebCrypto object");
        if (signer === -1) {
            if (extendedMode) {
                return Promise.reject({
                    date: checkDate,
                    code: 1,
                    message: "Unable to get signer index from input parameters",
                    signatureVerified: null,
                    signerCertificate: null,
                    signerCertificateVerified: null
                });
            }
            return Promise.reject("Unable to get signer index from input parameters");
        }
        if ("certificates" in this === false) {
            if (extendedMode) {
                return Promise.reject({
                    date: checkDate,
                    code: 2,
                    message: "No certificates attached to this signed data",
                    signatureVerified: null,
                    signerCertificate: null,
                    signerCertificateVerified: null
                });
            }
            return Promise.reject("No certificates attached to this signed data");
        }
        if (this.signerInfos[signer].sid instanceof IssuerAndSerialNumber) {
            sequence = sequence.then(()=>{
                for (const certificate of this.certificates){
                    if (certificate instanceof Certificate === false) continue;
                    if (certificate.issuer.isEqual(this.signerInfos[signer].sid.issuer) && certificate.serialNumber.isEqual(this.signerInfos[signer].sid.serialNumber)) {
                        signerCertificate = certificate;
                        return Promise.resolve();
                    }
                }
                if (extendedMode) {
                    return Promise.reject({
                        date: checkDate,
                        code: 3,
                        message: "Unable to find signer certificate",
                        signatureVerified: null,
                        signerCertificate: null,
                        signerCertificateVerified: null
                    });
                }
                return Promise.reject("Unable to find signer certificate");
            });
        } else {
            sequence = sequence.then(()=>Promise.all(Array.from(this.certificates.filter((certificate)=>certificate instanceof Certificate
                ), (certificate)=>crypto.digest({
                        name: "sha-1"
                    }, new Uint8Array(certificate.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex))
                )).then((results)=>{
                    for (const [index, certificate] of this.certificates.entries()){
                        if (certificate instanceof Certificate === false) continue;
                        if (isEqualBuffer(results[index], this.signerInfos[signer].sid.valueBlock.valueHex)) {
                            signerCertificate = certificate;
                            return Promise.resolve();
                        }
                    }
                    if (extendedMode) {
                        return Promise.reject({
                            date: checkDate,
                            code: 3,
                            message: "Unable to find signer certificate",
                            signatureVerified: null,
                            signerCertificate: null,
                            signerCertificateVerified: null
                        });
                    }
                    return Promise.reject("Unable to find signer certificate");
                }, ()=>{
                    if (extendedMode) {
                        return Promise.reject({
                            date: checkDate,
                            code: 3,
                            message: "Unable to find signer certificate",
                            signatureVerified: null,
                            signerCertificate: null,
                            signerCertificateVerified: null
                        });
                    }
                    return Promise.reject("Unable to find signer certificate");
                })
            );
        }
        sequence = sequence.then(()=>{
            if (this.encapContentInfo.eContentType === "1.2.840.113549.1.9.16.1.4") {
                if ("eContent" in this.encapContentInfo === false) return false;
                const asn1 = fromBER(this.encapContentInfo.eContent.valueBlock.valueHex);
                let tstInfo;
                try {
                    tstInfo = new TSTInfo({
                        schema: asn1.result
                    });
                } catch (ex) {
                    return false;
                }
                checkDate = tstInfo.genTime;
                timestampSerial = tstInfo.serialNumber.valueBlock.valueHex;
                if (data.byteLength === 0) {
                    if (extendedMode) {
                        return Promise.reject({
                            date: checkDate,
                            code: 4,
                            message: "Missed detached data input array",
                            signatureVerified: null,
                            signerCertificate,
                            signerCertificateVerified: null
                        });
                    }
                    return Promise.reject("Missed detached data input array");
                }
                return tstInfo.verify({
                    data
                });
            }
            return true;
        });
        function checkCA(cert) {
            if (cert.issuer.isEqual(signerCertificate.issuer) === true && cert.serialNumber.isEqual(signerCertificate.serialNumber) === true) return null;
            let isCA = false;
            if ("extensions" in cert) {
                for (const extension of cert.extensions){
                    if (extension.extnID === "2.5.29.19") {
                        if ("cA" in extension.parsedValue) {
                            if (extension.parsedValue.cA === true) isCA = true;
                        }
                    }
                }
            }
            if (isCA) return cert;
            return null;
        }
        if (checkChain) {
            sequence = sequence.then((result)=>{
                if (result === false) return false;
                const promiseResults = Array.from(this.certificates.filter((certificate)=>certificate instanceof Certificate
                ), (certificate)=>checkCA(certificate)
                );
                const certificateChainValidationEngineParameters = {
                    checkDate,
                    certs: Array.from(promiseResults.filter((_result)=>_result !== null
                    )),
                    trustedCerts
                };
                if (findIssuer !== null) certificateChainValidationEngineParameters.findIssuer = findIssuer;
                if (findOrigin !== null) certificateChainValidationEngineParameters.findOrigin = findOrigin;
                const certificateChainEngine = new CertificateChainValidationEngine(certificateChainValidationEngineParameters);
                certificateChainEngine.certs.push(signerCertificate);
                if ("crls" in this) {
                    for (const crl of this.crls){
                        if (crl instanceof CertificateRevocationList) certificateChainEngine.crls.push(crl);
                        else {
                            if (crl.otherRevInfoFormat === "1.3.6.1.5.5.7.48.1.1") certificateChainEngine.ocsps.push(new BasicOCSPResponse({
                                schema: crl.otherRevInfo
                            }));
                        }
                    }
                }
                if ("ocsps" in this) certificateChainEngine.ocsps.push(...this.ocsps);
                return certificateChainEngine.verify().then((verificationResult)=>{
                    if ("certificatePath" in verificationResult) certificatePath = verificationResult.certificatePath;
                    if (verificationResult.result === true) return Promise.resolve(true);
                    if (extendedMode) {
                        return Promise.reject({
                            date: checkDate,
                            code: 5,
                            message: `Validation of signer's certificate failed: ${verificationResult.resultMessage}`,
                            signatureVerified: null,
                            signerCertificate,
                            signerCertificateVerified: false
                        });
                    }
                    return Promise.reject("Validation of signer's certificate failed");
                }, (error69)=>{
                    if (extendedMode) {
                        return Promise.reject({
                            date: checkDate,
                            code: 5,
                            message: `Validation of signer's certificate failed with error: ${error69 instanceof Object ? error69.resultMessage : error69}`,
                            signatureVerified: null,
                            signerCertificate,
                            signerCertificateVerified: false
                        });
                    }
                    return Promise.reject(`Validation of signer's certificate failed with error: ${error69 instanceof Object ? error69.resultMessage : error69}`);
                });
            });
        }
        sequence = sequence.then((result)=>{
            if (result === false) return false;
            const signerInfoHashAlgorithm = getAlgorithmByOID(this.signerInfos[signer].digestAlgorithm.algorithmId);
            if ("name" in signerInfoHashAlgorithm === false) {
                if (extendedMode) {
                    return Promise.reject({
                        date: checkDate,
                        code: 7,
                        message: `Unsupported signature algorithm: ${this.signerInfos[signer].digestAlgorithm.algorithmId}`,
                        signatureVerified: null,
                        signerCertificate,
                        signerCertificateVerified: true
                    });
                }
                return Promise.reject(`Unsupported signature algorithm: ${this.signerInfos[signer].digestAlgorithm.algorithmId}`);
            }
            shaAlgorithm = signerInfoHashAlgorithm.name;
            return true;
        });
        sequence = sequence.then((result)=>{
            if (result === false) return false;
            if ("eContent" in this.encapContentInfo) {
                if (this.encapContentInfo.eContent.idBlock.tagClass === 1 && this.encapContentInfo.eContent.idBlock.tagNumber === 4) {
                    if (this.encapContentInfo.eContent.idBlock.isConstructed === false) data = this.encapContentInfo.eContent.valueBlock.valueHex;
                    else {
                        for (const contentValue of this.encapContentInfo.eContent.valueBlock.value)data = utilConcatBuf(data, contentValue.valueBlock.valueHex);
                    }
                } else data = this.encapContentInfo.eContent.valueBlock.valueBeforeDecode;
            } else {
                if (data.byteLength === 0) {
                    if (extendedMode) {
                        return Promise.reject({
                            date: checkDate,
                            code: 8,
                            message: "Missed detached data input array",
                            signatureVerified: null,
                            signerCertificate,
                            signerCertificateVerified: true
                        });
                    }
                    return Promise.reject("Missed detached data input array");
                }
            }
            if ("signedAttrs" in this.signerInfos[signer]) {
                let foundContentType = false;
                let foundMessageDigest = false;
                for (const attribute of this.signerInfos[signer].signedAttrs.attributes){
                    if (attribute.type === "1.2.840.113549.1.9.3") foundContentType = true;
                    if (attribute.type === "1.2.840.113549.1.9.4") {
                        foundMessageDigest = true;
                        messageDigestValue = attribute.values[0].valueBlock.valueHex;
                    }
                    if (foundContentType && foundMessageDigest) break;
                }
                if (foundContentType === false) {
                    if (extendedMode) {
                        return Promise.reject({
                            date: checkDate,
                            code: 9,
                            message: "Attribute \"content-type\" is a mandatory attribute for \"signed attributes\"",
                            signatureVerified: null,
                            signerCertificate,
                            signerCertificateVerified: true
                        });
                    }
                    return Promise.reject("Attribute \"content-type\" is a mandatory attribute for \"signed attributes\"");
                }
                if (foundMessageDigest === false) {
                    if (extendedMode) {
                        return Promise.reject({
                            date: checkDate,
                            code: 10,
                            message: "Attribute \"message-digest\" is a mandatory attribute for \"signed attributes\"",
                            signatureVerified: null,
                            signerCertificate,
                            signerCertificateVerified: true
                        });
                    }
                    return Promise.reject("Attribute \"message-digest\" is a mandatory attribute for \"signed attributes\"");
                }
            }
            return true;
        });
        sequence = sequence.then((result)=>{
            if (result === false) return false;
            if ("signedAttrs" in this.signerInfos[signer]) return crypto.digest(shaAlgorithm, new Uint8Array(data));
            return true;
        }).then((result)=>{
            if (result === false) return false;
            if ("signedAttrs" in this.signerInfos[signer]) {
                if (isEqualBuffer(result, messageDigestValue)) {
                    data = this.signerInfos[signer].signedAttrs.encodedValue;
                    return true;
                }
                return false;
            }
            return true;
        });
        sequence = sequence.then((result)=>{
            if (result === false) return false;
            return engine10.subtle.verifyWithPublicKey(data, this.signerInfos[signer].signature, signerCertificate.subjectPublicKeyInfo, signerCertificate.signatureAlgorithm, shaAlgorithm);
        });
        sequence = sequence.then((result)=>{
            if (extendedMode) {
                return {
                    date: checkDate,
                    code: 14,
                    message: "",
                    signatureVerified: result,
                    signerCertificate,
                    timestampSerial,
                    signerCertificateVerified: true,
                    certificatePath
                };
            }
            return result;
        }, (error70)=>{
            if (extendedMode) {
                if ("code" in error70) return Promise.reject(error70);
                return Promise.reject({
                    date: checkDate,
                    code: 15,
                    message: `Error during verification: ${error70.message}`,
                    signatureVerified: null,
                    signerCertificate,
                    timestampSerial,
                    signerCertificateVerified: true
                });
            }
            return Promise.reject(error70);
        });
        return sequence;
    }
    sign(privateKey, signerIndex, hashAlgorithm = "SHA-1", data = new ArrayBuffer(0)) {
        if (typeof privateKey === "undefined") return Promise.reject("Need to provide a private key for signing");
        let sequence = Promise.resolve();
        let parameters;
        const engine11 = getEngine();
        const hashAlgorithmOID = getOIDByAlgorithm({
            name: hashAlgorithm
        });
        if (hashAlgorithmOID === "") return Promise.reject(`Unsupported hash algorithm: ${hashAlgorithm}`);
        if (this.digestAlgorithms.filter((algorithm)=>algorithm.algorithmId === hashAlgorithmOID
        ).length === 0) {
            this.digestAlgorithms.push(new AlgorithmIdentifier({
                algorithmId: hashAlgorithmOID,
                algorithmParams: new Null()
            }));
        }
        this.signerInfos[signerIndex].digestAlgorithm = new AlgorithmIdentifier({
            algorithmId: hashAlgorithmOID,
            algorithmParams: new Null()
        });
        sequence = sequence.then(()=>engine11.subtle.getSignatureParameters(privateKey, hashAlgorithm)
        );
        sequence = sequence.then((result)=>{
            parameters = result.parameters;
            this.signerInfos[signerIndex].signatureAlgorithm = result.signatureAlgorithm;
        });
        sequence = sequence.then(()=>{
            if ("signedAttrs" in this.signerInfos[signerIndex]) {
                if (this.signerInfos[signerIndex].signedAttrs.encodedValue.byteLength !== 0) data = this.signerInfos[signerIndex].signedAttrs.encodedValue;
                else {
                    data = this.signerInfos[signerIndex].signedAttrs.toSchema(true).toBER(false);
                    const view = new Uint8Array(data);
                    view[0] = 0x31;
                }
            } else {
                if ("eContent" in this.encapContentInfo) {
                    if (this.encapContentInfo.eContent.idBlock.tagClass === 1 && this.encapContentInfo.eContent.idBlock.tagNumber === 4) {
                        if (this.encapContentInfo.eContent.idBlock.isConstructed === false) data = this.encapContentInfo.eContent.valueBlock.valueHex;
                        else {
                            for (const content of this.encapContentInfo.eContent.valueBlock.value)data = utilConcatBuf(data, content.valueBlock.valueHex);
                        }
                    } else data = this.encapContentInfo.eContent.valueBlock.valueBeforeDecode;
                } else {
                    if (data.byteLength === 0) return Promise.reject("Missed detached data input array");
                }
            }
            return Promise.resolve();
        });
        sequence = sequence.then(()=>engine11.subtle.signWithPrivateKey(data, privateKey, parameters)
        );
        sequence = sequence.then((result)=>{
            this.signerInfos[signerIndex].signature = new OctetString({
                valueHex: result
            });
            return result;
        });
        return sequence;
    }
}
class PFX {
    constructor(parameters = {}){
        this.version = getParametersValue(parameters, "version", PFX.defaultValues("version"));
        this.authSafe = getParametersValue(parameters, "authSafe", PFX.defaultValues("authSafe"));
        if ("macData" in parameters) this.macData = getParametersValue(parameters, "macData", PFX.defaultValues("macData"));
        if ("parsedValue" in parameters) this.parsedValue = getParametersValue(parameters, "parsedValue", PFX.defaultValues("parsedValue"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "version":
                return 3;
            case "authSafe":
                return new ContentInfo();
            case "macData":
                return new MacData();
            case "parsedValue":
                return {};
            default:
                throw new Error(`Invalid member name for PFX class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "version":
                return memberValue === PFX.defaultValues(memberName);
            case "authSafe":
                return ContentInfo.compareWithDefault("contentType", memberValue.contentType) && ContentInfo.compareWithDefault("content", memberValue.content);
            case "macData":
                return MacData.compareWithDefault("mac", memberValue.mac) && MacData.compareWithDefault("macSalt", memberValue.macSalt) && MacData.compareWithDefault("iterations", memberValue.iterations);
            case "parsedValue":
                return memberValue instanceof Object && Object.keys(memberValue).length === 0;
            default:
                throw new Error(`Invalid member name for PFX class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Integer({
                    name: names.version || "version"
                }),
                ContentInfo.schema(names.authSafe || {
                    names: {
                        blockName: "authSafe"
                    }
                }),
                MacData.schema(names.macData || {
                    names: {
                        blockName: "macData",
                        optional: true
                    }
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "version",
            "authSafe",
            "macData"
        ]);
        const asn1 = compareSchema(schema, schema, PFX.schema({
            names: {
                version: "version",
                authSafe: {
                    names: {
                        blockName: "authSafe"
                    }
                },
                macData: {
                    names: {
                        blockName: "macData"
                    }
                }
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PFX");
        this.version = asn1.result.version.valueBlock.valueDec;
        this.authSafe = new ContentInfo({
            schema: asn1.result.authSafe
        });
        if ("macData" in asn1.result) this.macData = new MacData({
            schema: asn1.result.macData
        });
    }
    toSchema() {
        const outputArray = [
            new Integer({
                value: this.version
            }),
            this.authSafe.toSchema()
        ];
        if ("macData" in this) outputArray.push(this.macData.toSchema());
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const output = {
            version: this.version,
            authSafe: this.authSafe.toJSON()
        };
        if ("macData" in this) output.macData = this.macData.toJSON();
        return output;
    }
    makeInternalValues(parameters = {}) {
        if (parameters instanceof Object === false) return Promise.reject("The \"parameters\" must has \"Object\" type");
        if ("parsedValue" in this === false) return Promise.reject("Please call \"parseValues\" function first in order to make \"parsedValue\" data");
        if ("integrityMode" in this.parsedValue === false) return Promise.reject("Absent mandatory parameter \"integrityMode\" inside \"parsedValue\"");
        let sequence = Promise.resolve();
        const crypto = getCrypto();
        if (typeof crypto === "undefined") return Promise.reject("Unable to create WebCrypto object");
        if ("authenticatedSafe" in this.parsedValue === false) return Promise.reject("Absent mandatory parameter \"authenticatedSafe\" in \"parsedValue\"");
        switch(this.parsedValue.integrityMode){
            case 0:
                {
                    if ("iterations" in parameters === false) return Promise.reject("Absent mandatory parameter \"iterations\"");
                    if ("pbkdf2HashAlgorithm" in parameters === false) return Promise.reject("Absent mandatory parameter \"pbkdf2HashAlgorithm\"");
                    if ("hmacHashAlgorithm" in parameters === false) return Promise.reject("Absent mandatory parameter \"hmacHashAlgorithm\"");
                    if ("password" in parameters === false) return Promise.reject("Absent mandatory parameter \"password\"");
                    const saltBuffer = new ArrayBuffer(64);
                    const saltView = new Uint8Array(saltBuffer);
                    getRandomValues(saltView);
                    const data = this.parsedValue.authenticatedSafe.toSchema().toBER(false);
                    this.authSafe = new ContentInfo({
                        contentType: "1.2.840.113549.1.7.1",
                        content: new OctetString({
                            valueHex: data
                        })
                    });
                    const engine12 = getEngine();
                    if ("stampDataWithPassword" in engine12.subtle === false) return Promise.reject(`No support for "stampDataWithPassword" in current engine "${engine12.name}"`);
                    sequence = sequence.then(()=>engine12.subtle.stampDataWithPassword({
                            password: parameters.password,
                            hashAlgorithm: parameters.hmacHashAlgorithm,
                            salt: saltBuffer,
                            iterationCount: parameters.iterations,
                            contentToStamp: data
                        })
                    );
                    sequence = sequence.then((result)=>{
                        this.macData = new MacData({
                            mac: new DigestInfo({
                                digestAlgorithm: new AlgorithmIdentifier({
                                    algorithmId: getOIDByAlgorithm({
                                        name: parameters.hmacHashAlgorithm
                                    })
                                }),
                                digest: new OctetString({
                                    valueHex: result
                                })
                            }),
                            macSalt: new OctetString({
                                valueHex: saltBuffer
                            }),
                            iterations: parameters.iterations
                        });
                    }, (error71)=>Promise.reject(error71)
                    );
                }
                break;
            case 1:
                {
                    if ("signingCertificate" in parameters === false) return Promise.reject("Absent mandatory parameter \"signingCertificate\"");
                    if ("privateKey" in parameters === false) return Promise.reject("Absent mandatory parameter \"privateKey\"");
                    if ("hashAlgorithm" in parameters === false) return Promise.reject("Absent mandatory parameter \"hashAlgorithm\"");
                    const toBeSigned = this.parsedValue.authenticatedSafe.toSchema().toBER(false);
                    const cmsSigned = new SignedData({
                        version: 1,
                        encapContentInfo: new EncapsulatedContentInfo({
                            eContentType: "1.2.840.113549.1.7.1",
                            eContent: new OctetString({
                                valueHex: toBeSigned
                            })
                        }),
                        certificates: [
                            parameters.signingCertificate
                        ]
                    });
                    sequence = sequence.then(()=>crypto.digest({
                            name: parameters.hashAlgorithm
                        }, new Uint8Array(toBeSigned))
                    );
                    sequence = sequence.then((result)=>{
                        const signedAttr = [];
                        signedAttr.push(new Attribute({
                            type: "1.2.840.113549.1.9.3",
                            values: [
                                new ObjectIdentifier({
                                    value: "1.2.840.113549.1.7.1"
                                })
                            ]
                        }));
                        signedAttr.push(new Attribute({
                            type: "1.2.840.113549.1.9.5",
                            values: [
                                new UTCTime({
                                    valueDate: new Date()
                                })
                            ]
                        }));
                        signedAttr.push(new Attribute({
                            type: "1.2.840.113549.1.9.4",
                            values: [
                                new OctetString({
                                    valueHex: result
                                })
                            ]
                        }));
                        cmsSigned.signerInfos.push(new SignerInfo({
                            version: 1,
                            sid: new IssuerAndSerialNumber({
                                issuer: parameters.signingCertificate.issuer,
                                serialNumber: parameters.signingCertificate.serialNumber
                            }),
                            signedAttrs: new SignedAndUnsignedAttributes({
                                type: 0,
                                attributes: signedAttr
                            })
                        }));
                    }, (error72)=>Promise.reject(`Error during making digest for message: ${error72}`)
                    );
                    sequence = sequence.then(()=>cmsSigned.sign(parameters.privateKey, 0, parameters.hashAlgorithm)
                    );
                    sequence = sequence.then(()=>{
                        this.authSafe = new ContentInfo({
                            contentType: "1.2.840.113549.1.7.2",
                            content: cmsSigned.toSchema(true)
                        });
                    }, (error73)=>Promise.reject(`Error during making signature: ${error73}`)
                    );
                }
                break;
            default:
                return Promise.reject(`Parameter "integrityMode" has unknown value: ${parameters.integrityMode}`);
        }
        return sequence;
    }
    parseInternalValues(parameters) {
        if (parameters instanceof Object === false) return Promise.reject("The \"parameters\" must has \"Object\" type");
        if ("checkIntegrity" in parameters === false) parameters.checkIntegrity = true;
        let sequence = Promise.resolve();
        const crypto = getCrypto();
        if (typeof crypto === "undefined") return Promise.reject("Unable to create WebCrypto object");
        this.parsedValue = {};
        switch(this.authSafe.contentType){
            case "1.2.840.113549.1.7.1":
                {
                    if ("password" in parameters === false) return Promise.reject("Absent mandatory parameter \"password\"");
                    this.parsedValue.integrityMode = 0;
                    if (this.authSafe.content instanceof OctetString === false) return Promise.reject("Wrong type of \"this.authSafe.content\"");
                    let authSafeContent = new ArrayBuffer(0);
                    if (this.authSafe.content.valueBlock.isConstructed) {
                        for (const contentValue of this.authSafe.content.valueBlock.value)authSafeContent = utilConcatBuf(authSafeContent, contentValue.valueBlock.valueHex);
                    } else authSafeContent = this.authSafe.content.valueBlock.valueHex;
                    const asn1 = fromBER(authSafeContent);
                    if (asn1.offset === -1) return Promise.reject("Error during parsing of ASN.1 data inside \"this.authSafe.content\"");
                    this.parsedValue.authenticatedSafe = new AuthenticatedSafe({
                        schema: asn1.result
                    });
                    if (parameters.checkIntegrity) {
                        if ("macData" in this === false) return Promise.reject("Absent \"macData\" value, can not check PKCS#12 data integrity");
                        const hashAlgorithm = getAlgorithmByOID(this.macData.mac.digestAlgorithm.algorithmId);
                        if ("name" in hashAlgorithm === false) return Promise.reject(`Unsupported digest algorithm: ${this.macData.mac.digestAlgorithm.algorithmId}`);
                        const engine13 = getEngine();
                        sequence = sequence.then(()=>engine13.subtle.verifyDataStampedWithPassword({
                                password: parameters.password,
                                hashAlgorithm: hashAlgorithm.name,
                                salt: this.macData.macSalt.valueBlock.valueHex,
                                iterationCount: this.macData.iterations,
                                contentToVerify: authSafeContent,
                                signatureToVerify: this.macData.mac.digest.valueBlock.valueHex
                            })
                        );
                        sequence = sequence.then((result)=>{
                            if (result === false) return Promise.reject("Integrity for the PKCS#12 data is broken!");
                            return Promise.resolve();
                        }, (error74)=>Promise.reject(error74)
                        );
                    }
                }
                break;
            case "1.2.840.113549.1.7.2":
                {
                    this.parsedValue.integrityMode = 1;
                    const cmsSigned = new SignedData({
                        schema: this.authSafe.content
                    });
                    if ("eContent" in cmsSigned.encapContentInfo === false) return Promise.reject("Absent of attached data in \"cmsSigned.encapContentInfo\"");
                    if (cmsSigned.encapContentInfo.eContent instanceof OctetString === false) return Promise.reject("Wrong type of \"cmsSigned.encapContentInfo.eContent\"");
                    let data = new ArrayBuffer(0);
                    if (cmsSigned.encapContentInfo.eContent.idBlock.isConstructed === false) data = cmsSigned.encapContentInfo.eContent.valueBlock.valueHex;
                    else {
                        for(let i193 = 0; i193 < cmsSigned.encapContentInfo.eContent.valueBlock.value.length; i193++)data = utilConcatBuf(data, cmsSigned.encapContentInfo.eContent.valueBlock.value[i193].valueBlock.valueHex);
                    }
                    const asn1 = fromBER(data);
                    if (asn1.offset === -1) return Promise.reject("Error during parsing of ASN.1 data inside \"this.authSafe.content\"");
                    this.parsedValue.authenticatedSafe = new AuthenticatedSafe({
                        schema: asn1.result
                    });
                    sequence = sequence.then(()=>cmsSigned.verify({
                            signer: 0,
                            checkChain: false
                        })
                    ).then((result)=>{
                        if (result === false) return Promise.reject("Integrity for the PKCS#12 data is broken!");
                        return Promise.resolve();
                    }, (error75)=>Promise.reject(`Error during integrity verification: ${error75}`)
                    );
                }
                break;
            default:
                return Promise.reject(`Incorrect value for "this.authSafe.contentType": ${this.authSafe.contentType}`);
        }
        return sequence.then(()=>this
        , (error76)=>Promise.reject(`Error during parsing: ${error76}`)
        );
    }
}
class PKIStatusInfo {
    constructor(parameters = {}){
        this.status = getParametersValue(parameters, "status", PKIStatusInfo.defaultValues("status"));
        if ("statusStrings" in parameters) this.statusStrings = getParametersValue(parameters, "statusStrings", PKIStatusInfo.defaultValues("statusStrings"));
        if ("failInfo" in parameters) this.failInfo = getParametersValue(parameters, "failInfo", PKIStatusInfo.defaultValues("failInfo"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "status":
                return 2;
            case "statusStrings":
                return [];
            case "failInfo":
                return new BitString();
            default:
                throw new Error(`Invalid member name for PKIStatusInfo class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "status":
                return memberValue === PKIStatusInfo.defaultValues(memberName);
            case "statusStrings":
                return memberValue.length === 0;
            case "failInfo":
                return memberValue.isEqual(PKIStatusInfo.defaultValues(memberName));
            default:
                throw new Error(`Invalid member name for PKIStatusInfo class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "",
            value: [
                new Integer({
                    name: names.status || ""
                }),
                new Sequence({
                    optional: true,
                    value: [
                        new Repeated({
                            name: names.statusStrings || "",
                            value: new Utf8String()
                        })
                    ]
                }),
                new BitString({
                    name: names.failInfo || "",
                    optional: true
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "status",
            "statusStrings",
            "failInfo"
        ]);
        const asn1 = compareSchema(schema, schema, PKIStatusInfo.schema({
            names: {
                status: "status",
                statusStrings: "statusStrings",
                failInfo: "failInfo"
            }
        }));
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for PKIStatusInfo");
        const _status = asn1.result.status;
        if (_status.valueBlock.isHexOnly === true || _status.valueBlock.valueDec < 0 || _status.valueBlock.valueDec > 5) throw new Error("PKIStatusInfo \"status\" has invalid value");
        this.status = _status.valueBlock.valueDec;
        if ("statusStrings" in asn1.result) this.statusStrings = asn1.result.statusStrings;
        if ("failInfo" in asn1.result) this.failInfo = asn1.result.failInfo;
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(new Integer({
            value: this.status
        }));
        if ("statusStrings" in this) {
            outputArray.push(new Sequence({
                optional: true,
                value: this.statusStrings
            }));
        }
        if ("failInfo" in this) outputArray.push(this.failInfo);
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const _object = {
            status: this.status
        };
        if ("statusStrings" in this) _object.statusStrings = Array.from(this.statusStrings, (element)=>element.toJSON()
        );
        if ("failInfo" in this) _object.failInfo = this.failInfo.toJSON();
        return _object;
    }
}
class TimeStampReq {
    constructor(parameters = {}){
        this.version = getParametersValue(parameters, "version", TimeStampReq.defaultValues("version"));
        this.messageImprint = getParametersValue(parameters, "messageImprint", TimeStampReq.defaultValues("messageImprint"));
        if ("reqPolicy" in parameters) this.reqPolicy = getParametersValue(parameters, "reqPolicy", TimeStampReq.defaultValues("reqPolicy"));
        if ("nonce" in parameters) this.nonce = getParametersValue(parameters, "nonce", TimeStampReq.defaultValues("nonce"));
        if ("certReq" in parameters) this.certReq = getParametersValue(parameters, "certReq", TimeStampReq.defaultValues("certReq"));
        if ("extensions" in parameters) this.extensions = getParametersValue(parameters, "extensions", TimeStampReq.defaultValues("extensions"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "version":
                return 0;
            case "messageImprint":
                return new MessageImprint();
            case "reqPolicy":
                return "";
            case "nonce":
                return new Integer();
            case "certReq":
                return false;
            case "extensions":
                return [];
            default:
                throw new Error(`Invalid member name for TimeStampReq class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "version":
            case "reqPolicy":
            case "certReq":
                return memberValue === TimeStampReq.defaultValues(memberName);
            case "messageImprint":
                return MessageImprint.compareWithDefault("hashAlgorithm", memberValue.hashAlgorithm) && MessageImprint.compareWithDefault("hashedMessage", memberValue.hashedMessage);
            case "nonce":
                return memberValue.isEqual(TimeStampReq.defaultValues(memberName));
            case "extensions":
                return memberValue.length === 0;
            default:
                throw new Error(`Invalid member name for TimeStampReq class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "TimeStampReq",
            value: [
                new Integer({
                    name: names.version || "TimeStampReq.version"
                }),
                MessageImprint.schema(names.messageImprint || {
                    names: {
                        blockName: "TimeStampReq.messageImprint"
                    }
                }),
                new ObjectIdentifier({
                    name: names.reqPolicy || "TimeStampReq.reqPolicy",
                    optional: true
                }),
                new Integer({
                    name: names.nonce || "TimeStampReq.nonce",
                    optional: true
                }),
                new Boolean1({
                    name: names.certReq || "TimeStampReq.certReq",
                    optional: true
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Repeated({
                            name: names.extensions || "TimeStampReq.extensions",
                            value: Extension.schema()
                        })
                    ]
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "TimeStampReq.version",
            "TimeStampReq.messageImprint",
            "TimeStampReq.reqPolicy",
            "TimeStampReq.nonce",
            "TimeStampReq.certReq",
            "TimeStampReq.extensions"
        ]);
        const asn1 = compareSchema(schema, schema, TimeStampReq.schema());
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for TimeStampReq");
        this.version = asn1.result["TimeStampReq.version"].valueBlock.valueDec;
        this.messageImprint = new MessageImprint({
            schema: asn1.result["TimeStampReq.messageImprint"]
        });
        if ("TimeStampReq.reqPolicy" in asn1.result) this.reqPolicy = asn1.result["TimeStampReq.reqPolicy"].valueBlock.toString();
        if ("TimeStampReq.nonce" in asn1.result) this.nonce = asn1.result["TimeStampReq.nonce"];
        if ("TimeStampReq.certReq" in asn1.result) this.certReq = asn1.result["TimeStampReq.certReq"].valueBlock.value;
        if ("TimeStampReq.extensions" in asn1.result) this.extensions = Array.from(asn1.result["TimeStampReq.extensions"], (element)=>new Extension({
                schema: element
            })
        );
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(new Integer({
            value: this.version
        }));
        outputArray.push(this.messageImprint.toSchema());
        if ("reqPolicy" in this) outputArray.push(new ObjectIdentifier({
            value: this.reqPolicy
        }));
        if ("nonce" in this) outputArray.push(this.nonce);
        if ("certReq" in this && TimeStampReq.compareWithDefault("certReq", this.certReq) === false) outputArray.push(new Boolean1({
            value: this.certReq
        }));
        if ("extensions" in this) {
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: Array.from(this.extensions, (element)=>element.toSchema()
                )
            }));
        }
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const _object = {
            version: this.version,
            messageImprint: this.messageImprint.toJSON()
        };
        if ("reqPolicy" in this) _object.reqPolicy = this.reqPolicy;
        if ("nonce" in this) _object.nonce = this.nonce.toJSON();
        if ("certReq" in this && TimeStampReq.compareWithDefault("certReq", this.certReq) === false) _object.certReq = this.certReq;
        if ("extensions" in this) _object.extensions = Array.from(this.extensions, (element)=>element.toJSON()
        );
        return _object;
    }
}
class TimeStampResp {
    constructor(parameters = {}){
        this.status = getParametersValue(parameters, "status", TimeStampResp.defaultValues("status"));
        if ("timeStampToken" in parameters) this.timeStampToken = getParametersValue(parameters, "timeStampToken", TimeStampResp.defaultValues("timeStampToken"));
        if ("schema" in parameters) this.fromSchema(parameters.schema);
    }
    static defaultValues(memberName) {
        switch(memberName){
            case "status":
                return new PKIStatusInfo();
            case "timeStampToken":
                return new ContentInfo();
            default:
                throw new Error(`Invalid member name for TimeStampResp class: ${memberName}`);
        }
    }
    static compareWithDefault(memberName, memberValue) {
        switch(memberName){
            case "status":
                return PKIStatusInfo.compareWithDefault("status", memberValue.status) && "statusStrings" in memberValue === false && "failInfo" in memberValue === false;
            case "timeStampToken":
                return memberValue.contentType === "" && memberValue.content instanceof Any;
            default:
                throw new Error(`Invalid member name for TimeStampResp class: ${memberName}`);
        }
    }
    static schema(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return new Sequence({
            name: names.blockName || "TimeStampResp",
            value: [
                PKIStatusInfo.schema(names.status || {
                    names: {
                        blockName: "TimeStampResp.status"
                    }
                }),
                ContentInfo.schema(names.timeStampToken || {
                    names: {
                        blockName: "TimeStampResp.timeStampToken",
                        optional: true
                    }
                })
            ]
        });
    }
    fromSchema(schema) {
        clearProps(schema, [
            "TimeStampResp.status",
            "TimeStampResp.timeStampToken"
        ]);
        const asn1 = compareSchema(schema, schema, TimeStampResp.schema());
        if (asn1.verified === false) throw new Error("Object's schema was not verified against input data for TimeStampResp");
        this.status = new PKIStatusInfo({
            schema: asn1.result["TimeStampResp.status"]
        });
        if ("TimeStampResp.timeStampToken" in asn1.result) this.timeStampToken = new ContentInfo({
            schema: asn1.result["TimeStampResp.timeStampToken"]
        });
    }
    toSchema() {
        const outputArray = [];
        outputArray.push(this.status.toSchema());
        if ("timeStampToken" in this) outputArray.push(this.timeStampToken.toSchema());
        return new Sequence({
            value: outputArray
        });
    }
    toJSON() {
        const _object = {
            status: this.status
        };
        if ("timeStampToken" in this) _object.timeStampToken = this.timeStampToken.toJSON();
        return _object;
    }
    sign(privateKey, hashAlgorithm) {
        if ("timeStampToken" in this === false) return Promise.reject("timeStampToken is absent in TSP response");
        if (this.timeStampToken.contentType !== "1.2.840.113549.1.7.2") return Promise.reject(`Wrong format of timeStampToken: ${this.timeStampToken.contentType}`);
        const signed = new ContentInfo({
            schema: this.timeStampToken.content
        });
        return signed.sign(privateKey, 0, hashAlgorithm);
    }
    verify(verificationParameters = {
        signer: 0,
        trustedCerts: [],
        data: new ArrayBuffer(0)
    }) {
        if ("timeStampToken" in this === false) return Promise.reject("timeStampToken is absent in TSP response");
        if (this.timeStampToken.contentType !== "1.2.840.113549.1.7.2") return Promise.reject(`Wrong format of timeStampToken: ${this.timeStampToken.contentType}`);
        const signed = new SignedData({
            schema: this.timeStampToken.content
        });
        return signed.verify(verificationParameters);
    }
}
let decoder1;
try {
    decoder1 = new TextDecoder();
} catch (error77) {}
let src;
let srcEnd;
let position = 0;
const EMPTY_ARRAY = [];
const LEGACY_RECORD_INLINE_ID = 105;
const PACKED_REFERENCE_TAG_ID = 6;
const STOP_CODE = {};
let strings = EMPTY_ARRAY;
let stringPosition = 0;
let currentDecoder = {};
let currentStructures;
let srcString;
let srcStringStart = 0;
let srcStringEnd = 0;
let bundledStrings;
let referenceMap;
let currentExtensions = [];
let currentExtensionRanges = [];
let packedValues;
let dataView;
let restoreMapsAsObject;
let defaultOptions = {
    useRecords: false,
    mapsAsObjects: true
};
let sequentialMode = false;
class Decoder {
    constructor(options){
        if (options) {
            if ((options.keyMap || options._keyMap) && !options.useRecords) {
                options.useRecords = false;
                options.mapsAsObjects = true;
            }
            if (options.useRecords === false && options.mapsAsObjects === undefined) options.mapsAsObjects = true;
            if (options.getStructures) options.getShared = options.getStructures;
            if (options.getShared && !options.structures) (options.structures = []).uninitialized = true;
            if (options.keyMap) {
                this.mapKey = new Map();
                for (let [k, v] of Object.entries(options.keyMap))this.mapKey.set(v, k);
            }
        }
        Object.assign(this, options);
    }
    decodeKey(key) {
        return this.keyMap ? this.mapKey.get(key) || key : key;
    }
    encodeKey(key) {
        return this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key;
    }
    encodeKeys(rec) {
        if (!this._keyMap) return rec;
        let map4 = new Map();
        for (let [k, v] of Object.entries(rec))map4.set(this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k, v);
        return map4;
    }
    decodeKeys(map5) {
        if (!this._keyMap || map5.constructor.name != 'Map') return map5;
        if (!this._mapKey) {
            this._mapKey = new Map();
            for (let [k, v] of Object.entries(this._keyMap))this._mapKey.set(v, k);
        }
        let res = {};
        map5.forEach((v, k)=>res[this._mapKey.has(k) ? this._mapKey.get(k) : k] = v
        );
        return res;
    }
    mapDecode(source, end) {
        let res = this.decode(source);
        if (this._keyMap) {
            switch(res.constructor.name){
                case 'Array':
                    return res.map((r8)=>this.decodeKeys(r8)
                    );
            }
        }
        return res;
    }
    decode(source, end) {
        if (src) {
            return saveState(()=>{
                clearSource();
                return this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end);
            });
        }
        srcEnd = end > -1 ? end : source.length;
        position = 0;
        stringPosition = 0;
        srcStringEnd = 0;
        srcString = null;
        strings = EMPTY_ARRAY;
        bundledStrings = null;
        src = source;
        try {
            dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
        } catch (error110) {
            src = null;
            if (source instanceof Uint8Array) throw error110;
            throw new Error('Source must be a Uint8Array or Buffer but was a ' + (source && typeof source == 'object' ? source.constructor.name : typeof source));
        }
        if (this instanceof Decoder) {
            currentDecoder = this;
            packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);
            if (this.structures) {
                currentStructures = this.structures;
                return checkedRead();
            } else if (!currentStructures || currentStructures.length > 0) {
                currentStructures = [];
            }
        } else {
            currentDecoder = defaultOptions;
            if (!currentStructures || currentStructures.length > 0) currentStructures = [];
            packedValues = null;
        }
        return checkedRead();
    }
    decodeMultiple(source, forEach) {
        let values, lastPosition = 0;
        try {
            let size = source.length;
            sequentialMode = true;
            let value = this ? this.decode(source, size) : defaultDecoder.decode(source, size);
            if (forEach) {
                if (forEach(value) === false) {
                    return;
                }
                while(position < size){
                    lastPosition = position;
                    if (forEach(checkedRead()) === false) {
                        return;
                    }
                }
            } else {
                values = [
                    value
                ];
                while(position < size){
                    lastPosition = position;
                    values.push(checkedRead());
                }
                return values;
            }
        } catch (error2) {
            error2.lastPosition = lastPosition;
            error2.values = values;
            throw error2;
        } finally{
            sequentialMode = false;
            clearSource();
        }
    }
}
function checkedRead() {
    try {
        let result = read();
        if (bundledStrings) position = bundledStrings.postBundlePosition;
        if (position == srcEnd) {
            currentStructures = null;
            src = null;
            if (referenceMap) referenceMap = null;
        } else if (position > srcEnd) {
            let error3 = new Error('Unexpected end of CBOR data');
            error3.incomplete = true;
            throw error3;
        } else if (!sequentialMode) {
            throw new Error('Data read, but end of buffer not reached');
        }
        return result;
    } catch (error4) {
        clearSource();
        if (error4 instanceof RangeError || error4.message.startsWith('Unexpected end of buffer')) {
            error4.incomplete = true;
        }
        throw error4;
    }
}
function read() {
    let token = src[position++];
    let majorType = token >> 5;
    token = token & 0x1f;
    if (token > 0x17) {
        switch(token){
            case 0x18:
                token = src[position++];
                break;
            case 0x19:
                if (majorType == 7) {
                    return getFloat16();
                }
                token = dataView.getUint16(position);
                position += 2;
                break;
            case 0x1a:
                if (majorType == 7) {
                    let value = dataView.getFloat32(position);
                    if (currentDecoder.useFloat32 > 2) {
                        let multiplier = mult10[(src[position] & 0x7f) << 1 | src[position + 1] >> 7];
                        position += 4;
                        return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;
                    }
                    position += 4;
                    return value;
                }
                token = dataView.getUint32(position);
                position += 4;
                break;
            case 0x1b:
                if (majorType == 7) {
                    let value = dataView.getFloat64(position);
                    position += 8;
                    return value;
                }
                if (majorType > 1) {
                    if (dataView.getUint32(position) > 0) throw new Error('JavaScript does not support arrays, maps, or strings with length over 4294967295');
                    token = dataView.getUint32(position + 4);
                } else if (currentDecoder.int64AsNumber) {
                    token = dataView.getUint32(position) * 0x100000000;
                    token += dataView.getUint32(position + 4);
                } else token = dataView.getBigUint64(position);
                position += 8;
                break;
            case 0x1f:
                switch(majorType){
                    case 2:
                    case 3:
                        throw new Error('Indefinite length not supported for byte or text strings');
                    case 4:
                        let array = [];
                        let value, i214 = 0;
                        while((value = read()) != STOP_CODE){
                            array[i214++] = value;
                        }
                        return majorType == 4 ? array : majorType == 3 ? array.join('') : Buffer.concat(array);
                    case 5:
                        let key;
                        if (currentDecoder.mapsAsObjects) {
                            let object = {};
                            if (currentDecoder.keyMap) while((key = read()) != STOP_CODE)object[currentDecoder.decodeKey(key)] = read();
                            else while((key = read()) != STOP_CODE)object[key] = read();
                            return object;
                        } else {
                            if (restoreMapsAsObject) {
                                currentDecoder.mapsAsObjects = true;
                                restoreMapsAsObject = false;
                            }
                            let map6 = new Map();
                            if (currentDecoder.keyMap) while((key = read()) != STOP_CODE)map6.set(currentDecoder.decodeKey(key), read());
                            else while((key = read()) != STOP_CODE)map6.set(key, read());
                            return map6;
                        }
                    case 7:
                        return STOP_CODE;
                    default:
                        throw new Error('Invalid major type for indefinite length ' + majorType);
                }
            default:
                throw new Error('Unknown token ' + token);
        }
    }
    switch(majorType){
        case 0:
            return token;
        case 1:
            return ~token;
        case 2:
            return readBin(token);
        case 3:
            if (srcStringEnd >= position) {
                return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);
            }
            if (srcStringEnd == 0 && srcEnd < 140 && token < 32) {
                let string = token < 16 ? shortStringInJS(token) : longStringInJS(token);
                if (string != null) return string;
            }
            return readFixedString(token);
        case 4:
            let array = new Array(token);
            for(let i3 = 0; i3 < token; i3++)array[i3] = read();
            return array;
        case 5:
            if (currentDecoder.mapsAsObjects) {
                let object = {};
                if (currentDecoder.keyMap) for(let i5 = 0; i5 < token; i5++)object[currentDecoder.decodeKey(read())] = read();
                else for(let i4 = 0; i4 < token; i4++)object[read()] = read();
                return object;
            } else {
                if (restoreMapsAsObject) {
                    currentDecoder.mapsAsObjects = true;
                    restoreMapsAsObject = false;
                }
                let map7 = new Map();
                if (currentDecoder.keyMap) for(let i7 = 0; i7 < token; i7++)map7.set(currentDecoder.decodeKey(read()), read());
                else for(let i6 = 0; i6 < token; i6++)map7.set(read(), read());
                return map7;
            }
        case 6:
            if (token >= 0xdff9) {
                let structure = currentStructures[token & 0x1fff];
                if (structure) {
                    if (!structure.read) structure.read = createStructureReader(structure);
                    return structure.read();
                }
                if (token < 0x10000) {
                    if (token == 0xdfff) return recordDefinition(read());
                    else if (token == 0xdffe) {
                        let length = readJustLength();
                        let id = read();
                        for(let i8 = 2; i8 < length; i8++){
                            recordDefinition([
                                id++,
                                read()
                            ]);
                        }
                        return read();
                    } else if (token == 0xdff9) {
                        return readBundleExt();
                    }
                    if (currentDecoder.getShared) {
                        loadShared();
                        structure = currentStructures[token & 0x1fff];
                        if (structure) {
                            if (!structure.read) structure.read = createStructureReader(structure);
                            return structure.read();
                        }
                    }
                }
            }
            let extension = currentExtensions[token];
            if (extension) {
                if (extension.handlesRead) return extension(read);
                else return extension(read());
            } else {
                let input = read();
                for(let i9 = 0; i9 < currentExtensionRanges.length; i9++){
                    let value = currentExtensionRanges[i9](token, input);
                    if (value !== undefined) return value;
                }
                return new Tag(input, token);
            }
        case 7:
            switch(token){
                case 0x14:
                    return false;
                case 0x15:
                    return true;
                case 0x16:
                    return null;
                case 0x17:
                    return;
                case 0x1f:
                default:
                    let packedValue = (packedValues || getPackedValues())[token];
                    if (packedValue !== undefined) return packedValue;
                    throw new Error('Unknown token ' + token);
            }
        default:
            if (isNaN(token)) {
                let error5 = new Error('Unexpected end of CBOR data');
                error5.incomplete = true;
                throw error5;
            }
            throw new Error('Unknown CBOR token ' + token);
    }
}
const validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function createStructureReader(structure) {
    function readObject() {
        let length = src[position++];
        length = length & 0x1f;
        if (length > 0x17) {
            switch(length){
                case 0x18:
                    length = src[position++];
                    break;
                case 0x19:
                    length = dataView.getUint16(position);
                    position += 2;
                    break;
                case 0x1a:
                    length = dataView.getUint32(position);
                    position += 4;
                    break;
                default:
                    throw new Error('Expected array header, but got ' + src[position - 1]);
            }
        }
        let compiledReader = this.compiledReader;
        while(compiledReader){
            if (compiledReader.propertyCount === length) return compiledReader(read);
            compiledReader = compiledReader.next;
        }
        if (this.slowReads++ >= 3) {
            let array = this.length == length ? this : this.slice(0, length);
            compiledReader = currentDecoder.keyMap ? new Function('r', 'return {' + array.map((k)=>currentDecoder.decodeKey(k)
            ).map((k)=>validName.test(k) ? k + ':r()' : '[' + JSON.stringify(k) + ']:r()'
            ).join(',') + '}') : new Function('r', 'return {' + array.map((key)=>validName.test(key) ? key + ':r()' : '[' + JSON.stringify(key) + ']:r()'
            ).join(',') + '}');
            if (this.compiledReader) compiledReader.next = this.compiledReader;
            compiledReader.propertyCount = length;
            this.compiledReader = compiledReader;
            return compiledReader(read);
        }
        let object = {};
        if (currentDecoder.keyMap) for(let i11 = 0; i11 < length; i11++)object[currentDecoder.decodeKey(this[i11])] = read();
        else for(let i10 = 0; i10 < length; i10++)object[this[i10]] = read();
        return object;
    }
    structure.slowReads = 0;
    return readObject;
}
let readFixedString = readStringJS;
function readStringJS(length) {
    let result;
    if (length < 16) {
        if (result = shortStringInJS(length)) return result;
    }
    if (length > 64 && decoder1) return decoder1.decode(src.subarray(position, position += length));
    const end = position + length;
    const units = [];
    result = '';
    while(position < end){
        const byte1 = src[position++];
        if ((byte1 & 0x80) === 0) {
            units.push(byte1);
        } else if ((byte1 & 0xe0) === 0xc0) {
            const byte2 = src[position++] & 0x3f;
            units.push((byte1 & 0x1f) << 6 | byte2);
        } else if ((byte1 & 0xf0) === 0xe0) {
            const byte2 = src[position++] & 0x3f;
            const byte3 = src[position++] & 0x3f;
            units.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);
        } else if ((byte1 & 0xf8) === 0xf0) {
            const byte2 = src[position++] & 0x3f;
            const byte3 = src[position++] & 0x3f;
            const byte4 = src[position++] & 0x3f;
            let unit = (byte1 & 0x07) << 0x12 | byte2 << 0x0c | byte3 << 0x06 | byte4;
            if (unit > 0xffff) {
                unit -= 0x10000;
                units.push(unit >>> 10 & 0x3ff | 0xd800);
                unit = 0xdc00 | unit & 0x3ff;
            }
            units.push(unit);
        } else {
            units.push(byte1);
        }
        if (units.length >= 0x1000) {
            result += fromCharCode.apply(String, units);
            units.length = 0;
        }
    }
    if (units.length > 0) {
        result += fromCharCode.apply(String, units);
    }
    return result;
}
let fromCharCode = String.fromCharCode;
function longStringInJS(length) {
    let start = position;
    let bytes = new Array(length);
    for(let i12 = 0; i12 < length; i12++){
        const __byte = src[position++];
        if ((__byte & 0x80) > 0) {
            position = start;
            return;
        }
        bytes[i12] = __byte;
    }
    return fromCharCode.apply(String, bytes);
}
function shortStringInJS(length) {
    if (length < 4) {
        if (length < 2) {
            if (length === 0) return '';
            else {
                let a22 = src[position++];
                if ((a22 & 0x80) > 1) {
                    position -= 1;
                    return;
                }
                return fromCharCode(a22);
            }
        } else {
            let a23 = src[position++];
            let b = src[position++];
            if ((a23 & 0x80) > 0 || (b & 0x80) > 0) {
                position -= 2;
                return;
            }
            if (length < 3) return fromCharCode(a23, b);
            let c = src[position++];
            if ((c & 0x80) > 0) {
                position -= 3;
                return;
            }
            return fromCharCode(a23, b, c);
        }
    } else {
        let a24 = src[position++];
        let b = src[position++];
        let c = src[position++];
        let d = src[position++];
        if ((a24 & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {
            position -= 4;
            return;
        }
        if (length < 6) {
            if (length === 4) return fromCharCode(a24, b, c, d);
            else {
                let e16 = src[position++];
                if ((e16 & 0x80) > 0) {
                    position -= 5;
                    return;
                }
                return fromCharCode(a24, b, c, d, e16);
            }
        } else if (length < 8) {
            let e17 = src[position++];
            let f = src[position++];
            if ((e17 & 0x80) > 0 || (f & 0x80) > 0) {
                position -= 6;
                return;
            }
            if (length < 7) return fromCharCode(a24, b, c, d, e17, f);
            let g = src[position++];
            if ((g & 0x80) > 0) {
                position -= 7;
                return;
            }
            return fromCharCode(a24, b, c, d, e17, f, g);
        } else {
            let e18 = src[position++];
            let f = src[position++];
            let g = src[position++];
            let h = src[position++];
            if ((e18 & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {
                position -= 8;
                return;
            }
            if (length < 10) {
                if (length === 8) return fromCharCode(a24, b, c, d, e18, f, g, h);
                else {
                    let i13 = src[position++];
                    if ((i13 & 0x80) > 0) {
                        position -= 9;
                        return;
                    }
                    return fromCharCode(a24, b, c, d, e18, f, g, h, i13);
                }
            } else if (length < 12) {
                let i14 = src[position++];
                let j = src[position++];
                if ((i14 & 0x80) > 0 || (j & 0x80) > 0) {
                    position -= 10;
                    return;
                }
                if (length < 11) return fromCharCode(a24, b, c, d, e18, f, g, h, i14, j);
                let k = src[position++];
                if ((k & 0x80) > 0) {
                    position -= 11;
                    return;
                }
                return fromCharCode(a24, b, c, d, e18, f, g, h, i14, j, k);
            } else {
                let i15 = src[position++];
                let j = src[position++];
                let k = src[position++];
                let l = src[position++];
                if ((i15 & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {
                    position -= 12;
                    return;
                }
                if (length < 14) {
                    if (length === 12) return fromCharCode(a24, b, c, d, e18, f, g, h, i15, j, k, l);
                    else {
                        let m = src[position++];
                        if ((m & 0x80) > 0) {
                            position -= 13;
                            return;
                        }
                        return fromCharCode(a24, b, c, d, e18, f, g, h, i15, j, k, l, m);
                    }
                } else {
                    let m = src[position++];
                    let n12 = src[position++];
                    if ((m & 0x80) > 0 || (n12 & 0x80) > 0) {
                        position -= 14;
                        return;
                    }
                    if (length < 15) return fromCharCode(a24, b, c, d, e18, f, g, h, i15, j, k, l, m, n12);
                    let o24 = src[position++];
                    if ((o24 & 0x80) > 0) {
                        position -= 15;
                        return;
                    }
                    return fromCharCode(a24, b, c, d, e18, f, g, h, i15, j, k, l, m, n12, o24);
                }
            }
        }
    }
}
function readBin(length) {
    return currentDecoder.copyBuffers ? Uint8Array.prototype.slice.call(src, position, position += length) : src.subarray(position, position += length);
}
function getFloat16() {
    let byte0 = src[position++];
    let byte1 = src[position++];
    let half = (byte0 << 8) + byte1;
    let exp = half >> 10 & 0x1f;
    let mant = half & 0x3ff;
    let val;
    if (exp == 0) val = Math.exp(mant, -24);
    else if (exp != 31) val = Math.exp(mant + 1024, exp - 25);
    else val = mant == 0 ? Infinity : NaN;
    return half & 0x8000 ? -val : val;
}
new Array(4096);
class Tag {
    constructor(value, tag){
        this.value = value;
        this.tag = tag;
    }
}
let glbl = typeof self == 'object' ? self : global;
currentExtensions[0] = (dateString)=>{
    return new Date(dateString);
};
currentExtensions[1] = (epochSec)=>{
    return new Date(Math.round(epochSec * 1000));
};
currentExtensions[2] = (buffer)=>{
    let value = BigInt(0);
    for(let i17 = 0, l = buffer.byteLength; i17 < l; i17++){
        value = BigInt(buffer[i17]) + value << BigInt(8);
    }
    return value;
};
currentExtensions[3] = (buffer)=>{
    return BigInt(-1) - currentExtensions[2](buffer);
};
currentExtensions[4] = (fraction)=>{
    return +(fraction[1] + 'e' + fraction[0]);
};
currentExtensions[5] = (fraction)=>{
    return fraction[1] * Math.exp(fraction[0] * Math.log(2));
};
const recordDefinition = (definition)=>{
    let id = definition[0] - 0xe000;
    let structure = definition[1];
    let existingStructure = currentStructures[id];
    if (existingStructure && existingStructure.isShared) {
        (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;
    }
    currentStructures[id] = structure;
    structure.read = createStructureReader(structure);
    let object = {};
    if (currentDecoder.keyMap) for(let i19 = 2, l = definition.length; i19 < l; i19++){
        let key = currentDecoder.decodeKey(structure[i19 - 2]);
        object[key] = definition[i19];
    }
    else for(let i18 = 2, l1 = definition.length; i18 < l1; i18++){
        let key = structure[i18 - 2];
        object[key] = definition[i18];
    }
    return object;
};
currentExtensions[LEGACY_RECORD_INLINE_ID] = recordDefinition;
currentExtensions[14] = (value)=>{
    if (bundledStrings) return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value);
    return new Tag(value, 14);
};
currentExtensions[15] = (value)=>{
    if (bundledStrings) return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value);
    return new Tag(value, 15);
};
currentExtensions[27] = (data)=>{
    return (glbl[data[0]] || Error)(data[1], data[2]);
};
const packedTable = (read1)=>{
    if (src[position++] != 0x84) throw new Error('Packed values structure must be followed by a 4 element array');
    let newPackedValues = read1();
    packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;
    packedValues.prefixes = read1();
    packedValues.suffixes = read1();
    return read1();
};
packedTable.handlesRead = true;
currentExtensions[51] = packedTable;
currentExtensions[PACKED_REFERENCE_TAG_ID] = (data)=>{
    if (!packedValues) {
        if (currentDecoder.getShared) loadShared();
        else return new Tag(data, PACKED_REFERENCE_TAG_ID);
    }
    if (typeof data == 'number') return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];
    throw new Error('No support for non-integer packed references yet');
};
currentExtensions[25] = (id)=>{
    return stringRefs[id];
};
currentExtensions[256] = (read2)=>{
    stringRefs = [];
    try {
        return read2();
    } finally{
        stringRefs = null;
    }
};
currentExtensions[256].handlesRead = true;
currentExtensions[28] = (read3)=>{
    if (!referenceMap) {
        referenceMap = new Map();
        referenceMap.id = 0;
    }
    let id = referenceMap.id++;
    let token = src[position];
    let target8;
    if (token >> 5 == 4) target8 = [];
    else target8 = {};
    let refEntry = {
        target: target8
    };
    referenceMap.set(id, refEntry);
    let targetProperties = read3();
    if (refEntry.used) return Object.assign(target8, targetProperties);
    refEntry.target = targetProperties;
    return targetProperties;
};
currentExtensions[28].handlesRead = true;
currentExtensions[29] = (id)=>{
    let refEntry = referenceMap.get(id);
    refEntry.used = true;
    return refEntry.target;
};
currentExtensions[258] = (array)=>new Set(array)
;
(currentExtensions[259] = (read4)=>{
    if (currentDecoder.mapsAsObjects) {
        currentDecoder.mapsAsObjects = false;
        restoreMapsAsObject = true;
    }
    return read4();
}).handlesRead = true;
function combine(a25, b) {
    if (typeof a25 === 'string') return a25 + b;
    if (a25 instanceof Array) return a25.concat(b);
    return Object.assign({}, a25, b);
}
function getPackedValues() {
    if (!packedValues) {
        if (currentDecoder.getShared) loadShared();
        else throw new Error('No packed values available');
    }
    return packedValues;
}
currentExtensionRanges.push((tag, input)=>{
    if (tag >= 225 && tag <= 255) return combine(getPackedValues().prefixes[tag - 224], input);
    if (tag >= 28704 && tag <= 32767) return combine(getPackedValues().prefixes[tag - 28672], input);
    if (tag >= 1879052288 && tag <= 2147483647) return combine(getPackedValues().prefixes[tag - 1879048192], input);
    if (tag >= 216 && tag <= 223) return combine(input, getPackedValues().suffixes[tag - 216]);
    if (tag >= 27647 && tag <= 28671) return combine(input, getPackedValues().suffixes[tag - 27639]);
    if (tag >= 1811940352 && tag <= 1879048191) return combine(input, getPackedValues().suffixes[tag - 1811939328]);
    if (tag == 0x53687264) {
        return {
            packedValues: packedValues,
            structures: currentStructures.slice(0),
            version: input
        };
    }
    if (tag == 55799) return input;
});
const isLittleEndianMachine = new Uint8Array(new Uint16Array([
    1
]).buffer)[0] == 1;
const typedArrays = [
    'Uint8',
    'Uint8Clamped',
    'Uint16',
    'Uint32',
    'BigUint64',
    'Int8',
    'Int16',
    'Int32',
    'BigInt64',
    'Float32',
    'Float64'
];
const typedArrayTags = [
    64,
    68,
    69,
    70,
    71,
    72,
    77,
    78,
    79,
    85,
    86
];
for(let i3 = 0; i3 < typedArrays.length; i3++){
    registerTypedArray(typedArrays[i3], typedArrayTags[i3]);
}
function registerTypedArray(typedArrayId, tag, littleEndian) {
    let TypedArray = glbl[typedArrayId + 'Array'];
    let bytesPerElement = TypedArray.BYTES_PER_ELEMENT;
    for(let littleEndian1 = 0; littleEndian1 < 2; littleEndian1++){
        if (!littleEndian1 && bytesPerElement == 1) continue;
        let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3;
        currentExtensions[littleEndian1 ? tag : tag - 4] = bytesPerElement == 1 || littleEndian1 == isLittleEndianMachine ? (buffer)=>{
            if (!TypedArray) throw new Error('Could not find typed array for code ' + tag);
            return new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer);
        } : (buffer)=>{
            if (!TypedArray) throw new Error('Could not find typed array for code ' + tag);
            let dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
            let elements = buffer.length >> sizeShift;
            let ta = new TypedArray(elements);
            let method = dv['get' + typedArrayId];
            for(let i20 = 0; i20 < elements; i20++){
                ta[i20] = method.call(dv, i20 << sizeShift, littleEndian1);
            }
            return ta;
        };
    }
}
function readBundleExt() {
    let length = readJustLength();
    let bundlePosition = position + read();
    for(let i21 = 2; i21 < length; i21++){
        let bundleLength = readJustLength();
        position += bundleLength;
    }
    let dataPosition = position;
    position = bundlePosition;
    bundledStrings = [
        readStringJS(readJustLength()),
        readStringJS(readJustLength())
    ];
    bundledStrings.position0 = 0;
    bundledStrings.position1 = 0;
    bundledStrings.postBundlePosition = position;
    position = dataPosition;
    return read();
}
function readJustLength() {
    let token = src[position++] & 0x1f;
    if (token > 0x17) {
        switch(token){
            case 0x18:
                token = src[position++];
                break;
            case 0x19:
                token = dataView.getUint16(position);
                position += 2;
                break;
            case 0x1a:
                token = dataView.getUint32(position);
                position += 4;
                break;
        }
    }
    return token;
}
function loadShared() {
    if (currentDecoder.getShared) {
        let sharedData = saveState(()=>{
            src = null;
            return currentDecoder.getShared();
        }) || {};
        let updatedStructures = sharedData.structures || [];
        currentDecoder.sharedVersion = sharedData.version;
        packedValues = currentDecoder.sharedValues = sharedData.packedValues;
        if (currentStructures === true) currentDecoder.structures = currentStructures = updatedStructures;
        else currentStructures.splice.apply(currentStructures, [
            0,
            updatedStructures.length
        ].concat(updatedStructures));
    }
}
function saveState(callback) {
    let savedSrcEnd = srcEnd;
    let savedPosition = position;
    let savedStringPosition = stringPosition;
    let savedSrcStringStart = srcStringStart;
    let savedSrcStringEnd = srcStringEnd;
    let savedSrcString = srcString;
    let savedStrings = strings;
    let savedReferenceMap = referenceMap;
    let savedBundledStrings = bundledStrings;
    let savedSrc = new Uint8Array(src.slice(0, srcEnd));
    let savedStructures = currentStructures;
    let savedDecoder = currentDecoder;
    let savedSequentialMode = sequentialMode;
    let value = callback();
    srcEnd = savedSrcEnd;
    position = savedPosition;
    stringPosition = savedStringPosition;
    srcStringStart = savedSrcStringStart;
    srcStringEnd = savedSrcStringEnd;
    srcString = savedSrcString;
    strings = savedStrings;
    referenceMap = savedReferenceMap;
    bundledStrings = savedBundledStrings;
    src = savedSrc;
    sequentialMode = savedSequentialMode;
    currentStructures = savedStructures;
    currentDecoder = savedDecoder;
    dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);
    return value;
}
function clearSource() {
    src = null;
    referenceMap = null;
    currentStructures = null;
}
const mult10 = new Array(147);
for(let i112 = 0; i112 < 256; i112++){
    mult10[i112] = +('1e' + Math.floor(45.15 - i112 * 0.30103));
}
let defaultDecoder = new Decoder({
    useRecords: false
});
const decode5 = defaultDecoder.decode;
defaultDecoder.decodeMultiple;
const FLOAT32_OPTIONS = {
    NEVER: 0,
    ALWAYS: 1,
    DECIMAL_ROUND: 3,
    DECIMAL_FIT: 4
};
let f32Array = new Float32Array(1);
new Uint8Array(f32Array.buffer, 0, 4);
let textEncoder;
try {
    textEncoder = new TextEncoder();
} catch (error78) {}
let extensions, extensionClasses;
const hasNodeBuffer = typeof Buffer !== 'undefined';
const ByteArrayAllocate = hasNodeBuffer ? Buffer.allocUnsafeSlow : Uint8Array;
const ByteArray = hasNodeBuffer ? Buffer : Uint8Array;
const MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000;
let target;
let targetView;
let position1 = 0;
let safeEnd;
let bundledStrings1 = null;
const hasNonLatin = /[\u0080-\uFFFF]/;
const RECORD_SYMBOL = Symbol('record-id');
class Encoder extends Decoder {
    constructor(options1){
        super(options1);
        this.offset = 0;
        let start;
        let sharedStructures;
        let hasSharedUpdate;
        let structures;
        let referenceMap1;
        options1 = options1 || {};
        let encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position11, maxBytes) {
            return target.utf8Write(string, position11, maxBytes);
        } : textEncoder && textEncoder.encodeInto ? function(string, position2) {
            return textEncoder.encodeInto(string, target.subarray(position2)).written;
        } : false;
        let encoder1 = this;
        let hasSharedStructures = options1.structures || options1.saveStructures;
        let maxSharedStructures = options1.maxSharedStructures;
        if (maxSharedStructures == null) maxSharedStructures = hasSharedStructures ? 128 : 0;
        if (maxSharedStructures > 8190) throw new Error('Maximum maxSharedStructure is 8190');
        let isSequential = options1.sequential;
        if (isSequential) {
            maxSharedStructures = 0;
        }
        if (!this.structures) this.structures = [];
        if (this.saveStructures) this.saveShared = this.saveStructures;
        let samplingPackedValues, packedObjectMap, sharedValues1 = options1.sharedValues;
        let sharedPackedObjectMap;
        if (sharedValues1) {
            sharedPackedObjectMap = Object.create(null);
            for(let i194 = 0, l = sharedValues1.length; i194 < l; i194++){
                sharedPackedObjectMap[sharedValues1[i194]] = i194;
            }
        }
        let recordIdsToRemove = [];
        let transitionsCount = 0;
        let serializationsSinceTransitionRebuild = 0;
        this.mapEncode = function(value, encodeOptions) {
            if (this._keyMap && !this._mapped) {
                switch(value.constructor.name){
                    case 'Array':
                        value = value.map((r9)=>this.encodeKeys(r9)
                        );
                        break;
                }
            }
            return this.encode(value, encodeOptions);
        };
        this.encode = function(value, encodeOptions) {
            if (!target) {
                target = new ByteArrayAllocate(8192);
                targetView = new DataView(target.buffer, 0, 8192);
                position1 = 0;
            }
            safeEnd = target.length - 10;
            if (safeEnd - position1 < 0x800) {
                target = new ByteArrayAllocate(target.length);
                targetView = new DataView(target.buffer, 0, target.length);
                safeEnd = target.length - 10;
                position1 = 0;
            } else if (encodeOptions === REUSE_BUFFER_MODE) position1 = position1 + 7 & 0x7ffffff8;
            start = position1;
            if (encoder1.useSelfDescribedHeader) {
                targetView.setUint32(position1, 0xd9d9f700);
                position1 += 3;
            }
            referenceMap1 = encoder1.structuredClone ? new Map() : null;
            if (encoder1.bundleStrings && typeof value !== 'string') {
                bundledStrings1 = [];
                bundledStrings1.size = Infinity;
            } else bundledStrings1 = null;
            sharedStructures = encoder1.structures;
            if (sharedStructures) {
                if (sharedStructures.uninitialized) {
                    let sharedData = encoder1.getShared() || {};
                    encoder1.structures = sharedStructures = sharedData.structures || [];
                    encoder1.sharedVersion = sharedData.version;
                    let sharedValues = encoder1.sharedValues = sharedData.packedValues;
                    if (sharedValues) {
                        sharedPackedObjectMap = {};
                        for(let i195 = 0, l = sharedValues.length; i195 < l; i195++)sharedPackedObjectMap[sharedValues[i195]] = i195;
                    }
                }
                let sharedStructuresLength = sharedStructures.length;
                if (sharedStructuresLength > maxSharedStructures && !isSequential) sharedStructuresLength = maxSharedStructures;
                if (!sharedStructures.transitions) {
                    sharedStructures.transitions = Object.create(null);
                    for(let i196 = 0; i196 < sharedStructuresLength; i196++){
                        let keys = sharedStructures[i196];
                        if (!keys) continue;
                        let nextTransition, transition = sharedStructures.transitions;
                        for(let j = 0, l = keys.length; j < l; j++){
                            if (transition[RECORD_SYMBOL] === undefined) transition[RECORD_SYMBOL] = i196;
                            let key = keys[j];
                            nextTransition = transition[key];
                            if (!nextTransition) {
                                nextTransition = transition[key] = Object.create(null);
                            }
                            transition = nextTransition;
                        }
                        transition[RECORD_SYMBOL] = i196 | 0x100000;
                    }
                }
                if (!isSequential) sharedStructures.nextId = sharedStructuresLength;
            }
            if (hasSharedUpdate) hasSharedUpdate = false;
            structures = sharedStructures || [];
            packedObjectMap = sharedPackedObjectMap;
            if (options1.pack) {
                let packedValues1 = new Map();
                packedValues1.values = [];
                packedValues1.encoder = encoder1;
                packedValues1.maxValues = options1.maxPrivatePackedValues || (sharedPackedObjectMap ? 16 : Infinity);
                packedValues1.objectMap = sharedPackedObjectMap || false;
                packedValues1.samplingPackedValues = samplingPackedValues;
                findRepetitiveStrings(value, packedValues1);
                if (packedValues1.values.length > 0) {
                    target[position1++] = 0xd8;
                    target[position1++] = 51;
                    writeArrayHeader(4);
                    let valuesArray = packedValues1.values;
                    encode12(valuesArray);
                    writeArrayHeader(0);
                    writeArrayHeader(0);
                    packedObjectMap = Object.create(sharedPackedObjectMap || null);
                    for(let i197 = 0, l = valuesArray.length; i197 < l; i197++){
                        packedObjectMap[valuesArray[i197]] = i197;
                    }
                }
            }
            try {
                encode12(value);
                if (bundledStrings1) {
                    writeBundles(start, encode12);
                }
                encoder1.offset = position1;
                if (referenceMap1 && referenceMap1.idsToInsert) {
                    position1 += referenceMap1.idsToInsert.length * 2;
                    if (position1 > safeEnd) makeRoom(position1);
                    encoder1.offset = position1;
                    let serialized = insertIds(target.subarray(start, position1), referenceMap1.idsToInsert);
                    referenceMap1 = null;
                    return serialized;
                }
                if (encodeOptions & REUSE_BUFFER_MODE) {
                    target.start = start;
                    target.end = position1;
                    return target;
                }
                return target.subarray(start, position1);
            } finally{
                if (sharedStructures) {
                    if (serializationsSinceTransitionRebuild < 10) serializationsSinceTransitionRebuild++;
                    if (sharedStructures.length > maxSharedStructures) sharedStructures.length = maxSharedStructures;
                    if (transitionsCount > 10000) {
                        sharedStructures.transitions = null;
                        serializationsSinceTransitionRebuild = 0;
                        transitionsCount = 0;
                        if (recordIdsToRemove.length > 0) recordIdsToRemove = [];
                    } else if (recordIdsToRemove.length > 0 && !isSequential) {
                        for(let i198 = 0, l = recordIdsToRemove.length; i198 < l; i198++){
                            recordIdsToRemove[i198][RECORD_SYMBOL] = undefined;
                        }
                        recordIdsToRemove = [];
                    }
                }
                if (hasSharedUpdate && encoder1.saveShared) {
                    if (encoder1.structures.length > maxSharedStructures) {
                        encoder1.structures = encoder1.structures.slice(0, maxSharedStructures);
                    }
                    let returnBuffer = target.subarray(start, position1);
                    if (encoder1.updateSharedData() === false) return encoder1.encode(value);
                    return returnBuffer;
                }
                if (encodeOptions & RESET_BUFFER_MODE) position1 = start;
            }
        };
        this.findCommonStringsToPack = ()=>{
            samplingPackedValues = new Map();
            if (!sharedPackedObjectMap) sharedPackedObjectMap = Object.create(null);
            return (options)=>{
                let threshold = options && options.threshold || 4;
                let position3 = this.pack ? options.maxPrivatePackedValues || 16 : 0;
                if (!sharedValues1) sharedValues1 = this.sharedValues = [];
                for (let [key, status] of samplingPackedValues){
                    if (status.count > threshold) {
                        sharedPackedObjectMap[key] = position3++;
                        sharedValues1.push(key);
                        hasSharedUpdate = true;
                    }
                }
                while(this.saveShared && this.updateSharedData() === false){}
                samplingPackedValues = null;
            };
        };
        const encode12 = (value)=>{
            if (position1 > safeEnd) target = makeRoom(position1);
            var type = typeof value;
            var length;
            if (type === 'string') {
                if (packedObjectMap) {
                    let packedPosition = packedObjectMap[value];
                    if (packedPosition >= 0) {
                        if (packedPosition < 16) target[position1++] = packedPosition + 0xe0;
                        else {
                            target[position1++] = 0xc6;
                            if (packedPosition & 1) encode12(15 - packedPosition >> 1);
                            else encode12(packedPosition - 16 >> 1);
                        }
                        return;
                    } else if (samplingPackedValues && !options1.pack) {
                        let status = samplingPackedValues.get(value);
                        if (status) status.count++;
                        else samplingPackedValues.set(value, {
                            count: 1
                        });
                    }
                }
                let strLength = value.length;
                if (bundledStrings1 && strLength >= 4 && strLength < 0x400) {
                    if ((bundledStrings1.size += strLength) > 0xf000) {
                        let extStart;
                        let maxBytes = (bundledStrings1[0] ? bundledStrings1[0].length * 3 + bundledStrings1[1].length : 0) + 10;
                        if (position1 + maxBytes > safeEnd) target = makeRoom(position1 + maxBytes);
                        target[position1++] = 0xd9;
                        target[position1++] = 0xdf;
                        target[position1++] = 0xf9;
                        target[position1++] = bundledStrings1.position ? 0x84 : 0x82;
                        target[position1++] = 0x1a;
                        extStart = position1 - start;
                        position1 += 4;
                        if (bundledStrings1.position) {
                            writeBundles(start, encode12);
                        }
                        bundledStrings1 = [
                            '',
                            ''
                        ];
                        bundledStrings1.size = 0;
                        bundledStrings1.position = extStart;
                    }
                    let twoByte = hasNonLatin.test(value);
                    bundledStrings1[twoByte ? 0 : 1] += value;
                    target[position1++] = twoByte ? 0xce : 0xcf;
                    encode12(strLength);
                    return;
                }
                let headerSize;
                if (strLength < 0x20) {
                    headerSize = 1;
                } else if (strLength < 0x100) {
                    headerSize = 2;
                } else if (strLength < 0x10000) {
                    headerSize = 3;
                } else {
                    headerSize = 5;
                }
                let maxBytes = strLength * 3;
                if (position1 + maxBytes > safeEnd) target = makeRoom(position1 + maxBytes);
                if (strLength < 0x40 || !encodeUtf8) {
                    let i199, c1, c2, strPosition = position1 + headerSize;
                    for(i199 = 0; i199 < strLength; i199++){
                        c1 = value.charCodeAt(i199);
                        if (c1 < 0x80) {
                            target[strPosition++] = c1;
                        } else if (c1 < 0x800) {
                            target[strPosition++] = c1 >> 6 | 0xc0;
                            target[strPosition++] = c1 & 0x3f | 0x80;
                        } else if ((c1 & 0xfc00) === 0xd800 && ((c2 = value.charCodeAt(i199 + 1)) & 0xfc00) === 0xdc00) {
                            c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);
                            i199++;
                            target[strPosition++] = c1 >> 18 | 0xf0;
                            target[strPosition++] = c1 >> 12 & 0x3f | 0x80;
                            target[strPosition++] = c1 >> 6 & 0x3f | 0x80;
                            target[strPosition++] = c1 & 0x3f | 0x80;
                        } else {
                            target[strPosition++] = c1 >> 12 | 0xe0;
                            target[strPosition++] = c1 >> 6 & 0x3f | 0x80;
                            target[strPosition++] = c1 & 0x3f | 0x80;
                        }
                    }
                    length = strPosition - position1 - headerSize;
                } else {
                    length = encodeUtf8(value, position1 + headerSize, maxBytes);
                }
                if (length < 0x18) {
                    target[position1++] = 0x60 | length;
                } else if (length < 0x100) {
                    if (headerSize < 2) {
                        target.copyWithin(position1 + 2, position1 + 1, position1 + 1 + length);
                    }
                    target[position1++] = 0x78;
                    target[position1++] = length;
                } else if (length < 0x10000) {
                    if (headerSize < 3) {
                        target.copyWithin(position1 + 3, position1 + 2, position1 + 2 + length);
                    }
                    target[position1++] = 0x79;
                    target[position1++] = length >> 8;
                    target[position1++] = length & 0xff;
                } else {
                    if (headerSize < 5) {
                        target.copyWithin(position1 + 5, position1 + 3, position1 + 3 + length);
                    }
                    target[position1++] = 0x7a;
                    targetView.setUint32(position1, length);
                    position1 += 4;
                }
                position1 += length;
            } else if (type === 'number') {
                if (value >>> 0 === value) {
                    if (value < 0x18) {
                        target[position1++] = value;
                    } else if (value < 0x100) {
                        target[position1++] = 0x18;
                        target[position1++] = value;
                    } else if (value < 0x10000) {
                        target[position1++] = 0x19;
                        target[position1++] = value >> 8;
                        target[position1++] = value & 0xff;
                    } else {
                        target[position1++] = 0x1a;
                        targetView.setUint32(position1, value);
                        position1 += 4;
                    }
                } else if (value >> 0 === value) {
                    if (value >= -0x18) {
                        target[position1++] = 0x1f - value;
                    } else if (value >= -0x100) {
                        target[position1++] = 0x38;
                        target[position1++] = ~value;
                    } else if (value >= -0x10000) {
                        target[position1++] = 0x39;
                        targetView.setUint16(position1, ~value);
                        position1 += 2;
                    } else {
                        target[position1++] = 0x3a;
                        targetView.setUint32(position1, ~value);
                        position1 += 4;
                    }
                } else {
                    let useFloat32;
                    if ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {
                        target[position1++] = 0xfa;
                        targetView.setFloat32(position1, value);
                        let xShifted;
                        if (useFloat32 < 4 || (xShifted = value * mult10[(target[position1] & 0x7f) << 1 | target[position1 + 1] >> 7]) >> 0 === xShifted) {
                            position1 += 4;
                            return;
                        } else position1--;
                    }
                    target[position1++] = 0xfb;
                    targetView.setFloat64(position1, value);
                    position1 += 8;
                }
            } else if (type === 'object') {
                if (!value) target[position1++] = 0xf6;
                else {
                    if (referenceMap1) {
                        let referee = referenceMap1.get(value);
                        if (referee) {
                            target[position1++] = 0xd8;
                            target[position1++] = 29;
                            target[position1++] = 0x19;
                            if (!referee.references) {
                                let idsToInsert = referenceMap1.idsToInsert || (referenceMap1.idsToInsert = []);
                                referee.references = [];
                                idsToInsert.push(referee);
                            }
                            referee.references.push(position1 - start);
                            position1 += 2;
                            return;
                        } else referenceMap1.set(value, {
                            offset: position1 - start
                        });
                    }
                    let constructor = value.constructor;
                    if (constructor === Object) {
                        writeObject(value, true);
                    } else if (constructor === Array) {
                        length = value.length;
                        if (length < 0x18) {
                            target[position1++] = 0x80 | length;
                        } else {
                            writeArrayHeader(length);
                        }
                        for(let i200 = 0; i200 < length; i200++){
                            encode12(value[i200]);
                        }
                    } else if (constructor === Map) {
                        if (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {
                            target[position1++] = 0xd9;
                            target[position1++] = 1;
                            target[position1++] = 3;
                        }
                        length = value.size;
                        if (length < 0x18) {
                            target[position1++] = 0xa0 | length;
                        } else if (length < 0x100) {
                            target[position1++] = 0xb8;
                            target[position1++] = length;
                        } else if (length < 0x10000) {
                            target[position1++] = 0xb9;
                            target[position1++] = length >> 8;
                            target[position1++] = length & 0xff;
                        } else {
                            target[position1++] = 0xba;
                            targetView.setUint32(position1, length);
                            position1 += 4;
                        }
                        if (encoder1.keyMap) {
                            for (let [key, entryValue] of value){
                                encode12(encoder1.encodeKey(key));
                                encode12(entryValue);
                            }
                        } else {
                            for (let [key, entryValue] of value){
                                encode12(key);
                                encode12(entryValue);
                            }
                        }
                    } else {
                        for(let i201 = 0, l = extensions.length; i201 < l; i201++){
                            let extensionClass = extensionClasses[i201];
                            if (value instanceof extensionClass) {
                                let extension = extensions[i201];
                                let tag = extension.tag;
                                if (tag == undefined) tag = extension.getTag && extension.getTag(value);
                                if (tag < 0x18) {
                                    target[position1++] = 0xc0 | tag;
                                } else if (tag < 0x100) {
                                    target[position1++] = 0xd8;
                                    target[position1++] = tag;
                                } else if (tag < 0x10000) {
                                    target[position1++] = 0xd9;
                                    target[position1++] = tag >> 8;
                                    target[position1++] = tag & 0xff;
                                } else if (tag > -1) {
                                    target[position1++] = 0xda;
                                    targetView.setUint32(position1, tag);
                                    position1 += 4;
                                }
                                extension.encode.call(this, value, encode12, makeRoom);
                                return;
                            }
                        }
                        if (value[Symbol.iterator]) {
                            target[position1++] = 0x9f;
                            for (let entry of value){
                                encode12(entry);
                            }
                            target[position1++] = 0xff;
                            return;
                        }
                        writeObject(value, !value.hasOwnProperty);
                    }
                }
            } else if (type === 'boolean') {
                target[position1++] = value ? 0xf5 : 0xf4;
            } else if (type === 'bigint') {
                if (value < BigInt(1) << BigInt(64) && value >= 0) {
                    target[position1++] = 0x1b;
                    targetView.setBigUint64(position1, value);
                } else if (value > -(BigInt(1) << BigInt(64)) && value < 0) {
                    target[position1++] = 0x3b;
                    targetView.setBigUint64(position1, -value - BigInt(1));
                } else {
                    if (this.largeBigIntToFloat) {
                        target[position1++] = 0xfb;
                        targetView.setFloat64(position1, Number(value));
                    } else {
                        throw new RangeError(value + ' was too large to fit in CBOR 64-bit integer format, set largeBigIntToFloat to convert to float-64');
                    }
                }
                position1 += 8;
            } else if (type === 'undefined') {
                target[position1++] = 0xf7;
            } else {
                throw new Error('Unknown type: ' + type);
            }
        };
        const writeObject = this.useRecords === false ? this.variableMapSize ? (object)=>{
            let keys = Object.keys(object);
            let vals = Object.values(object);
            let length = keys.length;
            if (length < 0x18) {
                target[position1++] = 0xa0 | length;
            } else if (length < 0x100) {
                target[position1++] = 0xb8;
                target[position1++] = length;
            } else if (length < 0x10000) {
                target[position1++] = 0xb9;
                target[position1++] = length >> 8;
                target[position1++] = length & 0xff;
            } else {
                target[position1++] = 0xba;
                targetView.setUint32(position1, length);
                position1 += 4;
            }
            if (encoder1.keyMap) {
                for(let i202 = 0; i202 < length; i202++){
                    encode12(encodeKey(keys[i202]));
                    encode12(vals[i202]);
                }
            } else {
                for(let i203 = 0; i203 < length; i203++){
                    encode12(keys[i203]);
                    encode12(vals[i203]);
                }
            }
        } : (object, safePrototype)=>{
            target[position1++] = 0xb9;
            let objectOffset = position1 - start;
            position1 += 2;
            let size = 0;
            if (encoder1.keyMap) {
                for(let key in object)if (safePrototype || object.hasOwnProperty(key)) {
                    encode12(encoder1.encodeKey(key));
                    encode12(object[key]);
                    size++;
                }
            } else {
                for(let key in object)if (safePrototype || object.hasOwnProperty(key)) {
                    encode12(key);
                    encode12(object[key]);
                    size++;
                }
            }
            target[(objectOffset++) + start] = size >> 8;
            target[objectOffset + start] = size & 0xff;
        } : (object, safePrototype)=>{
            let nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null));
            let newTransitions = 0;
            let length = 0;
            let parentRecordId;
            let keys;
            if (this.keyMap) {
                keys = Object.keys(object).map((k)=>this.encodeKey(k)
                );
                length = keys.length;
                for(let i204 = 0; i204 < length; i204++){
                    let key = keys[i204];
                    nextTransition = transition[key];
                    if (!nextTransition) {
                        nextTransition = transition[key] = Object.create(null);
                        newTransitions++;
                    }
                    transition = nextTransition;
                }
            } else {
                for(let key in object)if (safePrototype || object.hasOwnProperty(key)) {
                    nextTransition = transition[key];
                    if (!nextTransition) {
                        if (transition[RECORD_SYMBOL] & 0x100000) {
                            parentRecordId = transition[RECORD_SYMBOL] & 0xffff;
                        }
                        nextTransition = transition[key] = Object.create(null);
                        newTransitions++;
                    }
                    transition = nextTransition;
                    length++;
                }
            }
            let recordId = transition[RECORD_SYMBOL];
            if (recordId !== undefined) {
                recordId &= 0xffff;
                target[position1++] = 0xd9;
                target[position1++] = recordId >> 8 | 0xe0;
                target[position1++] = recordId & 0xff;
            } else {
                if (!keys) keys = transition.__keys__ || (transition.__keys__ = Object.keys(object));
                if (parentRecordId === undefined) {
                    recordId = structures.nextId++;
                    if (!recordId) {
                        recordId = 0;
                        structures.nextId = 1;
                    }
                    if (recordId >= 0x100) {
                        structures.nextId = (recordId = maxSharedStructures) + 1;
                    }
                } else {
                    recordId = parentRecordId;
                }
                structures[recordId] = keys;
                if (recordId < maxSharedStructures) {
                    target[position1++] = 0xd9;
                    target[position1++] = recordId >> 8 | 0xe0;
                    target[position1++] = recordId & 0xff;
                    transition = structures.transitions;
                    for(let i205 = 0; i205 < length; i205++){
                        if (transition[RECORD_SYMBOL] === undefined || transition[RECORD_SYMBOL] & 0x100000) transition[RECORD_SYMBOL] = recordId;
                        transition = transition[keys[i205]];
                    }
                    transition[RECORD_SYMBOL] = recordId | 0x100000;
                    hasSharedUpdate = true;
                } else {
                    transition[RECORD_SYMBOL] = recordId;
                    targetView.setUint32(position1, 0xd9dfff00);
                    position1 += 3;
                    if (newTransitions) transitionsCount += serializationsSinceTransitionRebuild * newTransitions;
                    if (recordIdsToRemove.length >= 0x100 - maxSharedStructures) recordIdsToRemove.shift()[RECORD_SYMBOL] = undefined;
                    recordIdsToRemove.push(transition);
                    writeArrayHeader(length + 2);
                    encode12(0xe000 + recordId);
                    encode12(keys);
                    for (let v of Object.values(object))encode12(v);
                    return;
                }
            }
            if (length < 0x18) {
                target[position1++] = 0x80 | length;
            } else {
                writeArrayHeader(length);
            }
            for(let key in object)if (safePrototype || object.hasOwnProperty(key)) encode12(object[key]);
        };
        const makeRoom = (end)=>{
            let newSize;
            if (end > 0x1000000) {
                if (end - start > MAX_BUFFER_SIZE) throw new Error('Encoded buffer would be larger than maximum buffer size');
                newSize = Math.min(MAX_BUFFER_SIZE, Math.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000);
            } else newSize = (Math.max(end - start << 2, target.length - 1) >> 12) + 1 << 12;
            let newBuffer = new ByteArrayAllocate(newSize);
            targetView = new DataView(newBuffer.buffer, 0, newSize);
            if (target.copy) target.copy(newBuffer, 0, start, end);
            else newBuffer.set(target.slice(start, end));
            position1 -= start;
            start = 0;
            safeEnd = newBuffer.length - 10;
            return target = newBuffer;
        };
    }
    useBuffer(buffer) {
        target = buffer;
        targetView = new DataView(target.buffer, target.byteOffset, target.byteLength);
        position1 = 0;
    }
    clearSharedData() {
        if (this.structures) this.structures = [];
        if (this.sharedValues) this.sharedValues = undefined;
    }
    updateSharedData() {
        let lastVersion = this.sharedVersion || 0;
        this.sharedVersion = lastVersion + 1;
        let structuresCopy = this.structures.slice(0);
        let sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion);
        let saveResults = this.saveShared(sharedData, (existingShared)=>(existingShared && existingShared.version || 0) == lastVersion
        );
        if (saveResults === false) {
            sharedData = this.getShared() || {};
            this.structures = sharedData.structures || [];
            this.sharedValues = sharedData.packedValues;
            this.sharedVersion = sharedData.version;
            this.structures.nextId = this.structures.length;
        } else {
            structuresCopy.forEach((structure, i206)=>this.structures[i206] = structure
            );
        }
        return saveResults;
    }
}
class SharedData {
    constructor(structures, values, version){
        this.structures = structures;
        this.packedValues = values;
        this.version = version;
    }
}
function writeArrayHeader(length) {
    if (length < 0x18) target[position1++] = 0x80 | length;
    else if (length < 0x100) {
        target[position1++] = 0x98;
        target[position1++] = length;
    } else if (length < 0x10000) {
        target[position1++] = 0x99;
        target[position1++] = length >> 8;
        target[position1++] = length & 0xff;
    } else {
        target[position1++] = 0x9a;
        targetView.setUint32(position1, length);
        position1 += 4;
    }
}
function findRepetitiveStrings(value, packedValues2) {
    switch(typeof value){
        case 'string':
            if (value.length > 3) {
                if (packedValues2.objectMap[value] > -1 || packedValues2.values.length >= packedValues2.maxValues) return;
                let packedStatus = packedValues2.get(value);
                if (packedStatus) {
                    if (++packedStatus.count == 2) {
                        packedValues2.values.push(value);
                    }
                } else {
                    packedValues2.set(value, {
                        count: 1
                    });
                    if (packedValues2.samplingPackedValues) {
                        let status = packedValues2.samplingPackedValues.get(value);
                        if (status) status.count++;
                        else packedValues2.samplingPackedValues.set(value, {
                            count: 1
                        });
                    }
                }
            }
            break;
        case 'object':
            if (value) {
                if (value instanceof Array) {
                    for(let i207 = 0, l = value.length; i207 < l; i207++){
                        findRepetitiveStrings(value[i207], packedValues2);
                    }
                } else {
                    let includeKeys = !packedValues2.encoder.useRecords;
                    for(var key in value){
                        if (value.hasOwnProperty(key)) {
                            if (includeKeys) findRepetitiveStrings(key, packedValues2);
                            findRepetitiveStrings(value[key], packedValues2);
                        }
                    }
                }
            }
            break;
        case 'function':
            console.log(value);
    }
}
const isLittleEndianMachine1 = new Uint8Array(new Uint16Array([
    1
]).buffer)[0] == 1;
extensionClasses = [
    Date,
    Set,
    Error,
    RegExp,
    Tag,
    ArrayBuffer,
    ByteArray,
    Uint8Array,
    Uint8ClampedArray,
    Uint16Array,
    Uint32Array,
    typeof BigUint64Array == 'undefined' ? function() {} : BigUint64Array,
    Int8Array,
    Int16Array,
    Int32Array,
    typeof BigInt64Array == 'undefined' ? function() {} : BigInt64Array,
    Float32Array,
    Float64Array,
    SharedData
];
extensions = [
    {
        tag: 1,
        encode (date, encode) {
            let seconds = date.getTime() / 1000;
            if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {
                target[position1++] = 0x1a;
                targetView.setUint32(position1, seconds);
                position1 += 4;
            } else {
                target[position1++] = 0xfb;
                targetView.setFloat64(position1, seconds);
                position1 += 8;
            }
        }
    },
    {
        tag: 258,
        encode (set, encode22) {
            let array = Array.from(set);
            encode22(array);
        }
    },
    {
        tag: 27,
        encode (error111, encode32) {
            encode32([
                error111.name,
                error111.message
            ]);
        }
    },
    {
        tag: 27,
        encode (regex, encode41) {
            encode41([
                'RegExp',
                regex.source,
                regex.flags
            ]);
        }
    },
    {
        getTag (tag) {
            return tag.tag;
        },
        encode (tag, encode5) {
            encode5(tag.value);
        }
    },
    {
        encode (arrayBuffer, encode, makeRoom) {
            writeBuffer(arrayBuffer, makeRoom);
        }
    },
    {
        encode (arrayBuffer, encode, makeRoom) {
            writeBuffer(arrayBuffer, makeRoom);
        }
    },
    typedArrayEncoder(64, 1),
    typedArrayEncoder(68, 1),
    typedArrayEncoder(69, 2),
    typedArrayEncoder(70, 4),
    typedArrayEncoder(71, 8),
    typedArrayEncoder(72, 1),
    typedArrayEncoder(77, 2),
    typedArrayEncoder(78, 4),
    typedArrayEncoder(79, 8),
    typedArrayEncoder(85, 4),
    typedArrayEncoder(86, 8),
    {
        encode (sharedData, encode6) {
            let packedValues3 = sharedData.packedValues || [];
            let sharedStructures = sharedData.structures || [];
            if (packedValues3.values.length > 0) {
                target[position1++] = 0xd8;
                target[position1++] = 51;
                writeArrayHeader(4);
                let valuesArray = packedValues3.values;
                encode6(valuesArray);
                writeArrayHeader(0);
                writeArrayHeader(0);
                packedObjectMap = Object.create(sharedPackedObjectMap || null);
                for(let i208 = 0, l = valuesArray.length; i208 < l; i208++){
                    packedObjectMap[valuesArray[i208]] = i208;
                }
            }
            if (sharedStructures) {
                targetView.setUint32(position1, 0xd9dffe00);
                position1 += 3;
                let definitions = sharedStructures.slice(0);
                definitions.unshift(0xe000);
                definitions.push(new Tag(sharedData.version, 0x53687264));
                encode6(definitions);
            } else encode6(new Tag(sharedData.version, 0x53687264));
        }
    }
];
function typedArrayEncoder(tag, size) {
    if (!isLittleEndianMachine1 && size > 1) tag -= 4;
    return {
        tag: tag,
        encode: function writeExtBuffer(typedArray, encode7) {
            let length = typedArray.byteLength;
            let offset = typedArray.byteOffset || 0;
            let buffer = typedArray.buffer || typedArray;
            encode7(hasNodeBuffer ? Buffer.from(buffer, offset, length) : new Uint8Array(buffer, offset, length));
        }
    };
}
function writeBuffer(buffer, makeRoom) {
    let length = buffer.byteLength;
    if (length < 0x18) {
        target[position1++] = 0x40 + length;
    } else if (length < 0x100) {
        target[position1++] = 0x58;
        target[position1++] = length;
    } else if (length < 0x10000) {
        target[position1++] = 0x59;
        target[position1++] = length >> 8;
        target[position1++] = length & 0xff;
    } else {
        target[position1++] = 0x5a;
        targetView.setUint32(position1, length);
        position1 += 4;
    }
    if (position1 + length >= target.length) {
        makeRoom(position1 + length);
    }
    target.set(buffer, position1);
    position1 += length;
}
function insertIds(serialized, idsToInsert) {
    let nextId;
    let distanceToMove = idsToInsert.length * 2;
    let lastEnd = serialized.length - distanceToMove;
    idsToInsert.sort((a26, b)=>a26.offset > b.offset ? 1 : -1
    );
    for(let id = 0; id < idsToInsert.length; id++){
        let referee = idsToInsert[id];
        referee.id = id;
        for (let position4 of referee.references){
            serialized[position4++] = id >> 8;
            serialized[position4] = id & 0xff;
        }
    }
    while(nextId = idsToInsert.pop()){
        let offset = nextId.offset;
        serialized.copyWithin(offset + distanceToMove, offset, lastEnd);
        distanceToMove -= 2;
        let position5 = offset + distanceToMove;
        serialized[position5++] = 0xd8;
        serialized[position5++] = 28;
        lastEnd = offset;
    }
    return serialized;
}
function writeBundles(start, encode8) {
    targetView.setUint32(bundledStrings1.position + start, position1 - bundledStrings1.position - start + 1);
    let writeStrings = bundledStrings1;
    bundledStrings1 = null;
    encode8(writeStrings[0]);
    encode8(writeStrings[1]);
}
let defaultEncoder = new Encoder({
    useRecords: false
});
const encode5 = defaultEncoder.encode;
const { NEVER , ALWAYS , DECIMAL_ROUND , DECIMAL_FIT  } = FLOAT32_OPTIONS;
const REUSE_BUFFER_MODE = 512;
const RESET_BUFFER_MODE = 1024;
const pkijs = {
    setEngine,
    CryptoEngine,
    Certificate: Certificate,
    CertificateRevocationList,
    CertificateChainValidationEngine,
    PublicKeyInfo
};
function abToStr(buf) {
    let str = "";
    new Uint8Array(buf).forEach((ch)=>{
        str += String.fromCharCode(ch);
    });
    return str;
}
function isBase64Url(str) {
    return !!str.match(/^[A-Za-z0-9\-_]+={0,2}$/);
}
function isPem(pem) {
    if (typeof pem !== "string") {
        return false;
    }
    const pemRegex = /^-----BEGIN .+-----$\n([A-Za-z0-9+/=]|\n)*^-----END .+-----$/m;
    return !!pem.match(pemRegex);
}
function isPositiveInteger(n13) {
    return n13 >>> 0 === parseFloat(n13);
}
function abToBuf(ab) {
    return new Uint8Array(ab).buffer;
}
function abToInt(ab) {
    if (!(ab instanceof ArrayBuffer)) {
        throw new Error("abToInt: expected ArrayBuffer");
    }
    const buf = new Uint8Array(ab);
    let cnt = ab.byteLength - 1;
    let ret = 0;
    buf.forEach((__byte)=>{
        ret |= __byte << cnt * 8;
        cnt--;
    });
    return ret;
}
function abToPem(type, ab) {
    if (typeof type !== "string") {
        throw new Error("abToPem expected 'type' to be string like 'CERTIFICATE', got: " + type);
    }
    const str = coerceToBase64(ab, "pem buffer");
    return [
        `-----BEGIN ${type}-----\n`,
        ...str.match(/.{1,64}/g).map((s14)=>s14 + "\n"
        ),
        `-----END ${type}-----\n`, 
    ].join("");
}
const appendBuffer = function(buffer1, buffer2) {
    const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
    tmp.set(new Uint8Array(buffer1), 0);
    tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
    return tmp.buffer;
};
function coerceToArrayBuffer(buf, name) {
    if (!name) {
        throw new TypeError("name not specified in coerceToArrayBuffer");
    }
    if (typeof buf === "string" && buf === "") {
        buf = new Uint8Array(0);
    } else if (typeof buf === "string") {
        buf = buf.replace(/\+/g, "-").replace(/\//g, "_").replace("=", "");
        buf = base64.toArrayBuffer(buf, true);
    }
    if (Array.isArray(buf)) {
        buf = new Uint8Array(buf);
    }
    if (typeof Buffer !== "undefined" && buf instanceof Buffer) {
        buf = new Uint8Array(buf);
        buf = buf.buffer;
    }
    if (buf instanceof Uint8Array) {
        buf = buf.slice(0, buf.byteLength, buf.buffer.byteOffset).buffer;
    }
    if (!(buf instanceof ArrayBuffer)) {
        throw new TypeError(`could not coerce '${name}' to ArrayBuffer`);
    }
    return buf;
}
function coerceToBase64(thing, name) {
    if (!name) {
        throw new TypeError("name not specified in coerceToBase64");
    }
    if (typeof thing !== "string") {
        try {
            thing = base64.fromArrayBuffer(coerceToArrayBuffer(thing, name));
        } catch (_err) {
            throw new Error(`could not coerce '${name}' to string`);
        }
    }
    if (typeof thing !== "string") {
        throw new Error(`could not coerce '${name}' to string`);
    }
    return thing;
}
function strToAb(str) {
    const buf = new ArrayBuffer(str.length);
    const bufView = new Uint8Array(buf);
    for(let i209 = 0, strLen = str.length; i209 < strLen; i209++){
        bufView[i209] = str.charCodeAt(i209);
    }
    return buf;
}
function coerceToBase64Url(thing, name) {
    if (!name) {
        throw new TypeError("name not specified in coerceToBase64");
    }
    if (typeof thing !== "string") {
        try {
            thing = base64.fromArrayBuffer(coerceToArrayBuffer(thing, name), true);
        } catch (_err) {
            throw new Error(`could not coerce '${name}' to string`);
        }
    }
    if (typeof thing !== "string") {
        throw new Error(`could not coerce '${name}' to string`);
    }
    return thing;
}
function abEqual(b1, b2) {
    if (!(b1 instanceof ArrayBuffer) || !(b2 instanceof ArrayBuffer)) {
        console.log("not array buffers");
        return false;
    }
    if (b1.byteLength !== b2.byteLength) {
        console.log("not same length");
        return false;
    }
    b1 = new Uint8Array(b1);
    b2 = new Uint8Array(b2);
    for(let i215 = 0; i215 < b1.byteLength; i215++){
        if (b1[i215] !== b2[i215]) return false;
    }
    return true;
}
function abToHex(ab) {
    if (!(ab instanceof ArrayBuffer)) {
        throw new TypeError("Invalid argument passed to abToHex");
    }
    const result = Array.prototype.map.call(new Uint8Array(ab), (x)=>("00" + x.toString(16)).slice(-2)
    ).join("");
    return result;
}
function b64ToJsObject(b64, desc) {
    return JSON.parse(abToStr(coerceToArrayBuffer(b64, desc)));
}
function jsObjectToB64(obj) {
    return base64.fromString(JSON.stringify(obj).replace(/[\u{0080}-\u{FFFF}]/gu, ""));
}
function pemToBase64(pem) {
    if (!isPem(pem)) {
        throw new Error("expected PEM string as input");
    }
    let pemArr = pem.split("\n");
    pemArr = pemArr.slice(1, pemArr.length - 2);
    return pemArr.join("");
}
const cbor = {
    encode: encode5,
    decode: decode5
};
const webcrypto = crypto;
pkijs.setEngine('newEngine', webcrypto, new pkijs.CryptoEngine({
    name: '',
    crypto: webcrypto,
    subtle: webcrypto.subtle
}));
function derToRaw(signature) {
    const rStart = signature[4] === 0 ? 5 : 4;
    const rEnd = rStart + 32;
    const sStart = signature[rEnd + 2] === 0 ? rEnd + 3 : rEnd + 2;
    return new Uint8Array([
        ...signature.slice(rStart, rEnd),
        ...signature.slice(sStart)
    ]);
}
function checkOrigin(str) {
    const originUrl = new _url(str);
    const origin = originUrl.origin;
    if (origin !== str) {
        throw new Error('origin was malformatted');
    }
    const isLocalhost = originUrl.hostname == 'localhost' || originUrl.hostname.endsWith('.localhost');
    if (originUrl.protocol !== 'https:' && !isLocalhost) {
        throw new Error('origin should be https');
    }
    if ((!validDomainName(originUrl.hostname) || !validEtldPlusOne(originUrl.hostname)) && !isLocalhost) {
        throw new Error('origin is not a valid eTLD+1');
    }
    return origin;
}
function checkUrl(value, name, rules = {}) {
    if (!name) {
        throw new TypeError('name not specified in checkUrl');
    }
    if (typeof value !== 'string') {
        throw new Error(`${name} must be a string`);
    }
    let urlValue = null;
    try {
        urlValue = new _url(value);
    } catch (_err) {
        throw new Error(`${name} is not a valid eTLD+1/url`);
    }
    if (!value.startsWith('http')) {
        throw new Error(`${name} must be http protocol`);
    }
    if (!rules.allowHttp && urlValue.protocol !== 'https:') {
        throw new Error(`${name} should be https`);
    }
    if (!rules.allowPath && (value.endsWith('/') || urlValue.pathname !== '/')) {
        throw new Error(`${name} should not include path in url`);
    }
    if (!rules.allowHash && urlValue.hash) {
        throw new Error(`${name} should not include hash in url`);
    }
    if (!rules.allowCred && (urlValue.username || urlValue.password)) {
        throw new Error(`${name} should not include credentials in url`);
    }
    if (!rules.allowQuery && urlValue.search) {
        throw new Error(`${name} should not include query string in url`);
    }
    return value;
}
function validEtldPlusOne(value) {
    const result = u(value, {
        allowPrivateDomains: true
    });
    if (result.publicSuffix === null) {
        return false;
    }
    if (result.domainWithoutSuffix === null) {
        return false;
    }
    return true;
}
function validDomainName(value) {
    const ascii = __default.toASCII(value);
    if (ascii.length < 1) {
        return false;
    }
    if (ascii.length > 255) {
        return false;
    }
    const labels = ascii.split('.');
    let label;
    for(let i216 = 0; i216 < labels.length; ++i216){
        label = labels[i216];
        if (!label.length) {
            return false;
        }
        if (label.length > 63) {
            return false;
        }
        if (label.charAt(0) === '-') {
            return false;
        }
        if (!/^[a-z0-9-]+$/.test(label)) {
            return false;
        }
    }
    return true;
}
function checkDomainOrUrl(value, name, rules = {}) {
    if (!name) {
        throw new TypeError('name not specified in checkDomainOrUrl');
    }
    if (typeof value !== 'string') {
        throw new Error(`${name} must be a string`);
    }
    if (validEtldPlusOne(value, name) && validDomainName(value, name)) {
        return value;
    }
    return checkUrl(value, name, rules);
}
function checkRpId(rpId) {
    if (typeof rpId !== 'string') {
        throw new Error('rpId must be a string');
    }
    const isLocalhost = rpId === 'localhost' || rpId.endsWith('.localhost');
    if (isLocalhost) return rpId;
    return checkDomainOrUrl(rpId, 'rpId');
}
async function verifySignature(publicKeyPem, expectedSignature, data, hashName) {
    try {
        const publicKey = new Key();
        const importedKey = await publicKey.fromPem(publicKeyPem);
        let uSignature = new Uint8Array(expectedSignature);
        const alg = importedKey.algorithm;
        if (!alg.hash) {
            alg.hash = {
                name: hashName || 'SHA-256'
            };
        }
        if (alg.name === 'ECDSA') {
            uSignature = await derToRaw(uSignature);
        }
        return await crypto.subtle.verify(alg, publicKey.getKey(), new Uint8Array(uSignature), new Uint8Array(data));
    } catch (_e) {
        console.error(_e);
    }
}
async function hashDigest(o25, alg) {
    if (typeof o25 === 'string') {
        o25 = new TextEncoder().encode(o25);
    }
    const result = await crypto.subtle.digest(alg || 'sha-256', o25);
    return result;
}
function randomValues(n14) {
    const byteArray = new Uint8Array(n14);
    crypto.getRandomValues(byteArray);
    return byteArray;
}
function getHostname1(urlIn) {
    return new _url(urlIn).hostname;
}
async function getEmbeddedJwk(jwsHeader, alg) {
    let publicKey;
    if (jwsHeader.jwk) {
        publicKey = jwsHeader.jwk;
    } else if (jwsHeader.x5c) {
        const x5c0 = jwsHeader.x5c[0];
        const cert = new Certificate1(x5c0);
        publicKey = await cert.getPublicKey();
        publicKey.kid = publicKey.kid || cert.getCommonName();
    }
    if (!publicKey) {
        throw new Error('getEmbeddedJwk: JWK not found in JWS.');
    }
    publicKey.alg = publicKey.alg || jwsHeader.alg || alg;
    return publicKey;
}
const mod3 = {
    cbor: cbor,
    checkDomainOrUrl: checkDomainOrUrl,
    checkOrigin: checkOrigin,
    checkRpId: checkRpId,
    checkUrl: checkUrl,
    decodeProtectedHeader: decodeProtectedHeader,
    exportSPKI: exportSPKI,
    fromBER: fromBER,
    getEmbeddedJwk: getEmbeddedJwk,
    getHostname: getHostname1,
    hashDigest: hashDigest,
    importJWK: importJWK,
    importSPKI: importSPKI,
    jwtVerify: jwtVerify,
    pkijs: pkijs,
    randomValues: randomValues,
    verifySignature: verifySignature,
    webcrypto: webcrypto
};
const mod4 = {
    abEqual: abEqual,
    abToBuf: abToBuf,
    abToHex: abToHex,
    abToInt: abToInt,
    abToPem: abToPem,
    abToStr: abToStr,
    appendBuffer: appendBuffer,
    b64ToJsObject: b64ToJsObject,
    base64: base64,
    coerceToArrayBuffer: coerceToArrayBuffer,
    coerceToBase64: coerceToBase64,
    coerceToBase64Url: coerceToBase64Url,
    isBase64Url: isBase64Url,
    isPem: isPem,
    isPositiveInteger: isPositiveInteger,
    jsObjectToB64: jsObjectToB64,
    pemToBase64: pemToBase64,
    strToAb: strToAb,
    tools: mod3
};
class Certificate1 {
    constructor(cert){
        if (isPem(cert)) {
            cert = pemToBase64(cert);
        }
        cert = coerceToArrayBuffer(cert, "certificate");
        if (cert.byteLength === 0) {
            throw new Error("cert was empty (0 bytes)");
        }
        const asn1 = mod3.fromBER(cert);
        if (asn1.offset === -1) {
            throw new Error("error parsing ASN.1");
        }
        this._cert = new mod3.pkijs.Certificate({
            schema: asn1.result
        });
        this.warning = new Map();
        this.info = new Map();
    }
    getCommonName() {
        const X509_COMMON_NAME_KEY = "2.5.4.3";
        let commonName = "";
        const subjectAttributes = this._cert.subject.typesAndValues;
        for(let index = 0; index < subjectAttributes.length; index++){
            const attribute = subjectAttributes[index];
            if (attribute.type === X509_COMMON_NAME_KEY) {
                commonName = attribute.value.valueBlock.value;
                break;
            }
        }
        return commonName;
    }
    verify() {
        const issuerSerial = this.getIssuer();
        const issuerCert = CertManager.getCertBySerial(issuerSerial);
        const _issuerCert = issuerCert ? issuerCert._cert : undefined;
        return this._cert.verify(_issuerCert).catch((err)=>{
            if (typeof err === "string") {
                err = new Error(err);
            }
            return Promise.reject(err);
        });
    }
    getPublicKey() {
        let key;
        return this._cert.getPublicKey().then((k)=>{
            key = k;
            return mod3.webcrypto.subtle.exportKey("jwk", key);
        });
    }
    getIssuer() {
        return this._cert.issuer.typesAndValues[0].value.valueBlock.value;
    }
    getSerial() {
        return this._cert.subject.typesAndValues[0].value.valueBlock.value;
    }
    getVersion() {
        return this._cert.version + 1;
    }
    getSubject() {
        const ret = new Map();
        const subjectItems = this._cert.subject.typesAndValues;
        for (const subject of subjectItems){
            const kv = resolveOid(subject.type, decodeValue(subject.value.valueBlock));
            ret.set(kv.id, kv.value);
        }
        return ret;
    }
    getExtensions() {
        const ret = new Map();
        if (this._cert.extensions === undefined) return ret;
        for (const ext of this._cert.extensions){
            let kv;
            let v = ext.parsedValue || ext.extnValue;
            if (v.valueBlock) v = decodeValue(v.valueBlock);
            try {
                kv = resolveOid(ext.extnID, v);
            } catch (err) {
                if (ext.critical === false) {
                    this.warning.set("x509-extension-error", ext.extnID + ": " + err.message);
                    continue;
                } else {
                    throw err;
                }
            }
            ret.set(kv.id, kv.value);
        }
        return ret;
    }
}
function getKeyInfo(ber) {
    const asn1 = mod3.fromBER(ber);
    if (asn1.offset === -1) {
        throw new Error("error parsing ASN.1");
    }
    return new mod3.pkijs.PublicKeyInfo({
        schema: asn1.result
    });
}
function resolveOid(id, value) {
    const ret = {
        id,
        value
    };
    if (value && value.valueHex) value = value.valueHex;
    let retMap;
    switch(id){
        case "1.3.6.1.4.1.45724.2.1.1":
            ret.id = "fido-u2f-transports";
            ret.value = decodeU2FTransportType(value);
            return ret;
        case "1.3.6.1.4.1.45724.1.1.4":
            ret.id = "fido-aaguid";
            ret.value = decodeFidoAaguid(value);
            return ret;
        case "2.5.4.6":
            ret.id = "country-name";
            return ret;
        case "2.5.4.10":
            ret.id = "organization-name";
            return ret;
        case "2.5.4.11":
            ret.id = "organizational-unit-name";
            return ret;
        case "2.5.4.3":
            ret.id = "common-name";
            return ret;
        case "2.5.29.14":
            ret.id = "subject-key-identifier";
            return ret;
        case "2.5.29.15":
            ret.id = "key-usage";
            ret.value = decodeKeyUsage(value);
            return ret;
        case "2.5.29.19":
            ret.id = "basic-constraints";
            return ret;
        case "2.5.29.35":
            retMap = new Map();
            ret.id = "authority-key-identifier";
            retMap.set("key-identifier", decodeValue(value.keyIdentifier));
            ret.value = retMap;
            return ret;
        case "2.5.29.32":
            ret.id = "certificate-policies";
            ret.value = decodeCertificatePolicies(value);
            return ret;
        case "1.3.6.1.4.1.311.21.31":
            ret.id = "policy-qualifiers";
            ret.value = decodePolicyQualifiers(value);
            return ret;
        case "2.5.29.37":
            ret.id = "ext-key-usage";
            ret.value = decodeExtKeyUsage(value);
            return ret;
        case "2.5.29.17":
            ret.id = "subject-alt-name";
            ret.value = decodeAltNames(value);
            return ret;
        case "1.3.6.1.5.5.7.1.1":
            ret.id = "authority-info-access";
            ret.value = decodeAuthorityInfoAccess(value);
            return ret;
        case "1.3.6.1.5.5.7.48.2":
            ret.id = "cert-authority-issuers";
            if (typeof value !== "object") {
                throw new Error("expect cert-authority-issues to have Object as value");
            }
            ret.value = decodeGeneralName(value.type, value.value);
            return ret;
        case "1.3.6.1.5.5.7.2.2":
            ret.id = "policy-qualifier";
            ret.value = decodeValue(value.valueBlock);
            return ret;
        case "2.23.133.8.3":
            ret.id = "tcg-kp-aik-certificate";
            return ret;
        case "2.23.133.2.1":
            ret.id = "tcg-at-tpm-manufacturer";
            return ret;
        case "2.23.133.2.2":
            ret.id = "tcg-at-tpm-model";
            return ret;
        case "2.23.133.2.3":
            ret.id = "tcg-at-tpm-version";
            return ret;
        case "1.3.6.1.4.1.41482.2":
            ret.id = "yubico-device-id";
            ret.value = resolveOid(abToStr(value)).id;
            return ret;
        case "1.3.6.1.4.1.41482.1.1":
            ret.id = "Security Key by Yubico";
            return ret;
        case "1.3.6.1.4.1.41482.1.2":
            ret.id = "YubiKey NEO/NEO-n";
            return ret;
        case "1.3.6.1.4.1.41482.1.3":
            ret.id = "YubiKey Plus";
            return ret;
        case "1.3.6.1.4.1.41482.1.4":
            ret.id = "YubiKey Edge";
            return ret;
        case "1.3.6.1.4.1.41482.1.5":
            ret.id = "YubiKey 4/YubiKey 4 Nano";
            return ret;
        default:
            return ret;
    }
}
function decodeValue(valueBlock) {
    const blockType = Object.getPrototypeOf(valueBlock).constructor.name;
    switch(blockType){
        case "LocalOctetStringValueBlock":
        case "LocalOctetStringValueBlock1":
            return valueBlock.valueHex;
        case "LocalUtf8StringValueBlock":
        case "LocalUtf8StringValueBlock1":
            return valueBlock.value;
        case "LocalSimpleStringValueBlock":
        case "LocalSimpleStringValueBlock1":
            return valueBlock.value;
        case "OctetString":
        case "OctetString1":
            return valueBlock.valueBlock.valueHex;
        case "LocalBitStringValueBlock":
        case "LocalBitStringValueBlock1":
            return new Uint8Array(valueBlock.valueHex)[0];
        case "LocalBmpStringValueBlock":
        case "LocalBmpStringValueBlock1":
            return valueBlock.value;
        case "LocalConstructedValueBlock":
        case "LocalConstructedValueBlock1":
            if (typeof valueBlock === "object" && Array.isArray(valueBlock.value)) {
                return valueBlock.value.map((v)=>decodeValue(v)
                );
            }
            return valueBlock;
        case "BmpString":
        case "BmpString1":
            return decodeValue(valueBlock.valueBlock);
        case "Utf8String":
        case "Utf8String1":
            return valueBlock.valueBlock.value;
        default:
            throw new TypeError("unknown value type when decoding certificate: " + blockType);
    }
}
function decodeU2FTransportType(u2fRawTransports) {
    if (!(u2fRawTransports instanceof ArrayBuffer) || u2fRawTransports.byteLength !== 4) {
        throw new Error("u2fRawTransports was malformatted");
    }
    u2fRawTransports = new Uint8Array(u2fRawTransports);
    if (u2fRawTransports[0] !== 0x03 || u2fRawTransports[1] !== 0x02 || u2fRawTransports[2] > 7) {
        throw new Error("u2fRawTransports had unknown data");
    }
    const bitLen = u2fRawTransports[2];
    const bitCount = 8 - bitLen - 1;
    let type = u2fRawTransports[3] >> bitLen;
    const ret = new Set();
    for(let i217 = bitCount; i217 >= 0; i217--){
        if (type & 0x1) {
            switch(i217){
                case 0:
                    ret.add("bluetooth-classic");
                    break;
                case 1:
                    ret.add("bluetooth-low-energy");
                    break;
                case 2:
                    ret.add("usb");
                    break;
                case 3:
                    ret.add("nfc");
                    break;
                case 4:
                    ret.add("usb-internal");
                    break;
                default:
                    throw new Error("unknown U2F transport type: " + type);
            }
        }
        type >>= 1;
    }
    return ret;
}
function decodeKeyUsage(value) {
    if (typeof value !== "number") {
        throw new Error("certificate: expected 'keyUsage' value to be number");
    }
    const retSet = new Set();
    if (value & 0x80) retSet.add("digitalSignature");
    if (value & 0x40) retSet.add("contentCommitment");
    if (value & 0x20) retSet.add("keyEncipherment");
    if (value & 0x10) retSet.add("dataEncipherment");
    if (value & 0x08) retSet.add("keyAgreement");
    if (value & 0x04) retSet.add("keyCertSign");
    if (value & 0x02) retSet.add("cRLSign");
    if (value & 0x01) retSet.add("encipherOnly");
    if (value & 0x01) retSet.add("decipherOnly");
    return retSet;
}
function decodeExtKeyUsage(value) {
    let keyPurposes = value.keyPurposes;
    if (typeof value !== "object" || !Array.isArray(keyPurposes)) {
        throw new Error("expected extended key purposes to be an Array");
    }
    keyPurposes = keyPurposes.map((oid)=>resolveOid(oid).id
    );
    return keyPurposes;
}
function decodeFidoAaguid(value) {
    if (!(value instanceof ArrayBuffer)) {
        throw new Error("expected AAGUID to be ArrayBuffer");
    }
    if (value.byteLength !== 18) {
        throw new Error("AAGUID ASN.1 was wrong size. Should be 18, got " + value.byteLength);
    }
    const aaguidBuf = new Uint8Array(value);
    if (aaguidBuf[0] !== 0x04) {
        throw new Error("AAGUID ASN.1 should start with 0x04 (octet string)");
    }
    if (aaguidBuf[1] !== 0x10) {
        throw new Error("AAGUID ASN.1 should have length 16");
    }
    return aaguidBuf.buffer.slice(2);
}
function decodeCertificatePolicies(value) {
    if (value && Array.isArray(value.certificatePolicies)) {
        value = value.certificatePolicies.map(()=>resolveOid(value.certificatePolicies[0].policyIdentifier, value.certificatePolicies[0].policyQualifiers)
        );
    }
    return value;
}
function decodePolicyQualifiers(value) {
    if (value && Array.isArray(value)) {
        value = value.map((qual)=>resolveOid(qual.policyQualifierId, qual.qualifier)
        );
    }
    return value;
}
function decodeAltNames(value) {
    if (typeof value !== "object" || !Array.isArray(value.altNames)) {
        throw new Error("expected alternate names to be an Array");
    }
    let altNames = value.altNames;
    altNames = altNames.map((name)=>{
        if (typeof name !== "object") {
            throw new Error("expected alternate name to be an object");
        }
        if (name.type !== 4) {
            throw new Error("expected all alternate names to be of general type");
        }
        if (typeof name.value !== "object" || !Array.isArray(name.value.typesAndValues)) {
            throw new Error("malformatted alternate name");
        }
        return decodeGeneralName(name.type, name.value.typesAndValues);
    });
    return altNames;
}
function decodeAuthorityInfoAccess(v) {
    if (typeof v !== "object" || !Array.isArray(v.accessDescriptions)) {
        throw new Error("expected authority info access descriptions to be Array");
    }
    const retMap = new Map();
    v.accessDescriptions.forEach((desc)=>{
        const { id , value  } = resolveOid(desc.accessMethod, desc.accessLocation);
        retMap.set(id, value);
    });
    return retMap;
}
function decodeGeneralName(type, v) {
    if (typeof type !== "number") {
        throw new Error("malformed general name in x509 certificate");
    }
    let nameList;
    switch(type){
        case 0:
            throw new Error("general name 'other name' not supported");
        case 1:
            throw new Error("general name 'rfc822Name' not supported");
        case 2:
            throw new Error("general name 'dNSName' not supported");
        case 3:
            throw new Error("general name 'x400Address' not supported");
        case 4:
            if (!Array.isArray(v)) {
                throw new Error("expected general name 'directory name' to be Array");
            }
            nameList = new Map();
            v.forEach((val)=>{
                const { id , value  } = resolveOid(val.type, decodeValue(val.value));
                nameList.set(id, value);
            });
            return {
                directoryName: nameList
            };
        case 5:
            throw new Error("general name 'ediPartyName' not supported");
        case 6:
            return {
                uniformResourceIdentifier: v
            };
        case 7:
            throw new Error("general name 'iPAddress' not supported");
        case 8:
            throw new Error("general name 'registeredID' not supported");
        default:
            throw new Error("unknown general name type: " + type);
    }
}
class CRL {
    constructor(crl){
        if (isPem(crl)) {
            crl = pemToBase64(crl);
        }
        crl = coerceToArrayBuffer(crl, "crl");
        const asn1 = mod3.fromBER(crl);
        this._crl = new mod3.pkijs.CertificateRevocationList({
            schema: asn1.result
        });
    }
}
const certMap = new Map();
class CertManager {
    static addCert(certBuf) {
        const cert = new Certificate1(certBuf);
        const serial = cert.getSerial();
        certMap.set(serial, cert);
        return true;
    }
    static getCerts() {
        return new Map([
            ...certMap
        ]);
    }
    static getCertBySerial(serial) {
        return certMap.get(serial);
    }
    static removeAll() {
        certMap.clear();
    }
    static async verifyCertChain(certs, roots, crls) {
        if (!Array.isArray(certs) || certs.length < 1) {
            throw new Error("expected 'certs' to be non-empty Array, got: " + certs);
        }
        certs = certs.map((cert)=>{
            if (!(cert instanceof Certificate1)) {
                cert = new Certificate1(cert);
            }
            return cert._cert;
        });
        if (!Array.isArray(roots) || roots.length < 1) {
            throw new Error("expected 'roots' to be non-empty Array, got: " + roots);
        }
        roots = roots.map((r10)=>{
            if (!(r10 instanceof Certificate1)) {
                r10 = new Certificate1(r10);
            }
            return r10._cert;
        });
        crls = crls || [];
        if (!Array.isArray(crls)) {
            throw new Error("expected 'crls' to be undefined or Array, got: " + crls);
        }
        crls = crls.map((crl)=>{
            if (!(crl instanceof CRL)) {
                crl = new CRL(crl);
            }
            return crl._crl;
        });
        const chain = new mod3.pkijs.CertificateChainValidationEngine({
            trustedCerts: roots,
            certs,
            crls
        });
        const res = await chain.verify();
        if (!res.result) {
            throw new Error(res.resultMessage);
        } else {
            return res;
        }
    }
}
const helpers = {
    resolveOid
};
const coseLabels = {
    1: {
        name: "kty",
        values: {
            2: "EC",
            3: "RSA"
        }
    },
    2: {
        name: "kid",
        values: {}
    },
    3: {
        name: "alg",
        values: {
            "-7": "ECDSA_w_SHA256",
            "-8": "EdDSA",
            "-35": "ECDSA_w_SHA384",
            "-36": "ECDSA_w_SHA512",
            "-257": "RSASSA-PKCS1-v1_5_w_SHA256",
            "-258": "RSASSA-PKCS1-v1_5_w_SHA384",
            "-259": "RSASSA-PKCS1-v1_5_w_SHA512",
            "-65535": "RSASSA-PKCS1-v1_5_w_SHA1"
        }
    },
    4: {
        name: "key_ops",
        values: {}
    },
    5: {
        name: "base_iv",
        values: {}
    }
};
const algHashes = {
    ECDSA_w_SHA256: "SHA256",
    ECDSA_w_SHA384: "SHA384",
    ECDSA_w_SHA512: "SHA512",
    "RSASSA-PKCS1-v1_5_w_SHA256": "SHA256",
    "RSASSA-PKCS1-v1_5_w_SHA384": "SHA384",
    "RSASSA-PKCS1-v1_5_w_SHA512": "SHA512",
    "RSASSA-PKCS1-v1_5_w_SHA1": "SHA1"
};
const algMap = {
    "RSASSA-PKCS1-v1_5_w_SHA256": "RS256",
    ECDSA_w_SHA256: "ES256"
};
function algToStr(alg) {
    if (typeof alg !== "number") {
        throw new TypeError("expected 'alg' to be a number, got: " + alg);
    }
    const algValues = coseLabels["3"].values;
    return algValues[alg];
}
function algToHashStr(alg) {
    if (typeof alg === "number") alg = algToStr(alg);
    if (typeof alg !== "string") {
        throw new Error("'alg' is not a string or a valid COSE algorithm number");
    }
    return algHashes[alg];
}
const keyParamList = {
    EC: {
        "-1": {
            name: "crv",
            values: {
                1: "P-256",
                2: "P-384",
                3: "P-521",
                4: "X25519",
                5: "X448",
                6: "Ed25519",
                7: "Ed448"
            }
        },
        "-2": {
            name: "x"
        },
        "-3": {
            name: "y"
        },
        "-4": {
            name: "d"
        }
    },
    RSA: {
        "-1": {
            name: "n"
        },
        "-2": {
            name: "e"
        },
        "-3": {
            name: "d"
        },
        "-4": {
            name: "p"
        },
        "-5": {
            name: "q"
        },
        "-6": {
            name: "dP"
        },
        "-7": {
            name: "dQ"
        },
        "-8": {
            name: "qInv"
        },
        "-9": {
            name: "other"
        },
        "-10": {
            name: "r_i"
        },
        "-11": {
            name: "d_i"
        },
        "-12": {
            name: "t_i"
        }
    }
};
class Key {
    constructor(key){
        this._original_pem = undefined;
        this._original_jwk = undefined;
        this._original_cose = undefined;
        this._key = key;
    }
    async fromPem(pem) {
        let base64ber, ber;
        if (isPem(pem)) {
            base64ber = pemToBase64(pem);
            ber = coerceToArrayBuffer(base64ber, "base64ber");
        } else {
            throw new Error("Supplied key is not in PEM format");
        }
        if (ber.byteLength === 0) {
            throw new Error("Supplied key ber was empty (0 bytes)");
        }
        getKeyInfo(ber);
        let importSPKIResult;
        try {
            importSPKIResult = await mod3.importSPKI(pem, "ES256");
        } catch (_e1) {
            if (!importSPKIResult) {
                try {
                    importSPKIResult = await mod3.importSPKI(pem, "RS256");
                } catch (_e2) {
                    throw new Error("Unsupported key format", _e1, _e2);
                }
            }
        }
        this._original_pem = pem;
        this._key = importSPKIResult;
        return this._key;
    }
    async fromJWK(jwk, extractable) {
        const jwkCopy = JSON.parse(JSON.stringify(jwk));
        if (typeof extractable !== "undefined" && typeof extractable === "boolean") {
            jwkCopy.ext = extractable;
        }
        this._alg = jwkCopy._alg;
        this._original_jwk = jwk;
        const generatedKey = await mod3.importJWK(jwkCopy, algMap[jwkCopy.alg] || jjwkCopywk.alg);
        this._key = generatedKey;
        return this._key;
    }
    async fromCose(cose) {
        if (typeof cose !== "object") {
            throw new TypeError("'cose' argument must be an object, probably an Buffer conatining valid COSE");
        }
        this._cose = coerceToArrayBuffer(cose, "coseToJwk");
        let parsedCose;
        try {
            parsedCose = mod3.cbor.decode(new Uint8Array(cose));
        } catch (err) {
            throw new Error("couldn't parse authenticator.authData.attestationData CBOR: " + err);
        }
        if (typeof parsedCose !== "object") {
            throw new Error("invalid parsing of authenticator.authData.attestationData CBOR");
        }
        const coseMap = new Map(Object.entries(parsedCose));
        const extraMap = new Map();
        const retKey = {};
        for (const kv of coseMap){
            const key = kv[0].toString();
            let value = kv[1].toString();
            if (!coseLabels[key]) {
                extraMap.set(kv[0], kv[1]);
                continue;
            }
            const name = coseLabels[key].name;
            if (coseLabels[key].values[value]) value = coseLabels[key].values[value];
            retKey[name] = value;
        }
        const keyParams = keyParamList[retKey.kty];
        for (const kv1 of extraMap){
            const key = kv1[0].toString();
            let value = kv1[1];
            if (!keyParams[key]) {
                throw new Error("unknown COSE key label: " + retKey.kty + " " + key);
            }
            const name = keyParams[key].name;
            if (keyParams[key].values) {
                value = keyParams[key].values[value.toString()];
            }
            value = coerceToBase64Url(value, "coseToJwk");
            retKey[name] = value;
        }
        this._original_cose = cose;
        await this.fromJWK(retKey, true);
        return this._key;
    }
    async toPem() {
        if (this._original_pem) {
            return this._original_pem;
        } else if (this._key) {
            let pemResult = await mod3.exportSPKI(this._key);
            if (pemResult[pemResult.length] !== "\n") {
                pemResult += "\n";
            }
            return pemResult;
        } else {
            throw new Error("No key information available");
        }
    }
    toJwk() {
        if (this._original_jwk) {
            return this._original_jwk;
        } else {
            throw new Error("No key information available");
        }
    }
    toCose() {
        if (this._original_cose) {
            return this._original_cose;
        } else {
            throw new Error("Key to Cose is not implemented.");
        }
    }
    getKey() {
        if (this._key) {
            return this._key;
        } else {
            throw new Error("Key data not available.");
        }
    }
}
const fidoMdsRootCert = "-----BEGIN CERTIFICATE-----\n" + "MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\n" + "A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\n" + "Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\n" + "MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\n" + "A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\n" + "hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\n" + "RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\n" + "gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\n" + "KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\n" + "QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\n" + "XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\n" + "DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\n" + "LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\n" + "RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\n" + "jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\n" + "6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\n" + "mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\n" + "Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\n" + "WD9f\n" + "-----END CERTIFICATE-----\n";
class MdsEntry {
    constructor(mdsEntry, tocEntry){
        for (const key2 of Object.keys(tocEntry)){
            this[key2] = tocEntry[key2];
        }
        for (const key1 of Object.keys(mdsEntry)){
            this[key1] = mdsEntry[key1];
        }
        if (this.metadataStatement) {
            delete this.metadataStatement;
        }
        this.attachmentHint = this.attachmentHint instanceof Array ? this.attachmentHint : attachmentHintToArr(this.attachmentHint);
        function attachmentHintToArr(hint) {
            const ret = [];
            if (hint & 0x0001) ret.push("internal");
            if (hint & 0x0002) ret.push("external");
            if (hint & 0x0004) ret.push("wired");
            if (hint & 0x0008) ret.push("wireless");
            if (hint & 0x0010) ret.push("nfc");
            if (hint & 0x0020) ret.push("bluetooth");
            if (hint & 0x0040) ret.push("network");
            if (hint & 0x0080) ret.push("ready");
            if (hint & 0xFF00) {
                throw new Error("unknown attachment hint flags: " + hint & 0xFF00);
            }
            return ret;
        }
        if (!Array.isArray(this.attestationTypes)) {
            throw new Error("expected attestationTypes to be Array, got: " + this.attestationTypes);
        }
        this.attestationTypes = this.attestationTypes.map((att)=>typeof att === "string" ? att : attestationTypeToStr(att)
        );
        function attestationTypeToStr(att) {
            switch(att){
                case 0x3E07:
                    return "basic-full";
                case 0x3E08:
                    return "basic-surrogate";
                case 0x3E09:
                    return "ecdaa";
                default:
                    throw new Error("uknown attestation type: " + att);
            }
        }
        if (this.authenticationAlgorithms) {
            this.authenticationAlgorithm = this.authenticationAlgorithms[0];
        }
        this.authenticationAlgorithm = typeof this.authenticationAlgorithm === "string" ? this.authenticationAlgorithm : algToStr1(this.authenticationAlgorithm);
        function algToStr1(alg) {
            switch(alg){
                case 0x0001:
                    return "ALG_SIGN_SECP256R1_ECDSA_SHA256_RAW";
                case 0x0002:
                    return "ALG_SIGN_SECP256R1_ECDSA_SHA256_DER";
                case 0x0003:
                    return "ALG_SIGN_RSASSA_PSS_SHA256_RAW";
                case 0x0004:
                    return "ALG_SIGN_RSASSA_PSS_SHA256_DER";
                case 0x0005:
                    return "ALG_SIGN_SECP256K1_ECDSA_SHA256_RAW";
                case 0x0006:
                    return "ALG_SIGN_SECP256K1_ECDSA_SHA256_DER";
                case 0x0007:
                    return "ALG_SIGN_SM2_SM3_RAW";
                case 0x0008:
                    return "ALG_SIGN_RSA_EMSA_PKCS1_SHA256_RAW";
                case 0x0009:
                    return "ALG_SIGN_RSA_EMSA_PKCS1_SHA256_DER";
                default:
                    throw new Error("unknown authentication algorithm: " + alg);
            }
        }
        if (this.attestationRootCertificates) {
            for (const certificate of this.attestationRootCertificates){
                CertManager.addCert(certificate);
            }
        }
        this.keyProtection = this.keyProtection instanceof Array ? this.keyProtection : keyProtToArr(this.keyProtection);
        function keyProtToArr(kp) {
            const ret = [];
            if (kp & 0x0001) ret.push("software");
            if (kp & 0x0002) ret.push("hardware");
            if (kp & 0x0004) ret.push("tee");
            if (kp & 0x0008) ret.push("secure-element");
            if (kp & 0x0010) ret.push("remote-handle");
            if (kp & 0xFFE0) {
                throw new Error("unknown key protection flags: " + kp & 0xFFE0);
            }
            return ret;
        }
        this.matcherProtection = this.matcherProtection instanceof Array ? this.matcherProtection : matcherProtToArr(this.matcherProtection);
        function matcherProtToArr(mp) {
            const ret = [];
            if (mp & 0x0001) ret.push("software");
            if (mp & 0x0002) ret.push("hardware");
            if (mp & 0x0004) ret.push("tee");
            if (mp & 0xFFF8) {
                throw new Error("unknown key protection flags: " + mp & 0xFFF8);
            }
            return ret;
        }
        if (this.publicKeyAlgAndEncodings) {
            this.publicKeyAlgAndEncoding = `ALG_KEY_${this.publicKeyAlgAndEncodings[0].toUpperCase()}`;
        }
        this.publicKeyAlgAndEncoding = typeof this.publicKeyAlgAndEncoding === "string" ? this.publicKeyAlgAndEncoding : pkAlgAndEncodingToStr(this.publicKeyAlgAndEncoding);
        function pkAlgAndEncodingToStr(pkalg) {
            switch(pkalg){
                case 0x0100:
                    return "ALG_KEY_ECC_X962_RAW";
                case 0x0101:
                    return "ALG_KEY_ECC_X962_DER";
                case 0x0102:
                    return "ALG_KEY_RSA_2048_RAW";
                case 0x0103:
                    return "ALG_KEY_RSA_2048_DER";
                case 0x0104:
                    return "ALG_KEY_COSE";
                default:
                    throw new Error("unknown public key algorithm and encoding: " + pkalg);
            }
        }
        this.tcDisplay = this.tcDisplay instanceof Array ? this.tcDisplay : tcDisplayToArr(this.tcDisplay);
        function tcDisplayToArr(tcd) {
            const ret = [];
            if (tcd & 0x0001) ret.push("any");
            if (tcd & 0x0002) ret.push("priviledged-software");
            if (tcd & 0x0004) ret.push("tee");
            if (tcd & 0x0008) ret.push("hardware");
            if (tcd & 0x0010) ret.push("remote");
            if (tcd & 0xFFE0) {
                throw new Error("unknown transaction confirmation display flags: " + tcd & 0xFFE0);
            }
            return ret;
        }
        this.userVerificationDetails = uvDetailsToSet(this.userVerificationDetails);
        function uvDetailsToSet(uvList) {
            const ret = [];
            if (!Array.isArray(uvList)) {
                throw new Error("expected userVerificationDetails to be an Array, got: " + uvList);
            }
            uvList.forEach((uv)=>{
                if (!Array.isArray(uv)) {
                    throw new Error("expected userVerification to be Array, got " + uv);
                }
                const d = uv.map((desc)=>{
                    const newDesc = {};
                    let descKey;
                    if ("caDesc" in desc) {
                        newDesc.type = "code";
                        descKey = "caDesc";
                    }
                    if ("baDesc" in desc) {
                        newDesc.type = "biometric";
                        descKey = "baDesc";
                    }
                    if ("paDesc" in desc) {
                        newDesc.type = "pattern";
                        descKey = "paDesc";
                    }
                    newDesc.userVerification = uvToArr(desc.userVerification);
                    if (desc.userVerificationMethod) {
                        newDesc.userVerification = (desc.userVerificationMethod.match(/(\w+)_internal/) || [
                            "none",
                            "none"
                        ])[1];
                    }
                    if (descKey) {
                        for (const key of Object.keys(desc[descKey])){
                            newDesc[key] = desc[descKey][key];
                        }
                    }
                    return newDesc;
                });
                ret.push(d);
            });
            return ret;
        }
        function uvToArr(uv) {
            const ret = [];
            if (uv & 0x00000001) ret.push("presence");
            if (uv & 0x00000002) ret.push("fingerprint");
            if (uv & 0x00000004) ret.push("passcode");
            if (uv & 0x00000008) ret.push("voiceprint");
            if (uv & 0x00000010) ret.push("faceprint");
            if (uv & 0x00000020) ret.push("location");
            if (uv & 0x00000040) ret.push("eyeprint");
            if (uv & 0x00000080) ret.push("pattern");
            if (uv & 0x00000100) ret.push("handprint");
            if (uv & 0x00000200) ret.push("none");
            if (uv & 0x00000400) ret.push("all");
            return ret;
        }
        if (this.protocolFamily === undefined) this.protocolFamily = "uaf";
        realBoolean(this, "isSecondFactorOnly");
        realBoolean(this, "isKeyRestricted");
        realBoolean(this, "isFreshUserVerificationRequired");
    }
}
class MdsCollection {
    constructor(collectionName){
        if (typeof collectionName !== "string" || collectionName.length < 1) {
            throw new Error("expected 'collectionName' to be non-empty string, got: " + collectionName);
        }
        this.toc = null;
        this.unvalidatedEntryList = new Map();
        this.entryList = new Map();
        this.validated = false;
        this.name = collectionName;
    }
    async addToc(tocStr, rootCert, crls) {
        if (typeof tocStr !== "string" || tocStr.length < 1) {
            throw new Error("expected MDS TOC to be non-empty string");
        }
        let parsedJws;
        try {
            const protectedHeader = await mod3.decodeProtectedHeader(tocStr);
            const publicKey = await mod3.getEmbeddedJwk(protectedHeader);
            parsedJws = await mod3.jwtVerify(tocStr, await mod3.importJWK(publicKey));
            parsedJws.header = protectedHeader;
            parsedJws.key = publicKey;
            this.toc = parsedJws.payload;
        } catch (e19) {
            e19.message = "could not parse and validate MDS TOC: " + e19.message;
            throw e19;
        }
        if (rootCert === undefined) {
            if (parsedJws.kid === "Metadata TOC Signer 3" || parsedJws.key && parsedJws.key.kid === "Metadata TOC Signer 3") {
                rootCert = "-----BEGIN CERTIFICATE-----\n" + "MIICQzCCAcigAwIBAgIORqmxkzowRM99NQZJurcwCgYIKoZIzj0EAwMwUzELMAkG\n" + "A1UEBhMCVVMxFjAUBgNVBAoTDUZJRE8gQWxsaWFuY2UxHTAbBgNVBAsTFE1ldGFk\n" + "YXRhIFRPQyBTaWduaW5nMQ0wCwYDVQQDEwRSb290MB4XDTE1MDYxNzAwMDAwMFoX\n" + "DTQ1MDYxNzAwMDAwMFowUzELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUZJRE8gQWxs\n" + "aWFuY2UxHTAbBgNVBAsTFE1ldGFkYXRhIFRPQyBTaWduaW5nMQ0wCwYDVQQDEwRS\n" + "b290MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEFEoo+6jdxg6oUuOloqPjK/nVGyY+\n" + "AXCFz1i5JR4OPeFJs+my143ai0p34EX4R1Xxm9xGi9n8F+RxLjLNPHtlkB3X4ims\n" + "rfIx7QcEImx1cMTgu5zUiwxLX1ookVhIRSoso2MwYTAOBgNVHQ8BAf8EBAMCAQYw\n" + "DwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU0qUfC6f2YshA1Ni9udeO0VS7vEYw\n" + "HwYDVR0jBBgwFoAU0qUfC6f2YshA1Ni9udeO0VS7vEYwCgYIKoZIzj0EAwMDaQAw\n" + "ZgIxAKulGbSFkDSZusGjbNkAhAkqTkLWo3GrN5nRBNNk2Q4BlG+AvM5q9wa5WciW\n" + "DcMdeQIxAMOEzOFsxX9Bo0h4LOFE5y5H8bdPFYW+l5gy1tQiJv+5NUyM2IBB55XU\n" + "YjdBz56jSA==\n" + "-----END CERTIFICATE-----\n";
            } else {
                rootCert = fidoMdsRootCert;
            }
        }
        let rootCerts;
        if (Array.isArray(rootCert)) rootCerts = rootCert;
        else rootCerts = [
            rootCert
        ];
        const certHeader = parsedJws.header ? parsedJws.header : parsedJws.protectedHeader;
        await CertManager.verifyCertChain(certHeader.x5c, rootCerts, crls);
        this.toc.raw = tocStr;
        if (this.toc.entries.some((entry)=>!entry.metadataStatement
        )) {
            console.warn("[DEPRECATION WARNING] FIDO MDS v2 will be removed in October 2022. Please update to MDS v3!");
        }
        return this.toc;
    }
    getToc() {
        return this.toc;
    }
    addEntry(entryStr) {
        if (typeof entryStr !== "string" || entryStr.length < 1) {
            throw new Error("expected MDS entry to be non-empty string");
        }
        let newEntry = b64ToJsObject(entryStr, "MDS entry");
        if (newEntry.metadataStatement) {
            newEntry = newEntry.metadataStatement;
            entryStr = jsObjectToB64(newEntry);
        }
        newEntry.raw = entryStr;
        const newEntryId = getMdsEntryId(newEntry);
        if (Array.isArray(newEntryId)) {
            newEntryId.forEach((id)=>{
                this.unvalidatedEntryList.set(id, newEntry);
            });
        } else {
            this.unvalidatedEntryList.set(newEntryId, newEntry);
        }
    }
    async validate() {
        if (typeof this.toc !== "object" || this.toc === null) {
            throw new Error("add MDS TOC before attempting to validate MDS collection");
        }
        if (this.unvalidatedEntryList.size < 1) {
            throw new Error("add MDS entries before attempting to validate MDS collection");
        }
        let mapEntry;
        for (mapEntry of this.unvalidatedEntryList){
            const entry = mapEntry[1];
            const entryId = getMdsEntryId(entry);
            let tocEntry = this.toc.entries.filter((te)=>{
                const teId = getMdsEntryId(te);
                const eq = idEquals(teId, entryId);
                return eq;
            });
            if (tocEntry.length !== 1) {
                throw new Error(`found the wrong number of TOC entries for '${entryId}': ${tocEntry.length}`);
            }
            tocEntry = tocEntry[0];
            const entryHash = await mod3.hashDigest(entry.raw);
            let tocEntryHash;
            if (tocEntry.hash) {
                tocEntryHash = tocEntry.hash;
            } else {
                tocEntryHash = await mod3.hashDigest(jsObjectToB64(tocEntry.metadataStatement));
            }
            tocEntryHash = coerceToArrayBuffer(tocEntryHash, "MDS TOC entry hash");
            if (!abEqual(entryHash, tocEntryHash)) {
                throw new Error("MDS entry hash did not match corresponding hash in MDS TOC");
            }
            const newEntry = new MdsEntry(entry, tocEntry);
            newEntry.collection = this;
            if (Array.isArray(entryId)) {
                entryId.forEach((id)=>{
                    this.entryList.set(tocEntry.metadataStatement ? id.replace(/-/g, "") : id, newEntry);
                });
            } else {
                this.entryList.set(tocEntry.metadataStatement ? entryId.replace(/-/g, "") : entryId, newEntry);
            }
        }
    }
    findEntry(id) {
        if (id instanceof ArrayBuffer) {
            id = coerceToBase64Url(id, "MDS entry id");
        }
        if (typeof id !== "string") {
            throw new Error("expected 'id' to be String, got: " + id);
        }
        return this.entryList.get(id.replace(/-/g, "")) || this.entryList.get(abToHex(base64.toArrayBuffer(id, true)).replace(/-/g, "")) || null;
    }
}
function getMdsEntryId(obj) {
    if (typeof obj !== "object") {
        throw new Error("getMdsEntryId expected 'obj' to be object, got: " + obj);
    }
    if (typeof obj.aaid === "string") {
        return obj.aaid;
    }
    if (typeof obj.aaguid === "string") {
        return obj.aaguid;
    }
    if (Array.isArray(obj.attestationCertificateKeyIdentifiers)) {
        return obj.attestationCertificateKeyIdentifiers;
    }
    throw new Error("MDS entry didn't have a valid ID");
}
function idEquals(id1, id2) {
    if (id1 instanceof ArrayBuffer) {
        id1 = coerceToBase64Url(id1);
    }
    if (id2 instanceof ArrayBuffer) {
        id2 = coerceToBase64Url(id2);
    }
    if (typeof id1 === "string" && typeof id2 === "string") {
        return id1 === id2;
    }
    if (Array.isArray(id1) && Array.isArray(id2)) {
        if (id1.length !== id2.length) return false;
        const allSame = id1.reduce((acc, val)=>acc && id2.includes(val)
        , true);
        if (!allSame) return false;
        return true;
    }
    return false;
}
function realBoolean(obj, prop) {
    if (obj[prop] === "true") obj[prop] = true;
    if (obj[prop] === "false") obj[prop] = false;
}
function noneParseFn(attStmt) {
    if (Object.keys(attStmt).length !== 0) {
        throw new Error("'none' attestation format: attStmt had fields");
    }
    return new Map();
}
function noneValidateFn() {
    this.audit.journal.add("fmt");
    return true;
}
const noneAttestation = {
    name: "none",
    parseFn: noneParseFn,
    validateFn: noneValidateFn
};
"use strict";
const u2fRootCerts = [
    "MIIDHjCCAgagAwIBAgIEG0BT9zANBgkqhkiG9w0BAQsFADAuMSwwKgYDVQQDEyNZ\n" + "dWJpY28gVTJGIFJvb3QgQ0EgU2VyaWFsIDQ1NzIwMDYzMTAgFw0xNDA4MDEwMDAw\n" + "MDBaGA8yMDUwMDkwNDAwMDAwMFowLjEsMCoGA1UEAxMjWXViaWNvIFUyRiBSb290\n" + "IENBIFNlcmlhbCA0NTcyMDA2MzEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK\n" + "AoIBAQC/jwYuhBVlqaiYWEMsrWFisgJ+PtM91eSrpI4TK7U53mwCIawSDHy8vUmk\n" + "5N2KAj9abvT9NP5SMS1hQi3usxoYGonXQgfO6ZXyUA9a+KAkqdFnBnlyugSeCOep\n" + "8EdZFfsaRFtMjkwz5Gcz2Py4vIYvCdMHPtwaz0bVuzneueIEz6TnQjE63Rdt2zbw\n" + "nebwTG5ZybeWSwbzy+BJ34ZHcUhPAY89yJQXuE0IzMZFcEBbPNRbWECRKgjq//qT\n" + "9nmDOFVlSRCt2wiqPSzluwn+v+suQEBsUjTGMEd25tKXXTkNW21wIWbxeSyUoTXw\n" + "LvGS6xlwQSgNpk2qXYwf8iXg7VWZAgMBAAGjQjBAMB0GA1UdDgQWBBQgIvz0bNGJ\n" + "hjgpToksyKpP9xv9oDAPBgNVHRMECDAGAQH/AgEAMA4GA1UdDwEB/wQEAwIBBjAN\n" + "BgkqhkiG9w0BAQsFAAOCAQEAjvjuOMDSa+JXFCLyBKsycXtBVZsJ4Ue3LbaEsPY4\n" + "MYN/hIQ5ZM5p7EjfcnMG4CtYkNsfNHc0AhBLdq45rnT87q/6O3vUEtNMafbhU6kt\n" + "hX7Y+9XFN9NpmYxr+ekVY5xOxi8h9JDIgoMP4VB1uS0aunL1IGqrNooL9mmFnL2k\n" + "LVVee6/VR6C5+KSTCMCWppMuJIZII2v9o4dkoZ8Y7QRjQlLfYzd3qGtKbw7xaF1U\n" + "sG/5xUb/Btwb2X2g4InpiB/yt/3CpQXpiWX/K4mBvUKiGn05ZsqeY1gx4g0xLBqc\n" + "U9psmyPzK+Vsgw2jeRQ5JlKDyqE0hebfC1tvFu0CCrJFcw==", 
];
const algMap1 = new Map([
    [
        -7,
        {
            algName: "ECDSA_w_SHA256",
            hashAlg: "SHA256"
        }
    ],
    [
        -35,
        {
            algName: "ECDSA_w_SHA384",
            hashAlg: "SHA384"
        }
    ],
    [
        -36,
        {
            algName: "ECDSA_w_SHA512",
            hashAlg: "SHA512"
        }
    ], 
]);
function packedParseFn(attStmt) {
    const ret = new Map();
    const algEntry = algMap1.get(attStmt.alg);
    if (algEntry === undefined) {
        throw new Error("packed attestation: unknown algorithm: " + attStmt.alg);
    }
    ret.set("alg", algEntry);
    const x5c = attStmt.x5c;
    const newX5c = [];
    if (Array.isArray(x5c)) {
        for (let cert of x5c){
            cert = coerceToArrayBuffer(cert, "packed x5c cert");
            newX5c.push(cert);
        }
        ret.set("attCert", newX5c.shift());
        ret.set("x5c", newX5c);
    } else {
        ret.set("x5c", x5c);
    }
    let ecdaaKeyId = attStmt.ecdaaKeyId;
    if (ecdaaKeyId !== undefined) {
        ecdaaKeyId = coerceToArrayBuffer(ecdaaKeyId, "ecdaaKeyId");
        ret.set("ecdaaKeyId", ecdaaKeyId);
    }
    let sig = attStmt.sig;
    sig = coerceToArrayBuffer(sig, "packed signature");
    ret.set("sig", sig);
    return ret;
}
function packedValidateFn() {
    const x5c = this.authnrData.get("x5c");
    const ecdaaKeyId = this.authnrData.get("ecdaaKeyId");
    if (x5c !== undefined && ecdaaKeyId !== undefined) {
        throw new Error("packed attestation: should be 'basic' or 'ecdaa', got both");
    }
    if (x5c) return packedValidateBasic.call(this);
    if (ecdaaKeyId) return packedValidateEcdaa.call(this);
    return packedValidateSurrogate.call(this);
}
async function packedValidateBasic() {
    const { algName , hashAlg ,  } = this.authnrData.get("alg");
    if (algName === undefined) {
        throw new Error("packed attestation: unknown algorithm " + algName);
    }
    const res = validateSignature(this.clientData.get("rawClientDataJson"), this.authnrData.get("rawAuthnrData"), this.authnrData.get("sig"), hashAlg, this.authnrData.get("attCert"));
    if (!res) {
        throw new Error("packed attestation signature verification failed");
    }
    this.audit.journal.add("sig");
    this.audit.journal.add("alg");
    await validateCerts(this.authnrData.get("attCert"), this.authnrData.get("aaguid"), this.authnrData.get("x5c"), this.audit);
    this.audit.info.set("attestation-type", "basic");
    this.audit.journal.add("fmt");
    return true;
}
function validateSignature(rawClientData, authenticatorData, sig, hashAlg, parsedAttCert) {
    const hash = mod3.hashDigest(rawClientData);
    const clientDataHash = new Uint8Array(hash).buffer;
    const attCertPem = abToPem("CERTIFICATE", parsedAttCert);
    const verify1 = mod3.verifySignature(hashAlg, attCertPem, sig, appendBuffer(authenticatorData, clientDataHash));
    return verify1;
}
async function validateCerts(parsedAttCert, aaguid, _x5c, audit) {
    if (CertManager.getCerts().size === 0) {
        u2fRootCerts.forEach((cert)=>CertManager.addCert(cert)
        );
    }
    const attCert = new Certificate1(coerceToBase64(parsedAttCert, "parsedAttCert"));
    try {
        await attCert.verify();
    } catch (e20) {
        const err = e20;
        if (err.message === "Please provide issuer certificate as a parameter") {
            audit.warning.set("attesation-not-validated", "could not validate attestation because the root attestation certification could not be found");
        } else {
            throw err;
        }
    }
    audit.journal.add("x5c");
    if (attCert.getVersion() !== 3) {
        throw new Error("expected packed attestation certificate to be x.509v3");
    }
    const exts = attCert.getExtensions();
    exts.forEach((v, k)=>audit.info.set(k, v)
    );
    attCert.info.forEach((v, k)=>audit.info.set(k, v)
    );
    attCert.warning.forEach((v, k)=>audit.warning.set(k, v)
    );
    audit.journal.add("attCert");
    if (attCert.getVersion() !== 3) {
        throw new Error("expected packed attestation certificate to be x.509v3");
    }
    const subject = attCert.getSubject();
    if (typeof subject.get("country-name") !== "string") {
        throw new Error("packed attestation: attestation certificate missing 'country name'");
    }
    if (typeof subject.get("organization-name") !== "string") {
        throw new Error("packed attestation: attestation certificate missing 'organization name'");
    }
    if (subject.get("organizational-unit-name") !== "Authenticator Attestation") {
        throw new Error("packed attestation: attestation certificate 'organizational unit name' must be 'Authenticator Attestation'");
    }
    if (typeof subject.get("common-name") !== "string") {
        throw new Error("packed attestation: attestation certificate missing 'common name'");
    }
    const basicConstraints = exts.get("basic-constraints");
    if (basicConstraints.cA !== false) {
        throw new Error("packed attestation: basic constraints 'cA' must be 'false'");
    }
    const certAaguid = exts.get("fido-aaguid");
    if (certAaguid !== undefined && !abEqual(aaguid, certAaguid)) {
        throw new Error("packed attestation: authnrData AAGUID did not match AAGUID in attestation certificate");
    }
}
async function validateSelfSignature(rawClientData, authenticatorData, sig, hashAlg, publicKeyPem) {
    const clientDataHash = await mod3.hashDigest(rawClientData, hashAlg);
    const verify2 = mod3.verifySignature(publicKeyPem, sig, appendBuffer(authenticatorData, clientDataHash));
    return verify2;
}
function packedValidateSurrogate() {
    const { algName , hashAlg ,  } = this.authnrData.get("alg");
    if (algName === undefined) {
        throw new Error("packed attestation: unknown algorithm " + algName);
    }
    const res = validateSelfSignature(this.clientData.get("rawClientDataJson"), this.authnrData.get("rawAuthnrData"), this.authnrData.get("sig"), hashAlg, this.authnrData.get("credentialPublicKeyPem"));
    if (!res) {
        throw new Error("packed attestation signature verification failed");
    }
    this.audit.journal.add("sig");
    this.audit.journal.add("alg");
    this.audit.journal.add("x5c");
    this.audit.info.set("attestation-type", "self");
    this.audit.journal.add("fmt");
    return true;
}
function packedValidateEcdaa() {
    throw new Error("packed attestation: ECDAA not implemented, please open a GitHub issue.");
}
const packedAttestation = {
    name: "packed",
    parseFn: packedParseFn,
    validateFn: packedValidateFn
};
function fidoU2fParseFn(attStmt) {
    const ret = new Map();
    const x5c = attStmt.x5c;
    let sig = attStmt.sig;
    if (!Array.isArray(x5c)) {
        throw new TypeError("expected U2F attestation x5c field to be of type Array");
    }
    if (x5c.length < 1) {
        throw new TypeError("no certificates in U2F x5c field");
    }
    const newX5c = [];
    for (let cert of x5c){
        cert = coerceToArrayBuffer(cert, "U2F x5c cert");
        newX5c.push(cert);
    }
    ret.set("attCert", newX5c.shift());
    ret.set("x5c", newX5c);
    sig = coerceToArrayBuffer(sig, "U2F signature");
    ret.set("sig", sig);
    return ret;
}
async function fidoU2fValidateFn() {
    const x5c = this.authnrData.get("x5c");
    const parsedAttCert = this.authnrData.get("attCert");
    if (x5c.length > 0) {
        throw new Error("cert chain not validated");
    }
    this.audit.journal.add("x5c");
    if (CertManager.getCerts().size === 0) {
        u2fRootCerts.forEach((cert)=>CertManager.addCert(cert)
        );
    }
    const attCert = new Certificate1(coerceToBase64(parsedAttCert, "parsedAttCert"));
    try {
        await attCert.verify();
    } catch (e21) {
        const err = e21;
        if (err.message === "Please provide issuer certificate as a parameter") {
            this.audit.warning.set("attesation-not-validated", "could not validate attestation because the root attestation certification could not be found");
        } else {
            throw err;
        }
    }
    if (attCert.getVersion() !== 3) {
        throw new Error("expected U2F attestation certificate to be x.509v3");
    }
    attCert.getExtensions().forEach((v, k)=>this.audit.info.set(k, v)
    );
    attCert.info.forEach((v, k)=>this.audit.info.set(k, v)
    );
    attCert.warning.forEach((v, k)=>this.audit.warning.set(k, v)
    );
    this.audit.journal.add("attCert");
    const jwk = this.authnrData.get("credentialPublicKeyJwk");
    if (jwk.kty !== "EC" || jwk.crv !== "P-256") {
        throw new Error("bad U2F key type");
    }
    const rpIdHash = this.authnrData.get("rpIdHash");
    const credId = this.authnrData.get("credId");
    const rawClientData = this.clientData.get("rawClientDataJson");
    const clientDataHash = abToBuf(mod3.hashDigest(abToBuf(rawClientData)));
    const x = coerceToArrayBuffer(jwk.x, "U2F public key x component");
    if (x.byteLength !== 32) {
        throw new Error("U2F public key x component was wrong size");
    }
    const y = coerceToArrayBuffer(jwk.y, "U2F public key y component");
    if (y.byteLength !== 32) {
        throw new Error("U2F public key y component was wrong size");
    }
    const verificationData = new Uint8Array([
        0x00,
        ...new Uint8Array(rpIdHash),
        ...new Uint8Array(clientDataHash),
        ...new Uint8Array(credId),
        0x04,
        ...new Uint8Array(x),
        ...new Uint8Array(y), 
    ]);
    const sig = this.authnrData.get("sig");
    const attCertPem = abToPem("CERTIFICATE", parsedAttCert);
    const res = await mod3.verifySignature(attCertPem, abToBuf(sig), abToBuf(verificationData));
    if (!res) {
        throw new Error("U2F attestation signature verification failed");
    }
    this.audit.journal.add("sig");
    this.audit.info.set("attestation-type", "basic");
    this.audit.journal.add("fmt");
    return true;
}
const fidoU2fAttestation = {
    name: "fido-u2f",
    parseFn: fidoU2fParseFn,
    validateFn: fidoU2fValidateFn
};
function androidSafetyNetParseFn(attStmt) {
    const ret = new Map();
    ret.set("ver", attStmt.ver);
    const response = abToStr(attStmt.response);
    ret.set("response", response);
    return ret;
}
async function androidSafetyNetValidateFn() {
    const response = this.authnrData.get("response");
    const protectedHeader = await mod3.decodeProtectedHeader(response);
    const publicKey = await mod3.getEmbeddedJwk(protectedHeader);
    const parsedJws = await mod3.jwtVerify(response, await mod3.importJWK(publicKey));
    parsedJws.header = protectedHeader;
    this.authnrData.set("payload", parsedJws.payload);
    if (!parsedJws.payload.ctsProfileMatch) {
        throw new Error("android-safetynet attestation: ctsProfileMatch: the device is not compatible");
    }
    const rawClientData = this.clientData.get("rawClientDataJson");
    const rawAuthnrData = this.authnrData.get("rawAuthnrData");
    const clientDataHash = await mod3.hashDigest(rawClientData);
    const rawAuthnrDataBuf = new Uint8Array(rawAuthnrData);
    const clientDataHashBuf = new Uint8Array(clientDataHash);
    const concatenated = appendBuffer(rawAuthnrDataBuf, clientDataHashBuf);
    const hash = await mod3.hashDigest(concatenated);
    const nonce = base64.fromArrayBuffer(hash);
    if (nonce !== parsedJws.payload.nonce) {
        throw new Error("android-safetynet attestation: nonce check hash failed");
    }
    if (parsedJws.payload.error) {
        throw new Error("android-safetynet: " + parsedJws.payload.error + "advice: " + parsedJws.payload.advice);
    }
    this.audit.journal.add("payload");
    this.audit.journal.add("ver");
    this.audit.journal.add("response");
    this.authnrData.set("attCert", parsedJws.header.x5c.shift());
    this.authnrData.set("x5c", parsedJws.header.x5c);
    this.audit.journal.add("attCert");
    this.audit.journal.add("x5c");
    const attCert = new Certificate1(coerceToBase64(parsedJws.header.x5c.shift(), "parsedAttCert"));
    this.audit.info.set("organization-name", attCert.getSubject().get("organization-name"));
    this.audit.info.set("attestation-type", "basic");
    this.audit.journal.add("fmt");
    return true;
}
const androidSafetyNetAttestation = {
    name: "android-safetynet",
    parseFn: androidSafetyNetParseFn,
    validateFn: androidSafetyNetValidateFn
};
function tpmParseFn(attStmt) {
    const ret = new Map();
    if (attStmt.ecdaaKeyId !== undefined) {
        throw new Error("TPM ECDAA attesation is not currently supported.");
    }
    const x5c = attStmt.x5c;
    if (!Array.isArray(x5c)) {
        throw new TypeError("expected TPM attestation x5c field to be of type Array");
    }
    if (x5c.length < 1) {
        throw new TypeError("no certificates in TPM x5c field");
    }
    const newX5c = [];
    for (let cert of x5c){
        cert = coerceToArrayBuffer(cert, "TPM x5c cert");
        newX5c.push(cert);
    }
    ret.set("attCert", newX5c.shift());
    ret.set("x5c", newX5c);
    if (attStmt.ecdaaKeyId) ret.set("ecdaaKeyId", attStmt.ecdaaKeyId);
    ret.set("sig", coerceToArrayBuffer(attStmt.sig, "tpm signature"));
    ret.set("ver", attStmt.ver);
    const alg = {
        algName: algToStr(attStmt.alg),
        hashAlg: algToHashStr(attStmt.alg)
    };
    ret.set("alg", alg);
    const certInfo = parseCertInfo(coerceToArrayBuffer(attStmt.certInfo, "certInfo"));
    ret.set("certInfo", certInfo);
    const pubArea = parsePubArea(coerceToArrayBuffer(attStmt.pubArea, "pubArea"));
    ret.set("pubArea", pubArea);
    return ret;
}
function parseCertInfo(certInfo) {
    if (!(certInfo instanceof ArrayBuffer)) {
        throw new Error("tpm attestation: expected certInfo to be ArrayBuffer");
    }
    const dv = new DataView(certInfo);
    let offset = 0;
    let ret;
    const ci = new Map();
    ci.set("rawCertInfo", certInfo);
    const magic = dv.getUint32(offset);
    if (magic !== 0xff544347) {
        throw new Error("tpm attestation: certInfo had bad magic number: " + magic.toString(16));
    }
    ci.set("magic", magic);
    offset += 4;
    const type = decodeStructureTag(dv.getUint16(offset));
    if (type !== "TPM_ST_ATTEST_CERTIFY") {
        throw new Error("tpm attestation: got wrong type. expected 'TPM_ST_ATTEST_CERTIFY' got: " + type);
    }
    ci.set("type", type);
    offset += 2;
    ret = getTpm2bName(dv, offset);
    ci.set("qualifiedSignerHashType", ret.hashType);
    ci.set("qualifiedSigner", ret.nameHash);
    offset = ret.offset;
    ret = getSizedElement(dv, offset);
    ci.set("extraData", ret.buf);
    offset = ret.offset;
    ci.set("clock", dv.buffer.slice(offset, offset + 8));
    offset += 8;
    ci.set("resetCount", dv.getUint32(offset));
    offset += 4;
    ci.set("restartCount", dv.getUint32(offset));
    offset += 4;
    ci.set("safe", !!dv.getUint8(offset));
    offset++;
    ci.set("firmwareVersion", dv.buffer.slice(offset, offset + 8));
    offset += 8;
    ret = getTpm2bName(dv, offset);
    ci.set("nameHashType", ret.hashType);
    ci.set("name", ret.nameHash);
    offset = ret.offset;
    ret = getTpm2bName(dv, offset);
    ci.set("qualifiedNameHashType", ret.hashType);
    ci.set("qualifiedName", ret.nameHash);
    offset = ret.offset;
    if (offset !== certInfo.byteLength) {
        throw new Error("tpm attestation: left over bytes when parsing cert info");
    }
    return ci;
}
function parsePubArea(pubArea) {
    if (!(pubArea instanceof ArrayBuffer)) {
        throw new Error("tpm attestation: expected pubArea to be ArrayBuffer");
    }
    const dv = new DataView(pubArea);
    let offset = 0;
    let ret;
    const pa = new Map();
    pa.set("rawPubArea", pubArea);
    const type = algIdToStr(dv.getUint16(offset));
    pa.set("type", type);
    offset += 2;
    pa.set("nameAlg", algIdToStr(dv.getUint16(offset)));
    offset += 2;
    pa.set("objectAttributes", decodeObjectAttributes(dv.getUint32(offset)));
    offset += 4;
    ret = getSizedElement(dv, offset);
    pa.set("authPolicy", ret.buf);
    offset = ret.offset;
    if (type !== "TPM_ALG_RSA") {
        throw new Error("tpm attestation: only TPM_ALG_RSA supported");
    }
    pa.set("symmetric", algIdToStr(dv.getUint16(offset)));
    offset += 2;
    pa.set("scheme", algIdToStr(dv.getUint16(offset)));
    offset += 2;
    pa.set("keyBits", dv.getUint16(offset));
    offset += 2;
    let exponent = dv.getUint32(offset);
    if (exponent === 0) exponent = 65537;
    pa.set("exponent", exponent);
    offset += 4;
    ret = getSizedElement(dv, offset);
    pa.set("unique", ret.buf);
    offset = ret.offset;
    if (offset !== pubArea.byteLength) {
        throw new Error("tpm attestation: left over bytes when parsing public area");
    }
    return pa;
}
function decodeStructureTag(t6) {
    switch(t6){
        case 0x00C4:
            return "TPM_ST_RSP_COMMAND";
        case 0x8000:
            return "TPM_ST_NULL";
        case 0x8001:
            return "TPM_ST_NO_SESSIONS";
        case 0x8002:
            return "TPM_ST_SESSIONS";
        case 0x8003:
            return "TPM_RESERVED_0x8003";
        case 0x8004:
            return "TPM_RESERVED_0x8004";
        case 0x8014:
            return "TPM_ST_ATTEST_NV";
        case 0x8015:
            return "TPM_ST_ATTEST_COMMAND_AUDIT";
        case 0x8016:
            return "TPM_ST_ATTEST_SESSION_AUDIT";
        case 0x8017:
            return "TPM_ST_ATTEST_CERTIFY";
        case 0x8018:
            return "TPM_ST_ATTEST_QUOTE";
        case 0x8019:
            return "TPM_ST_ATTEST_TIME";
        case 0x801A:
            return "TPM_ST_ATTEST_CREATION";
        case 0x801B:
            return "TPM_RESERVED_0x801B";
        case 0x8021:
            return "TPM_ST_CREATION";
        case 0x8022:
            return "TPM_ST_VERIFIED";
        case 0x8023:
            return "TPM_ST_AUTH_SECRET";
        case 0x8024:
            return "TPM_ST_HASHCHECK";
        case 0x8025:
            return "TPM_ST_AUTH_SIGNED";
        case 0x8029:
            return "TPM_ST_FU_MANIFEST";
        default:
            throw new Error("tpm attestation: unknown structure tag: " + t6.toString(16));
    }
}
function decodeObjectAttributes(oa) {
    const attrList = [
        "RESERVED_0",
        "FIXED_TPM",
        "ST_CLEAR",
        "RESERVED_3",
        "FIXED_PARENT",
        "SENSITIVE_DATA_ORIGIN",
        "USER_WITH_AUTH",
        "ADMIN_WITH_POLICY",
        "RESERVED_8",
        "RESERVED_9",
        "NO_DA",
        "ENCRYPTED_DUPLICATION",
        "RESERVED_12",
        "RESERVED_13",
        "RESERVED_14",
        "RESERVED_15",
        "RESTRICTED",
        "DECRYPT",
        "SIGN_ENCRYPT",
        "RESERVED_19",
        "RESERVED_20",
        "RESERVED_21",
        "RESERVED_22",
        "RESERVED_23",
        "RESERVED_24",
        "RESERVED_25",
        "RESERVED_26",
        "RESERVED_27",
        "RESERVED_28",
        "RESERVED_29",
        "RESERVED_30",
        "RESERVED_31", 
    ];
    const ret = new Set();
    for(let i218 = 0; i218 < 32; i218++){
        const bit = 1 << i218;
        if (oa & bit) {
            ret.add(attrList[i218]);
        }
    }
    return ret;
}
function getSizedElement(dv, offset) {
    const size = dv.getUint16(offset);
    offset += 2;
    const buf = dv.buffer.slice(offset, offset + size);
    dv = new DataView(buf);
    offset += size;
    return {
        size,
        dv,
        buf,
        offset
    };
}
function getTpm2bName(dvIn, oIn) {
    const { offset , dv ,  } = getSizedElement(dvIn, oIn);
    const hashType = algIdToStr(dv.getUint16(0));
    const nameHash = dv.buffer.slice(2);
    return {
        hashType,
        nameHash,
        offset
    };
}
function algIdToStr(hashType) {
    const hashList = [
        "TPM_ALG_ERROR",
        "TPM_ALG_RSA",
        null,
        null,
        "TPM_ALG_SHA1",
        "TPM_ALG_HMAC",
        "TPM_ALG_AES",
        "TPM_ALG_MGF1",
        null,
        "TPM_ALG_KEYEDHASH",
        "TPM_ALG_XOR",
        "TPM_ALG_SHA256",
        "TPM_ALG_SHA384",
        "TPM_ALG_SHA512",
        null,
        null,
        "TPM_ALG_NULL",
        null,
        "TPM_ALG_SM3_256",
        "TPM_ALG_SM4",
        "TPM_ALG_RSASSA",
        "TPM_ALG_RSAES",
        "TPM_ALG_RSAPSS",
        "TPM_ALG_OAEP",
        "TPM_ALG_ECDSA"
    ];
    return hashList[hashType];
}
async function tpmValidateFn() {
    const parsedAttCert = this.authnrData.get("attCert");
    const certInfo = this.authnrData.get("certInfo");
    const pubArea = this.authnrData.get("pubArea");
    const ver = this.authnrData.get("ver");
    if (ver != "2.0") {
        throw new Error("tpm attestation: expected TPM version 2.0");
    }
    this.audit.journal.add("ver");
    const pubAreaPkN = pubArea.get("unique");
    const pubAreaPkExp = pubArea.get("exponent");
    const credentialPublicKeyJwk = this.authnrData.get("credentialPublicKeyJwk");
    const credentialPublicKeyJwkN = coerceToArrayBuffer(credentialPublicKeyJwk.n, "credentialPublicKeyJwk.n");
    const credentialPublicKeyJwkExpBuf = coerceToArrayBuffer(credentialPublicKeyJwk.e, "credentialPublicKeyJwk.e");
    const credentialPublicKeyJwkExp = abToInt(credentialPublicKeyJwkExpBuf);
    if (credentialPublicKeyJwk.kty !== "RSA" || pubArea.get("type") !== "TPM_ALG_RSA") {
        throw new Error("tpm attestation: only RSA keys are currently supported");
    }
    if (pubAreaPkExp !== credentialPublicKeyJwkExp) {
        throw new Error("tpm attestation: RSA exponents of WebAuthn credentialPublicKey and TPM publicArea did not match");
    }
    if (!abEqual(credentialPublicKeyJwkN, pubAreaPkN)) {
        throw new Error("tpm attestation: RSA 'n' of WebAuthn credentialPublicKey and TPM publicArea did not match");
    }
    const magic = certInfo.get("magic");
    if (magic !== 0xff544347) {
        throw new Error("tpm attestation: certInfo had bad magic number: " + magic.toString(16));
    }
    const type = certInfo.get("type");
    if (type !== "TPM_ST_ATTEST_CERTIFY") {
        throw new Error("tpm attestation: got wrong type. expected 'TPM_ST_ATTEST_CERTIFY' got: " + type);
    }
    const rawAuthnrData = this.authnrData.get("rawAuthnrData");
    const rawClientData = this.clientData.get("rawClientDataJson");
    const clientDataHashBuf = await mod3.hashDigest(abToBuf(rawClientData));
    const alg = this.authnrData.get("alg");
    if (alg.hashAlg === undefined) {
        throw new Error("tpm attestation: unknown algorithm: " + alg);
    }
    this.audit.journal.add("alg");
    const extraDataHashBuf = mod3.hashDigest(appendBuffer(abToBuf(rawAuthnrData), clientDataHashBuf), alg.hashAlg);
    const generatedExtraDataHash = new Uint8Array(extraDataHashBuf).buffer;
    const extraData = certInfo.get("extraData");
    if (!abEqual(generatedExtraDataHash, extraData)) {
        throw new Error("extraData hash did not match authnrData + clientDataHash hashed");
    }
    const pubAreaName = certInfo.get("name");
    const pubAreaNameHashAlg = tpmHashToNpmHash(certInfo.get("nameHashType"));
    const pubAreaNameHashBuf = mod3.hashDigest(abToBuf(pubArea.get("rawPubArea")), pubAreaNameHashAlg);
    const generatedPubAreaNameHash = new Uint8Array(pubAreaNameHashBuf).buffer;
    if (!abEqual(generatedPubAreaNameHash, pubAreaName)) {
        throw new Error("pubAreaName hash did not match hash of publicArea");
    }
    this.audit.journal.add("pubArea");
    const sig = this.authnrData.get("sig");
    const rawCertInfo = certInfo.get("rawCertInfo");
    const attCertPem = abToPem("CERTIFICATE", parsedAttCert);
    const res = await mod3.verifySignature(attCertPem, sig, abToBuf(rawCertInfo), alg.hashAlg);
    if (!res) {
        throw new Error("TPM attestation signature verification failed");
    }
    this.audit.journal.add("sig");
    this.audit.journal.add("certInfo");
    const attCert = new Certificate1(coerceToBase64(parsedAttCert, "parsedAttCert"));
    try {
        await attCert.verify();
    } catch (e22) {
        const err = e22;
        if (err.message === "Please provide issuer certificate as a parameter") {
            this.audit.warning.set("attesation-not-validated", "could not validate attestation because the root attestation certification could not be found");
        } else {
            throw err;
        }
    }
    if (attCert.getVersion() !== 3) {
        throw new Error("expected TPM attestation certificate to be x.509v3");
    }
    const attCertSubject = attCert.getSubject();
    if (attCertSubject.size !== 0) {
        throw new Error("tpm attestation: attestation certificate MUST have empty subject");
    }
    const attCertExt = attCert.getExtensions();
    attCertExt.forEach((v, k)=>this.audit.info.set(k, v)
    );
    attCert.info.forEach((v, k)=>this.audit.info.set(k, v)
    );
    attCert.warning.forEach((v, k)=>this.audit.warning.set(k, v)
    );
    const altName = attCertExt.get("subject-alt-name");
    if (altName === undefined || !Array.isArray(altName) || altName.length < 1) {
        throw new Error("tpm attestation: Subject Alternative Name extension MUST be set as defined in [TPMv2-EK-Profile] section 3.2.9");
    }
    let directoryName;
    altName.forEach((name)=>{
        if (name.directoryName !== undefined) {
            directoryName = name.directoryName;
        }
    });
    if (directoryName === undefined) {
        throw new Error("tpm attestation: subject alternative name did not contain directory name");
    }
    if (!directoryName.has("tcg-at-tpm-manufacturer")) {
        throw new Error("tpm attestation: subject alternative name did not list manufacturer");
    }
    if (!directoryName.has("tcg-at-tpm-model")) {
        throw new Error("tpm attestation: subject alternative name did not list model number");
    }
    if (!directoryName.has("tcg-at-tpm-version")) {
        throw new Error("tpm attestation: subject alternative name did not list firmware version");
    }
    const extKeyUsage = attCertExt.get("ext-key-usage");
    if (!Array.isArray(extKeyUsage) || !extKeyUsage.includes("tcg-kp-aik-certificate")) {
        throw new Error("tpm attestation: the Extended Key Usage extension MUST contain 'tcg-kp-aik-certificate'");
    }
    const basicConstraints = attCertExt.get("basic-constraints");
    if (typeof basicConstraints !== "object" || basicConstraints.cA !== false) {
        throw new Error("tpm attestation: the Basic Constraints extension MUST have the CA component set to false");
    }
    const certAaguid = attCertExt.get("fido-aaguid");
    const aaguid = this.authnrData.get("aaguid");
    if (certAaguid !== undefined && !abEqual(aaguid, certAaguid)) {
        throw new Error("tpm attestation: authnrData AAGUID did not match AAGUID in attestation certificate");
    }
    this.audit.journal.add("x5c");
    this.audit.journal.add("attCert");
    this.audit.info.set("attestation-type", "AttCA");
    this.audit.journal.add("fmt");
    return true;
}
function tpmHashToNpmHash(tpmHash) {
    switch(tpmHash){
        case "TPM_ALG_SHA1":
            return "SHA1";
        case "TPM_ALG_SHA256":
            return "SHA256";
        case "TPM_ALG_SHA384":
            return "SHA384";
        case "TPM_ALG_SHA512":
            return "SHA512";
        default:
            throw new TypeError("Unsupported hash type: " + tpmHash);
    }
}
const tpmAttestation = {
    name: "tpm",
    parseFn: tpmParseFn,
    validateFn: tpmValidateFn
};
const { coerceToArrayBuffer: coerceToArrayBuffer1 , abToBuf: abToBuf1 , tools , appendBuffer: appendBuffer1 ,  } = mod4;
const lockSym = Symbol();
function validateCreateRequest() {
    let req = this.request;
    if (typeof req !== "object") {
        throw new TypeError("expected request to be Object, got " + typeof req);
    }
    if (!(req.rawId instanceof ArrayBuffer) && !(req.id instanceof ArrayBuffer)) {
        throw new TypeError("expected 'id' or 'rawId' field of request to be ArrayBuffer, got rawId " + typeof req.rawId + " and id " + typeof req.id);
    }
    if (typeof req.response !== "object") {
        throw new TypeError("expected 'response' field of request to be Object, got " + typeof req.response);
    }
    if (typeof req.response.attestationObject !== "string" && !(req.response.attestationObject instanceof ArrayBuffer)) {
        throw new TypeError("expected 'response.attestationObject' to be base64 String or ArrayBuffer");
    }
    if (typeof req.response.clientDataJSON !== "string" && !(req.response.clientDataJSON instanceof ArrayBuffer)) {
        throw new TypeError("expected 'response.clientDataJSON' to be base64 String or ArrayBuffer");
    }
    this.audit.validRequest = true;
    return true;
}
const globalAttestationMap = new Map();
const globalExtensionMap = new Map();
const globalMdsCollection = new Map();
class Webauthn {
    constructor(opts){
        opts = opts || {};
        this.config = {};
        this.config.timeout = opts.timeout === undefined ? 60000 : opts.timeout;
        checkOptType(this.config, "timeout", "number");
        if (!(this.config.timeout >>> 0 === parseFloat(this.config.timeout))) {
            throw new RangeError("timeout should be zero or positive integer");
        }
        this.config.challengeSize = opts.challengeSize || 64;
        checkOptType(this.config, "challengeSize", "number");
        if (this.config.challengeSize < 32) {
            throw new RangeError("challenge size too small, must be 32 or greater");
        }
        this.config.rpId = opts.rpId;
        checkOptType(this.config, "rpId", "string");
        this.config.rpName = opts.rpName || "Anonymous Service";
        checkOptType(this.config, "rpName", "string");
        this.config.rpIcon = opts.rpIcon;
        checkOptType(this.config, "rpIcon", "string");
        this.config.authenticatorRequireResidentKey = opts.authenticatorRequireResidentKey;
        checkOptType(this.config, "authenticatorRequireResidentKey", "boolean");
        this.config.authenticatorAttachment = opts.authenticatorAttachment;
        if (this.config.authenticatorAttachment !== undefined && this.config.authenticatorAttachment !== "platform" && this.config.authenticatorAttachment !== "cross-platform") {
            throw new TypeError("expected authenticatorAttachment to be 'platform', or 'cross-platform', got: " + this.config.authenticatorAttachment);
        }
        this.config.authenticatorUserVerification = opts.authenticatorUserVerification;
        if (this.config.authenticatorUserVerification !== undefined && this.config.authenticatorUserVerification !== "required" && this.config.authenticatorUserVerification !== "preferred" && this.config.authenticatorUserVerification !== "discouraged") {
            throw new TypeError("expected authenticatorUserVerification to be 'required', 'preferred', or 'discouraged', got: " + this.config.authenticatorUserVerification);
        }
        this.config.attestation = opts.attestation || "direct";
        if (this.config.attestation !== "direct" && this.config.attestation !== "indirect" && this.config.attestation !== "none") {
            throw new TypeError("expected attestation to be 'direct', 'indirect', or 'none', got: " + this.config.attestation);
        }
        this.config.cryptoParams = opts.cryptoParams || [
            -7,
            -257
        ];
        checkOptType(this.config, "cryptoParams", Array);
        if (this.config.cryptoParams.length < 1) {
            throw new TypeError("cryptoParams must have at least one element");
        }
        this.config.cryptoParams.forEach((param)=>{
            checkOptType({
                cryptoParam: param
            }, "cryptoParam", "number");
        });
        this.attestationMap = globalAttestationMap;
        this.extSet = new Set();
        this.extOptMap = new Map();
    }
    static utils = mod4;
    static createMdsCollection(collectionName) {
        return new MdsCollection(collectionName);
    }
    static async addMdsCollection(mdsCollection) {
        if (!(mdsCollection instanceof MdsCollection)) {
            throw new Error("expected 'mdsCollection' to be instance of MdsCollection, got: " + mdsCollection);
        }
        await mdsCollection.validate();
        globalMdsCollection.set(mdsCollection.name, mdsCollection);
    }
    static clearMdsCollections() {
        globalMdsCollection.clear();
    }
    static findMdsEntry(id) {
        if (globalMdsCollection.size < 1) {
            throw new Error("must set MDS collection before attempting to find an MDS entry");
        }
        const ret = [];
        for (const collection of globalMdsCollection.values()){
            const entry = collection.findEntry(id);
            if (entry) ret.push(entry);
        }
        return ret;
    }
    static addExtension(extName, optionGeneratorFn, resultParserFn, resultValidatorFn) {
        if (typeof extName !== "string") {
            throw new Error("expected 'extName' to be String, got: " + extName);
        }
        if (globalExtensionMap.has(extName)) {
            throw new Error(`the extension '${extName}' has already been added`);
        }
        if (typeof optionGeneratorFn !== "function") {
            throw new Error("expected 'optionGeneratorFn' to be a Function, got: " + optionGeneratorFn);
        }
        if (typeof resultParserFn !== "function") {
            throw new Error("expected 'resultParserFn' to be a Function, got: " + resultParserFn);
        }
        if (typeof resultValidatorFn !== "function") {
            throw new Error("expected 'resultValidatorFn' to be a Function, got: " + resultValidatorFn);
        }
        globalExtensionMap.set(extName, {
            optionGeneratorFn,
            resultParserFn,
            resultValidatorFn
        });
    }
    static deleteAllExtensions() {
        globalExtensionMap.clear();
    }
    generateExtensionOptions(extName, type, options) {
        if (typeof extName !== "string") {
            throw new Error("expected 'extName' to be String, got: " + extName);
        }
        if (type !== "attestation" && type !== "assertion") {
            throw new Error("expected 'type' to be 'attestation' or 'assertion', got: " + type);
        }
        const ext = globalExtensionMap.get(extName);
        if (typeof ext !== "object" || typeof ext.optionGeneratorFn !== "function") {
            throw new Error(`valid extension for '${extName}' not found`);
        }
        const ret = ext.optionGeneratorFn(extName, type, options);
        return ret;
    }
    static parseExtensionResult(extName, clientThing, authnrThing) {
        if (typeof extName !== "string") {
            throw new Error("expected 'extName' to be String, got: " + extName);
        }
        const ext = globalExtensionMap.get(extName);
        if (typeof ext !== "object" || typeof ext.parseFn !== "function") {
            throw new Error(`valid extension for '${extName}' not found`);
        }
        const ret = ext.parseFn(extName, clientThing, authnrThing);
        return ret;
    }
    static validateExtensionResult(extName) {
        const ext = globalExtensionMap.get(extName);
        if (typeof ext !== "object" || typeof ext.validateFn !== "function") {
            throw new Error(`valid extension for '${extName}' not found`);
        }
        const ret = ext.validateFn.call(this);
        return ret;
    }
    enableExtension(extName) {
        if (typeof extName !== "string") {
            throw new Error("expected 'extName' to be String, got: " + extName);
        }
        if (!globalExtensionMap.has(extName)) {
            throw new Error(`valid extension for '${extName}' not found`);
        }
        this.extSet.add(extName);
    }
    disableExtension(extName) {
        if (typeof extName !== "string") {
            throw new Error("expected 'extName' to be String, got: " + extName);
        }
        if (!globalExtensionMap.has(extName)) {
            throw new Error(`valid extension for '${extName}' not found`);
        }
        this.extSet.delete(extName);
    }
    setExtensionOptions(extName, options) {
        if (typeof extName !== "string") {
            throw new Error("expected 'extName' to be String, got: " + extName);
        }
        if (!globalExtensionMap.has(extName)) {
            throw new Error(`valid extension for '${extName}' not found`);
        }
        this.extOptMap.set(extName, options);
    }
    static async validateAttestation() {
        const fmt = this.authnrData.get("fmt");
        if (typeof fmt !== "string") {
            throw new TypeError("expected 'fmt' to be string, got: " + typeof fmt);
        }
        const fmtObj = globalAttestationMap.get(fmt);
        if (typeof fmtObj !== "object" || typeof fmtObj.parseFn !== "function" || typeof fmtObj.validateFn !== "function") {
            throw new Error(`no support for attestation format: ${fmt}`);
        }
        const ret = await fmtObj.validateFn.call(this);
        if (ret !== true) {
            throw new Error(`${fmt} validateFn did not return 'true'`);
        }
        return ret;
    }
    static addAttestationFormat(fmt, parseFn, validateFn) {
        if (typeof fmt !== "string") {
            throw new TypeError("expected 'fmt' to be string, got: " + typeof fmt);
        }
        if (typeof parseFn !== "function") {
            throw new TypeError("expected 'parseFn' to be string, got: " + typeof parseFn);
        }
        if (typeof validateFn !== "function") {
            throw new TypeError("expected 'validateFn' to be string, got: " + typeof validateFn);
        }
        if (globalAttestationMap.has(fmt)) {
            throw new Error(`can't add format: '${fmt}' already exists`);
        }
        globalAttestationMap.set(fmt, {
            parseFn,
            validateFn
        });
        return true;
    }
    static deleteAllAttestationFormats() {
        globalAttestationMap.clear();
    }
    static parseAttestation(fmt, attStmt) {
        if (typeof fmt !== "string") {
            throw new TypeError("expected 'fmt' to be string, got: " + typeof fmt);
        }
        if (typeof attStmt !== "object") {
            throw new TypeError("expected 'attStmt' to be object, got: " + typeof attStmt);
        }
        const fmtObj = globalAttestationMap.get(fmt);
        if (typeof fmtObj !== "object" || typeof fmtObj.parseFn !== "function" || typeof fmtObj.validateFn !== "function") {
            throw new Error(`no support for attestation format: ${fmt}`);
        }
        const ret = fmtObj.parseFn.call(this, attStmt);
        if (!(ret instanceof Map)) {
            throw new Error(`${fmt} parseFn did not return a Map`);
        }
        return new Map([
            [
                "fmt",
                fmt
            ],
            ...ret, 
        ]);
    }
    attestationResult(res, expected) {
        expected.flags = factorToFlags(expected.factor, [
            "AT"
        ]);
        delete expected.factor;
        return Fido2AttestationResult.create(res, expected);
    }
    async assertionResult(res, expected) {
        expected.flags = factorToFlags(expected.factor, []);
        delete expected.factor;
        return Fido2AssertionResult.create(res, expected);
    }
    async attestationOptions(opts) {
        opts = opts || {};
        let challenge = tools.randomValues(this.config.challengeSize);
        challenge = coerceToArrayBuffer1(challenge, "challenge");
        const pubKeyCredParams = [];
        this.config.cryptoParams.forEach((coseId)=>{
            pubKeyCredParams.push({
                type: "public-key",
                alg: coseId
            });
        });
        let rawChallenge;
        if (opts.extraData) {
            rawChallenge = challenge;
            const extraData = coerceToArrayBuffer1(opts.extraData, "extraData");
            const hash = await tools.hashDigest(appendBuffer1(challenge, extraData));
            challenge = new Uint8Array(hash).buffer;
        }
        const options = {
            rp: {},
            user: {}
        };
        const extensions2 = createExtensions.call(this, "attestation", opts.extensionOptions);
        setOpt(options.rp, "name", this.config.rpName);
        setOpt(options.rp, "id", this.config.rpId);
        setOpt(options.rp, "icon", this.config.rpIcon);
        setOpt(options, "challenge", challenge);
        setOpt(options, "pubKeyCredParams", pubKeyCredParams);
        setOpt(options, "timeout", this.config.timeout);
        setOpt(options, "attestation", this.config.attestation);
        if (this.config.authenticatorAttachment !== undefined || this.config.authenticatorRequireResidentKey !== undefined || this.config.authenticatorUserVerification !== undefined) {
            options.authenticatorSelection = {};
            setOpt(options.authenticatorSelection, "authenticatorAttachment", this.config.authenticatorAttachment);
            setOpt(options.authenticatorSelection, "requireResidentKey", this.config.authenticatorRequireResidentKey);
            setOpt(options.authenticatorSelection, "userVerification", this.config.authenticatorUserVerification);
        }
        setOpt(options, "rawChallenge", rawChallenge);
        if (Object.keys(extensions2).length > 0) {
            options.extensions = extensions2;
        }
        return options;
    }
    async assertionOptions(opts) {
        opts = opts || {};
        let challenge = tools.randomValues(this.config.challengeSize);
        challenge = coerceToArrayBuffer1(challenge, "challenge");
        const options = {};
        let rawChallenge;
        if (opts.extraData) {
            rawChallenge = challenge;
            const extraData = coerceToArrayBuffer1(opts.extraData, "extraData");
            challenge = abToBuf1(await tools.hashDigest(appendBuffer1(challenge, extraData)));
        }
        const extensions3 = createExtensions.call(this, "assertion", opts.extensionOptions);
        setOpt(options, "challenge", challenge);
        setOpt(options, "timeout", this.config.timeout);
        setOpt(options, "rpId", this.config.rpId);
        setOpt(options, "userVerification", this.config.authenticatorUserVerification);
        setOpt(options, "rawChallenge", rawChallenge);
        if (Object.keys(extensions3).length > 0) {
            options.extensions = extensions3;
        }
        return options;
    }
}
async function parseAttestationObject(attestationObject) {
    attestationObject = coerceToArrayBuffer(attestationObject, "attestationObject");
    let parsed;
    try {
        parsed = mod3.cbor.decode(new Uint8Array(attestationObject));
    } catch (_err) {
        throw new TypeError("couldn't parse attestationObject CBOR");
    }
    if (typeof parsed !== "object") {
        throw new TypeError("invalid parsing of attestationObject cbor");
    }
    if (typeof parsed.fmt !== "string") {
        throw new Error("expected attestation CBOR to contain a 'fmt' string");
    }
    if (typeof parsed.attStmt !== "object") {
        throw new Error("expected attestation CBOR to contain a 'attStmt' object");
    }
    if (!(parsed.authData instanceof Uint8Array)) {
        throw new Error("expected attestation CBOR to contain a 'authData' byte sequence");
    }
    const ret = new Map([
        ...Webauthn.parseAttestation(parsed.fmt, parsed.attStmt),
        [
            "rawAuthnrData",
            coerceToArrayBuffer(parsed.authData, "authData")
        ],
        [
            "transports",
            undefined
        ],
        ...await parseAuthenticatorData(parsed.authData), 
    ]);
    return ret;
}
function checkOptType(opts, prop, type) {
    if (typeof opts !== "object") return;
    if (opts[prop] === undefined) return;
    if (typeof type === "string") {
        if (typeof opts[prop] !== type) {
            throw new TypeError(`expected ${prop} to be ${type}, got: ${opts[prop]}`);
        }
    }
    if (typeof type === "function") {
        if (!(opts[prop] instanceof type)) {
            throw new TypeError(`expected ${prop} to be ${type.name}, got: ${opts[prop]}`);
        }
    }
}
function setOpt(obj, prop, val) {
    if (val !== undefined) {
        obj[prop] = val;
    }
}
function factorToFlags(expectedFactor, flags) {
    flags = flags || [];
    switch(expectedFactor){
        case "first":
            flags.push("UP");
            flags.push("UV");
            break;
        case "second":
            flags.push("UP");
            break;
        case "either":
            flags.push("UP-or-UV");
            break;
        default:
            throw new TypeError("expectedFactor should be 'first', 'second' or 'either'");
    }
    return flags;
}
function createExtensions(type, extObj) {
    const extensions4 = {};
    let enabledExtensions = this.extSet;
    let extensionsOptions = this.extOptMap;
    if (typeof extObj === "object") {
        enabledExtensions = new Set(Object.keys(extObj));
        extensionsOptions = new Map();
        for (const key of Object.keys(extObj)){
            extensionsOptions.set(key, extObj[key]);
        }
    }
    for (const extension of enabledExtensions){
        const extVal = this.generateExtensionOptions(extension, type, extensionsOptions.get(extension));
        if (extVal !== undefined) extensions4[extension] = extVal;
    }
    return extensions4;
}
Webauthn.addAttestationFormat(noneAttestation.name, noneAttestation.parseFn, noneAttestation.validateFn);
Webauthn.addAttestationFormat(packedAttestation.name, packedAttestation.parseFn, packedAttestation.validateFn);
Webauthn.addAttestationFormat(fidoU2fAttestation.name, fidoU2fAttestation.parseFn, fidoU2fAttestation.validateFn);
Webauthn.addAttestationFormat(androidSafetyNetAttestation.name, androidSafetyNetAttestation.parseFn, androidSafetyNetAttestation.validateFn);
Webauthn.addAttestationFormat(tpmAttestation.name, tpmAttestation.parseFn, tpmAttestation.validateFn);
function parseExpectations(exp) {
    if (typeof exp !== "object") {
        throw new TypeError("expected 'expectations' to be of type object, got " + typeof exp);
    }
    const ret = new Map();
    if (exp.origin) {
        if (typeof exp.origin !== "string") {
            throw new TypeError("expected 'origin' should be string, got " + typeof exp.origin);
        }
        const origin = mod3.checkOrigin(exp.origin);
        ret.set("origin", origin);
    }
    if (exp.rpId) {
        if (typeof exp.rpId !== "string") {
            throw new TypeError("expected 'rpId' should be string, got " + typeof exp.rpId);
        }
        const rpId = mod3.checkRpId(exp.rpId);
        ret.set("rpId", rpId);
    }
    if (exp.challenge) {
        let challenge = exp.challenge;
        challenge = coerceToBase64Url(challenge, "expected challenge");
        ret.set("challenge", challenge);
    }
    if (exp.flags) {
        let flags = exp.flags;
        if (Array.isArray(flags)) {
            flags = new Set(flags);
        }
        if (!(flags instanceof Set)) {
            throw new TypeError("expected flags to be an Array or a Set, got: " + typeof flags);
        }
        ret.set("flags", flags);
    }
    if (exp.prevCounter !== undefined) {
        if (typeof exp.prevCounter !== "number") {
            throw new TypeError("expected 'prevCounter' should be Number, got " + typeof exp.prevCounter);
        }
        ret.set("prevCounter", exp.prevCounter);
    }
    if (exp.publicKey) {
        if (typeof exp.publicKey !== "string") {
            throw new TypeError("expected 'publicKey' should be String, got " + typeof exp.publicKey);
        }
        ret.set("publicKey", exp.publicKey);
    }
    if (exp.userHandle !== undefined) {
        let userHandle = exp.userHandle;
        if (userHandle !== null && userHandle !== "") {
            userHandle = coerceToBase64Url(userHandle, "userHandle");
        }
        ret.set("userHandle", userHandle);
    }
    if (exp.allowCredentials !== undefined) {
        const allowCredentials = exp.allowCredentials;
        if (allowCredentials !== null && !Array.isArray(allowCredentials)) {
            throw new TypeError("expected 'allowCredentials' to be null or array, got " + typeof allowCredentials);
        }
        for(const index in allowCredentials){
            if (allowCredentials[index].id != null) {
                allowCredentials[index].id = coerceToArrayBuffer(allowCredentials[index].id, "allowCredentials[" + index + "].id");
            }
        }
        ret.set("allowCredentials", allowCredentials);
    }
    return ret;
}
async function parseAuthnrAttestationResponse(msg) {
    if (typeof msg !== "object") {
        throw new TypeError("expected msg to be Object");
    }
    if (typeof msg.response !== "object") {
        throw new TypeError("expected response to be Object");
    }
    let attestationObject = msg.response.attestationObject;
    attestationObject = coerceToArrayBuffer(attestationObject, "attestationObject");
    let parsed;
    try {
        parsed = mod3.cbor.decode(new Uint8Array(attestationObject));
    } catch (err) {
        throw new TypeError("couldn't parse attestationObject cbor" + err);
    }
    if (typeof parsed !== "object") {
        throw new TypeError("invalid parsing of attestationObject cbor");
    }
    if (typeof parsed.fmt !== "string") {
        throw new Error("expected attestation  to contain a 'fmt' string");
    }
    if (typeof parsed.attStmt !== "object") {
        throw new Error("expected attestation cbor to contain a 'attStmt' object");
    }
    if (!(parsed.authData instanceof Uint8Array)) {
        throw new Error("expected attestation cbor to contain a 'authData' byte sequence");
    }
    if (msg.transports != undefined && !Array.isArray(msg.transports)) {
        throw new Error("expected transports to be 'null' or 'array<string>'");
    }
    const ret = new Map([
        ...Webauthn.parseAttestation(parsed.fmt, parsed.attStmt),
        [
            "rawAuthnrData",
            coerceToArrayBuffer(parsed.authData, "authData")
        ],
        [
            "transports",
            msg.transports
        ],
        ...await parseAuthenticatorData(parsed.authData, mod3), 
    ]);
    return ret;
}
async function parseAuthenticatorData(authnrDataArrayBuffer) {
    authnrDataArrayBuffer = coerceToArrayBuffer(authnrDataArrayBuffer, "authnrDataArrayBuffer");
    const ret = new Map();
    const authnrDataBuf = new DataView(authnrDataArrayBuffer);
    let offset = 0;
    ret.set("rpIdHash", authnrDataBuf.buffer.slice(offset, offset + 32));
    offset += 32;
    const flags = authnrDataBuf.getUint8(offset);
    const flagsSet = new Set();
    ret.set("flags", flagsSet);
    if (flags & 0x01) flagsSet.add("UP");
    if (flags & 0x02) flagsSet.add("RFU1");
    if (flags & 0x04) flagsSet.add("UV");
    if (flags & 0x08) flagsSet.add("RFU3");
    if (flags & 0x10) flagsSet.add("RFU4");
    if (flags & 0x20) flagsSet.add("RFU5");
    if (flags & 0x40) flagsSet.add("AT");
    if (flags & 0x80) flagsSet.add("ED");
    offset++;
    ret.set("counter", authnrDataBuf.getUint32(offset, false));
    offset += 4;
    const attestation = flagsSet.has("AT");
    const extensions5 = flagsSet.has("ED");
    if (attestation) {
        ret.set("aaguid", authnrDataBuf.buffer.slice(offset, offset + 16));
        offset += 16;
        const credIdLen = authnrDataBuf.getUint16(offset, false);
        ret.set("credIdLen", credIdLen);
        offset += 2;
        ret.set("credId", authnrDataBuf.buffer.slice(offset, offset + credIdLen));
        offset += credIdLen;
        const publicKey = new Key();
        await publicKey.fromCose(authnrDataBuf.buffer.slice(offset, authnrDataBuf.buffer.byteLength));
        ret.set("credentialPublicKeyCose", await publicKey.toCose());
        ret.set("credentialPublicKeyJwk", await publicKey.toJwk());
        ret.set("credentialPublicKeyPem", await publicKey.toPem());
    }
    if (extensions5) {
        throw new Error("authenticator extensions not supported");
    }
    return ret;
}
async function parseAuthnrAssertionResponse(msg) {
    if (typeof msg !== "object") {
        throw new TypeError("expected msg to be Object");
    }
    if (typeof msg.response !== "object") {
        throw new TypeError("expected response to be Object");
    }
    let userHandle;
    if (msg.response.userHandle !== undefined) {
        userHandle = coerceToArrayBuffer(msg.response.userHandle, "response.userHandle");
        if (userHandle.byteLength === 0) {
            userHandle = undefined;
        }
    }
    const sigAb = coerceToArrayBuffer(msg.response.signature, "response.signature");
    const ret = new Map([
        [
            "sig",
            sigAb
        ],
        [
            "userHandle",
            userHandle
        ],
        [
            "rawAuthnrData",
            coerceToArrayBuffer(msg.response.authenticatorData, "response.authenticatorData"), 
        ],
        ...await parseAuthenticatorData(msg.response.authenticatorData, mod3), 
    ]);
    return ret;
}
function parseClientResponse(msg) {
    if (typeof msg !== "object") {
        throw new TypeError("expected msg to be Object");
    }
    if (msg.id && !msg.rawId) {
        msg.rawId = msg.id;
    }
    const rawId = coerceToArrayBuffer(msg.rawId, "rawId");
    if (typeof msg.response !== "object") {
        throw new TypeError("expected response to be Object");
    }
    const clientDataJSON = coerceToArrayBuffer(msg.response.clientDataJSON, "clientDataJSON");
    if (!(clientDataJSON instanceof ArrayBuffer)) {
        throw new TypeError("expected 'clientDataJSON' to be ArrayBuffer");
    }
    const clientDataJson = abToStr(clientDataJSON);
    let parsed;
    try {
        parsed = JSON.parse(clientDataJson);
    } catch (err) {
        throw new Error("couldn't parse clientDataJson: " + err);
    }
    const ret = new Map([
        [
            "challenge",
            parsed.challenge
        ],
        [
            "origin",
            parsed.origin
        ],
        [
            "type",
            parsed.type
        ],
        [
            "tokenBinding",
            parsed.tokenBinding
        ],
        [
            "rawClientDataJson",
            clientDataJSON
        ],
        [
            "rawId",
            rawId
        ], 
    ]);
    return ret;
}
class Fido2Result {
    constructor(sym){
        if (sym !== lockSym) {
            throw new Error("Do not create with 'new' operator. Call 'Fido2AttestationResult.create()' or 'Fido2AssertionResult.create()' instead.");
        }
        attach(this);
    }
    parse() {
        this.clientData = parseClientResponse(this.request);
    }
    async validate() {
        await this.validateRawClientDataJson();
        await this.validateOrigin();
        await this.validateChallenge();
        await this.validateTokenBinding();
        await this.validateId();
        await this.validateRawAuthnrData();
        await this.validateRpIdHash();
        await this.validateFlags();
    }
    async create(req, exp) {
        if (typeof req !== "object") {
            throw new TypeError("expected 'request' to be object, got: " + typeof req);
        }
        if (typeof exp !== "object") {
            throw new TypeError("expected 'expectations' to be object, got: " + typeof exp);
        }
        this.expectations = parseExpectations(exp);
        this.request = req;
        await this.validateExpectations();
        await this.parse();
        await this.validate();
        await this.validateAudit();
        return this;
    }
}
class Fido2AttestationResult extends Fido2Result {
    constructor(sym){
        super(sym);
        this.requiredExpectations = new Set([
            "origin",
            "challenge",
            "flags", 
        ]);
        this.optionalExpectations = new Set([
            "rpId", 
        ]);
    }
    async parse() {
        this.validateCreateRequest();
        await super.parse();
        this.authnrData = await parseAuthnrAttestationResponse(this.request);
    }
    async validate() {
        await this.validateCreateType();
        await this.validateAaguid();
        await this.validatePublicKey();
        await super.validate();
        await this.validateAttestation();
        await this.validateInitialCounter();
        await this.validateCredId();
        await this.validateTransports();
    }
    static create(req, exp, tools1) {
        return new Fido2AttestationResult(lockSym).create(req, exp, tools1);
    }
}
class Fido2AssertionResult extends Fido2Result {
    constructor(sym, tools2){
        super(sym, tools2);
        this.requiredExpectations = new Set([
            "origin",
            "challenge",
            "flags",
            "prevCounter",
            "publicKey",
            "userHandle", 
        ]);
        this.optionalExpectations = new Set([
            "rpId",
            "allowCredentials", 
        ]);
    }
    async parse() {
        this.validateAssertionResponse();
        await super.parse();
        this.authnrData = await parseAuthnrAssertionResponse(this.request, mod3);
    }
    async validate() {
        await this.validateGetType();
        await super.validate();
        await this.validateAssertionSignature();
        await this.validateUserHandle();
        await this.validateCounter();
    }
    static create(req, exp, tools3) {
        return new Fido2AssertionResult(lockSym).create(req, exp, tools3);
    }
}
function validateAssertionResponse() {
    let req = this.request;
    if (typeof req !== "object") {
        throw new TypeError("expected request to be Object, got " + typeof req);
    }
    if (!(req.rawId instanceof ArrayBuffer) && !(req.id instanceof ArrayBuffer)) {
        throw new TypeError("expected 'id' or 'rawId' field of request to be ArrayBuffer, got rawId " + typeof req.rawId + " and id " + typeof req.id);
    }
    if (typeof req.response !== "object") {
        throw new TypeError("expected 'response' field of request to be Object, got " + typeof req.response);
    }
    if (typeof req.response.clientDataJSON !== "string" && !(req.response.clientDataJSON instanceof ArrayBuffer)) {
        throw new TypeError("expected 'response.clientDataJSON' to be base64 String or ArrayBuffer");
    }
    if (typeof req.response.authenticatorData !== "string" && !(req.response.authenticatorData instanceof ArrayBuffer)) {
        throw new TypeError("expected 'response.authenticatorData' to be base64 String or ArrayBuffer");
    }
    if (typeof req.response.signature !== "string" && !(req.response.signature instanceof ArrayBuffer)) {
        throw new TypeError("expected 'response.signature' to be base64 String or ArrayBuffer");
    }
    if (typeof req.response.userHandle !== "string" && !(req.response.userHandle instanceof ArrayBuffer) && req.response.userHandle !== undefined) {
        throw new TypeError("expected 'response.userHandle' to be base64 String, ArrayBuffer, or undefined");
    }
    this.audit.validRequest = true;
    return true;
}
async function validateRawClientDataJson() {
    let rawClientDataJson = this.clientData.get("rawClientDataJson");
    if (!(rawClientDataJson instanceof ArrayBuffer)) {
        throw new Error("clientData clientDataJson should be ArrayBuffer");
    }
    this.audit.journal.add("rawClientDataJson");
    return true;
}
async function validateTransports() {
    let transports = this.authnrData.get("transports");
    if (transports != null && !Array.isArray(transports)) {
        throw new Error("expected transports to be 'null' or 'array<string>'");
    }
    for(const index in transports){
        if (typeof transports[index] !== "string") {
            throw new Error("expected transports[" + index + "] to be 'string'");
        }
    }
    this.audit.journal.add("transports");
    return true;
}
async function validateId() {
    let rawId = this.clientData.get("rawId");
    if (!(rawId instanceof ArrayBuffer)) {
        throw new Error("expected id to be of type ArrayBuffer");
    }
    let credId = this.authnrData.get("credId");
    if (credId !== undefined && !abEqual(rawId, credId)) {
        throw new Error("id and credId were not the same");
    }
    let allowCredentials = this.expectations.get("allowCredentials");
    if (allowCredentials != undefined) {
        if (!allowCredentials.some((cred)=>{
            let result = abEqual(rawId, cred.id);
            return result;
        })) {
            throw new Error("Credential ID does not match any value in allowCredentials");
        }
    }
    this.audit.journal.add("rawId");
    return true;
}
async function validateCreateType() {
    let type = this.clientData.get("type");
    if (type !== "webauthn.create") {
        throw new Error("clientData type should be 'webauthn.create', got: " + type);
    }
    this.audit.journal.add("type");
    return true;
}
async function validateGetType() {
    let type = this.clientData.get("type");
    if (type !== "webauthn.get") {
        throw new Error("clientData type should be 'webauthn.get'");
    }
    this.audit.journal.add("type");
    return true;
}
async function validateChallenge() {
    let expectedChallenge = this.expectations.get("challenge");
    let challenge = this.clientData.get("challenge");
    if (typeof challenge !== "string") {
        throw new Error("clientData challenge was not a string");
    }
    if (!isBase64Url(challenge)) {
        throw new TypeError("clientData challenge was not properly encoded base64url");
    }
    challenge = challenge.replace(/={1,2}$/, "");
    if (challenge !== expectedChallenge) {
        throw new Error("clientData challenge mismatch");
    }
    this.audit.journal.add("challenge");
    return true;
}
async function validateTokenBinding() {
    let tokenBinding = this.clientData.get("tokenBinding");
    if (typeof tokenBinding === "object") {
        if (tokenBinding.status !== "not-supported" && tokenBinding.status !== "supported") {
            throw new Error("tokenBinding status should be 'not-supported' or 'supported', got: " + tokenBinding.status);
        }
        if (Object.keys(tokenBinding).length != 1) {
            throw new Error("tokenBinding had too many keys");
        }
    } else if (tokenBinding !== undefined) {
        throw new Error("Token binding field malformed: " + tokenBinding);
    }
    this.audit.journal.add("tokenBinding");
    return true;
}
async function validateRawAuthnrData() {
    let rawAuthnrData = this.authnrData.get("rawAuthnrData");
    if (!(rawAuthnrData instanceof ArrayBuffer)) {
        throw new Error("authnrData rawAuthnrData should be ArrayBuffer");
    }
    this.audit.journal.add("rawAuthnrData");
    return true;
}
async function validateFlags() {
    let expectedFlags = this.expectations.get("flags");
    let flags = this.authnrData.get("flags");
    for (let expFlag of expectedFlags){
        if (expFlag === "UP-or-UV") {
            if (flags.has("UV")) {
                if (flags.has("UP")) {
                    continue;
                } else {
                    throw new Error("expected User Presence (UP) flag to be set if User Verification (UV) is set");
                }
            } else if (flags.has("UP")) {
                continue;
            } else {
                throw new Error("expected User Presence (UP) or User Verification (UV) flag to be set and neither was");
            }
        }
        if (expFlag === "UV") {
            if (flags.has("UV")) {
                if (flags.has("UP")) {
                    continue;
                } else {
                    throw new Error("expected User Presence (UP) flag to be set if User Verification (UV) is set");
                }
            } else {
                throw new Error(`expected flag was not set: ${expFlag}`);
            }
        }
        if (!flags.has(expFlag)) {
            throw new Error(`expected flag was not set: ${expFlag}`);
        }
    }
    this.audit.journal.add("flags");
    return true;
}
async function validateInitialCounter() {
    let counter = this.authnrData.get("counter");
    if (typeof counter !== "number") {
        throw new Error("authnrData counter wasn't a number");
    }
    this.audit.journal.add("counter");
    return true;
}
async function validateAaguid() {
    let aaguid = this.authnrData.get("aaguid");
    if (!(aaguid instanceof ArrayBuffer)) {
        throw new Error("authnrData AAGUID is not ArrayBuffer");
    }
    if (aaguid.byteLength !== 16) {
        throw new Error("authnrData AAGUID was wrong length");
    }
    this.audit.journal.add("aaguid");
    return true;
}
async function validateCredId() {
    let credId = this.authnrData.get("credId");
    let credIdLen = this.authnrData.get("credIdLen");
    if (!(credId instanceof ArrayBuffer)) {
        throw new Error("authnrData credId should be ArrayBuffer");
    }
    if (typeof credIdLen !== "number") {
        throw new Error("authnrData credIdLen should be number, got " + typeof credIdLen);
    }
    if (credId.byteLength !== credIdLen) {
        throw new Error("authnrData credId was wrong length");
    }
    this.audit.journal.add("credId");
    this.audit.journal.add("credIdLen");
    return true;
}
async function validatePublicKey() {
    let cbor1 = this.authnrData.get("credentialPublicKeyCose");
    let jwk = this.authnrData.get("credentialPublicKeyJwk");
    let pem = this.authnrData.get("credentialPublicKeyPem");
    if (!(cbor1 instanceof ArrayBuffer)) {
        throw new Error("authnrData credentialPublicKeyCose isn't of type ArrayBuffer");
    }
    this.audit.journal.add("credentialPublicKeyCose");
    if (typeof jwk !== "object") {
        throw new Error("authnrData credentialPublicKeyJwk isn't of type Object");
    }
    if (typeof jwk.kty !== "string") {
        throw new Error("authnrData credentialPublicKeyJwk.kty isn't of type String");
    }
    if (typeof jwk.alg !== "string") {
        throw new Error("authnrData credentialPublicKeyJwk.alg isn't of type String");
    }
    switch(jwk.kty){
        case "EC":
            if (typeof jwk.crv !== "string") {
                throw new Error("authnrData credentialPublicKeyJwk.crv isn't of type String");
            }
            break;
        case "RSA":
            if (typeof jwk.n !== "string") {
                throw new Error("authnrData credentialPublicKeyJwk.n isn't of type String");
            }
            if (typeof jwk.e !== "string") {
                throw new Error("authnrData credentialPublicKeyJwk.e isn't of type String");
            }
            break;
        default:
            throw new Error("authnrData unknown JWK key type: " + jwk.kty);
    }
    this.audit.journal.add("credentialPublicKeyJwk");
    if (typeof pem !== "string") {
        throw new Error("authnrData credentialPublicKeyPem isn't of type String");
    }
    if (!isPem(pem)) {
        throw new Error("authnrData credentialPublicKeyPem was malformatted");
    }
    this.audit.journal.add("credentialPublicKeyPem");
    return true;
}
async function validateCounter() {
    let prevCounter = this.expectations.get("prevCounter");
    let counter = this.authnrData.get("counter");
    let counterSupported = !(counter === 0 && prevCounter === 0);
    if (counter <= prevCounter && counterSupported) {
        throw new Error("counter rollback detected");
    }
    this.audit.journal.add("counter");
    this.audit.info.set("counter-supported", "" + counterSupported);
    return true;
}
async function validateAudit() {
    let journal = this.audit.journal;
    let clientData = this.clientData;
    let authnrData = this.authnrData;
    for (let kv of clientData){
        let val = kv[0];
        if (!journal.has(val)) {
            throw new Error(`internal audit failed: ${val} was not validated`);
        }
    }
    for (let kv1 of authnrData){
        let val = kv1[0];
        if (!journal.has(val)) {
            throw new Error(`internal audit failed: ${val} was not validated`);
        }
    }
    if (journal.size !== clientData.size + authnrData.size) {
        throw new Error(`internal audit failed: ${journal.size} fields checked; expected ${clientData.size + authnrData.size}`);
    }
    if (!this.audit.validExpectations) {
        throw new Error("internal audit failed: expectations not validated");
    }
    if (!this.audit.validRequest) {
        throw new Error("internal audit failed: request not validated");
    }
    this.audit.complete = true;
    return true;
}
async function validateRpIdHash() {
    let rpIdHash = this.authnrData.get("rpIdHash");
    if (typeof Buffer !== "undefined" && rpIdHash instanceof Buffer) {
        rpIdHash = new Uint8Array(rpIdHash).buffer;
    }
    if (!(rpIdHash instanceof ArrayBuffer)) {
        throw new Error("couldn't coerce clientData rpIdHash to ArrayBuffer");
    }
    let domain = this.expectations.has("rpId") ? this.expectations.get("rpId") : mod3.getHostname(this.expectations.get("origin"));
    let createdHash = new Uint8Array(await mod3.hashDigest(domain)).buffer;
    if (rpIdHash.byteLength !== createdHash.byteLength) {
        throw new Error("authnrData rpIdHash length mismatch");
    }
    rpIdHash = new Uint8Array(rpIdHash);
    createdHash = new Uint8Array(createdHash);
    for(let i219 = 0; i219 < rpIdHash.byteLength; i219++){
        if (rpIdHash[i219] !== createdHash[i219]) {
            throw new TypeError("authnrData rpIdHash mismatch");
        }
    }
    this.audit.journal.add("rpIdHash");
    return true;
}
async function validateAttestation() {
    return Webauthn.validateAttestation.call(this);
}
async function validateExpectations() {
    let req = this.requiredExpectations;
    let opt = this.optionalExpectations;
    let exp = this.expectations;
    if (!(exp instanceof Map)) {
        throw new Error("expectations should be of type Map");
    }
    if (Array.isArray(req)) {
        req = new Set([
            req
        ]);
    }
    if (!(req instanceof Set)) {
        throw new Error("requiredExpectaions should be of type Set");
    }
    if (Array.isArray(opt)) {
        opt = new Set([
            opt
        ]);
    }
    if (!(opt instanceof Set)) {
        throw new Error("optionalExpectations should be of type Set");
    }
    for (let field of req){
        if (!exp.has(field)) {
            throw new Error(`expectation did not contain value for '${field}'`);
        }
    }
    let optCount = 0;
    for (const [field1] of exp){
        if (opt.has(field1)) {
            optCount++;
        }
    }
    if (req.size !== exp.size - optCount) {
        throw new Error(`wrong number of expectations: should have ${req.size} but got ${exp.size - optCount}`);
    }
    if (req.has("origin")) {
        let expectedOrigin = exp.get("origin");
        mod3.checkOrigin(expectedOrigin);
    }
    if (exp.has("rpId")) {
        let expectedRpId = exp.get("rpId");
        mod3.checkRpId(expectedRpId);
    }
    if (exp.has("challenge")) {
        let challenge = exp.get("challenge");
        if (typeof challenge !== "string") {
            throw new Error("expected challenge should be of type String, got: " + typeof challenge);
        }
        if (!isBase64Url(challenge)) {
            throw new Error("expected challenge should be properly encoded base64url String");
        }
    }
    if (req.has("flags")) {
        let validFlags = new Set([
            "UP",
            "UV",
            "UP-or-UV",
            "AT",
            "ED"
        ]);
        let flags = exp.get("flags");
        for (let flag of flags){
            if (!validFlags.has(flag)) {
                throw new Error(`expected flag unknown: ${flag}`);
            }
        }
    }
    if (req.has("prevCounter")) {
        let prevCounter = exp.get("prevCounter");
        if (!isPositiveInteger(prevCounter)) {
            throw new Error("expected counter to be positive integer");
        }
    }
    if (req.has("publicKey")) {
        let publicKey = exp.get("publicKey");
        if (!isPem(publicKey)) {
            throw new Error("expected publicKey to be in PEM format");
        }
    }
    if (req.has("userHandle")) {
        let userHandle = exp.get("userHandle");
        if (userHandle !== null && typeof userHandle !== "string") {
            throw new Error("expected userHandle to be null or string");
        }
    }
    if (exp.has("allowCredentials")) {
        let allowCredentials = exp.get("allowCredentials");
        if (allowCredentials != null) {
            if (!Array.isArray(allowCredentials)) {
                throw new Error("expected allowCredentials to be null or array");
            } else {
                for(const index in allowCredentials){
                    if (typeof allowCredentials[index].id === "string") {
                        allowCredentials[index].id = coerceToArrayBuffer(allowCredentials[index].id, "allowCredentials[" + index + "].id");
                    }
                    if (allowCredentials[index].id == null || !(allowCredentials[index].id instanceof ArrayBuffer)) {
                        throw new Error("expected id of allowCredentials[" + index + "] to be ArrayBuffer");
                    }
                    if (allowCredentials[index].type == null || allowCredentials[index].type !== "public-key") {
                        throw new Error("expected type of allowCredentials[" + index + "] to be string with value 'public-key'");
                    }
                    if (allowCredentials[index].transports != null && !Array.isArray(allowCredentials[index].transports)) {
                        throw new Error("expected transports of allowCredentials[" + index + "] to be array or null");
                    } else if (allowCredentials[index].transports != null && !allowCredentials[index].transports.every((el)=>[
                            "usb",
                            "nfc",
                            "ble",
                            "internal"
                        ].includes(el)
                    )) {
                        throw new Error("expected transports of allowCredentials[" + index + "] to be string with value 'usb', 'nfc', 'ble', 'internal' or null");
                    }
                }
            }
        }
    }
    this.audit.validExpectations = true;
    return true;
}
async function validateUserHandle() {
    let userHandle = this.authnrData.get("userHandle");
    if (userHandle === undefined || userHandle === null || userHandle === "") {
        this.audit.journal.add("userHandle");
        return true;
    }
    userHandle = coerceToBase64Url(userHandle, "userHandle");
    let expUserHandle = this.expectations.get("userHandle");
    if (typeof userHandle === "string" && userHandle === expUserHandle) {
        this.audit.journal.add("userHandle");
        return true;
    }
    throw new Error("unable to validate userHandle");
}
async function validateAssertionSignature() {
    let expectedSignature = this.authnrData.get("sig");
    let publicKey = this.expectations.get("publicKey");
    let rawAuthnrData = this.authnrData.get("rawAuthnrData");
    let rawClientData = this.clientData.get("rawClientDataJson");
    let clientDataHashBuf = await mod3.hashDigest(rawClientData);
    let clientDataHash = new Uint8Array(clientDataHashBuf).buffer;
    let res = await mod3.verifySignature(publicKey, expectedSignature, appendBuffer(rawAuthnrData, clientDataHash));
    if (!res) {
        throw new Error("signature validation failed");
    }
    this.audit.journal.add("sig");
    return true;
}
async function validateOrigin() {
    let expectedOrigin = this.expectations.get("origin");
    let clientDataOrigin = this.clientData.get("origin");
    let origin = mod3.checkOrigin(clientDataOrigin);
    if (origin !== expectedOrigin) {
        throw new Error("clientData origin did not match expected origin");
    }
    this.audit.journal.add("origin");
    return true;
}
function attach(o26) {
    let mixins = {
        validateExpectations,
        validateCreateRequest,
        validateRawClientDataJson,
        validateOrigin,
        validateId,
        validateCreateType,
        validateGetType,
        validateChallenge,
        validateTokenBinding,
        validateTransports,
        validateRawAuthnrData,
        validateAttestation,
        validateAssertionSignature,
        validateRpIdHash,
        validateAaguid,
        validateCredId,
        validatePublicKey,
        validateFlags,
        validateUserHandle,
        validateCounter,
        validateInitialCounter,
        validateAssertionResponse,
        audit: {
            validExpectations: false,
            validRequest: false,
            complete: false,
            journal: new Set(),
            warning: new Map(),
            info: new Map()
        },
        validateAudit
    };
    for (let key of Object.keys(mixins)){
        o26[key] = mixins[key];
    }
}
export { Webauthn as Webauthn };
export { parseAttestationObject as parseAttestationObject, parseAuthenticatorData as parseAuthenticatorData, parseAuthnrAssertionResponse as parseAuthnrAssertionResponse, parseAuthnrAttestationResponse as parseAuthnrAttestationResponse, parseClientResponse as parseClientResponse, parseExpectations as parseExpectations };
export { Certificate1 as Certificate, CertManager as CertManager, CRL as CRL, helpers as helpers };
export { Fido2AssertionResult as Fido2AssertionResult, Fido2AttestationResult as Fido2AttestationResult, Fido2Result as Fido2Result };
export { attach as attach };
export { MdsCollection as MdsCollection, MdsEntry as MdsEntry };
export { noneAttestation as noneAttestation };
export { fidoU2fAttestation as fidoU2fAttestation };
export { packedAttestation as packedAttestation };
export { tpmAttestation as tpmAttestation };
export { androidSafetyNetAttestation as androidSafetyNetAttestation };
export { abEqual as abEqual, abToBuf as abToBuf, abToHex as abToHex, appendBuffer as appendBuffer, base64 as base64, coerceToArrayBuffer as coerceToArrayBuffer, coerceToBase64 as coerceToBase64, coerceToBase64Url as coerceToBase64Url, isBase64Url as isBase64Url, isPem as isPem, jsObjectToB64 as jsObjectToB64, pemToBase64 as pemToBase64, strToAb as strToAb, mod3 as tools };
