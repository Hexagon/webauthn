/* ------------------------------------------------------------------------------------

  webauthn - MIT License - Hexagon <github.com/Hexagon>

  ------------------------------------------------------------------------------------

  License:

	Copyright (c) 2022 Hexagon <github.com/Hexagon>

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.

  ------------------------------------------------------------------------------------  */

import {
	Fido2AttestationResult,
	Fido2AssertionResult
} from "./response.js";
import {
	WebauthnCommon,
	factorToFlags,
	setOpt,
	createExtensions
} from "../common/webauthn.js";
import {
	randomValues,
	coerceToArrayBuffer,
	hashDigest,
	abToBuf
} from "../common/utils.js";
/**
 * The main FIDO2 server class
 */
class Webauthn extends WebauthnCommon {
	constructor(opts) {
		super(opts);
	}

	/**
     * Parses and validates an attestation response from the client
     * @param {Object} res The assertion result that was generated by the client.
     * See {@link https://w3.org/TR/webauthn/#authenticatorattestationresponse AuthenticatorAttestationResponse} in the WebAuthn spec.
     * @param {String} [res.id] The base64url encoded id returned by the client
     * @param {String} [res.rawId] The base64url encoded rawId returned by the client. If `res.rawId` is missing, `res.id` will be used instead. If both are missing an error will be thrown.
     * @param {String} res.response.clientDataJSON The base64url encoded clientDataJSON returned by the client
     * @param {String} res.response.authenticatorData The base64url encoded authenticatorData returned by the client
     * @param {Object} expected The expected parameters for the assertion response.
     * If these parameters don't match the recieved values, validation will fail and an error will be thrown.
     * @param {String} expected.challenge The base64url encoded challenge that was sent to the client, as generated by [assertionOptions]{@link Fido2Lib#assertionOptions}
     * @param {String} expected.origin The expected origin that the authenticator has signed over. For example, "https://localhost:8443" or "https://webauthn.org"
     * @param {String} expected.factor Which factor is expected for the assertion. Valid values are "first", "second", or "either".
     * If "first", this requires that the authenticator performed user verification (e.g. - biometric authentication, PIN authentication, etc.).
     * If "second", this requires that the authenticator performed user presence (e.g. - user pressed a button).
     * If "either", then either "first" or "second" is acceptable
     * @return {Promise<Fido2AttestationResult>} Returns a Promise that resolves to a {@link Fido2AttestationResult}
     * @throws {Error} If parsing or validation fails
     */
	async attestationResult(res, expected) {
		expected.flags = factorToFlags(expected.factor, ["AT"]);
		delete expected.factor;
		return Fido2AttestationResult.create(res, expected);
	}

	/**
     * Parses and validates an assertion response from the client
     * @param {Object} res The assertion result that was generated by the client.
     * See {@link https://w3.org/TR/webauthn/#authenticatorassertionresponse AuthenticatorAssertionResponse} in the WebAuthn spec.
     * @param {String} [res.id] The base64url encoded id returned by the client
     * @param {String} [res.rawId] The base64url encoded rawId returned by the client. If `res.rawId` is missing, `res.id` will be used instead. If both are missing an error will be thrown.
     * @param {String} res.response.clientDataJSON The base64url encoded clientDataJSON returned by the client
     * @param {String} res.response.attestationObject The base64url encoded authenticatorData returned by the client
     * @param {String} res.response.signature The base64url encoded signature returned by the client
     * @param {String|null} [res.response.userHandle] The base64url encoded userHandle returned by the client. May be null or an empty string.
     * @param {Object} expected The expected parameters for the assertion response.
     * If these parameters don't match the recieved values, validation will fail and an error will be thrown.
     * @param {String} expected.challenge The base64url encoded challenge that was sent to the client, as generated by [assertionOptions]{@link Fido2Lib#assertionOptions}
     * @param {String} expected.origin The expected origin that the authenticator has signed over. For example, "https://localhost:8443" or "https://webauthn.org"
     * @param {String} expected.factor Which factor is expected for the assertion. Valid values are "first", "second", or "either".
     * If "first", this requires that the authenticator performed user verification (e.g. - biometric authentication, PIN authentication, etc.).
     * If "second", this requires that the authenticator performed user presence (e.g. - user pressed a button).
     * If "either", then either "first" or "second" is acceptable
     * @param {String} expected.publicKey A PEM encoded public key that will be used to validate the assertion response signature.
     * This is the public key that was returned for this user during [attestationResult]{@link Fido2Lib#attestationResult}
     * @param {Number} expected.prevCounter The previous value of the signature counter for this authenticator.
     * @param {String|null} expected.userHandle The expected userHandle, which was the user.id during registration
     * @return {Promise<Fido2AssertionResult>} Returns a Promise that resolves to a {@link Fido2AssertionResult}
     * @throws {Error} If parsing or validation fails
     */
	async assertionResult(res, expected) {
		expected.flags = factorToFlags(expected.factor, []);
		delete expected.factor;
		return Fido2AssertionResult.create(res, expected);
	}

	/**
     * Gets a challenge and any other parameters for the `navigator.credentials.create()` call
     * The `challenge` property is an `ArrayBuffer` and will need to be encoded to be transmitted to the client.
     * @param {Object} [opts] An object containing various options for the option creation
     * @param {Object} [opts.extensionOptions] An object that contains the extensions to enable, and the options to use for each of them.
     * The keys of this object are the names of the extensions (e.g. - "appid"), and the value of each key is the option that will
     * be passed to that extension when it is generating the value to send to the client. This object overrides the extensions that
     * have been set with {@link enableExtension} and the options that have been set with {@link setExtensionOptions}. If an extension
     * was enabled with {@link enableExtension} but it isn't included in this object, the extension won't be sent to the client. Likewise,
     * if an extension was disabled with {@link disableExtension} but it is included in this object, it will be sent to the client.
     * @param {String} [extraData] Extra data to be signed by the authenticator during attestation. The challenge will be a hash:
     * SHA256(rawChallenge + extraData) and the `rawChallenge` will be returned as part of PublicKeyCredentialCreationOptions.
     * @returns {Promise<PublicKeyCredentialCreationOptions>} The options for creating calling `navigator.credentials.create()`
     */
	async attestationOptions(opts) {
		opts = opts || {};

		// The object being returned is described here:
		// https://w3c.github.io/webauthn/#dictdef-publickeycredentialcreationoptions
		let challenge = randomValues(this.config.challengeSize);
		challenge = coerceToArrayBuffer(challenge, "challenge");
		let pubKeyCredParams = [];
		this.config.cryptoParams.forEach((coseId) => {
			pubKeyCredParams.push({
				type: "public-key",
				alg: coseId });
		});

		// mix extraData into challenge
		let rawChallenge;
		if (opts.extraData) {
			rawChallenge = challenge;
			let extraData = coerceToArrayBuffer(opts.extraData, "extraData");
			let hash = await hashDigest([...abToBuf(challenge),...abToBuf(extraData)]);
			challenge = new Uint8Array(hash).buffer;
		}

		let options = {
			rp: {},
			user: {},
		};

		let extensions = createExtensions.call(this, "attestation", opts.extensionOptions);

		/**
         * @typedef {Object} PublicKeyCredentialCreationOptions
         * @description This object is returned by {@link attestationOptions} and is basially the same as
         * the [PublicKeyCredentialCreationOptions]{@link https://w3.org/TR/webauthn/#dictdef-publickeycredentialcreationoptions}
         * object that is required to be passed to `navigator.credentials.create()`. With the exception of the `challenge` property,
         * all other properties are optional and only set if they were specified in the configuration paramater
         * that was passed to the constructor.
         * @property {Object} rp Relying party information (a.k.a. - server / service information)
         * @property {String} [rp.name] Relying party name (e.g. - "ACME"). This is only set if `rpName` was specified during the `new` call.
         * @property {String} [rp.id] Relying party ID, a domain name (e.g. - "example.com"). This is only set if `rpId` was specified during the `new` call.
         * @property {Object} user User information. This will be an empty object
         * @property {ArrayBuffer} challenge An ArrayBuffer filled with random bytes. This will be verified in {@link attestationResult}
         * @property {Array} [pubKeyCredParams] A list of PublicKeyCredentialParameters objects, based on the `cryptoParams` that was passed to the constructor.
         * @property {Number} [timeout] The amount of time that the call should take before returning an error
         * @property {String} [attestation] Whether the client should request attestation from the authenticator or not
         * @property {Object} [authenticatorSelectionCriteria] A object describing which authenticators are preferred for registration
         * @property {String} [authenticatorSelectionCriteria.attachment] What type of attachement is acceptable for new authenticators.
         * Allowed values are "platform", meaning that the authenticator is embedded in the operating system, or
         * "cross-platform", meaning that the authenticator is removeable (e.g. USB, NFC, or BLE).
         * @property {Boolean} [authenticatorSelectionCriteria.requireResidentKey] Indicates whether authenticators must store the keys internally, or if they can
         * store them externally (using a KDF or key wrapping)
         * @property {String} [authenticatorSelectionCriteria.userVerification] Indicates whether user verification is required for authenticators. User verification
         * means that an authenticator will validate a use through their biometrics (e.g. fingerprint) or knowledge (e.g. PIN). Allowed
         * values for `userVerification` are "required", meaning that registration will fail if no authenticator provides user verification;
         * "preferred", meaning that if multiple authenticators are available, the one(s) that provide user verification should be used; or
         * "discouraged", which means that authenticators that don't provide user verification are preferred.
         * @property {ArrayBuffer} [rawChallenge] If `extraData` was passed to {@link attestationOptions}, this
         * will be the original challenge used, and `challenge` will be a hash:
         * SHA256(rawChallenge + extraData)
         * @property {Object} [extensions] The values of any enabled extensions.
         */
		setOpt(options.rp, "name", this.config.rpName);
		setOpt(options.rp, "id", this.config.rpId);
		setOpt(options.rp, "icon", this.config.rpIcon);
		setOpt(options, "challenge", challenge);
		setOpt(options, "pubKeyCredParams", pubKeyCredParams);
		setOpt(options, "timeout", this.config.timeout);
		setOpt(options, "attestation", this.config.attestation);
		if (this.config.authenticatorAttachment !== undefined ||
            this.config.authenticatorRequireResidentKey !== undefined ||
            this.config.authenticatorUserVerification !== undefined) {
			options.authenticatorSelection = {};
			setOpt(options.authenticatorSelection, "authenticatorAttachment", this.config.authenticatorAttachment);
			setOpt(options.authenticatorSelection, "requireResidentKey", this.config.authenticatorRequireResidentKey);
			setOpt(options.authenticatorSelection, "userVerification", this.config.authenticatorUserVerification);
		}
		setOpt(options, "rawChallenge", rawChallenge);

		if (Object.keys(extensions).length > 0) {
			options.extensions = extensions;
		}

		return options;
	}
	/**
     * Creates an assertion challenge and any other parameters for the `navigator.credentials.get()` call.
     * The `challenge` property is an `ArrayBuffer` and will need to be encoded to be transmitted to the client.
     * @param {Object} [opts] An object containing various options for the option creation
     * @param {Object} [opts.extensionOptions] An object that contains the extensions to enable, and the options to use for each of them.
     * The keys of this object are the names of the extensions (e.g. - "appid"), and the value of each key is the option that will
     * be passed to that extension when it is generating the value to send to the client. This object overrides the extensions that
     * have been set with {@link enableExtension} and the options that have been set with {@link setExtensionOptions}. If an extension
     * was enabled with {@link enableExtension} but it isn't included in this object, the extension won't be sent to the client. Likewise,
     * if an extension was disabled with {@link disableExtension} but it is included in this object, it will be sent to the client.
     * @param {String} [extraData] Extra data to be signed by the authenticator during attestation. The challenge will be a hash:
     * SHA256(rawChallenge + extraData) and the `rawChallenge` will be returned as part of PublicKeyCredentialCreationOptions.
     * @returns {Promise<PublicKeyCredentialRequestOptions>} The options to be passed to `navigator.credentials.get()`
     */
	async assertionOptions(opts) {
		opts = opts || {};

		// https://w3c.github.io/webauthn/#dictdef-publickeycredentialcreationoptions
		let challenge = randomValues(this.config.challengeSize);
		challenge = coerceToArrayBuffer(challenge, "challenge");
		let options = {};

		// mix extraData into challenge
		let rawChallenge;
		if (opts.extraData) {
			rawChallenge = challenge;
			let extraData = coerceToArrayBuffer(opts.extraData, "extraData");
			let hash = await hashDigest([...abToBuf(challenge),...abToBuf(extraData)]);
			challenge = new Uint8Array(hash).buffer;
		}

		let extensions = createExtensions.call(this, "assertion", opts.extensionOptions);

		/**
         * @typedef {Object} PublicKeyCredentialRequestOptions
         * @description This object is returned by {@link assertionOptions} and is basially the same as
         * the [PublicKeyCredentialRequestOptions]{@link https://w3.org/TR/webauthn/#dictdef-publickeycredentialrequestoptions}
         * object that is required to be passed to `navigator.credentials.get()`. With the exception of the `challenge` property,
         * all other properties are optional and only set if they were specified in the configuration paramater
         * that was passed to the constructor.
         * @property {ArrayBuffer} challenge An ArrayBuffer filled with random bytes. This will be verified in {@link attestationResult}
         * @property {Number} [timeout] The amount of time that the call should take before returning an error
         * @property {String} [rpId] Relying party ID, a domain name (e.g. - "example.com"). This is only set if `rpId` was specified during the `new` call.
         * @property {String} [attestation] Whether the client should request attestation from the authenticator or not
         * @property {String} [userVerification] Indicates whether user verification is required for authenticators. User verification
         * means that an authenticator will validate a use through their biometrics (e.g. fingerprint) or knowledge (e.g. PIN). Allowed
         * values for `userVerification` are "required", meaning that authentication will fail if no authenticator provides user verification;
         * "preferred", meaning that if multiple authenticators are available, the one(s) that provide user verification should be used; or
         * "discouraged", which means that authenticators that don't provide user verification are preferred.
         * @property {ArrayBuffer} [rawChallenge] If `extraData` was passed to {@link attestationOptions}, this
         * will be the original challenge used, and `challenge` will be a hash:
         * SHA256(rawChallenge + extraData)
         * @property {Object} [extensions] The values of any enabled extensions.
         */
		setOpt(options, "challenge", challenge);
		setOpt(options, "timeout", this.config.timeout);
		setOpt(options, "rpId", this.config.rpId);
		setOpt(options, "userVerification", this.config.authenticatorUserVerification);

		setOpt(options, "rawChallenge", rawChallenge);

		if (Object.keys(extensions).length > 0) {
			options.extensions = extensions;
		}

		return options;
	}
    

}

// add 'none' attestation format
import { noneAttestation } from "../common/attestations/none.js";
Webauthn.addAttestationFormat(
	noneAttestation.name,
	noneAttestation.parseFn,
	noneAttestation.validateFn
);

Webauthn.Webauthn = Webauthn;
export default Webauthn;
export { Webauthn };